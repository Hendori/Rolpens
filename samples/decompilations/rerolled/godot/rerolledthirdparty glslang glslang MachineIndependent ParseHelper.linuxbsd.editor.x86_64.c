/* glslang::TParseContext::finalizeAtomicCounterBlockLayout(glslang::TVariable&) */void glslang::TParseContext::finalizeAtomicCounterBlockLayout(TVariable *param_1) {
   return;
}
/* glslang::TParseContext::lineDirectiveShouldSetNextLine() const */bool glslang::TParseContext::lineDirectiveShouldSetNextLine(TParseContext *this) {
   bool bVar1;
   bVar1 = true;
   if (*(int*)( this + 0xc ) != 8) {
      bVar1 = 0x149 < *(int*)( this + 0x18 );
   }

   return bVar1;
}
/* glslang::TParseContext::setLimits(TBuiltInResource const&) */void glslang::TParseContext::setLimits(TParseContext *this, TBuiltInResource *param_1) {
   TParseContext TVar1;
   void *__s;
   long lVar2;
   long lVar3;
   ulong uVar4;
   TBuiltInResource *pTVar5;
   TParseContext *pTVar6;
   undefined8 *puVar7;
   pTVar5 = param_1;
   pTVar6 = this + 0x5c0;
   for (lVar2 = 0x34; lVar2 != 0; lVar2 = lVar2 + -1) {
      *(undefined8*)pTVar6 = *(undefined8*)pTVar5;
      pTVar5 = pTVar5 + 8;
      pTVar6 = pTVar6 + 8;
   }

   *(undefined4*)pTVar6 = *(undefined4*)pTVar5;
   lVar2 = *(long*)( this + 0x38 );
   puVar7 = (undefined8*)( lVar2 + 0xc0U & 0xfffffffffffffff8 );
   *(undefined8*)( lVar2 + 0xb8 ) = *(undefined8*)param_1;
   lVar3 = ( lVar2 + 0xb8 ) - (long)puVar7;
   *(undefined8*)( lVar2 + 0x254 ) = *(undefined8*)( param_1 + 0x19c );
   pTVar5 = param_1 + -lVar3;
   for (uVar4 = ( ulong )((int)lVar3 + 0x1a4U >> 3); uVar4 != 0; uVar4 = uVar4 - 1) {
      *puVar7 = *(undefined8*)pTVar5;
      pTVar5 = pTVar5 + 8;
      puVar7 = puVar7 + 1;
   }

   *(undefined1*)( lVar2 + 0x25c ) = 1;
   lVar2 = *(long*)( this + 0x768 );
   if (*(TParseContext*)( lVar2 + 4 ) == (TParseContext)0x0) {
      TVar1 = (TParseContext)0x1;
   }
 else {
      TVar1 = *(TParseContext*)( lVar2 + 4 );
      if (( ( ( *(TParseContext*)( lVar2 + 8 ) != (TParseContext)0x0 ) && ( TVar1 = *(TParseContext*)( lVar2 + 8 ) * (TParseContext*)( lVar2 + 6 ) != (TParseContext)0x0 ) ) && ( TVar1 = *(TParseContext*)( lVar2 + 6 ) * (TParseContext*)( lVar2 + 3 ) != (TParseContext)0x0 ) ) && ( TVar1 = *(TParseContext*)( lVar2 + 3 ) * (char*)( lVar2 + 7 ) != '\0' )) {
         TVar1 = ( TParseContext )(*(byte*)( lVar2 + 5 ) ^ 1);
      }

   }

   this[0x7540] = TVar1;
   uVar4 = (long)*(int*)( this + 0x6d8 ) * 4;
   if (0x1ffffffffffffffe < ( ulong )(long) * (int*)( this + 0x6d8 )) {
      uVar4 = 0xffffffffffffffff;
   }

   __s = operator_new__(uVar4);
   *(void**)( this + 0x7538 ) = __s;
   if ((int)*(uint*)( this + 0x6d8 ) < 1) {
      return;
   }

   memset(__s, 0, ( ulong ) * (uint*)( this + 0x6d8 ) << 2);
   return;
}
/* glslang::TParseContext::lineContinuationCheck(glslang::TSourceLoc const&, bool) */undefined8 glslang::TParseContext::lineContinuationCheck(TParseContext *this, TSourceLoc *param_1, bool param_2) {
   char cVar1;
   undefined8 uVar2;
   if (*(int*)( this + 0xc ) == 8) {
      if (*(int*)( this + 0x18 ) < 300) goto LAB_001001f1;
   }
 else if (( *(int*)( this + 0x18 ) < 0x1a4 ) && ( cVar1 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_ARB_shading_language_420pack") ),cVar1 == '\0') {
      LAB_001001f1:if (param_2) {
         ( **(code**)( *(long*)this + 0x160 ) )(this, param_1, "used at end of comment, but this version does not provide line continuation", "line continuation", &_LC1);
         return 0;
      }

      uVar2 = 0;
      if (( (byte)this[0xd0] & 1 ) != 0) {
         ( **(code**)( *(long*)this + 0x160 ) )(this, param_1, "not allowed in this version", "line continuation", &_LC1);
         return 1;
      }

      goto LAB_00100191;
   }

   if (param_2) {
      ( **(code**)( *(long*)this + 0x160 ) )(this, param_1, "used at end of comment; the following line is still part of the comment", "line continuation", &_LC1);
   }
 else if (( (byte)this[0xd0] & 1 ) == 0) {
      uVar2 = 1;
      LAB_00100191:glslang::TParseVersions::profileRequires((TSourceLoc*)this, (int)param_1, 8, (char*)0x12c, (char*)0x0);
      glslang::TParseVersions::profileRequires((TSourceLoc*)this, (int)param_1, -9, (char*)0x1a4, "GL_ARB_shading_language_420pack");
      return uVar2;
   }

   return 1;
}
/* glslang::TParseContext::reservedPpErrorCheck(glslang::TSourceLoc const&, char const*, char
   const*) */void glslang::TParseContext::reservedPpErrorCheck(TParseContext *this, TSourceLoc *param_1, char *param_2, char *param_3) {
   long lVar1;
   char cVar2;
   int iVar3;
   char *pcVar4;
   code *UNRECOVERED_JUMPTABLE;
   if (( ( ( *param_2 == 'G' ) && ( param_2[1] == 'L' ) ) && ( param_2[2] == '_' ) ) && ( cVar2 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_EXT_spirv_intrinsics") ),cVar2 == '\0') {
      pcVar4 = "names beginning with \"GL_\" can\'t be (un)defined:";
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x168 );
   }
 else {
      iVar3 = strcmp(param_2, "defined");
      if (iVar3 == 0) {
         if (( (byte)this[0xd0] & 1 ) == 0) {
            UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x168 );
            pcVar4 = "\"defined\" can\'t be (un)defined:";
         }
 else {
            UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x170 );
            pcVar4 = "\"defined\" is (un)defined:";
         }

      }
 else {
         pcVar4 = strstr(param_2, "__");
         if (pcVar4 == (char*)0x0) {
            return;
         }

         cVar2 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_EXT_spirv_intrinsics");
         if (cVar2 != '\0') {
            return;
         }

         lVar1 = *(long*)this;
         if (*(int*)( this + 0xc ) == 8) {
            if (*(int*)( this + 0x18 ) < 300) {
               if (( (byte)this[0xd0] & 1 ) == 0) {
                  UNRECOVERED_JUMPTABLE = *(code**)( lVar1 + 0x168 );
                  pcVar4 = "names containing consecutive underscores are reserved, and an error if version < 300:";
                  goto LAB_00100302;
               }

            }
 else {
               iVar3 = strcmp(param_2, "__LINE__");
               if (( ( iVar3 == 0 ) || ( iVar3 = strcmp(param_2, "__FILE__") ),iVar3 == 0 )) {
                  UNRECOVERED_JUMPTABLE = *(code**)( lVar1 + 0x168 );
                  pcVar4 = "predefined names can\'t be (un)defined:";
                  goto LAB_00100302;
               }

            }

         }

         UNRECOVERED_JUMPTABLE = *(code**)( lVar1 + 0x170 );
         pcVar4 = "names containing consecutive underscores are reserved:";
      }

   }

   LAB_00100302:/* WARNING: Could not recover jumptable at 0x00100312. Too many branches *//* WARNING: Treating indirect jump as call */( *UNRECOVERED_JUMPTABLE )(this, param_1, pcVar4, param_3, param_2, UNRECOVERED_JUMPTABLE);
   return;
}
/* glslang::TParseContext::invariantCheck(glslang::TSourceLoc const&, glslang::TQualifier const&)
   [clone .part.0] */void glslang::TParseContext::invariantCheck(TParseContext *this, TSourceLoc *param_1, TQualifier *param_2) {
   byte bVar1;
   uint uVar2;
   int iVar3;
   bool bVar4;
   bool bVar5;
   uVar2 = (byte)param_2[8] & 0x7f;
   bVar1 = (byte)uVar2;
   if (bVar1 < 0x1f) {
      bVar4 = ( 0x71c00010UL >> ( (ulong)uVar2 & 0x3f ) & 1 ) != 0;
      iVar3 = *(int*)( this + 0x18 );
      if (!bVar4) {
         if (bVar1 < 0x1c) goto LAB_0010048a;
         if (iVar3 < 300) goto LAB_001004b2;
         if (( *(int*)( this + 0xc ) == 8 ) || ( 0x1a3 < iVar3 )) goto LAB_001004fa;
         LAB_00100566:bVar5 = false;
         goto LAB_00100570;
      }

      if (0x1b < bVar1) {
         if (iVar3 < 300) {
            return;
         }

         if (*(int*)( this + 0xc ) == 8) {
            return;
         }

         if (0x1a3 < iVar3) {
            return;
         }

         goto LAB_00100566;
      }

      LAB_0010048a:bVar5 = ( 0xe300008UL >> ( (ulong)uVar2 & 0x3f ) & 1 ) != 0;
      if (bVar5) {
         if (iVar3 < 300) {
            if (*(int*)( this + 0x1c ) != 0) {
               return;
            }

            goto LAB_001004b2;
         }

         LAB_00100520:if (*(int*)( this + 0xc ) != 8) goto LAB_00100526;
         goto LAB_0010052e;
      }

      if (299 < iVar3) goto LAB_00100520;
   }
 else {
      iVar3 = *(int*)( this + 0x18 );
      if (iVar3 < 300) goto LAB_001004b2;
      if (*(int*)( this + 0xc ) == 8) goto LAB_001004fa;
      bVar4 = false;
      bVar5 = false;
      LAB_00100526:if (0x1a3 < iVar3) {
         LAB_0010052e:if (bVar4) {
            return;
         }

         LAB_001004fa:/* WARNING: Could not recover jumptable at 0x0010051b. Too many branches *//* WARNING: Treating indirect jump as call */( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to an output", "invariant", &_LC1, *(code**)( *(long*)this + 0x158 ));
         return;
      }

      LAB_00100570:if (( *(int*)( this + 0x1c ) == 0 ) && ( bVar5 )) goto LAB_001004b2;
      bVar4 = (bool)( bVar4 | bVar5 );
   }

   if (bVar4) {
      return;
   }

   LAB_001004b2:/* WARNING: Could not recover jumptable at 0x001004d3. Too many branches *//* WARNING: Treating indirect jump as call */( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to an output, or to an input in a non-vertex stage\n", "invariant", &_LC1, *(code**)( *(long*)this + 0x158 ));
   return;
}
/* std::_Rb_tree<unsigned long, std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc>
   const*>, std::_Select1st<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc>
   const*> >, std::less<unsigned long>, std::allocator<std::pair<unsigned long const,
   glslang::TVector<glslang::TTypeLoc> const*> > >::_M_get_insert_unique_pos(unsigned long const&)
   [clone .isra.0] */undefined1[16];std::_Rb_tree<unsigned_long,std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>,std::_Select1st<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>::_M_get_insert_unique_pos (_Rb_tree<unsigned_long,std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>,std::_Select1st<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>
           *this,ulong *param_1) {
   undefined1 auVar1[16];
   _Rb_tree_node_base *p_Var2;
   _Rb_tree_node_base *p_Var3;
   _Rb_tree_node_base *p_Var4;
   ulong *puVar5;
   undefined1 auVar6[16];
   p_Var2 = *(_Rb_tree_node_base**)( this + 0x10 );
   if (*(_Rb_tree_node_base**)( this + 0x10 ) == (_Rb_tree_node_base*)0x0) {
      p_Var2 = (_Rb_tree_node_base*)( this + 8 );
   }
 else {
      do {
         p_Var4 = p_Var2;
         puVar5 = *(ulong**)( p_Var4 + 0x20 );
         p_Var2 = *(_Rb_tree_node_base**)( p_Var4 + 0x18 );
         if (param_1 < puVar5) {
            p_Var2 = *(_Rb_tree_node_base**)( p_Var4 + 0x10 );
         }

      }
 while ( p_Var2 != (_Rb_tree_node_base*)0x0 );
      p_Var2 = p_Var4;
      if (param_1 >= puVar5) goto LAB_001005fa;
   }

   if (*(_Rb_tree_node_base**)( this + 0x18 ) == p_Var2) {
      auVar1._8_8_ = 0;
      auVar1._0_8_ = p_Var2;
      return auVar1 << 0x40;
   }

   p_Var4 = (_Rb_tree_node_base*)std::_Rb_tree_decrement(p_Var2);
   puVar5 = *(ulong**)( p_Var4 + 0x20 );
   LAB_001005fa:p_Var3 = (_Rb_tree_node_base*)0x0;
   if (puVar5 < param_1) {
      p_Var4 = p_Var3;
      p_Var3 = p_Var2;
   }

   auVar6._8_8_ = p_Var3;
   auVar6._0_8_ = p_Var4;
   return auVar6;
}
/* std::_Rb_tree<glslang::TVector<glslang::TTypeLoc> const*,
   std::pair<glslang::TVector<glslang::TTypeLoc> const* const, std::map<unsigned long,
   glslang::TVector<glslang::TTypeLoc> const*, std::less<unsigned long>,
   std::allocator<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc> const*> > > >,
   std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc> const* const, std::map<unsigned
   long, glslang::TVector<glslang::TTypeLoc> const*, std::less<unsigned long>,
   std::allocator<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc> const*> > > >
   >, std::less<glslang::TVector<glslang::TTypeLoc> const*>,
   std::allocator<std::pair<glslang::TVector<glslang::TTypeLoc> const* const, std::map<unsigned
   long, glslang::TVector<glslang::TTypeLoc> const*, std::less<unsigned long>,
   std::allocator<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc> const*> > > > >
   >::_M_get_insert_unique_pos(glslang::TVector<glslang::TTypeLoc> const* const&) [clone .isra.0] */undefined1[16];std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>const*,std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>>>,std::less<glslang::TVector<glslang::TTypeLoc>const*>,std::allocator<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>>>>::_M_get_insert_unique_pos (_Rb_tree<glslang::TVector<glslang::TTypeLoc>const*,std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>>>,std::less<glslang::TVector<glslang::TTypeLoc>const*>,std::allocator<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>>>>
           *this,TVector **param_1) {
   undefined1 auVar1[16];
   _Rb_tree_node_base *p_Var2;
   _Rb_tree_node_base *p_Var3;
   _Rb_tree_node_base *p_Var4;
   TVector **ppTVar5;
   undefined1 auVar6[16];
   p_Var2 = *(_Rb_tree_node_base**)( this + 0x10 );
   if (*(_Rb_tree_node_base**)( this + 0x10 ) == (_Rb_tree_node_base*)0x0) {
      p_Var2 = (_Rb_tree_node_base*)( this + 8 );
   }
 else {
      do {
         p_Var4 = p_Var2;
         ppTVar5 = *(TVector***)( p_Var4 + 0x20 );
         p_Var2 = *(_Rb_tree_node_base**)( p_Var4 + 0x18 );
         if (param_1 < ppTVar5) {
            p_Var2 = *(_Rb_tree_node_base**)( p_Var4 + 0x10 );
         }

      }
 while ( p_Var2 != (_Rb_tree_node_base*)0x0 );
      p_Var2 = p_Var4;
      if (param_1 >= ppTVar5) goto LAB_0010069a;
   }

   if (*(_Rb_tree_node_base**)( this + 0x18 ) == p_Var2) {
      auVar1._8_8_ = 0;
      auVar1._0_8_ = p_Var2;
      return auVar1 << 0x40;
   }

   p_Var4 = (_Rb_tree_node_base*)std::_Rb_tree_decrement(p_Var2);
   ppTVar5 = *(TVector***)( p_Var4 + 0x20 );
   LAB_0010069a:p_Var3 = (_Rb_tree_node_base*)0x0;
   if (ppTVar5 < param_1) {
      p_Var4 = p_Var3;
      p_Var3 = p_Var2;
   }

   auVar6._8_8_ = p_Var3;
   auVar6._0_8_ = p_Var4;
   return auVar6;
}
/* std::_Rb_tree<int, std::pair<int const, glslang::TVariable*>, std::_Select1st<std::pair<int
   const, glslang::TVariable*> >, std::less<int>, glslang::pool_allocator<std::pair<int const,
   glslang::TVariable*> > >::_M_get_insert_unique_pos(int const&) [clone .isra.0] */undefined1[16];std::_Rb_tree<int,std::pair<int_const,glslang::TVariable*>,std::_Select1st<std::pair<int_const,glslang::TVariable*>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVariable*>>>::_M_get_insert_unique_pos (_Rb_tree<int,std::pair<int_const,glslang::TVariable*>,std::_Select1st<std::pair<int_const,glslang::TVariable*>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVariable*>>>
           *this,int *param_1) {
   undefined1 auVar1[16];
   _Rb_tree_node_base *p_Var2;
   _Rb_tree_node_base *p_Var3;
   _Rb_tree_node_base *p_Var4;
   int iVar5;
   int iVar6;
   undefined1 auVar7[16];
   iVar6 = (int)param_1;
   p_Var2 = *(_Rb_tree_node_base**)( this + 0x18 );
   if (*(_Rb_tree_node_base**)( this + 0x18 ) == (_Rb_tree_node_base*)0x0) {
      p_Var2 = (_Rb_tree_node_base*)( this + 0x10 );
   }
 else {
      do {
         p_Var4 = p_Var2;
         iVar5 = *(int*)( p_Var4 + 0x20 );
         p_Var2 = *(_Rb_tree_node_base**)( p_Var4 + 0x18 );
         if (iVar6 < iVar5) {
            p_Var2 = *(_Rb_tree_node_base**)( p_Var4 + 0x10 );
         }

      }
 while ( p_Var2 != (_Rb_tree_node_base*)0x0 );
      p_Var2 = p_Var4;
      if (iVar5 <= iVar6) goto LAB_00100738;
   }

   if (*(_Rb_tree_node_base**)( this + 0x20 ) == p_Var2) {
      auVar1._8_8_ = 0;
      auVar1._0_8_ = p_Var2;
      return auVar1 << 0x40;
   }

   p_Var4 = (_Rb_tree_node_base*)std::_Rb_tree_decrement(p_Var2);
   iVar5 = *(int*)( p_Var4 + 0x20 );
   LAB_00100738:p_Var3 = (_Rb_tree_node_base*)0x0;
   if (iVar5 < iVar6) {
      p_Var4 = p_Var3;
      p_Var3 = p_Var2;
   }

   auVar7._8_8_ = p_Var3;
   auVar7._0_8_ = p_Var4;
   return auVar7;
}
/* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::compare(std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   > const&) const [clone .isra.0] */ulong std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::compare(basic_string *param_1) {
   uint uVar1;
   ulong uVar2;
   ulong in_RCX;
   void *in_RDX;
   ulong uVar3;
   ulong in_RSI;
   uVar2 = in_RCX;
   if (in_RSI <= in_RCX) {
      uVar2 = in_RSI;
   }

   if (uVar2 != 0) {
      uVar1 = memcmp(param_1, in_RDX, uVar2);
      if (uVar1 != 0) {
         return (ulong)uVar1;
      }

   }

   uVar3 = in_RSI - in_RCX;
   uVar2 = 0x7fffffff;
   if (( (long)uVar3 < 0x80000000 ) && ( uVar2 = 0x80000000 ),-0x80000001 < (long)uVar3) {
      uVar2 = uVar3 & 0xffffffff;
   }

   return uVar2;
}
/* std::_Function_handler<bool (glslang::TType const&, glslang::TType const&, glslang::TType
   const&), glslang::TParseContext::findFunctionExplicitTypes(glslang::TSourceLoc const&,
   glslang::TFunction const&, bool&)::{lambda(glslang::TType const&, glslang::TType const&,
   glslang::TType const&)#1}>::_M_manager(std::_Any_data&, std::_Any_data const&,
   std::_Manager_operation) */undefined8 std::_Function_handler<bool(glslang::TType_const &, glslang::TType_const &, glslang::TType_const &),glslang::TParseContext::findFunctionExplicitTypes(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::{lambda(glslang::TType_const&,glslang::TType_const&,glslang::TType_const&)#1}>::_M_manager(undefined8 *param_1, undefined8 *param_2, int param_3) {
   if (param_3 != 0) {
      if (param_3 == 1) {
         *param_1 = param_2;
      }
 else if (param_3 == 2) {
         *param_1 = *param_2;
      }

      return 0;
   }

   *param_1 = &glslang::TParseContext::
              findFunctionExplicitTypes(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)
              ::{lambda(glslang::TType_const&,glslang::TType_const&,glslang::TType_const&)#1}::
              typeinfo;
   return 0;
}
/* std::_Function_handler<bool (glslang::TType const&, glslang::TType const&, glslang::TOperator,
   int), glslang::TParseContext::findFunctionExplicitTypes(glslang::TSourceLoc const&,
   glslang::TFunction const&, bool&)::{lambda(glslang::TType const&, glslang::TType const&,
   glslang::TOperator, int)#1}>::_M_manager(std::_Any_data&, std::_Any_data const&,
   std::_Manager_operation) */undefined8 std::_Function_handler<bool(glslang::TType_const &, glslang::TType_const &, glslang::TOperator, int),glslang::TParseContext::findFunctionExplicitTypes(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::{lambda(glslang::TType_const&,glslang::TType_const&,glslang::TOperator,int)#1}>::_M_manager(undefined8 *param_1, undefined8 *param_2, int param_3) {
   undefined8 uVar1;
   if (param_3 != 0) {
      if (param_3 == 1) {
         *param_1 = param_2;
      }
 else if (param_3 == 2) {
         uVar1 = param_2[1];
         *param_1 = *param_2;
         param_1[1] = uVar1;
      }

      return 0;
   }

   *param_1 = &glslang::TParseContext::findFunctionExplicitTypes(glslang::TSourceLoc_const & glslang::TFunction_const & ::{lambda(glslang::TType_const & glslang::TType_const & glslang::TOperator, int)#1}::
              typeinfo;
  return 0;
}, /* std::_Function_handler<bool (glslang::TType const&, glslang::TType const&, glslang::TType
   const&), glslang::TParseContext::findFunction400(glslang::TSourceLoc const&, glslang::TFunction
   const&, bool&)::{lambda(glslang::TType const&, glslang::TType const&, glslang::TType
   const&)#1}>::_M_manager(std::_Any_data&, std::_Any_data const&, std::_Manager_operation) */, undefined8std::_Function_handler<bool(glslang::TType_const &, glslang::TType_const &, glslang::TType_const &),glslang::TParseContext::findFunction400(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::{lambda(glslang::TType_const &, glslang::TType_const &, glslang::TType_const &)#1}>::_M_manager(undefined8 * param_1, undefined8, param_2,int param_3)(param_3 == 0) * param_1 = &glslang::TParseContext::findFunction400(glslang::TSourceLoc_const & glslang::TFunction_const & ::{lambda(glslang::TType_const&,glslang::TType_const&,glslang::TType_const&)#1}::
                typeinfo;
    return 0;
  }
  if (param_3 != 1) {
    return 0;
  }
  *param_1 = param_2;
  return 0;
}, /* std::_Function_handler<bool (glslang::TType const&, glslang::TType const&, glslang::TOperator,
   int), glslang::TParseContext::findFunction400(glslang::TSourceLoc const&, glslang::TFunction
   const&, bool&)::{lambda(glslang::TType const&, glslang::TType const&, glslang::TOperator,
   int)#1}>::_M_manager(std::_Any_data&, std::_Any_data const&, std::_Manager_operation) */, undefined8
std::
_Function_handler<bool(glslang::TType_const&,glslang::TType_const&,glslang::TOperator,int),glslang::TParseContext::findFunction400(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::{lambda(glslang::TType_const&,glslang::TType_const&,glslang::TOperator,int)#1}>
::_M_manager(undefined8 *param_1,undefined8 *param_2,int param_3), {
                  undefined8 uVar1;
                  if (param_3 != 0) {
                     if (param_3 == 1) {
                        *param_1 = param_2;
                     }
 else if (param_3 == 2) {
                        uVar1 = param_2[1];
                        *param_1 = *param_2;
                        param_1[1] = uVar1;
                     }

                     return 0;
                  }

                  *param_1 = &glslang::TParseContext::findFunction400(glslang::TSourceLoc_const & glslang::TFunction_const & ::{lambda(glslang::TType_const & glslang::TType_const & glslang::TOperator, int)#1}::
              typeinfo;
  return 0;
}, /* std::_Function_handler<bool (TIntermNode const&),
   glslang::TParseContext::builtInOpCheck(glslang::TSourceLoc const&, glslang::TFunction const&,
   glslang::TIntermOperator&)::{lambda(TIntermNode const&)#1}>::_M_manager(std::_Any_data&,
   std::_Any_data const&, std::_Manager_operation) */, undefined8
std::
_Function_handler<bool(TIntermNode_const&),glslang::TParseContext::builtInOpCheck(glslang::TSourceLoc_const&,glslang::TFunction_const&,glslang::TIntermOperator&)::{lambda(TIntermNode_const&)#1}>
::_M_manager(long *param_1,long *param_2,int param_3), {
                           undefined8 *puVar1;
                           undefined8 uVar2;
                           undefined8 *puVar3;
                           if (param_3 != 0) {
                              if (param_3 == 1) {
                                 *param_1 = *param_2;
                              }
 else if (param_3 == 2) {
                                 puVar1 = (undefined8*)*param_2;
                                 puVar3 = (undefined8*)operator_new(0x28);
                                 uVar2 = puVar1[1];
                                 *puVar3 = *puVar1;
                                 puVar3[1] = uVar2;
                                 uVar2 = puVar1[3];
                                 puVar3[2] = puVar1[2];
                                 puVar3[3] = uVar2;
                                 puVar3[4] = puVar1[4];
                                 *param_1 = (long)puVar3;
                              }
 else if (( param_3 == 3 ) && ( (void*)*param_1 != (void*)0x0 )) {
                                 operator_delete((void*)*param_1, 0x28);
                              }

                              return 0;
                           }

                           *param_1 = (long)&glslang::TParseContext::builtInOpCheck(glslang::TSourceLoc_const & glslang::TFunction_const & glslang::TIntermOperator & ::{lambda(TIntermNode_const&)#1}::typeinfo;
  return 0;
}



/* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::find(char const*, unsigned long, unsigned long) const [clone .isra.0] */

ulong std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::find
                (char *param_1,ulong param_2,ulong param_3), {
                                    char cVar1;
                                    int iVar2;
                                    void *__s1;
                                    ulong uVar3;
                                    ulong in_RCX;
                                    char *__n;
                                    char *__s;
                                    char *in_R8;
                                    if (in_R8 == (char*)0x0) {
                                       uVar3 = 0xffffffffffffffff;
                                       if (in_RCX <= param_2) {
                                          uVar3 = in_RCX;
                                       }

                                       return uVar3;
                                    }

                                    if (param_2 <= in_RCX) {
                                       return 0xffffffffffffffff;
                                    }

                                    __s = param_1 + in_RCX;
                                    if (( in_R8 <= (char*)( param_2 - in_RCX ) ) && ( __n = (char*)( param_2 - in_RCX ) + ( 1 - (long)in_R8 ) ),__n != (char*)0x0) {
                                       cVar1 = *(char*)param_3;
                                       while (__s1 = memchr(__s, (int)cVar1, (size_t)__n),__s1 != (void*)0x0) {
                                          iVar2 = memcmp(__s1, (void*)param_3, (size_t)in_R8);
                                          if (iVar2 == 0) {
                                             return (long)__s1 - (long)param_1;
                                          }

                                          __s = (char*)( (long)__s1 + 1 );
                                          if (param_1 + ( param_2 - (long)__s ) < in_R8) {
                                             return 0xffffffffffffffff;
                                          }

                                          __n = param_1 + ( param_2 - (long)__s ) + ( 1 - (long)in_R8 );
                                          if (__n == (char*)0x0) {
                                             return 0xffffffffffffffff;
                                          }

                                       }
;
                                    }

                                    return 0xffffffffffffffff;
                                 }
, /* std::_Rb_tree_iterator<std::pair<int const, glslang::TVariable*> > std::_Rb_tree<int,
   std::pair<int const, glslang::TVariable*>, std::_Select1st<std::pair<int const,
   glslang::TVariable*> >, std::less<int>, glslang::pool_allocator<std::pair<int const,
   glslang::TVariable*> > >::_M_emplace_hint_unique<std::piecewise_construct_t const&,
   std::tuple<int const&>, std::tuple<> >(std::_Rb_tree_const_iterator<std::pair<int const,
   glslang::TVariable*> >, std::piecewise_construct_t const&, std::tuple<int const&>&&,
   std::tuple<>&&) [clone .isra.0] */, _Rb_tree_node_base *
std::
_Rb_tree<int, std::pair<int_const,glslang::TVariable*>, std::_Select1st<std::pair<int_const,glslang::TVariable*>>, std::less<int>, glslang::pool_allocator<std::pair<int_const,glslang::TVariable*>> > ::_M_emplace_hint_unique<std::piecewise_construct_t_const&,std::tuple<int_const&>,std::tuple<>>(_Rb_tree<int,std::pair<int_const,glslang::TVariable*>,std::_Select1st<std::pair<int_const,glslang::TVariable*>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVariable*>>> * param_1, _Rb_tree_node_base * param_2, undefined8 * param_3) * p_Var1 * puVar3 * p_Var4 * p_Var5;
  bool bVar6;
  undefined1 auVar7[16](_Rb_tree_node_base * )(param_1 + 0x10)(_Rb_tree_node_base *)glslang::TPoolAllocator::allocate(*(ulong *)param_1);
  puVar3 = (uint *)*param_3;
  *(undefined8 *)(p_Var4 + 0x28) = 0;
  uVar2 = *puVar3;
  *(uint *)(p_Var4 + 0x20) = uVar2;
  if (param_2 == p_Var1), {
                                       if (( *(long*)( param_1 + 0x30 ) != 0 ) && ( p_Var5 = *(_Rb_tree_node_base**)( param_1 + 0x28 ) * (int*)( p_Var5 + 0x20 ) < (int)uVar2 )) goto LAB_00100b5b;
                                       LAB_00100b28:auVar7 = _M_get_insert_unique_pos(param_1, (int*)(ulong)uVar2);
                                       bVar6 = auVar7._0_8_ != (_Rb_tree_node_base*)0x0;
                                       p_Var5 = auVar7._8_8_;
                                       if (auVar7._8_8_ == (_Rb_tree_node_base*)0x0) {
                                          return auVar7._0_8_;
                                       }

                                       LAB_00100af0:param_2 = p_Var5;
                                       p_Var5 = param_2;
                                       if (( p_Var1 != param_2 ) && ( !bVar6 )) {
                                          LAB_00100b68:bVar6 = (int)uVar2 < *(int*)( param_2 + 0x20 );
                                          goto LAB_00100afe;
                                       }

                                    }
, else {
    if (*(int *)(param_2 + 0x20) <= (int)uVar2)((int)uVar2 <= *(int*)( param_2 + 0x20 )) = *(_Rb_tree_node_base**)( param_1 + 0x28 ));
                           if (param_2 == p_Var5) goto LAB_00100b5b;
                           p_Var5 = (_Rb_tree_node_base*)std::_Rb_tree_increment(param_2);
                           if (*(int*)( p_Var5 + 0x20 ) <= (int)uVar2) goto LAB_00100b28;
                           bVar6 = true;
                           if (*(long*)( param_2 + 0x18 ) != 0) goto LAB_00100af0;
                           goto LAB_00100b68;
                        }
, p_Var5 = *(_Rb_tree_node_base **)(param_1 + 0x20));
                  if (param_2 != *(_Rb_tree_node_base**)( param_1 + 0x20 )) {
                     p_Var5 = (_Rb_tree_node_base*)std::_Rb_tree_decrement(param_2);
                     if ((int)uVar2 <= *(int*)( p_Var5 + 0x20 )) goto LAB_00100b28;
                     if (*(long*)( p_Var5 + 0x18 ) != 0) {
                        bVar6 = true;
                        goto LAB_00100afe;
                     }

                     LAB_00100b5b:bVar6 = false;
                     goto LAB_00100af0;
                  }

               }
, param_2 = p_Var5;
  bVar6 = true;
LAB_00100afe:
  std::_Rb_tree_insert_and_rebalance(bVar6, p_Var4, param_2, p_Var1) * (long*)( param_1 + 0x30 ) = *(long*)( param_1 + 0x30 ) + 1, ;
  return p_Var4;
}



/* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::compare(char const*) const [clone .isra.0] */

ulong std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>>::compare
                (char *param_1), {
               uint uVar1;
               size_t sVar2;
               ulong uVar3;
               char *in_RDX;
               ulong uVar4;
               ulong in_RSI;
               sVar2 = strlen(in_RDX);
               uVar3 = in_RSI;
               if (sVar2 <= in_RSI) {
                  uVar3 = sVar2;
               }

               if (uVar3 != 0) {
                  uVar1 = memcmp(param_1, in_RDX, uVar3);
                  if (uVar1 != 0) {
                     return (ulong)uVar1;
                  }

               }

               uVar4 = in_RSI - sVar2;
               uVar3 = 0x7fffffff;
               if (( (long)uVar4 < 0x80000000 ) && ( uVar3 = 0x80000000 ),-0x80000001 < (long)uVar4) {
                  uVar3 = uVar4 & 0xffffffff;
               }

               return uVar3;
            }
, /* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::compare(unsigned long, unsigned long, char const*) const [clone .isra.0] */, ulong std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>>::compare
                (ulong param_1,ulong param_2,char *param_3), {
               code *pcVar1;
               uint uVar2;
               size_t sVar3;
               ulong uVar4;
               long lVar5;
               long *plVar6;
               ulong in_RCX;
               size_t __n;
               ulong uVar7;
               char *pcVar8;
               char *in_R8;
               if (param_3 <= param_2) {
                  uVar7 = param_2 - (long)param_3;
                  if (in_RCX < param_2 - (long)param_3) {
                     uVar7 = in_RCX;
                  }

                  sVar3 = strlen(in_R8);
                  __n = sVar3;
                  if (uVar7 <= sVar3) {
                     __n = uVar7;
                  }

                  if (__n != 0) {
                     uVar2 = memcmp(param_3 + param_1, in_R8, __n);
                     if (uVar2 != 0) {
                        return (ulong)uVar2;
                     }

                  }

                  uVar7 = uVar7 - sVar3;
                  uVar4 = 0x7fffffff;
                  if (( (long)uVar7 < 0x80000000 ) && ( uVar4 = 0x80000000 ),-0x80000001 < (long)uVar7) {
                     uVar4 = uVar7 & 0xffffffff;
                  }

                  return uVar4;
               }

               pcVar8 = "basic_string::compare";
               std::__throw_out_of_range_fmt("%s: __pos (which is %zu) > this->size() (which is %zu)", "basic_string::compare", param_3, param_2);
               if (*(code**)( *(long*)pcVar8 + 0x50 ) == glslang::TType::getQualifier) {
                  *(byte*)( (long)pcVar8 + 0x20 ) = *(byte*)( (long)pcVar8 + 0x20 ) & 0xf0 | 2;
               }
 else {
                  lVar5 = ( **(code**)( *(long*)pcVar8 + 0x50 ) )(pcVar8);
                  pcVar1 = *(code**)( *(long*)pcVar8 + 0x50 );
                  *(byte*)( lVar5 + 0x10 ) = *(byte*)( lVar5 + 0x10 ) & 0xf0 | 2;
                  if (pcVar1 != glslang::TType::getQualifier) {
                     plVar6 = (long*)( *pcVar1 )(pcVar8);
                     goto LAB_00100cb1;
                  }

               }

               plVar6 = (long*)( (long)pcVar8 + 0x10 );
               LAB_00100cb1:uVar2 = *(byte*)( (long)plVar6 + 0xf ) & 0xffffff8f | 0x20;
               *(char*)( (long)plVar6 + 0xf ) = (char)uVar2;
               return (ulong)uVar2;
            }
, /* glslang::TParseContext::setUniformBlockDefaults(glslang::TType&) const */, void __thiscall glslang::TParseContext::setUniformBlockDefaults(TParseContext *this, TType * param_1) * pcVar1 * pTVar3(*(code**)( *(long*)param_1 + 0x50 ) == TType::getQualifier){
    param_1[0x20] = ( TType )((byte)param_1[0x20] & 0xf0 | 2)(**(code**)( *(long*)param_1 + 0x50 ))(param_1) * (code**)( *(long*)param_1 + 0x50 ) * (byte*)( lVar2 + 0x10 ) = *(byte*)( lVar2 + 0x10 ) & 0xf0 | 2(pcVar1 != TType::getQualifier) = (TType*)( *pcVar1 )(param_1) + 0x10;
LAB_00100cb1:
  pTVar3[0xf] = ( TType )((byte)pTVar3[0xf] & 0x8f | 0x20) * this, TType * param_1) * pcVar1);
   long lVar2;
   TType *pTVar3;
   if (*(code**)( *(long*)param_1 + 0x50 ) == TType::getQualifier) {
      param_1[0x20] = ( TType )((byte)param_1[0x20] & 0xf0 | 3);
   }
 else {
      lVar2 = ( **(code**)( *(long*)param_1 + 0x50 ) )(param_1);
      pcVar1 = *(code**)( *(long*)param_1 + 0x50 );
      *(byte*)( lVar2 + 0x10 ) = *(byte*)( lVar2 + 0x10 ) & 0xf0 | 3;
      if (pcVar1 != TType::getQualifier) {
         pTVar3 = (TType*)( *pcVar1 )(param_1);
         goto LAB_00100d21;
      }

   }

   pTVar3 = param_1 + 0x10;
   LAB_00100d21:pTVar3[0xf] = ( TType )((byte)pTVar3[0xf] & 0x8f | 0x10);
   return;
}
/* glslang::TParseContext::rValueErrorCheck(glslang::TSourceLoc const&, char const*,
   glslang::TIntermTyped*) */void glslang::TParseContext::rValueErrorCheck(TParseContext *this, TSourceLoc *param_1, char *param_2, TIntermTyped *param_3) {
   ushort uVar1;
   code *pcVar2;
   long *plVar3;
   long lVar4;
   long *plVar5;
   glslang::TParseContextBase::rValueErrorCheck((TSourceLoc*)this, (char*)param_1, (TIntermTyped*)param_2);
   plVar3 = (long*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
   if (plVar3 != (long*)0x0) {
      if (*(code**)( *plVar3 + 0x108 ) == TIntermTyped::getQualifier) {
         if (( *(byte*)( (long)plVar3 + 0x3e ) & 1 ) == 0) {
            LAB_00100df8:plVar5 = plVar3 + 6;
            LAB_00100dfc:if (( *(byte*)( (long)plVar5 + 0xc ) & 0x40 ) != 0) {
               pcVar2 = *(code**)( *(long*)this + 0x158 );
               if (*(code**)( *plVar3 + 400 ) == TIntermSymbol::getName_abi_cxx11_) {
                  plVar3 = plVar3 + 0x19;
               }
 else {
                  plVar3 = (long*)( **(code**)( *plVar3 + 400 ) )(plVar3);
               }

               ( *pcVar2 )(this, param_1, "can\'t read from explicitly-interpolated object: ", param_2, plVar3[1]);
               pcVar2 = *(code**)( *(long*)param_3 + 0x108 );
               goto joined_r0x00100dc9;
            }

         }

      }
 else {
         lVar4 = ( **(code**)( *plVar3 + 0x108 ) )(plVar3);
         if (( *(byte*)( lVar4 + 0xe ) & 1 ) == 0) {
            if (*(code**)( *plVar3 + 0x108 ) == TIntermTyped::getQualifier) goto LAB_00100df8;
            plVar5 = (long*)( **(code**)( *plVar3 + 0x108 ) )(plVar3);
            goto LAB_00100dfc;
         }

      }

   }

   pcVar2 = *(code**)( *(long*)param_3 + 0x108 );
   joined_r0x00100dc9:if (pcVar2 == TIntermTyped::getQualifier) {
      uVar1 = *(ushort*)( param_3 + 0x38 );
   }
 else {
      lVar4 = ( *pcVar2 )(param_3);
      uVar1 = *(ushort*)( lVar4 + 8 );
   }

   if (( ( ( ( uVar1 & 0xff80 ) == 0x100 ) && ( lVar4 = *(long*)( this + 0x38 ) * (char*)( lVar4 + 0x284 ) == '\0' ) ) && ( *(char*)( lVar4 + 0x285 ) == '\0' ) ) && ( ( ( *(char*)( lVar4 + 0x286 ) == '\0' && ( *(long*)( lVar4 + 0x288 ) == -1 ) ) && ( *(int*)( lVar4 + 0x290 ) == -1 ) ) )) {
      /* WARNING: Could not recover jumptable at 0x00100eeb. Too many branches */
      /* WARNING: Treating indirect jump as call */
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can\'t read from gl_WorkGroupSize before a fixed workgroup size has been declared", param_2, &_LC1, *(code**)( *(long*)this + 0x158 ));
      return;
   }

   return;
}
/* glslang::TParseContext::fixBlockUniformOffsets(glslang::TQualifier&,
   glslang::TVector<glslang::TTypeLoc>&) [clone .part.0] */void glslang::TParseContext::fixBlockUniformOffsets(TParseContext *this, TQualifier *param_1, TVector *param_2) {
   int iVar1;
   code *pcVar2;
   int iVar3;
   byte bVar4;
   int iVar5;
   long *plVar6;
   long *plVar7;
   long lVar8;
   uint uVar9;
   uint uVar10;
   long *plVar11;
   uint uVar12;
   ulong uVar13;
   long lVar14;
   long in_FS_OFFSET;
   bool bVar15;
   uint local_50;
   int local_48;
   undefined1 local_44[4];
   long local_40;
   lVar8 = *(long*)( param_2 + 8 );
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(long*)( param_2 + 0x10 ) != lVar8) {
      uVar10 = 0;
      uVar13 = 0;
      local_50 = 0;
      do {
         lVar14 = uVar13 * 0x20;
         pcVar2 = *(code**)( **(long**)( lVar8 + lVar14 ) + 0x50 );
         if (pcVar2 == TType::getQualifier) {
            plVar7 = *(long**)( lVar8 + lVar14 ) + 2;
         }
 else {
            plVar7 = (long*)( *pcVar2 )();
            lVar8 = *(long*)( param_2 + 8 );
         }

         plVar11 = *(long**)( lVar8 + lVar14 );
         if (*(code**)( *plVar11 + 0x50 ) == TType::getQualifier) {
            plVar6 = plVar11 + 2;
         }
 else {
            plVar6 = (long*)( **(code**)( *plVar11 + 0x50 ) )();
            plVar11 = *(long**)( *(long*)( param_2 + 8 ) + lVar14 );
         }

         bVar4 = *(byte*)( (long)plVar6 + 0xf ) >> 4;
         if (( bVar4 & 7 ) == 0) {
            bVar15 = ( (byte)param_1[0xf] & 0x70 ) == 0x10;
         }
 else {
            bVar15 = ( bVar4 & 7 ) == 1;
         }

         iVar5 = glslang::TIntermediate::getMemberAlignment(plVar11, &local_48, local_44, (byte)param_1[0x10] & 0xf, bVar15);
         uVar12 = *(uint*)( (long)plVar7 + 0x14 );
         uVar9 = uVar10;
         if (uVar12 != 0xffffffff) {
            plVar11 = (long*)( lVar8 + lVar14 ) + 1;
            uVar9 = uVar12;
            if (( iVar5 - 1U & uVar12 ) != 0) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, plVar11, "must be a multiple of the member\'s alignment", "offset", "(layout offset = %d | member alignment = %d)", uVar12, iVar5);
               uVar9 = *(uint*)( (long)plVar7 + 0x14 );
            }

            if (*(int*)( this + 0x20 ) == 0) {
               uVar12 = uVar9;
               if ((int)uVar9 < (int)uVar10) {
                  ( **(code**)( *(long*)this + 0x158 ) )(this, plVar11, "cannot lie in previous members", "offset", &_LC1);
                  uVar12 = *(uint*)( (long)plVar7 + 0x14 );
               }

               uVar9 = uVar10;
               if ((int)uVar10 < (int)uVar12) {
                  uVar9 = uVar12;
               }

            }

         }

         iVar1 = (int)plVar7[3];
         lVar8 = *(long*)( param_2 + 8 );
         iVar3 = iVar1;
         if (iVar1 <= iVar5) {
            iVar3 = iVar5;
         }

         if (iVar1 != -1) {
            iVar5 = iVar3;
         }

         pcVar2 = *(code**)( **(long**)( lVar8 + lVar14 ) + 0x50 );
         uVar10 = iVar5 + -1 + uVar9 & -iVar5;
         if (pcVar2 == TType::getQualifier) {
            plVar7 = *(long**)( lVar8 + lVar14 ) + 2;
         }
 else {
            plVar7 = (long*)( *pcVar2 )();
            lVar8 = *(long*)( param_2 + 8 );
         }

         lVar14 = *(long*)( param_2 + 0x10 );
         local_50 = local_50 + 1;
         uVar13 = (ulong)local_50;
         *(uint*)( (long)plVar7 + 0x14 ) = uVar10;
         uVar10 = uVar10 + local_48;
      }
 while ( uVar13 < ( ulong )(lVar14 - lVar8 >> 5) );
   }

   if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   return;
}
/* glslang::TParseContext::lValueErrorCheck(glslang::TSourceLoc const&, char const*,
   glslang::TIntermTyped*) */undefined8 glslang::TParseContext::lValueErrorCheck(TParseContext *this, TSourceLoc *param_1, char *param_2, TIntermTyped *param_3) {
   int iVar1;
   long lVar2;
   char cVar3;
   uint uVar4;
   long *plVar5;
   long lVar6;
   long *plVar7;
   undefined8 uVar8;
   long *plVar9;
   code *pcVar10;
   char *pcVar11;
   TIntermTyped *pTVar12;
   undefined8 *puVar13;
   long in_FS_OFFSET;
   undefined1 local_58[16];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   plVar5 = (long*)( **(code**)( *(long*)param_3 + 0x40 ) )(param_3);
   if (plVar5 != (long*)0x0) {
      uVar4 = *(uint*)( plVar5 + 0x17 );
      if (uVar4 < 0xb8) {
         if (( 0xb5 < uVar4 ) && ( *(int*)( this + 0x1c ) == 1 )) {
            if (*(code**)( *plVar5 + 400 ) == TIntermBinary::getLeft) {
               plVar7 = (long*)plVar5[0x18];
            }
 else {
               plVar7 = (long*)( **(code**)( *plVar5 + 400 ) )(plVar5);
            }

            if (*(code**)( *plVar7 + 0xf0 ) == TIntermTyped::getType) {
               plVar7 = plVar7 + 4;
            }
 else {
               plVar7 = (long*)( **(code**)( *plVar7 + 0xf0 ) )();
            }

            if (*(code**)( *plVar7 + 0x58 ) == TType::getQualifier) {
               if (( *(byte*)( plVar7 + 3 ) & 0x7f ) == 4) {
                  LAB_00101590:plVar7 = plVar7 + 2;
                  LAB_00101594:if (( *(byte*)( (long)plVar7 + 0xd ) & 0x10 ) == 0) {
                     if (*(code**)( *plVar5 + 400 ) == TIntermBinary::getLeft) {
                        plVar7 = (long*)plVar5[0x18];
                     }
 else {
                        plVar7 = (long*)( **(code**)( *plVar5 + 400 ) )(plVar5);
                     }

                     lVar6 = ( **(code**)( *plVar7 + 0x60 ) )();
                     if (lVar6 != 0) {
                        if (*(code**)( *plVar5 + 0x198 ) == TIntermBinary::getRight) {
                           plVar7 = (long*)plVar5[0x19];
                        }
 else {
                           plVar7 = (long*)( **(code**)( *plVar5 + 0x198 ) )(plVar5);
                        }

                        plVar7 = (long*)( **(code**)( *plVar7 + 0x60 ) )();
                        if (plVar7 != (long*)0x0) {
                           if (*(code**)( *plVar7 + 0x110 ) == TIntermTyped::getQualifier) {
                              plVar7 = plVar7 + 6;
                           }
 else {
                              plVar7 = (long*)( **(code**)( *plVar7 + 0x110 ) )(plVar7);
                           }

                           if (( *(ushort*)( plVar7 + 1 ) & 0xff80 ) == 0x1980) goto LAB_00101426;
                        }

                        ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "tessellation-control per-vertex output l-value must be indexed with gl_InvocationID", &_LC38, &_LC1);
                     }

                  }

               }

            }
 else {
               lVar6 = ( **(code**)( *plVar7 + 0x58 ) )(plVar7);
               if (( *(byte*)( lVar6 + 8 ) & 0x7f ) == 4) {
                  if (*(code**)( *plVar7 + 0x58 ) == TType::getQualifier) goto LAB_00101590;
                  plVar7 = (long*)( **(code**)( *plVar7 + 0x58 ) )(plVar7);
                  goto LAB_00101594;
               }

            }

            LAB_00101426:uVar4 = *(uint*)( plVar5 + 0x17 );
            goto LAB_0010142d;
         }

         goto LAB_00101329;
      }

      if (uVar4 == 0xb9) {
         pcVar10 = *(code**)( *(long*)this + 0x200 );
         if (*(code**)( *plVar5 + 400 ) == TIntermBinary::getLeft) {
            lVar6 = plVar5[0x18];
         }
 else {
            lVar6 = ( **(code**)( *plVar5 + 400 ) )(plVar5);
         }

         cVar3 = ( *pcVar10 )(this, param_1, param_2, lVar6);
         if (cVar3 == '\0') {
            local_58 = (undefined1[16])0x0;
            if (*(code**)( *plVar5 + 0x198 ) == TIntermBinary::getRight) {
               plVar5 = (long*)plVar5[0x19];
            }
 else {
               plVar5 = (long*)( **(code**)( *plVar5 + 0x198 ) )(plVar5);
            }

            plVar5 = (long*)( **(code**)( *plVar5 + 0x30 ) )();
            if (*(code**)( *plVar5 + 400 ) == TIntermAggregate::getSequence) {
               plVar7 = plVar5 + 0x18;
               pcVar10 = TIntermAggregate::getSequence;
            }
 else {
               plVar7 = (long*)( **(code**)( *plVar5 + 400 ) )(plVar5);
               pcVar10 = *(code**)( *plVar5 + 400 );
            }

            puVar13 = (undefined8*)plVar7[1];
            while (true) {
               plVar7 = plVar5 + 0x18;
               if (pcVar10 != TIntermAggregate::getSequence) {
                  plVar7 = (long*)( *pcVar10 )(plVar5);
               }

               if (puVar13 == (undefined8*)plVar7[2]) goto LAB_00101468;
               plVar7 = (long*)*puVar13;
               puVar13 = puVar13 + 1;
               plVar7 = (long*)( **(code**)( *plVar7 + 0x18 ) )();
               lVar6 = ( **(code**)( *plVar7 + 0x28 ) )(plVar7);
               lVar6 = (long)**(int**)( *(long*)( lVar6 + 0xc0 ) + 8 );
               iVar1 = *(int*)( local_58 + lVar6 * 4 );
               *(int*)( local_58 + lVar6 * 4 ) = iVar1 + 1;
               if (1 < iVar1 + 1) break;
               pcVar10 = *(code**)( *plVar5 + 400 );
            }
;
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, " l-value of swizzle cannot have duplicate components", param_2, &_LC1);
         }

         goto LAB_001014af;
      }

      LAB_0010142d:if (uVar4 != 0xb8) goto LAB_00101329;
      if (*(code**)( *plVar5 + 400 ) == TIntermBinary::getLeft) {
         lVar6 = plVar5[0x18];
      }
 else {
         lVar6 = ( **(code**)( *plVar5 + 400 ) )(plVar5);
      }

      if (*(char*)( lVar6 + 0x28 ) != '\x12') goto LAB_00101329;
      LAB_00101468:uVar8 = 0;
      goto LAB_001014b4;
   }

   LAB_00101329:cVar3 = glslang::TParseContextBase::lValueErrorCheck((TSourceLoc*)this, (char*)param_1, (TIntermTyped*)param_2);
   if (cVar3 == '\0') {
      plVar7 = (long*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
      lVar6 = 0;
      if (plVar7 != (long*)0x0) {
         if (*(code**)( *plVar7 + 400 ) == TIntermSymbol::getName_abi_cxx11_) {
            plVar9 = plVar7 + 0x19;
         }
 else {
            plVar9 = (long*)( **(code**)( *plVar7 + 400 ) )(plVar7);
         }

         lVar6 = plVar9[1];
      }

      if (*(code**)( *(long*)param_3 + 0x108 ) == TIntermTyped::getQualifier) {
         pTVar12 = param_3 + 0x30;
      }
 else {
         pTVar12 = (TIntermTyped*)( **(code**)( *(long*)param_3 + 0x108 ) )(param_3);
      }

      switch ((char)pTVar12[8] + 0x7dU & 0x7f) {
         case 0:
      pcVar11 = "can\'t modify shader input";
      break;
         default:
switchD_001013bc_caseD_1:
      if ((plVar5 != (long *)0x0) || (plVar7 != (long *)0x0)) goto LAB_00101468;
      (**(code **)(*(long *)this + 0x158))(this,param_1," l-value required",param_2,&_LC1);
      goto LAB_001014af;
         case 0xc:
      if (*(int *)(this + 0x1c) != 0xd) goto switchD_001013bc_caseD_1;
      pcVar11 = "can\'t modify variable with storage qualifier taskPayloadSharedEXT in mesh shaders"
      ;
      break;
         case 0x11:
      pcVar11 = "can\'t modify gl_VertexID";
      break;
         case 0x12:
      pcVar11 = "can\'t modify gl_InstanceID";
      break;
         case 0x16:
      pcVar11 = "can\'t modify gl_FrontFace";
      break;
         case 0x17:
      pcVar11 = "can\'t modify gl_FragCoord";
      break;
         case 0x18:
      pcVar11 = "can\'t modify gl_PointCoord";
      break;
         case 0x1a:
      lVar2 = *(long *)(this + 0x38);
      iVar1 = *(int *)(this + 0xc);
      *(undefined1 *)(lVar2 + 0x274) = 1;
      if ((iVar1 != 8) || (*(char *)(lVar2 + 0x329) == '\0')) goto switchD_001013bc_caseD_1;
      pcVar11 = "can\'t modify gl_FragDepth if using early_fragment_tests";
      break;
         case 0x1b:
      lVar2 = *(long *)(this + 0x38);
      iVar1 = *(int *)(this + 0xc);
      *(undefined1 *)(lVar2 + 0x275) = 1;
      if ((iVar1 != 8) || (*(char *)(lVar2 + 0x329) == '\0')) goto switchD_001013bc_caseD_1;
      pcVar11 = "can\'t modify EvqFragStencil if using early_fragment_tests";
      }

      if (plVar7 == (long*)0x0) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, " l-value required", param_2, &_LC43, pcVar11);
      }
 else {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, " l-value required", param_2, "\"%s\" (%s)", lVar6, pcVar11);
      }

   }

   LAB_001014af:uVar8 = 1;
   LAB_001014b4:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return uVar8;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* std::_Function_handler<bool (TIntermNode const&),
   glslang::TParseContext::builtInOpCheck(glslang::TSourceLoc const&, glslang::TFunction const&,
   glslang::TIntermOperator&)::{lambda(TIntermNode const&)#1}>::_M_invoke(std::_Any_data const&,
   TIntermNode const&) */undefined1 std::_Function_handler<bool(TIntermNode_const &),glslang::TParseContext::builtInOpCheck(glslang::TSourceLoc_const&,glslang::TFunction_const&,glslang::TIntermOperator&)::{lambda(TIntermNode_const&)#1}>::_M_invoke(_Any_data *param_1, TIntermNode *param_2) {
   char cVar1;
   undefined8 *puVar2;
   uint uVar3;
   long *plVar4;
   long lVar5;
   long *plVar6;
   puVar2 = *(undefined8**)param_1;
   plVar4 = (long*)( **(code**)( *(long*)param_2 + 0x78 ) )(param_2);
   if (plVar4 != (long*)0x0) {
      if (*(code**)( *plVar4 + 0xf0 ) == glslang::TIntermTyped::getType) {
         plVar6 = plVar4 + 4;
      }
 else {
         plVar6 = (long*)( **(code**)( *plVar4 + 0xf0 ) )(plVar4);
      }

      if (*(code**)( *plVar6 + 0x58 ) == glslang::TType::getQualifier) {
         plVar6 = plVar6 + 2;
      }
 else {
         plVar6 = (long*)( **(code**)( *plVar6 + 0x58 ) )();
      }

      if (( *(byte*)( plVar6 + 1 ) & 0x7f ) == 3) {
         *(undefined1*)puVar2[1] = 1;
         cVar1 = *(char*)puVar2[4];
      }
 else {
         cVar1 = *(char*)puVar2[4];
      }

      if (cVar1 != '\0') {
         if (*(code**)( *plVar4 + 0xf0 ) == glslang::TIntermTyped::getType) {
            plVar4 = plVar4 + 4;
         }
 else {
            plVar4 = (long*)( **(code**)( *plVar4 + 0xf0 ) )(plVar4);
         }

         if (*(code**)( *plVar4 + 0x38 ) == glslang::TType::getBasicType) {
            uVar3 = ( uint ) * (byte*)( plVar4 + 1 );
         }
 else {
            uVar3 = ( **(code**)( *plVar4 + 0x38 ) )();
         }

         if (uVar3 != 0x10) {
            if (0x3fffffffffffffffU - *(long*)( (char*)puVar2[2] + 8 ) < 0x58) {
               /* WARNING: Subroutine does not return */
               std::__throw_length_error("basic_string::append");
            }

            std::__cxx11::string::_M_append((char*)puVar2[2], 0x14b8b8);
            *(undefined1*)*puVar2 = 0;
            cVar1 = *(char*)( puVar2 + 3 );
            goto joined_r0x001018c8;
         }

      }

   }

   cVar1 = *(char*)( puVar2 + 3 );
   joined_r0x001018c8:if (( ( cVar1 != '\0' ) && ( lVar5 = ( **(code**)( *(long*)param_2 + 0xa0 ) )(param_2) ),lVar5 != 0 )) &&( *(int*)( lVar5 + 0xb8 ) == 0xb8 ) * (undefined1*)puVar2[4] = 1;
}
return *(undefined1*)*puVar2;}/* glslang::TParseContext::checkRuntimeSizable(glslang::TSourceLoc const&, glslang::TIntermTyped
   const&) [clone .part.0] */void glslang::TParseContext::checkRuntimeSizable(TParseContext *this, TSourceLoc *param_1, TIntermTyped *param_2) {
   TIntermTyped TVar1;
   int iVar2;
   uint uVar3;
   long *plVar4;
   long lVar5;
   long *plVar6;
   TIntermTyped *pTVar7;
   if (*(code**)( *(long*)param_2 + 0xf0 ) == TIntermTyped::getType) {
      pTVar7 = param_2 + 0x20;
   }
 else {
      pTVar7 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
   }

   if (*(code**)( *(long*)pTVar7 + 0x58 ) == TType::getQualifier) {
      pTVar7 = pTVar7 + 0x10;
   }
 else {
      pTVar7 = (TIntermTyped*)( **(code**)( *(long*)pTVar7 + 0x58 ) )();
   }

   if (( *(ushort*)( pTVar7 + 8 ) & 0xff80 ) == 0x2380) {
      return;
   }

   if (*(code**)( *(long*)param_2 + 0xf0 ) == TIntermTyped::getType) {
      pTVar7 = param_2 + 0x20;
   }
 else {
      pTVar7 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
   }

   if (*(code**)( *(long*)pTVar7 + 0x58 ) == TType::getQualifier) {
      pTVar7 = pTVar7 + 0x10;
   }
 else {
      pTVar7 = (TIntermTyped*)( **(code**)( *(long*)pTVar7 + 0x58 ) )();
   }

   lVar5 = *(long*)param_2;
   if (( (byte)pTVar7[8] & 0x7f ) == 6) {
      plVar4 = (long*)( **(code**)( lVar5 + 0xa0 ) )(param_2);
      if (( plVar4 != (long*)0x0 ) && ( (int)plVar4[0x17] == 0xb8 )) {
         if (*(code**)( *plVar4 + 400 ) == TIntermBinary::getLeft) {
            lVar5 = plVar4[0x18];
         }
 else {
            lVar5 = ( **(code**)( *plVar4 + 400 ) )(plVar4);
         }

         if (*(char*)( lVar5 + 0x28 ) == '\x12') {
            if (*(code**)( *plVar4 + 0x198 ) == TIntermBinary::getRight) {
               plVar6 = (long*)plVar4[0x19];
            }
 else {
               plVar6 = (long*)( **(code**)( *plVar4 + 0x198 ) )(plVar4);
            }

            lVar5 = ( **(code**)( *plVar6 + 0x28 ) )();
            iVar2 = **(int**)( *(long*)( lVar5 + 0xc0 ) + 8 );
            if (*(code**)( *plVar4 + 400 ) == TIntermBinary::getLeft) {
               plVar4 = (long*)plVar4[0x18];
            }
 else {
               plVar4 = (long*)( **(code**)( *plVar4 + 400 ) )(plVar4);
            }

            if (*(code**)( *plVar4 + 0xf0 ) == TIntermTyped::getType) {
               plVar4 = plVar4 + 4;
            }
 else {
               plVar4 = (long*)( **(code**)( *plVar4 + 0xf0 ) )();
            }

            if (*(code**)( *plVar4 + 0xa8 ) == TType::getReferentType) {
               lVar5 = plVar4[0xd];
            }
 else {
               lVar5 = ( **(code**)( *plVar4 + 0xa8 ) )();
            }

            if (iVar2 == (int)( *(long*)( *(long*)( lVar5 + 0x68 ) + 0x10 ) - *(long*)( *(long*)( lVar5 + 0x68 ) + 8 ) >> 5 ) + -1) {
               return;
            }

         }

      }

      lVar5 = *(long*)param_2;
   }

   if (*(code**)( lVar5 + 0x100 ) == TIntermTyped::getBasicType) {
      TVar1 = param_2[0x28];
      if (TVar1 == (TIntermTyped)0xe) goto LAB_00101b28;
      LAB_00101a81:if (TVar1 == (TIntermTyped)0x11) goto LAB_00101b28;
      LAB_00101a8a:if (TVar1 == (TIntermTyped)0x13) goto LAB_00101b28;
      LAB_00101a93:uVar3 = (uint)(byte)TVar1;
      if (TVar1 == (TIntermTyped)0x14) goto LAB_00101b28;
   }
 else {
      iVar2 = ( **(code**)( lVar5 + 0x100 ) )(param_2);
      if (iVar2 == 0xe) goto LAB_00101b28;
      if (*(code**)( *(long*)param_2 + 0x100 ) == TIntermTyped::getBasicType) {
         TVar1 = param_2[0x28];
         goto LAB_00101a81;
      }

      iVar2 = ( **(code**)( *(long*)param_2 + 0x100 ) )(param_2);
      if (iVar2 == 0x11) goto LAB_00101b28;
      if (*(code**)( *(long*)param_2 + 0x100 ) == TIntermTyped::getBasicType) {
         TVar1 = param_2[0x28];
         goto LAB_00101a8a;
      }

      iVar2 = ( **(code**)( *(long*)param_2 + 0x100 ) )(param_2);
      if (iVar2 == 0x13) goto LAB_00101b28;
      if (*(code**)( *(long*)param_2 + 0x100 ) == TIntermTyped::getBasicType) {
         TVar1 = param_2[0x28];
         goto LAB_00101a93;
      }

      iVar2 = ( **(code**)( *(long*)param_2 + 0x100 ) )(param_2);
      if (iVar2 == 0x14) goto LAB_00101b28;
      if (*(code**)( *(long*)param_2 + 0x100 ) == TIntermTyped::getBasicType) {
         uVar3 = (uint)(byte)param_2[0x28];
      }
 else {
         uVar3 = ( **(code**)( *(long*)param_2 + 0x100 ) )(param_2);
      }

   }

   if (uVar3 == 0x10) {
      if (*(code**)( *(long*)param_2 + 0xf0 ) == TIntermTyped::getType) {
         pTVar7 = param_2 + 0x20;
      }
 else {
         pTVar7 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
      }

      if (*(code**)( *(long*)pTVar7 + 0x58 ) == TType::getQualifier) {
         pTVar7 = pTVar7 + 0x10;
      }
 else {
         pTVar7 = (TIntermTyped*)( **(code**)( *(long*)pTVar7 + 0x58 ) )();
      }

      if (( (byte)pTVar7[8] & 0x7f ) - 5 < 2) {
         LAB_00101b28:/* WARNING: Could not recover jumptable at 0x00101b57. Too many branches *//* WARNING: Treating indirect jump as call */( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_EXT_nonuniform_qualifier, "variable index");
         return;
      }

   }

   /* WARNING: Could not recover jumptable at 0x00101adb. Too many branches */
   /* WARNING: Treating indirect jump as call */
   ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, &_LC1, &_LC48, "array must be redeclared with a size before being indexed with a variable", *(code**)( *(long*)this + 0x158 ));
   return;
}
/* glslang::TSmallArrayVector::TEMPNAMEPLACEHOLDERVALUE(glslang::TSmallArrayVector const&) const
   [clone .isra.0] */ulong glslang::TSmallArrayVector::operator ==(TSmallArrayVector *this, TSmallArrayVector *param_1) {
   int *piVar1;
   long *plVar2;
   long lVar3;
   long *plVar4;
   long lVar5;
   undefined8 in_RDX;
   ulong uVar6;
   int *piVar7;
   int *piVar8;
   uVar6 = CONCAT71(( int7 )((ulong)in_RDX >> 8), param_1 == (TSmallArrayVector*)0x0);
   if (( this == (TSmallArrayVector*)0x0 ) || ( uVar6 = 0 ),param_1 == (TSmallArrayVector*)0x0) {
      return uVar6 & 0xffffffff;
   }

   piVar1 = *(int**)( this + 0x10 );
   piVar7 = *(int**)( this + 8 );
   piVar8 = *(int**)( param_1 + 8 );
   if ((long)piVar1 - (long)piVar7 == *(long*)( param_1 + 0x10 ) - (long)piVar8) {
      for (; piVar7 != piVar1; piVar7 = piVar7 + 4) {
         if (*piVar7 != *piVar8) {
            return 0;
         }

         plVar4 = *(long**)( piVar7 + 2 );
         plVar2 = *(long**)( piVar8 + 2 );
         if (plVar4 == (long*)0x0) {
            if (plVar2 != (long*)0x0) {
               return 0;
            }

         }
 else {
            if (( ( plVar2 == (long*)0x0 ) || ( lVar3 = ( **(code**)( *plVar4 + 0x60 ) )(plVar4) ),lVar3 == 0 )) {
               return 0;
            }

            plVar4 = (long*)( **(code**)( *plVar4 + 0x60 ) )(plVar4);
            if (*(code**)( *plVar4 + 0x180 ) == TIntermSymbol::getId) {
               lVar3 = plVar4[0x17];
            }
 else {
               lVar3 = ( **(code**)( *plVar4 + 0x180 ) )();
            }

            plVar4 = (long*)( **(code**)( *plVar2 + 0x60 ) )(plVar2);
            if (*(code**)( *plVar4 + 0x180 ) == TIntermSymbol::getId) {
               lVar5 = plVar4[0x17];
            }
 else {
               lVar5 = ( **(code**)( *plVar4 + 0x180 ) )();
            }

            if (lVar3 != lVar5) {
               return 0;
            }

         }

         piVar8 = piVar8 + 4;
      }

      uVar6 = 1;
   }

   return uVar6;
}
/* std::_Rb_tree_iterator<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc> const*>
   > std::_Rb_tree<unsigned long, std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc>
   const*>, std::_Select1st<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc>
   const*> >, std::less<unsigned long>, std::allocator<std::pair<unsigned long const,
   glslang::TVector<glslang::TTypeLoc> const*> >
   >::_M_emplace_hint_unique<std::piecewise_construct_t const&, std::tuple<unsigned long const&>,
   std::tuple<> >(std::_Rb_tree_const_iterator<std::pair<unsigned long const,
   glslang::TVector<glslang::TTypeLoc> const*> >, std::piecewise_construct_t const&,
   std::tuple<unsigned long const&>&&, std::tuple<>&&) [clone .isra.0] */_Rb_tree_node_base * std::_Rb_tree<unsigned_long,std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>,std::_Select1st<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>::_M_emplace_hint_unique<std::piecewise_construct_t_const&,std::tuple<unsigned_long_const&>,std::tuple<>>(_Rb_tree<unsigned_long,std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>,std::_Select1st<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>> * param_1, _Rb_tree_node_base * param_2, undefined8 * param_3) * p_Var1 ;ulong *puVar2_Rb_tree_node_base *p_Var3_Rb_tree_node_base *p_Var4bool bVar5undefined1 auVar6[16]p_Var1 = (_Rb_tree_node_base*)( param_1 + 8 );p_Var3 = (_Rb_tree_node_base*)operator_new(0x30);param_3 = (undefined8*)*param_3;*(undefined8*)( p_Var3 + 0x28 ) = 0;puVar2 = (ulong*)*param_3;*(ulong**)( p_Var3 + 0x20 ) = puVar2;if (p_Var1 == param_2) {
   if (( *(long*)( param_1 + 0x28 ) == 0 ) || ( p_Var4 = *(_Rb_tree_node_base**)( param_1 + 0x20 ) ),puVar2 <= *(ulong**)( p_Var4 + 0x20 )) {
      LAB_00101ff8:auVar6 = _M_get_insert_unique_pos(param_1, puVar2);
      param_2 = auVar6._0_8_;
      bVar5 = param_2 != (_Rb_tree_node_base*)0x0;
      p_Var4 = auVar6._8_8_;
      if (auVar6._8_8_ == (_Rb_tree_node_base*)0x0) {
         LAB_00102011:operator_delete(p_Var3, 0x30);
         return param_2;
      }

   }
 else {
      LAB_0010203b:bVar5 = false;
   }

   joined_r0x00101fc7:param_2 = p_Var4;
   p_Var4 = param_2;
   if (( p_Var1 == param_2 ) || ( bVar5 )) {
      LAB_00101fcd:param_2 = p_Var4;
      bVar5 = true;
      goto LAB_00101fd2;
   }

}
 else {
   if (puVar2 < *(ulong**)( param_2 + 0x20 )) {
      p_Var4 = *(_Rb_tree_node_base**)( param_1 + 0x18 );
      if (*(_Rb_tree_node_base**)( param_1 + 0x18 ) != param_2) {
         p_Var4 = (_Rb_tree_node_base*)std::_Rb_tree_decrement(param_2);
         if (puVar2 <= *(ulong**)( p_Var4 + 0x20 )) goto LAB_00101ff8;
         if (*(long*)( p_Var4 + 0x18 ) != 0) {
            bVar5 = true;
            goto LAB_00101fd2;
         }

         goto LAB_0010203b;
      }

      goto LAB_00101fcd;
   }

   if (puVar2 <= *(ulong**)( param_2 + 0x20 )) goto LAB_00102011;
   if (*(_Rb_tree_node_base**)( param_1 + 0x20 ) != param_2) {
      p_Var4 = (_Rb_tree_node_base*)std::_Rb_tree_increment(param_2);
      if (*(ulong**)( p_Var4 + 0x20 ) <= puVar2) goto LAB_00101ff8;
      bVar5 = true;
      if (*(long*)( param_2 + 0x18 ) != 0) goto joined_r0x00101fc7;
   }

}
bVar5 = puVar2 < *(ulong**)( param_2 + 0x20 );LAB_00101fd2:std::_Rb_tree_insert_and_rebalance(bVar5, p_Var3, param_2, p_Var1);*(long*)( param_1 + 0x28 ) = *(long*)( param_1 + 0x28 ) + 1;return p_Var3;}/* TIntermNode*& std::vector<TIntermNode*, glslang::pool_allocator<TIntermNode*>
   >::emplace_back<TIntermNode*>(TIntermNode*&&) [clone .isra.0] */TIntermNode ** __thiscall
std::vector<TIntermNode*,glslang::pool_allocator<TIntermNode*>>::emplace_back<TIntermNode*>
          (vector<TIntermNode*,glslang::pool_allocator<TIntermNode*>> *this,TIntermNode **param_1){
   undefined8 *puVar1;
   TIntermNode *pTVar2;
   undefined8 *puVar3;
   long lVar4;
   ulong uVar5;
   TIntermNode **ppTVar6;
   long lVar7;
   TIntermNode **ppTVar8;
   ulong uVar9;
   long lVar10;
   undefined8 *puVar11;
   puVar1 = *(undefined8**)( this + 0x10 );
   if (puVar1 != *(undefined8**)( this + 0x18 )) {
      pTVar2 = *param_1;
      *puVar1 = pTVar2;
      *(undefined8**)( this + 0x10 ) = puVar1 + 1;
      return (TIntermNode**)pTVar2;
   }

   puVar3 = *(undefined8**)( this + 8 );
   puVar11 = (undefined8*)( (long)puVar1 - (long)puVar3 );
   uVar5 = (long)puVar11 >> 3;
   if (uVar5 == 0xfffffffffffffff) {
      /* WARNING: Subroutine does not return */
      std::__throw_length_error("vector::_M_realloc_insert");
   }

   if (puVar1 == puVar3) {
      uVar9 = uVar5 + 1;
      if (0xfffffffffffffffe < uVar5) goto LAB_00102170;
      if (0xfffffffffffffff < uVar9) {
         uVar9 = 0xfffffffffffffff;
      }

      lVar10 = uVar9 * 8;
      LAB_00102147:ppTVar6 = (TIntermNode**)glslang::TPoolAllocator::allocate(*(ulong*)this);
      lVar10 = (long)ppTVar6 + lVar10;
      *(TIntermNode**)( (long)ppTVar6 + (long)puVar11 ) = *param_1;
      ppTVar8 = ppTVar6 + 1;
      if (puVar1 == puVar3) goto LAB_00102107;
   }
 else {
      uVar9 = uVar5 * 2;
      if (uVar9 < uVar5) {
         LAB_00102170:lVar10 = 0x7ffffffffffffff8;
         goto LAB_00102147;
      }

      if (uVar9 != 0) {
         if (0xfffffffffffffff < uVar9) {
            uVar9 = 0xfffffffffffffff;
         }

         lVar10 = uVar9 * 8;
         goto LAB_00102147;
      }

      lVar10 = 0;
      *puVar11 = *param_1;
      ppTVar6 = (TIntermNode**)0x0;
   }

   lVar4 = 0;
   do {
      lVar7 = lVar4;
      *(undefined8*)( (long)ppTVar6 + lVar7 ) = *(undefined8*)( (long)puVar3 + lVar7 );
      lVar4 = lVar7 + 8;
   }
 while ( lVar7 + 8 != (long)puVar1 - (long)puVar3 );
   ppTVar8 = (TIntermNode**)( (long)ppTVar6 + lVar7 + 0x10 );
   LAB_00102107:*(TIntermNode***)( this + 8 ) = ppTVar6;
   *(TIntermNode***)( this + 0x10 ) = ppTVar8;
   *(long*)( this + 0x18 ) = lVar10;
   return ppTVar6;
}
/* void std::__cxx11::string::_M_construct<char const*>(char const*, char const*,
   std::forward_iterator_tag) [clone .isra.0] */void std::__cxx11::string::_M_construct<char_const*>(ulong *param_1, undefined1 *param_2, long param_3) {
   undefined1 *__dest;
   ulong __n;
   long in_FS_OFFSET;
   ulong local_28;
   long local_20;
   __n = param_3 - (long)param_2;
   local_20 = *(long*)( in_FS_OFFSET + 0x28 );
   local_28 = __n;
   if (__n < 0x10) {
      __dest = (undefined1*)*param_1;
      if (__n == 1) {
         *__dest = *param_2;
         __dest = (undefined1*)*param_1;
         goto LAB_001021f4;
      }

      if (__n == 0) goto LAB_001021f4;
   }
 else {
      __dest = (undefined1*)std::__cxx11::string::_M_create(param_1, ( ulong ) & local_28);
      *param_1 = (ulong)__dest;
      param_1[2] = local_28;
   }

   memcpy(__dest, param_2, __n);
   __dest = (undefined1*)*param_1;
   LAB_001021f4:param_1[1] = local_28;
   __dest[local_28] = 0;
   if (local_20 != *(long*)( in_FS_OFFSET + 0x28 )) {
      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   return;
}
/* std::vector<glslang::TArraySize, glslang::pool_allocator<glslang::TArraySize>
   >::TEMPNAMEPLACEHOLDERVALUE(std::vector<glslang::TArraySize,
   glslang::pool_allocator<glslang::TArraySize> > const&) [clone .isra.0] */void std::vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>::operator =(vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>> *this, vector *param_1) {
   undefined8 uVar1;
   long lVar2;
   long lVar3;
   size_t __n;
   ulong uVar4;
   undefined8 *puVar5;
   undefined8 *__dest;
   ulong __n_00;
   long lVar6;
   undefined8 *puVar7;
   if (param_1 == (vector*)this) {
      return;
   }

   puVar7 = *(undefined8**)( param_1 + 0x10 );
   puVar5 = *(undefined8**)( param_1 + 8 );
   __dest = *(undefined8**)( this + 8 );
   __n_00 = (long)puVar7 - (long)puVar5;
   if (( ulong )(*(long*)( this + 0x18 ) - (long)__dest) < __n_00) {
      lVar2 = glslang::TPoolAllocator::allocate(*(ulong*)this);
      uVar4 = 0;
      if (puVar7 != puVar5) {
         do {
            uVar1 = ( (undefined8*)( (long)puVar5 + uVar4 ) )[1];
            *(undefined8*)( lVar2 + uVar4 ) = *(undefined8*)( (long)puVar5 + uVar4 );
            ( (undefined8*)( lVar2 + uVar4 ) )[1] = uVar1;
            uVar4 = uVar4 + 0x10;
         }
 while ( uVar4 != __n_00 );
      }

      *(long*)( this + 8 ) = lVar2;
      *(ulong*)( this + 0x18 ) = __n_00 + lVar2;
      *(ulong*)( this + 0x10 ) = __n_00 + lVar2;
      return;
   }

   lVar2 = *(long*)( this + 0x10 );
   __n = lVar2 - (long)__dest;
   if (__n < __n_00) {
      if ((long)__n < 0x11) {
         if (__n == 0x10) {
            uVar1 = puVar5[1];
            *__dest = *puVar5;
            __dest[1] = uVar1;
         }

      }
 else {
         memmove(__dest, puVar5, __n);
         lVar2 = *(long*)( this + 0x10 );
         __dest = *(undefined8**)( this + 8 );
         puVar7 = *(undefined8**)( param_1 + 0x10 );
         puVar5 = *(undefined8**)( param_1 + 8 );
         __n = lVar2 - (long)__dest;
      }

      puVar5 = (undefined8*)( (long)puVar5 + __n );
      lVar6 = __n_00 + (long)__dest;
      if (puVar5 != puVar7) {
         lVar3 = 0;
         do {
            uVar1 = ( (undefined8*)( (long)puVar5 + lVar3 ) )[1];
            *(undefined8*)( lVar2 + lVar3 ) = *(undefined8*)( (long)puVar5 + lVar3 );
            ( (undefined8*)( lVar2 + lVar3 ) )[1] = uVar1;
            lVar3 = lVar3 + 0x10;
         }
 while ( lVar3 != (long)puVar7 - (long)puVar5 );
         *(long*)( this + 0x10 ) = lVar6;
         return;
      }

   }
 else if ((long)__n_00 < 0x11) {
      if (__n_00 == 0x10) {
         uVar1 = puVar5[1];
         *__dest = *puVar5;
         __dest[1] = uVar1;
      }

      lVar6 = __n_00 + (long)__dest;
   }
 else {
      memmove(__dest, puVar5, __n_00);
      lVar6 = __n_00 + *(long*)( this + 8 );
   }

   *(long*)( this + 0x10 ) = lVar6;
   return;
}
/* void std::vector<glslang::TArraySize, glslang::pool_allocator<glslang::TArraySize>
   >::_M_range_insert<__gnu_cxx::__normal_iterator<glslang::TArraySize*,
   std::vector<glslang::TArraySize, glslang::pool_allocator<glslang::TArraySize> > >
   >(__gnu_cxx::__normal_iterator<glslang::TArraySize*, std::vector<glslang::TArraySize,
   glslang::pool_allocator<glslang::TArraySize> > >,
   __gnu_cxx::__normal_iterator<glslang::TArraySize*, std::vector<glslang::TArraySize,
   glslang::pool_allocator<glslang::TArraySize> > >,
   __gnu_cxx::__normal_iterator<glslang::TArraySize*, std::vector<glslang::TArraySize,
   glslang::pool_allocator<glslang::TArraySize> > >, std::forward_iterator_tag) [clone .isra.0] */void std::vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>::_M_range_insert<__gnu_cxx::__normal_iterator<glslang::TArraySize*,std::vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>>>(ulong *param_1, undefined8 *param_2, undefined8 *param_3, undefined8 *param_4) {
   undefined8 *puVar1;
   undefined8 *puVar2;
   undefined8 uVar3;
   long lVar4;
   ulong uVar5;
   ulong uVar6;
   size_t __n;
   long lVar7;
   size_t __n_00;
   ulong uVar8;
   if (param_3 == param_4) {
      return;
   }

   uVar8 = (long)param_4 - (long)param_3;
   uVar6 = (long)uVar8 >> 4;
   puVar2 = (undefined8*)param_1[2];
   if (uVar8 <= param_1[3] - (long)puVar2) {
      __n_00 = (long)puVar2 - (long)param_2;
      if (uVar8 < __n_00) {
         __n_00 = 0;
         do {
            puVar1 = (undefined8*)( (long)puVar2 + ( __n_00 - uVar8 ) );
            uVar3 = puVar1[1];
            *(undefined8*)( (long)puVar2 + __n_00 ) = *puVar1;
            ( (undefined8*)( (long)puVar2 + __n_00 ) )[1] = uVar3;
            __n_00 = __n_00 + 0x10;
         }
 while ( uVar8 != __n_00 );
         __n = (long)puVar2 + ( -(long)param_2 - uVar8 );
         param_1[2] = (long)puVar2 + uVar8;
         if ((long)__n < 0x11) {
            if (__n == 0x10) {
               uVar3 = param_2[1];
               puVar2[-2] = *param_2;
               puVar2[-1] = uVar3;
            }

         }
 else {
            memmove((void*)( (long)puVar2 - __n ), param_2, __n);
         }

         if ((long)uVar8 < 0x11) {
            if (uVar8 != 0x10) {
               return;
            }

            uVar3 = param_3[1];
            *param_2 = *param_3;
            param_2[1] = uVar3;
            return;
         }

      }
 else {
         puVar1 = (undefined8*)( (long)param_3 + __n_00 );
         lVar4 = 0;
         if (param_4 != puVar1) {
            do {
               uVar3 = ( (undefined8*)( (long)puVar1 + lVar4 ) )[1];
               *(undefined8*)( (long)puVar2 + lVar4 ) = *(undefined8*)( (long)puVar1 + lVar4 );
               ( (undefined8*)( (long)puVar2 + lVar4 ) )[1] = uVar3;
               lVar4 = lVar4 + 0x10;
            }
 while ( lVar4 != (long)param_4 - (long)puVar1 );
         }

         lVar7 = uVar6 - ( (long)__n_00 >> 4 );
         lVar4 = 0;
         if (param_2 != puVar2) {
            do {
               uVar3 = ( (undefined8*)( (long)param_2 + lVar4 ) )[1];
               puVar1 = (undefined8*)( (long)puVar2 + lVar4 + lVar7 * 0x10 );
               *puVar1 = *(undefined8*)( (long)param_2 + lVar4 );
               puVar1[1] = uVar3;
               lVar4 = lVar4 + 0x10;
            }
 while ( lVar4 != (long)puVar2 - (long)param_2 );
         }

         param_1[2] = (long)puVar2 + __n_00 + lVar7 * 0x10;
         if ((long)__n_00 < 0x11) {
            if (__n_00 != 0x10) {
               return;
            }

            uVar3 = param_3[1];
            *param_2 = *param_3;
            param_2[1] = uVar3;
            return;
         }

      }

      memmove(param_2, param_3, __n_00);
      return;
   }

   puVar1 = (undefined8*)param_1[1];
   uVar5 = (long)puVar2 - (long)puVar1 >> 4;
   if (0x7ffffffffffffff - uVar5 < uVar6) {
      /* WARNING: Subroutine does not return */
      std::__throw_length_error("vector::_M_range_insert");
   }

   if (( ulong )((long)puVar2 - (long)puVar1) < uVar8) {
      uVar6 = uVar6 + uVar5;
      LAB_0010256b:if (uVar6 == 0) {
         uVar6 = 0;
         uVar8 = 0;
         goto LAB_001024d3;
      }

      if (0x7ffffffffffffff < uVar6) {
         uVar6 = 0x7ffffffffffffff;
      }

      lVar4 = uVar6 << 4;
   }
 else {
      lVar4 = 0x7ffffffffffffff0;
      uVar6 = uVar5 * 2;
      if (uVar5 <= uVar6) goto LAB_0010256b;
   }

   uVar8 = glslang::TPoolAllocator::allocate(*param_1);
   uVar6 = uVar8 + lVar4;
   LAB_001024d3:uVar5 = uVar8;
   if (param_2 != puVar1) {
      lVar4 = 0;
      do {
         uVar3 = ( (undefined8*)( (long)puVar1 + lVar4 ) )[1];
         *(undefined8*)( uVar8 + lVar4 ) = *(undefined8*)( (long)puVar1 + lVar4 );
         ( (undefined8*)( uVar8 + lVar4 ) )[1] = uVar3;
         lVar4 = lVar4 + 0x10;
      }
 while ( (long)param_2 - (long)puVar1 != lVar4 );
      uVar5 = ( (long)param_2 - (long)puVar1 ) + uVar8;
   }

   lVar4 = 0;
   do {
      uVar3 = ( (undefined8*)( (long)param_3 + lVar4 ) )[1];
      *(undefined8*)( uVar5 + lVar4 ) = *(undefined8*)( (long)param_3 + lVar4 );
      ( (undefined8*)( uVar5 + lVar4 ) )[1] = uVar3;
      lVar4 = lVar4 + 0x10;
   }
 while ( (long)param_4 - (long)param_3 != lVar4 );
   uVar5 = uVar5 + ( (long)param_4 - (long)param_3 );
   if (param_2 != puVar2) {
      lVar4 = 0;
      do {
         uVar3 = ( (undefined8*)( (long)param_2 + lVar4 ) )[1];
         *(undefined8*)( uVar5 + lVar4 ) = *(undefined8*)( (long)param_2 + lVar4 );
         ( (undefined8*)( uVar5 + lVar4 ) )[1] = uVar3;
         lVar4 = lVar4 + 0x10;
      }
 while ( lVar4 != (long)puVar2 - (long)param_2 );
      uVar5 = uVar5 + lVar4;
   }

   param_1[1] = uVar8;
   param_1[2] = uVar5;
   param_1[3] = uVar6;
   return;
}
/* std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>*,
   std::pair<glslang::TVector<glslang::TTypeLoc>* const, glslang::TVector<glslang::TTypeLoc>*>,
   std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>* const,
   glslang::TVector<glslang::TTypeLoc>*> >, std::less<glslang::TVector<glslang::TTypeLoc>*>,
   glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>* const,
   glslang::TVector<glslang::TTypeLoc>*> >
   >::_M_erase(std::_Rb_tree_node<std::pair<glslang::TVector<glslang::TTypeLoc>* const,
   glslang::TVector<glslang::TTypeLoc>*> >*) [clone .isra.0] */void std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>*,std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>>,std::less<glslang::TVector<glslang::TTypeLoc>*>,glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>>>::_M_erase(_Rb_tree_node *param_1) {
   long lVar1;
   long lVar2;
   long lVar3;
   long lVar4;
   long lVar5;
   long lVar6;
   long lVar7;
   long lVar8;
   if (param_1 != (_Rb_tree_node*)0x0) {
      do {
         for (lVar1 = *(long*)( param_1 + 0x18 ); lVar1 != 0; lVar1 = *(long*)( lVar1 + 0x10 )) {
            for (lVar2 = *(long*)( lVar1 + 0x18 ); lVar2 != 0; lVar2 = *(long*)( lVar2 + 0x10 )) {
               for (lVar3 = *(long*)( lVar2 + 0x18 ); lVar3 != 0; lVar3 = *(long*)( lVar3 + 0x10 )) {
                  for (lVar4 = *(long*)( lVar3 + 0x18 ); lVar4 != 0; lVar4 = *(long*)( lVar4 + 0x10 )) {
                     for (lVar5 = *(long*)( lVar4 + 0x18 ); lVar5 != 0; lVar5 = *(long*)( lVar5 + 0x10 )) {
                        for (lVar6 = *(long*)( lVar5 + 0x18 ); lVar6 != 0; lVar6 = *(long*)( lVar6 + 0x10 )) {
                           for (lVar7 = *(long*)( lVar6 + 0x18 ); lVar7 != 0; lVar7 = *(long*)( lVar7 + 0x10 )) {
                              for (lVar8 = *(long*)( lVar7 + 0x18 ); lVar8 != 0; lVar8 = *(long*)( lVar8 + 0x10 )) {
                                 _M_erase(*(_Rb_tree_node**)( lVar8 + 0x18 ));
                              }

                           }

                        }

                     }

                  }

               }

            }

         }

         param_1 = *(_Rb_tree_node**)( param_1 + 0x10 );
      }
 while ( param_1 != (_Rb_tree_node*)0x0 );
      return;
   }

   return;
}
/* glslang::TParseContext::getGlobalUniformBlockName() const */char *__thiscallglslang::TParseContext::getGlobalUniformBlockName(TParseContext *this) {
   size_t sVar1;
   char *__s;
   long in_FS_OFFSET;
   long *local_48;
   long local_40;
   long local_38[3];
   long local_20;
   local_20 = *(long*)( in_FS_OFFSET + 0x28 );
   __s = *(char**)( *(long*)( this + 0x38 ) + 0x2a0 );
   local_48 = local_38;
   if (__s == (char*)0x0) {
      /* WARNING: Subroutine does not return */
      std::__throw_logic_error("basic_string: construction from null is not valid");
   }

   sVar1 = strlen(__s);
   std::__cxx11::string::_M_construct<char_const*>(&local_48, __s, __s + sVar1);
   if (local_40 == 0) {
      if (local_48 != local_38) {
         operator_delete(local_48, local_38[0] + 1);
      }

      __s = "gl_DefaultUniformBlock";
   }
 else if (local_48 != local_38) {
      operator_delete(local_48, local_38[0] + 1);
   }

   if (local_20 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return __s;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::getAtomicCounterBlockName() const */char *__thiscallglslang::TParseContext::getAtomicCounterBlockName(TParseContext *this) {
   size_t sVar1;
   char *__s;
   long in_FS_OFFSET;
   long *local_48;
   long local_40;
   long local_38[3];
   long local_20;
   local_20 = *(long*)( in_FS_OFFSET + 0x28 );
   __s = *(char**)( *(long*)( this + 0x38 ) + 0x2c0 );
   local_48 = local_38;
   if (__s == (char*)0x0) {
      /* WARNING: Subroutine does not return */
      std::__throw_logic_error("basic_string: construction from null is not valid");
   }

   sVar1 = strlen(__s);
   std::__cxx11::string::_M_construct<char_const*>(&local_48, __s, __s + sVar1);
   if (local_40 == 0) {
      if (local_48 != local_38) {
         operator_delete(local_48, local_38[0] + 1);
      }

      __s = "gl_AtomicCounterBlock";
   }
 else if (local_48 != local_38) {
      operator_delete(local_48, local_38[0] + 1);
   }

   if (local_20 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return __s;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* std::_Rb_tree<long long, long long, std::_Identity<long long>, std::less<long long>,
   std::allocator<long long> >::_M_erase(std::_Rb_tree_node<long long>*) [clone .isra.0] */void std::_Rb_tree<long_long,long_long,std::_Identity<long_long>,std::less<long_long>,std::allocator<long_long>>::_M_erase(_Rb_tree_node *param_1) {
   void *pvVar1;
   void *pvVar2;
   void *pvVar3;
   void *pvVar4;
   void *pvVar5;
   void *pvVar6;
   void *pvVar7;
   void *pvVar8;
   _Rb_tree_node *p_Var9;
   void *pvVar10;
   _Rb_tree_node *local_48;
   local_48 = param_1;
   if (param_1 != (_Rb_tree_node*)0x0) {
      do {
         pvVar10 = *(void**)( local_48 + 0x18 );
         while (pvVar10 != (void*)0x0) {
            pvVar8 = *(void**)( (long)pvVar10 + 0x18 );
            while (pvVar8 != (void*)0x0) {
               pvVar7 = *(void**)( (long)pvVar8 + 0x18 );
               while (pvVar7 != (void*)0x0) {
                  pvVar5 = *(void**)( (long)pvVar7 + 0x18 );
                  while (pvVar5 != (void*)0x0) {
                     pvVar3 = *(void**)( (long)pvVar5 + 0x18 );
                     while (pvVar3 != (void*)0x0) {
                        pvVar4 = *(void**)( (long)pvVar3 + 0x18 );
                        while (pvVar4 != (void*)0x0) {
                           pvVar6 = *(void**)( (long)pvVar4 + 0x18 );
                           while (pvVar6 != (void*)0x0) {
                              pvVar2 = *(void**)( (long)pvVar6 + 0x18 );
                              while (pvVar2 != (void*)0x0) {
                                 _M_erase(*(_Rb_tree_node**)( (long)pvVar2 + 0x18 ));
                                 pvVar1 = *(void**)( (long)pvVar2 + 0x10 );
                                 operator_delete(pvVar2, 0x28);
                                 pvVar2 = pvVar1;
                              }
;
                              pvVar2 = *(void**)( (long)pvVar6 + 0x10 );
                              operator_delete(pvVar6, 0x28);
                              pvVar6 = pvVar2;
                           }
;
                           pvVar6 = *(void**)( (long)pvVar4 + 0x10 );
                           operator_delete(pvVar4, 0x28);
                           pvVar4 = pvVar6;
                        }
;
                        pvVar4 = *(void**)( (long)pvVar3 + 0x10 );
                        operator_delete(pvVar3, 0x28);
                        pvVar3 = pvVar4;
                     }
;
                     pvVar3 = *(void**)( (long)pvVar5 + 0x10 );
                     operator_delete(pvVar5, 0x28);
                     pvVar5 = pvVar3;
                  }
;
                  pvVar5 = *(void**)( (long)pvVar7 + 0x10 );
                  operator_delete(pvVar7, 0x28);
                  pvVar7 = pvVar5;
               }
;
               pvVar7 = *(void**)( (long)pvVar8 + 0x10 );
               operator_delete(pvVar8, 0x28);
               pvVar8 = pvVar7;
            }
;
            pvVar8 = *(void**)( (long)pvVar10 + 0x10 );
            operator_delete(pvVar10, 0x28);
            pvVar10 = pvVar8;
         }
;
         p_Var9 = *(_Rb_tree_node**)( local_48 + 0x10 );
         operator_delete(local_48, 0x28);
         local_48 = p_Var9;
      }
 while ( p_Var9 != (_Rb_tree_node*)0x0 );
   }

   return;
}
/* void std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::_M_construct<char const*>(char const*, char const*, std::forward_iterator_tag) [clone .isra.0]
    */void std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(ulong *param_1, undefined1 *param_2, long param_3) {
   undefined1 *__dest;
   ulong __n;
   __n = param_3 - (long)param_2;
   if (__n < 0x10) {
      __dest = (undefined1*)param_1[1];
      if (__n == 1) {
         *__dest = *param_2;
         param_1[2] = 1;
         *(undefined1*)( param_1[1] + 1 ) = 0;
         return;
      }

      if (__n == 0) {
         param_1[2] = 0;
         *__dest = 0;
         return;
      }

   }
 else {
      if ((long)__n < 0) {
         /* WARNING: Subroutine does not return */
         std::__throw_length_error("basic_string::_M_create");
      }

      __dest = (undefined1*)glslang::TPoolAllocator::allocate(*param_1);
      param_1[3] = __n;
      param_1[1] = (ulong)__dest;
   }

   memcpy(__dest, param_2, __n);
   param_1[2] = __n;
   *(undefined1*)( param_1[1] + __n ) = 0;
   return;
}
/* std::_Rb_tree<unsigned long, std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc>
   const*>, std::_Select1st<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc>
   const*> >, std::less<unsigned long>, std::allocator<std::pair<unsigned long const,
   glslang::TVector<glslang::TTypeLoc> const*> > >::_M_erase(std::_Rb_tree_node<std::pair<unsigned
   long const, glslang::TVector<glslang::TTypeLoc> const*> >*) [clone .isra.0] */void std::_Rb_tree<unsigned_long,std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>,std::_Select1st<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>::_M_erase(_Rb_tree_node *param_1) {
   void *pvVar1;
   void *pvVar2;
   void *pvVar3;
   void *pvVar4;
   void *pvVar5;
   void *pvVar6;
   void *pvVar7;
   void *pvVar8;
   _Rb_tree_node *p_Var9;
   void *pvVar10;
   _Rb_tree_node *local_48;
   local_48 = param_1;
   if (param_1 != (_Rb_tree_node*)0x0) {
      do {
         pvVar10 = *(void**)( local_48 + 0x18 );
         while (pvVar10 != (void*)0x0) {
            pvVar8 = *(void**)( (long)pvVar10 + 0x18 );
            while (pvVar8 != (void*)0x0) {
               pvVar7 = *(void**)( (long)pvVar8 + 0x18 );
               while (pvVar7 != (void*)0x0) {
                  pvVar5 = *(void**)( (long)pvVar7 + 0x18 );
                  while (pvVar5 != (void*)0x0) {
                     pvVar3 = *(void**)( (long)pvVar5 + 0x18 );
                     while (pvVar3 != (void*)0x0) {
                        pvVar4 = *(void**)( (long)pvVar3 + 0x18 );
                        while (pvVar4 != (void*)0x0) {
                           pvVar6 = *(void**)( (long)pvVar4 + 0x18 );
                           while (pvVar6 != (void*)0x0) {
                              pvVar2 = *(void**)( (long)pvVar6 + 0x18 );
                              while (pvVar2 != (void*)0x0) {
                                 _M_erase(*(_Rb_tree_node**)( (long)pvVar2 + 0x18 ));
                                 pvVar1 = *(void**)( (long)pvVar2 + 0x10 );
                                 operator_delete(pvVar2, 0x30);
                                 pvVar2 = pvVar1;
                              }
;
                              pvVar2 = *(void**)( (long)pvVar6 + 0x10 );
                              operator_delete(pvVar6, 0x30);
                              pvVar6 = pvVar2;
                           }
;
                           pvVar6 = *(void**)( (long)pvVar4 + 0x10 );
                           operator_delete(pvVar4, 0x30);
                           pvVar4 = pvVar6;
                        }
;
                        pvVar4 = *(void**)( (long)pvVar3 + 0x10 );
                        operator_delete(pvVar3, 0x30);
                        pvVar3 = pvVar4;
                     }
;
                     pvVar3 = *(void**)( (long)pvVar5 + 0x10 );
                     operator_delete(pvVar5, 0x30);
                     pvVar5 = pvVar3;
                  }
;
                  pvVar5 = *(void**)( (long)pvVar7 + 0x10 );
                  operator_delete(pvVar7, 0x30);
                  pvVar7 = pvVar5;
               }
;
               pvVar7 = *(void**)( (long)pvVar8 + 0x10 );
               operator_delete(pvVar8, 0x30);
               pvVar8 = pvVar7;
            }
;
            pvVar8 = *(void**)( (long)pvVar10 + 0x10 );
            operator_delete(pvVar10, 0x30);
            pvVar10 = pvVar8;
         }
;
         p_Var9 = *(_Rb_tree_node**)( local_48 + 0x10 );
         operator_delete(local_48, 0x30);
         local_48 = p_Var9;
      }
 while ( p_Var9 != (_Rb_tree_node*)0x0 );
   }

   return;
}
/* std::_Rb_tree<glslang::TVector<glslang::TTypeLoc> const*,
   std::pair<glslang::TVector<glslang::TTypeLoc> const* const, std::map<unsigned long,
   glslang::TVector<glslang::TTypeLoc> const*, std::less<unsigned long>,
   std::allocator<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc> const*> > > >,
   std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc> const* const, std::map<unsigned
   long, glslang::TVector<glslang::TTypeLoc> const*, std::less<unsigned long>,
   std::allocator<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc> const*> > > >
   >, std::less<glslang::TVector<glslang::TTypeLoc> const*>,
   std::allocator<std::pair<glslang::TVector<glslang::TTypeLoc> const* const, std::map<unsigned
   long, glslang::TVector<glslang::TTypeLoc> const*, std::less<unsigned long>,
   std::allocator<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc> const*> > > > >
   >::_M_erase(std::_Rb_tree_node<std::pair<glslang::TVector<glslang::TTypeLoc> const* const,
   std::map<unsigned long, glslang::TVector<glslang::TTypeLoc> const*, std::less<unsigned long>,
   std::allocator<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc> const*> > > >
   >*) [clone .isra.0] */void std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>const*,std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator < std::pair < unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>>void *pvVar2void *pvVar3if (param_1 != (_Rb_tree_node*)0x0) {
   do {
      _M_erase(*(_Rb_tree_node**)( param_1 + 0x18 ));
      p_Var1 = *(_Rb_tree_node**)( param_1 + 0x10 );
      pvVar3 = *(void**)( param_1 + 0x38 );
      while (pvVar3 != (void*)0x0) {
         _Rb_tree<unsigned_long,std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>,std::_Select1st<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>::_M_erase(*(_Rb_tree_node**)( (long)pvVar3 + 0x18 ));
         pvVar2 = *(void**)( (long)pvVar3 + 0x10 );
         operator_delete(pvVar3, 0x30);
         pvVar3 = pvVar2;
      }
;
      operator_delete(param_1, 0x58);
      param_1 = p_Var1;
   }
 while ( p_Var1 != (_Rb_tree_node*)0x0 );
   return;
}
return;}/* std::_Rb_tree_iterator<std::pair<glslang::TVector<glslang::TTypeLoc> const* const,
   std::map<unsigned long, glslang::TVector<glslang::TTypeLoc> const*, std::less<unsigned long>,
   std::allocator<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc> const*> > > > >
   std::_Rb_tree<glslang::TVector<glslang::TTypeLoc> const*,
   std::pair<glslang::TVector<glslang::TTypeLoc> const* const, std::map<unsigned long,
   glslang::TVector<glslang::TTypeLoc> const*, std::less<unsigned long>,
   std::allocator<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc> const*> > > >,
   std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc> const* const, std::map<unsigned
   long, glslang::TVector<glslang::TTypeLoc> const*, std::less<unsigned long>,
   std::allocator<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc> const*> > > >
   >, std::less<glslang::TVector<glslang::TTypeLoc> const*>,
   std::allocator<std::pair<glslang::TVector<glslang::TTypeLoc> const* const, std::map<unsigned
   long, glslang::TVector<glslang::TTypeLoc> const*, std::less<unsigned long>,
   std::allocator<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc> const*> > > > >
   >::_M_emplace_hint_unique<std::piecewise_construct_t const&,
   std::tuple<glslang::TVector<glslang::TTypeLoc> const* const&>, std::tuple<>
   >(std::_Rb_tree_const_iterator<std::pair<glslang::TVector<glslang::TTypeLoc> const* const,
   std::map<unsigned long, glslang::TVector<glslang::TTypeLoc> const*, std::less<unsigned long>,
   std::allocator<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc> const*> > > >
   >, std::piecewise_construct_t const&, std::tuple<glslang::TVector<glslang::TTypeLoc> const*
   const&>&&, std::tuple<>&&) [clone .isra.0] */_Rb_tree_node_base * std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>const*,std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator < std::pair < unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>> > std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less < unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>> > std::less<glslang::TVector<glslang::TTypeLoc>const*> < std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>> >> ::_M_emplace_hint_unique<std::piecewise_construct_t_const&,std::tuple<glslang::TVector<glslang::TTypeLoc>const*const&>,std::tuple<>>(_Rb_tree<glslang::TVector<glslang::TTypeLoc>const*,std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator < std::pair < unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>> > std::less<glslang::TVector<glslang::TTypeLoc>const*>, std::allocator<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less < unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>> >> *param_1, _Rb_tree_node_base * param_2, undefined8 * param_3) * p_Var1 ;TVector **ppTVar2_Rb_tree_node_base *p_Var3_Rb_tree_node_base *p_Var4bool bVar5undefined1 auVar6[16]p_Var1 = (_Rb_tree_node_base*)( param_1 + 8 );p_Var3 = (_Rb_tree_node_base*)operator_new(0x58);ppTVar2 = *(TVector***)*param_3;*(undefined4*)( p_Var3 + 0x30 ) = 0;*(undefined8*)( p_Var3 + 0x38 ) = 0;*(TVector***)( p_Var3 + 0x20 ) = ppTVar2;*(_Rb_tree_node_base**)( p_Var3 + 0x40 ) = p_Var3 + 0x30;*(_Rb_tree_node_base**)( p_Var3 + 0x48 ) = p_Var3 + 0x30;*(undefined8*)( p_Var3 + 0x50 ) = 0;if (p_Var1 == param_2) {
   if (( *(long*)( param_1 + 0x28 ) == 0 ) || ( p_Var4 = *(_Rb_tree_node_base**)( param_1 + 0x20 ) ),ppTVar2 <= *(TVector***)( p_Var4 + 0x20 )) {
      LAB_00102ed8:auVar6 = _M_get_insert_unique_pos(param_1, ppTVar2);
      param_2 = auVar6._0_8_;
      bVar5 = param_2 != (_Rb_tree_node_base*)0x0;
      p_Var4 = auVar6._8_8_;
      if (auVar6._8_8_ == (_Rb_tree_node_base*)0x0) {
         LAB_00102ef1:operator_delete(p_Var3, 0x58);
         return param_2;
      }

   }
 else {
      LAB_00102f1b:bVar5 = false;
   }

   joined_r0x00102ea7:param_2 = p_Var4;
   p_Var4 = param_2;
   if (( p_Var1 == param_2 ) || ( bVar5 )) {
      LAB_00102ead:param_2 = p_Var4;
      bVar5 = true;
      goto LAB_00102eb2;
   }

}
 else {
   if (ppTVar2 < *(TVector***)( param_2 + 0x20 )) {
      p_Var4 = *(_Rb_tree_node_base**)( param_1 + 0x18 );
      if (*(_Rb_tree_node_base**)( param_1 + 0x18 ) != param_2) {
         p_Var4 = (_Rb_tree_node_base*)std::_Rb_tree_decrement(param_2);
         if (ppTVar2 <= *(TVector***)( p_Var4 + 0x20 )) goto LAB_00102ed8;
         if (*(long*)( p_Var4 + 0x18 ) != 0) {
            bVar5 = true;
            goto LAB_00102eb2;
         }

         goto LAB_00102f1b;
      }

      goto LAB_00102ead;
   }

   if (ppTVar2 <= *(TVector***)( param_2 + 0x20 )) goto LAB_00102ef1;
   if (*(_Rb_tree_node_base**)( param_1 + 0x20 ) != param_2) {
      p_Var4 = (_Rb_tree_node_base*)std::_Rb_tree_increment(param_2);
      if (*(TVector***)( p_Var4 + 0x20 ) <= ppTVar2) goto LAB_00102ed8;
      bVar5 = true;
      if (*(long*)( param_2 + 0x18 ) != 0) goto joined_r0x00102ea7;
   }

}
bVar5 = ppTVar2 < *(TVector***)( param_2 + 0x20 );LAB_00102eb2:std::_Rb_tree_insert_and_rebalance(bVar5, p_Var3, param_2, p_Var1);*(long*)( param_1 + 0x28 ) = *(long*)( param_1 + 0x28 ) + 1;return p_Var3;}/* glslang::StartsWith(std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const&, char const*) [clone .isra.0] */bool glslang::StartsWith(glslang *this, basic_string *param_1, char *param_2) {
   int iVar1;
   basic_string *pbVar2;
   long lVar3;
   bool bVar4;
   pbVar2 = (basic_string*)strlen(param_2);
   if (pbVar2 <= param_1) {
      param_1 = pbVar2;
   }

   if (( param_1 != (basic_string*)0x0 ) && ( iVar1 = iVar1 != 0 )) {
      return false;
   }

   bVar4 = false;
   lVar3 = (long)param_1 - (long)pbVar2;
   if (( lVar3 < 0x80000000 ) && ( -0x80000001 < lVar3 )) {
      bVar4 = (int)lVar3 == 0;
   }

   return bVar4;
}
/* glslang::TSymbolTable::copyUpDeferredInsert(glslang::TSymbol*) [clone .isra.0] */long *glslang::TSymbolTable::copyUpDeferredInsert(TSymbol *param_1) {
   code *pcVar1;
   long lVar2;
   long *plVar3;
   long *plVar4;
   ulong uVar5;
   undefined8 *puVar6;
   undefined8 uVar7;
   lVar2 = ( **(code**)( *(long*)param_1 + 0x48 ) )();
   if (lVar2 == 0) {
      plVar4 = (long*)( *(code*)( *(undefined8**)param_1 )[0xb] )(param_1);
      if (*(code**)( *plVar4 + 0xb0 ) == TAnonMember::getAnonContainer) {
         puVar6 = (undefined8*)plVar4[5];
      }
 else {
         puVar6 = (undefined8*)( **(code**)( *plVar4 + 0xb0 ) )(plVar4);
      }

      plVar3 = (long*)( **(code**)*puVar6 )();
      pcVar1 = *(code**)( *plVar3 + 0x20 );
      uVar5 = glslang::GetThreadPoolAllocator();
      puVar6 = (undefined8*)glslang::TPoolAllocator::allocate(uVar5);
      uVar7 = glslang::GetThreadPoolAllocator();
      *puVar6 = uVar7;
      puVar6[1] = puVar6 + 3;
      std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(puVar6, &_LC1, &_LC1);
      if (pcVar1 == TSymbol::changeName) {
         plVar3[1] = (long)puVar6;
      }
 else {
         ( *pcVar1 )(plVar3, puVar6);
      }

      pcVar1 = *(code**)( *plVar3 + 0x70 );
      if (*(code**)( *plVar4 + 0xb0 ) == TAnonMember::getAnonContainer) {
         plVar4 = (long*)plVar4[5];
      }
 else {
         plVar4 = (long*)( **(code**)( *plVar4 + 0xb0 ) )(plVar4);
      }

      if (*(code**)( *plVar4 + 0x78 ) == TSymbol::getUniqueId) {
         lVar2 = plVar4[2];
      }
 else {
         lVar2 = ( **(code**)( *plVar4 + 0x78 ) )();
      }

      if (pcVar1 != TSymbol::setUniqueId) {
         ( *pcVar1 )(plVar3);
         return plVar3;
      }

   }
 else {
      plVar3 = (long*)( *(code*)**(undefined8**)param_1 )();
      pcVar1 = *(code**)( *plVar3 + 0x70 );
      if (*(code**)( *(long*)param_1 + 0x78 ) == TSymbol::getUniqueId) {
         lVar2 = *(long*)( param_1 + 0x10 );
      }
 else {
         lVar2 = ( **(code**)( *(long*)param_1 + 0x78 ) )(param_1);
      }

      if (pcVar1 != TSymbol::setUniqueId) {
         ( *pcVar1 )(plVar3);
         return plVar3;
      }

   }

   plVar3[2] = lVar2;
   return plVar3;
}
/* glslang::TParseContext::finish() [clone .part.0] */void glslang::TParseContext::finish(TParseContext *this) {
   int iVar1;
   long lVar2;
   char cVar3;
   int iVar4;
   long lVar5;
   ulong uVar6;
   long lVar7;
   char *pcVar8;
   code *pcVar9;
   uVar6 = 0;
   if (*(long*)( this + 0x7588 ) != *(long*)( this + 0x7580 )) {
      do {
         uVar6 = uVar6 + 1;
         glslang::TParseContext::constantIndexExpressionCheck((TIntermNode*)this);
      }
 while ( uVar6 < ( ulong )(*(long*)( this + 0x7588 ) - *(long*)( this + 0x7580 ) >> 3) );
   }

   switch (*(undefined4*)( this + 0x1c )) {
      default:
    return;
      case 1:
      case 2:
    if (*(int *)(this + 0xc) == 8) {
      if (*(int *)(this + 0x18) != 0x136) {
        return;
      }
      lVar7 = *(long *)(this + 0xd8);
      lVar5 = lVar7 + 0x40;
      if (*(char *)(lVar7 + 0x58) == '\0') {
        lVar5 = *(long *)(lVar7 + 0x30);
        iVar4 = (*(int *)(lVar7 + 8) - *(int *)(lVar7 + 0x3c)) + -1;
        if (*(int *)(lVar7 + 0x20) < iVar4) {
          iVar4 = *(int *)(lVar7 + 0x20);
        }
        if (0 < iVar4) {
          lVar5 = lVar5 + (long)iVar4 * 0x18;
        }
      }
      (**(code **)(*(long *)this + 0x28))
                (this,lVar5,2,AEP_tessellation_shader,"tessellation shaders");
      iVar4 = *(int *)(this + 0x1c);
    }
    else {
      if (399 < *(int *)(this + 0x18)) {
        return;
      }
      lVar7 = *(long *)(this + 0xd8);
      lVar5 = lVar7 + 0x40;
      if (*(char *)(lVar7 + 0x58) == '\0') {
        lVar5 = *(long *)(lVar7 + 0x30);
        iVar4 = (*(int *)(lVar7 + 8) - *(int *)(lVar7 + 0x3c)) + -1;
        if (*(int *)(lVar7 + 0x20) < iVar4) {
          iVar4 = *(int *)(lVar7 + 0x20);
        }
        if (0 < iVar4) {
          lVar5 = lVar5 + (long)iVar4 * 0x18;
        }
      }
      (**(code **)(*(long *)this + 0x28))
                (this,lVar5,1,&E_GL_ARB_tessellation_shader,"tessellation shaders");
      iVar4 = *(int *)(this + 0x1c);
    }
    break;
      case 3:
    lVar5 = *(long *)this;
    if ((*(int *)(this + 0xc) == 8) && (*(int *)(this + 0x18) == 0x136)) {
      lVar2 = *(long *)(this + 0xd8);
      lVar7 = lVar2 + 0x40;
      if (*(char *)(lVar2 + 0x58) == '\0') {
        lVar7 = *(long *)(lVar2 + 0x30);
        iVar4 = (*(int *)(lVar2 + 8) - *(int *)(lVar2 + 0x3c)) + -1;
        if (*(int *)(lVar2 + 0x20) < iVar4) {
          iVar4 = *(int *)(lVar2 + 0x20);
        }
        if (0 < iVar4) {
          lVar7 = lVar7 + (long)iVar4 * 0x18;
        }
      }
      (**(code **)(lVar5 + 0x28))(this,lVar7,2,AEP_geometry_shader,"geometry shaders");
      iVar4 = *(int *)(this + 0x1c);
      break;
    }
    goto LAB_00103245;
      case 5:
    if (*(int *)(this + 0xc) == 8) {
      return;
    }
    if (0x1ad < *(int *)(this + 0x18)) {
      return;
    }
    lVar7 = *(long *)(this + 0xd8);
    lVar5 = lVar7 + 0x40;
    if (*(char *)(lVar7 + 0x58) == '\0') {
      lVar5 = *(long *)(lVar7 + 0x30);
      iVar4 = (*(int *)(lVar7 + 8) - *(int *)(lVar7 + 0x3c)) + -1;
      if (*(int *)(lVar7 + 0x20) < iVar4) {
        iVar4 = *(int *)(lVar7 + 0x20);
      }
      if (0 < iVar4) {
        lVar5 = lVar5 + (long)iVar4 * 0x18;
      }
    }
    (**(code **)(*(long *)this + 0x28))(this,lVar5,1,&E_GL_ARB_compute_shader,"compute shaders");
    iVar4 = *(int *)(this + 0x1c);
    break;
      case 0xc:
    lVar7 = *(long *)(this + 0xd8);
    pcVar9 = *(code **)(*(long *)this + 0x28);
    lVar5 = lVar7 + 0x40;
    if (*(char *)(lVar7 + 0x58) == '\0') {
      lVar5 = *(long *)(lVar7 + 0x30);
      iVar4 = (*(int *)(lVar7 + 8) - *(int *)(lVar7 + 0x3c)) + -1;
      if (*(int *)(lVar7 + 0x20) < iVar4) {
        iVar4 = *(int *)(lVar7 + 0x20);
      }
      if (0 < iVar4) {
        lVar5 = lVar5 + (long)iVar4 * 0x18;
      }
    }
    pcVar8 = "task shaders";
    goto LAB_001032fa;
      case 0xd:
    lVar7 = *(long *)(this + 0xd8);
    pcVar9 = *(code **)(*(long *)this + 0x28);
    lVar5 = lVar7 + 0x40;
    if (*(char *)(lVar7 + 0x58) == '\0') {
      lVar5 = *(long *)(lVar7 + 0x30);
      iVar4 = (*(int *)(lVar7 + 8) - *(int *)(lVar7 + 0x3c)) + -1;
      if (*(int *)(lVar7 + 0x20) < iVar4) {
        iVar4 = *(int *)(lVar7 + 0x20);
      }
      if (0 < iVar4) {
        lVar5 = lVar5 + (long)iVar4 * 0x18;
      }
    }
    pcVar8 = "mesh shaders";
LAB_001032fa:
    (*pcVar9)(this,lVar5,2,AEP_mesh_shader,pcVar8);
    iVar4 = *(int *)(this + 0x1c);
   }

   if (iVar4 != 3) {
      return;
   }

   lVar5 = *(long*)this;
   LAB_00103245:cVar3 = ( **(code**)( lVar5 + 0x40 ) )(this, "GL_NV_geometry_shader_passthrough");
   if (cVar3 == '\0') {
      return;
   }

   lVar5 = *(long*)( this + 0x38 );
   iVar4 = *(int*)( lVar5 + 0x30c );
   if (*(int*)( lVar5 + 0x314 ) == 0) {
      iVar1 = *(int*)( lVar5 + 0x310 );
      if (iVar1 == 2) {
         *(undefined4*)( lVar5 + 0x314 ) = 4;
         if (iVar4 != -1) {
            return;
         }

         LAB_001034f7:*(undefined4*)( lVar5 + 0x30c ) = 2;
         return;
      }

      if (iVar1 == 5) {
         *(undefined4*)( lVar5 + 0x314 ) = 7;
         if (iVar4 != -1) {
            return;
         }

         LAB_001034d5:*(undefined4*)( lVar5 + 0x30c ) = 3;
         return;
      }

      if (iVar1 != 1) {
         return;
      }

      *(undefined4*)( lVar5 + 0x314 ) = 1;
      if (iVar4 != -1) {
         return;
      }

   }
 else {
      if (iVar4 != -1) {
         return;
      }

      iVar4 = *(int*)( lVar5 + 0x310 );
      if (iVar4 == 2) goto LAB_001034f7;
      if (iVar4 == 5) goto LAB_001034d5;
      if (iVar4 != 1) {
         return;
      }

   }

   *(undefined4*)( lVar5 + 0x30c ) = 1;
   return;
}
/* glslang::TParseContext::finish() */void glslang::TParseContext::finish(TParseContext *this) {
   glslang::TParseContextBase::finish();
   if (this[0x1c1] == (TParseContext)0x0) {
      finish(this);
      return;
   }

   return;
}
/* glslang::TParseContext::parseShaderStrings(glslang::TPpContext&, glslang::TInputScanner&, bool)
    */undefined4 glslang::TParseContext::parseShaderStrings(TPpContext *param_1, TInputScanner *param_2, bool param_3) {
   undefined7 in_register_00000011;
   *(ulong*)( param_1 + 0xd8 ) = CONCAT71(in_register_00000011, param_3);
   glslang::TPpContext::setInput(param_2, param_3);
   yyparse((TParseContext*)param_1);
   if (*(code**)( *(long*)param_1 + 0x270 ) == finish) {
      glslang::TParseContextBase::finish();
      if (param_1[0x1c1] == (TPpContext)0x0) {
         finish((TParseContext*)param_1);
      }

      return CONCAT31(( int3 )(( uint ) * (int*)( param_1 + 0xd4 ) >> 8), *(int*)( param_1 + 0xd4 ) == 0);
   }

   ( **(code**)( *(long*)param_1 + 0x270 ) )(param_1);
   return CONCAT31(( int3 )(( uint ) * (int*)( param_1 + 0xd4 ) >> 8), *(int*)( param_1 + 0xd4 ) == 0);
}
/* glslang::TParseContext::reservedErrorCheck(glslang::TSourceLoc const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const&)
   [clone .part.0] */void glslang::TParseContext::reservedErrorCheck(TParseContext *this, TSourceLoc *param_1, basic_string *param_2) {
   char cVar1;
   int iVar2;
   long lVar3;
   char *pcVar4;
   code *UNRECOVERED_JUMPTABLE;
   size_t __n;
   ulong uVar5;
   uVar5 = *(ulong*)( param_2 + 0x10 );
   pcVar4 = *(char**)( param_2 + 8 );
   if (uVar5 != 0) {
      __n = 3;
      if (uVar5 < 4) {
         __n = uVar5;
      }

      iVar2 = memcmp(pcVar4, &_LC61, __n);
      if (iVar2 == 0 && (int)__n == 3) {
         cVar1 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_EXT_spirv_intrinsics");
         if (cVar1 == '\0') {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "identifiers starting with \"gl_\" are reserved", *(undefined8*)( param_2 + 8 ), &_LC1);
         }

         pcVar4 = *(char**)( param_2 + 8 );
         uVar5 = *(ulong*)( param_2 + 0x10 );
      }

   }

   lVar3 = std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::find(pcVar4, uVar5, 0x152469);
   if (lVar3 != -1) {
      cVar1 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_EXT_spirv_intrinsics");
      if (cVar1 == '\0') {
         if (( *(int*)( this + 0xc ) == 8 ) && ( *(int*)( this + 0x18 ) < 300 )) {
            UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
            pcVar4 = "identifiers containing consecutive underscores (\"__\") are reserved, and an error if version < 300";
         }
 else {
            UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x160 );
            pcVar4 = "identifiers containing consecutive underscores (\"__\") are reserved";
         }

         /* WARNING: Could not recover jumptable at 0x00103658. Too many branches */
         /* WARNING: Treating indirect jump as call */
         ( *UNRECOVERED_JUMPTABLE )(this, param_1, pcVar4, *(undefined8*)( param_2 + 8 ), &_LC1, UNRECOVERED_JUMPTABLE);
         return;
      }

   }

   return;
}
/* __gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >
   std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsNonOpaque()
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsNonOpaque()
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>
   >(__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >, __gnu_cxx::__normal_iterator<glslang::TTypeLoc*,
   std::vector<glslang::TTypeLoc, glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsNonOpaque()
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsNonOpaque()
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>,
   std::random_access_iterator_tag) [clone .isra.0] */long *std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsNonOpaque()const::_lambda(glslang::TType_const*)_1_>(glslang::TType::containsNonOpaque()const::_lambda(glslang::TType_const*)_1_)const::_lambda(glslang::TTypeLoc_const&)_1_>(long *param_1, long *param_2) {
   byte bVar1;
   long *plVar2;
   char cVar3;
   long lVar4;
   long lVar5;
   long *plVar6;
   lVar5 = (long)param_2 - (long)param_1;
   if (0 < lVar5 >> 7) {
      plVar6 = param_1 + ( lVar5 >> 7 ) * 0x10;
      do {
         plVar2 = (long*)*param_1;
         bVar1 = *(byte*)( plVar2 + 1 );
         if (bVar1 < 0xd) {
            return param_1;
         }

         if (bVar1 == 0x12) {
            return param_1;
         }

         if (*(code**)( *plVar2 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )(bVar1 - 0xf) < 2) {
               LAB_0010389d:lVar5 = *(long*)( plVar2[0xd] + 0x10 );
               lVar4 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsNonOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsNonOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar2[0xd] + 8 ),lVar5 ));
               if (lVar5 != lVar4) {
                  return param_1;
               }

            }

         }
 else {
            cVar3 = ( **(code**)( *plVar2 + 0x128 ) )(plVar2);
            if (cVar3 != '\0') goto LAB_0010389d;
         }

         plVar2 = (long*)param_1[4];
         bVar1 = *(byte*)( plVar2 + 1 );
         if (( bVar1 < 0xd ) || ( bVar1 == 0x12 )) goto LAB_0010379f;
         if (*(code**)( *plVar2 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )(bVar1 - 0xf) < 2) {
               LAB_001038dd:lVar5 = *(long*)( plVar2[0xd] + 0x10 );
               lVar4 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsNonOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsNonOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar2[0xd] + 8 ),lVar5 ));
               if (lVar5 != lVar4) {
                  LAB_0010379f:return param_1 + 4;
               }

            }

         }
 else {
            cVar3 = ( **(code**)( *plVar2 + 0x128 ) )(plVar2);
            if (cVar3 != '\0') goto LAB_001038dd;
         }

         plVar2 = (long*)param_1[8];
         bVar1 = *(byte*)( plVar2 + 1 );
         if (( bVar1 < 0xd ) || ( bVar1 == 0x12 )) goto LAB_001037df;
         if (*(code**)( *plVar2 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )(bVar1 - 0xf) < 2) {
               LAB_0010390d:lVar5 = *(long*)( plVar2[0xd] + 0x10 );
               lVar4 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsNonOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsNonOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar2[0xd] + 8 ),lVar5 ));
               if (lVar5 != lVar4) {
                  LAB_001037df:return param_1 + 8;
               }

            }

         }
 else {
            cVar3 = ( **(code**)( *plVar2 + 0x128 ) )(plVar2);
            if (cVar3 != '\0') goto LAB_0010390d;
         }

         plVar2 = (long*)param_1[0xc];
         bVar1 = *(byte*)( plVar2 + 1 );
         if (( bVar1 < 0xd ) || ( bVar1 == 0x12 )) goto LAB_0010381f;
         if (*(code**)( *plVar2 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )(bVar1 - 0xf) < 2) {
               LAB_0010393d:lVar5 = *(long*)( plVar2[0xd] + 0x10 );
               lVar4 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsNonOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsNonOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar2[0xd] + 8 ),lVar5 ));
               if (lVar5 != lVar4) {
                  LAB_0010381f:return param_1 + 0xc;
               }

            }

         }
 else {
            cVar3 = ( **(code**)( *plVar2 + 0x128 ) )(plVar2);
            if (cVar3 != '\0') goto LAB_0010393d;
         }

         param_1 = param_1 + 0x10;
      }
 while ( param_1 != plVar6 );
      lVar5 = (long)param_2 - (long)param_1;
   }

   lVar5 = lVar5 >> 5;
   if (lVar5 != 2) {
      if (lVar5 != 3) {
         if (lVar5 != 1) {
            return param_2;
         }

         goto LAB_001039d9;
      }

      plVar6 = (long*)*param_1;
      bVar1 = *(byte*)( plVar6 + 1 );
      if (bVar1 < 0xd) {
         return param_1;
      }

      if (bVar1 == 0x12) {
         return param_1;
      }

      if (*(code**)( *plVar6 + 0x128 ) == glslang::TType::isStruct) {
         if (( byte )(bVar1 - 0xf) < 2) {
            LAB_00103a7b:lVar5 = *(long*)( plVar6[0xd] + 0x10 );
            lVar4 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsNonOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsNonOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar6[0xd] + 8 ),lVar5 ));
            if (lVar5 != lVar4) {
               return param_1;
            }

         }

      }
 else {
         cVar3 = ( **(code**)( *plVar6 + 0x128 ) )(plVar6);
         if (cVar3 != '\0') goto LAB_00103a7b;
      }

      param_1 = param_1 + 4;
   }

   plVar6 = (long*)*param_1;
   bVar1 = *(byte*)( plVar6 + 1 );
   if (bVar1 < 0xd) {
      return param_1;
   }

   if (bVar1 == 0x12) {
      return param_1;
   }

   if (*(code**)( *plVar6 + 0x128 ) == glslang::TType::isStruct) {
      if (( byte )(bVar1 - 0xf) < 2) {
         LAB_00103a3d:lVar5 = *(long*)( plVar6[0xd] + 0x10 );
         lVar4 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsNonOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsNonOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar6[0xd] + 8 ),lVar5 ));
         if (lVar5 != lVar4) {
            return param_1;
         }

      }

   }
 else {
      cVar3 = ( **(code**)( *plVar6 + 0x128 ) )(plVar6);
      if (cVar3 != '\0') goto LAB_00103a3d;
   }

   param_1 = param_1 + 4;
   LAB_001039d9:plVar6 = (long*)*param_1;
   bVar1 = *(byte*)( plVar6 + 1 );
   if (bVar1 < 0xd) {
      return param_1;
   }

   if (bVar1 == 0x12) {
      return param_1;
   }

   if (*(code**)( *plVar6 + 0x128 ) == glslang::TType::isStruct) {
      if (1 < ( byte )(bVar1 - 0xf)) {
         return param_2;
      }

   }
 else {
      cVar3 = ( **(code**)( *plVar6 + 0x128 ) )(plVar6);
      if (cVar3 == '\0') {
         return param_2;
      }

   }

   lVar5 = *(long*)( plVar6[0xd] + 0x10 );
   lVar4 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsNonOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsNonOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar6[0xd] + 8 ),lVar5 ));
   if (lVar5 == lVar4) {
      return param_2;
   }

   return param_1;
}
/* __gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >
   std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsBasicType(glslang::TBasicType)
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>
   >(__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >, __gnu_cxx::__normal_iterator<glslang::TTypeLoc*,
   std::vector<glslang::TTypeLoc, glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsBasicType(glslang::TBasicType)
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>,
   std::random_access_iterator_tag) [clone .isra.0] */long *std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const*)_1_>(glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const*)_1_)const::_lambda(glslang::TTypeLoc_const&)_1_>(long *param_1, long *param_2, uint param_3) {
   long *plVar1;
   char cVar2;
   long lVar3;
   long lVar4;
   long *plVar5;
   lVar4 = (long)param_2 - (long)param_1;
   if (0 < lVar4 >> 7) {
      plVar5 = param_1 + ( lVar4 >> 7 ) * 0x10;
      do {
         plVar1 = (long*)*param_1;
         if (*(byte*)( plVar1 + 1 ) == param_3) {
            return param_1;
         }

         if (*(code**)( *plVar1 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )(*(byte*)( plVar1 + 1 ) - 0xf) < 2) {
               LAB_00103bdd:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4,param_3 ));
               if (lVar4 != lVar3) {
                  return param_1;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( *plVar1 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00103bdd;
         }

         plVar1 = (long*)param_1[4];
         if (*(byte*)( plVar1 + 1 ) == param_3) goto LAB_00103c2c;
         if (*(code**)( *plVar1 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )(*(byte*)( plVar1 + 1 ) - 0xf) < 2) {
               LAB_00103c0d:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4,param_3 ));
               if (lVar4 != lVar3) {
                  LAB_00103c2c:return param_1 + 4;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( *plVar1 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00103c0d;
         }

         plVar1 = (long*)param_1[8];
         if (*(byte*)( plVar1 + 1 ) == param_3) goto LAB_00103c64;
         if (*(code**)( *plVar1 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )(*(byte*)( plVar1 + 1 ) - 0xf) < 2) {
               LAB_00103c45:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4,param_3 ));
               if (lVar4 != lVar3) {
                  LAB_00103c64:return param_1 + 8;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( *plVar1 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00103c45;
         }

         plVar1 = (long*)param_1[0xc];
         if (*(byte*)( plVar1 + 1 ) == param_3) goto LAB_00103c9c;
         if (*(code**)( *plVar1 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )(*(byte*)( plVar1 + 1 ) - 0xf) < 2) {
               LAB_00103c7d:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4,param_3 ));
               if (lVar4 != lVar3) {
                  LAB_00103c9c:return param_1 + 0xc;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( *plVar1 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00103c7d;
         }

         param_1 = param_1 + 0x10;
      }
 while ( param_1 != plVar5 );
      lVar4 = (long)param_2 - (long)param_1;
   }

   lVar4 = lVar4 >> 5;
   if (lVar4 != 2) {
      if (lVar4 != 3) {
         if (lVar4 != 1) {
            return param_2;
         }

         goto LAB_00103d3e;
      }

      plVar5 = (long*)*param_1;
      if (*(byte*)( plVar5 + 1 ) == param_3) {
         return param_1;
      }

      if (*(code**)( *plVar5 + 0x128 ) == glslang::TType::isStruct) {
         if (( byte )(*(byte*)( plVar5 + 1 ) - 0xf) < 2) {
            LAB_00103de2:lVar4 = *(long*)( plVar5[0xd] + 0x10 );
            lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4,param_3 ));
            if (lVar4 != lVar3) {
               return param_1;
            }

         }

      }
 else {
         cVar2 = ( **(code**)( *plVar5 + 0x128 ) )(plVar5);
         if (cVar2 != '\0') goto LAB_00103de2;
      }

      param_1 = param_1 + 4;
   }

   plVar5 = (long*)*param_1;
   if (*(byte*)( plVar5 + 1 ) == param_3) {
      return param_1;
   }

   if (*(code**)( *plVar5 + 0x128 ) == glslang::TType::isStruct) {
      if (( byte )(*(byte*)( plVar5 + 1 ) - 0xf) < 2) {
         LAB_00103da1:lVar4 = *(long*)( plVar5[0xd] + 0x10 );
         lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4,param_3 ));
         if (lVar4 != lVar3) {
            return param_1;
         }

      }

   }
 else {
      cVar2 = ( **(code**)( *plVar5 + 0x128 ) )(plVar5);
      if (cVar2 != '\0') goto LAB_00103da1;
   }

   param_1 = param_1 + 4;
   LAB_00103d3e:plVar5 = (long*)*param_1;
   if (param_3 == *(byte*)( plVar5 + 1 )) {
      return param_1;
   }

   if (*(code**)( *plVar5 + 0x128 ) == glslang::TType::isStruct) {
      if (1 < ( byte )(*(byte*)( plVar5 + 1 ) - 0xf)) {
         return param_2;
      }

   }
 else {
      cVar2 = ( **(code**)( *plVar5 + 0x128 ) )(plVar5);
      if (cVar2 == '\0') {
         return param_2;
      }

   }

   lVar4 = *(long*)( plVar5[0xd] + 0x10 );
   lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4,param_3 ));
   if (lVar4 == lVar3) {
      return param_2;
   }

   return param_1;
}
/* __gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >
   std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSpecializationSize()
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsSpecializationSize()
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>
   >(__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >, __gnu_cxx::__normal_iterator<glslang::TTypeLoc*,
   std::vector<glslang::TTypeLoc, glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSpecializationSize()
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsSpecializationSize()
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>,
   std::random_access_iterator_tag) [clone .isra.0] */long *std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSpecializationSize()const::_lambda(glslang::TType_const*)_1_>(glslang::TType::containsSpecializationSize()const::_lambda(glslang::TType_const*)_1_)const::_lambda(glslang::TTypeLoc_const&)_1_>(long *param_1, long *param_2) {
   long *plVar1;
   char cVar2;
   long lVar3;
   long lVar4;
   long *plVar5;
   lVar4 = (long)param_2 - (long)param_1;
   if (0 < lVar4 >> 7) {
      plVar5 = param_1 + ( lVar4 >> 7 ) * 0x10;
      do {
         plVar1 = (long*)*param_1;
         lVar4 = *plVar1;
         if (*(code**)( lVar4 + 0xe8 ) == glslang::TType::isArray) {
            lVar3 = plVar1[0xc];
            if (lVar3 != 0) {
               LAB_00103e78:if (*(long*)( *(long*)( *(long*)( lVar3 + 8 ) + 8 ) + 8 ) != 0) {
                  return param_1;
               }

               goto LAB_00103ea0;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar1);
            if (cVar2 != '\0') {
               lVar3 = plVar1[0xc];
               goto LAB_00103e78;
            }

            LAB_00103ea0:lVar4 = *plVar1;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_001040bd:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSpecializationSize()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsSpecializationSize ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  return param_1;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_001040bd;
         }

         plVar1 = (long*)param_1[4];
         lVar4 = *plVar1;
         if (*(code**)( lVar4 + 0xe8 ) == glslang::TType::isArray) {
            lVar3 = plVar1[0xc];
            if (lVar3 != 0) {
               LAB_00103ee4:if (*(long*)( *(long*)( *(long*)( lVar3 + 8 ) + 8 ) + 8 ) != 0) goto LAB_00103ef3;
               goto LAB_00103f00;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar1);
            if (cVar2 != '\0') {
               lVar3 = plVar1[0xc];
               goto LAB_00103ee4;
            }

            LAB_00103f00:lVar4 = *plVar1;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_001040ed:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSpecializationSize()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsSpecializationSize ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  LAB_00103ef3:return param_1 + 4;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_001040ed;
         }

         plVar1 = (long*)param_1[8];
         lVar4 = *plVar1;
         if (*(code**)( lVar4 + 0xe8 ) == glslang::TType::isArray) {
            lVar3 = plVar1[0xc];
            if (lVar3 != 0) {
               LAB_00103f44:if (*(long*)( *(long*)( *(long*)( lVar3 + 8 ) + 8 ) + 8 ) != 0) goto LAB_00103f53;
               goto LAB_00103f60;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar1);
            if (cVar2 != '\0') {
               lVar3 = plVar1[0xc];
               goto LAB_00103f44;
            }

            LAB_00103f60:lVar4 = *plVar1;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_0010411d:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSpecializationSize()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsSpecializationSize ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  LAB_00103f53:return param_1 + 8;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_0010411d;
         }

         plVar1 = (long*)param_1[0xc];
         lVar4 = *plVar1;
         if (*(code**)( lVar4 + 0xe8 ) == glslang::TType::isArray) {
            lVar3 = plVar1[0xc];
            if (lVar3 != 0) {
               LAB_00103fa4:if (*(long*)( *(long*)( *(long*)( lVar3 + 8 ) + 8 ) + 8 ) != 0) goto LAB_00103fb3;
               goto LAB_00103fc0;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar1);
            if (cVar2 != '\0') {
               lVar3 = plVar1[0xc];
               goto LAB_00103fa4;
            }

            LAB_00103fc0:lVar4 = *plVar1;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_0010414d:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSpecializationSize()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsSpecializationSize ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  LAB_00103fb3:return param_1 + 0xc;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_0010414d;
         }

         param_1 = param_1 + 0x10;
      }
 while ( param_1 != plVar5 );
      lVar4 = (long)param_2 - (long)param_1;
   }

   lVar4 = lVar4 >> 5;
   if (lVar4 == 2) {
      LAB_0010424e:plVar5 = (long*)*param_1;
      lVar4 = *plVar5;
      if (*(code**)( lVar4 + 0xe8 ) == glslang::TType::isArray) {
         lVar3 = plVar5[0xc];
         if (lVar3 != 0) {
            LAB_0010426e:if (*(long*)( *(long*)( *(long*)( lVar3 + 8 ) + 8 ) + 8 ) != 0) {
               return param_1;
            }

            goto LAB_00104281;
         }

      }
 else {
         cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar5);
         if (cVar2 != '\0') {
            lVar3 = plVar5[0xc];
            goto LAB_0010426e;
         }

         LAB_00104281:lVar4 = *plVar5;
      }

      if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
         if (( byte )((char)plVar5[1] - 0xfU) < 2) {
            LAB_001042c7:lVar4 = *(long*)( plVar5[0xd] + 0x10 );
            lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSpecializationSize()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsSpecializationSize ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4 ));
            if (lVar4 != lVar3) {
               return param_1;
            }

         }

      }
 else {
         cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar5);
         if (cVar2 != '\0') goto LAB_001042c7;
      }

      param_1 = param_1 + 4;
   }
 else {
      if (lVar4 == 3) {
         plVar5 = (long*)*param_1;
         lVar4 = *plVar5;
         if (*(code**)( lVar4 + 0xe8 ) == glslang::TType::isArray) {
            lVar3 = plVar5[0xc];
            if (lVar3 != 0) {
               LAB_0010420d:if (*(long*)( *(long*)( *(long*)( lVar3 + 8 ) + 8 ) + 8 ) != 0) {
                  return param_1;
               }

               goto LAB_00104220;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar5);
            if (cVar2 != '\0') {
               lVar3 = plVar5[0xc];
               goto LAB_0010420d;
            }

            LAB_00104220:lVar4 = *plVar5;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar5[1] - 0xfU) < 2) {
               LAB_00104335:lVar4 = *(long*)( plVar5[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSpecializationSize()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsSpecializationSize ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  return param_1;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar5);
            if (cVar2 != '\0') goto LAB_00104335;
         }

         param_1 = param_1 + 4;
         goto LAB_0010424e;
      }

      if (lVar4 != 1) {
         return param_2;
      }

   }

   plVar5 = (long*)*param_1;
   lVar4 = *plVar5;
   if (*(code**)( lVar4 + 0xe8 ) == glslang::TType::isArray) {
      lVar3 = plVar5[0xc];
      if (lVar3 == 0) goto LAB_00104059;
      LAB_00104042:if (*(long*)( *(long*)( *(long*)( lVar3 + 8 ) + 8 ) + 8 ) != 0) {
         return param_1;
      }

   }
 else {
      cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar5);
      if (cVar2 != '\0') {
         lVar3 = plVar5[0xc];
         goto LAB_00104042;
      }

   }

   lVar4 = *plVar5;
   LAB_00104059:if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
      if (1 < ( byte )((char)plVar5[1] - 0xfU)) {
         return param_2;
      }

   }
 else {
      cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar5);
      if (cVar2 == '\0') {
         return param_2;
      }

   }

   lVar4 = *(long*)( plVar5[0xd] + 0x10 );
   lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSpecializationSize()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsSpecializationSize ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4 ));
   if (lVar4 == lVar3) {
      return param_2;
   }

   return param_1;
}
/* __gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >
   std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsOpaque()
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>
   >(__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >, __gnu_cxx::__normal_iterator<glslang::TTypeLoc*,
   std::vector<glslang::TTypeLoc, glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsOpaque()
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>,
   std::random_access_iterator_tag) [clone .isra.0] */long *std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()const::_lambda(glslang::TType_const*)_1_>(glslang::TType::containsOpaque()const::_lambda(glslang::TType_const*)_1_)const::_lambda(glslang::TTypeLoc_const&)_1_>(long *param_1, long *param_2) {
   long *plVar1;
   char cVar2;
   long lVar3;
   long lVar4;
   long *plVar5;
   lVar4 = (long)param_2 - (long)param_1;
   if (0 < lVar4 >> 7) {
      plVar5 = param_1 + ( lVar4 >> 7 ) * 0x10;
      do {
         plVar1 = (long*)*param_1;
         lVar4 = *plVar1;
         if (*(code**)( lVar4 + 0x140 ) == glslang::TType::isOpaque) {
            if (( *(byte*)( plVar1 + 1 ) < 0x15 ) && ( ( 0x1a6000UL >> ( ( ulong ) * (byte*)( plVar1 + 1 ) & 0x3f ) & 1 ) != 0 )) {
               return param_1;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x140 ) )(plVar1);
            if (cVar2 != '\0') {
               return param_1;
            }

            lVar4 = *plVar1;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_0010461d:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  return param_1;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_0010461d;
         }

         plVar1 = (long*)param_1[4];
         lVar4 = *plVar1;
         if (*(code**)( lVar4 + 0x140 ) == glslang::TType::isOpaque) {
            if (( *(byte*)( plVar1 + 1 ) < 0x15 ) && ( ( 0x1a6000UL >> ( ( ulong ) * (byte*)( plVar1 + 1 ) & 0x3f ) & 1 ) != 0 )) goto LAB_00104440;
         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x140 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00104440;
            lVar4 = *plVar1;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_0010464d:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  LAB_00104440:return param_1 + 4;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_0010464d;
         }

         plVar1 = (long*)param_1[8];
         lVar4 = *plVar1;
         if (*(code**)( lVar4 + 0x140 ) == glslang::TType::isOpaque) {
            if (( *(byte*)( plVar1 + 1 ) < 0x15 ) && ( ( 0x1a6000UL >> ( ( ulong ) * (byte*)( plVar1 + 1 ) & 0x3f ) & 1 ) != 0 )) goto LAB_001044a8;
         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x140 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_001044a8;
            lVar4 = *plVar1;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_0010467d:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  LAB_001044a8:return param_1 + 8;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_0010467d;
         }

         plVar1 = (long*)param_1[0xc];
         lVar4 = *plVar1;
         if (*(code**)( lVar4 + 0x140 ) == glslang::TType::isOpaque) {
            if (( *(byte*)( plVar1 + 1 ) < 0x15 ) && ( ( 0x1a6000UL >> ( ( ulong ) * (byte*)( plVar1 + 1 ) & 0x3f ) & 1 ) != 0 )) goto LAB_00104510;
         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x140 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00104510;
            lVar4 = *plVar1;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_001046ad:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  LAB_00104510:return param_1 + 0xc;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_001046ad;
         }

         param_1 = param_1 + 0x10;
      }
 while ( param_1 != plVar5 );
      lVar4 = (long)param_2 - (long)param_1;
   }

   lVar4 = lVar4 >> 5;
   if (lVar4 != 2) {
      if (lVar4 != 3) {
         if (lVar4 != 1) {
            return param_2;
         }

         goto LAB_0010458d;
      }

      plVar5 = (long*)*param_1;
      lVar4 = *plVar5;
      if (*(code**)( lVar4 + 0x140 ) == glslang::TType::isOpaque) {
         if (( *(byte*)( plVar5 + 1 ) < 0x15 ) && ( ( 0x1a6000UL >> ( ( ulong ) * (byte*)( plVar5 + 1 ) & 0x3f ) & 1 ) != 0 )) {
            return param_1;
         }

      }
 else {
         cVar2 = ( **(code**)( lVar4 + 0x140 ) )(plVar5);
         if (cVar2 != '\0') {
            return param_1;
         }

         lVar4 = *plVar5;
      }

      if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
         if (( byte )((char)plVar5[1] - 0xfU) < 2) {
            LAB_00104818:lVar4 = *(long*)( plVar5[0xd] + 0x10 );
            lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4 ));
            if (lVar4 != lVar3) {
               return param_1;
            }

         }

      }
 else {
         cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar5);
         if (cVar2 != '\0') goto LAB_00104818;
      }

      param_1 = param_1 + 4;
   }

   plVar5 = (long*)*param_1;
   lVar4 = *plVar5;
   if (*(code**)( lVar4 + 0x140 ) == glslang::TType::isOpaque) {
      if (( *(byte*)( plVar5 + 1 ) < 0x15 ) && ( ( 0x1a6000UL >> ( ( ulong ) * (byte*)( plVar5 + 1 ) & 0x3f ) & 1 ) != 0 )) {
         return param_1;
      }

   }
 else {
      cVar2 = ( **(code**)( lVar4 + 0x140 ) )(plVar5);
      if (cVar2 != '\0') {
         return param_1;
      }

      lVar4 = *plVar5;
   }

   if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
      if (( byte )((char)plVar5[1] - 0xfU) < 2) {
         LAB_001047bf:lVar4 = *(long*)( plVar5[0xd] + 0x10 );
         lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4 ));
         if (lVar4 != lVar3) {
            return param_1;
         }

      }

   }
 else {
      cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar5);
      if (cVar2 != '\0') goto LAB_001047bf;
   }

   param_1 = param_1 + 4;
   LAB_0010458d:plVar5 = (long*)*param_1;
   lVar4 = *plVar5;
   if (*(code**)( lVar4 + 0x140 ) == glslang::TType::isOpaque) {
      if (( *(byte*)( plVar5 + 1 ) < 0x15 ) && ( ( 0x1a6000UL >> ( ( ulong ) * (byte*)( plVar5 + 1 ) & 0x3f ) & 1 ) != 0 )) {
         return param_1;
      }

   }
 else {
      cVar2 = ( **(code**)( lVar4 + 0x140 ) )(plVar5);
      if (cVar2 != '\0') {
         return param_1;
      }

      lVar4 = *plVar5;
   }

   if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
      if (1 < ( byte )((char)plVar5[1] - 0xfU)) {
         return param_2;
      }

   }
 else {
      cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar5);
      if (cVar2 == '\0') {
         return param_2;
      }

   }

   lVar4 = *(long*)( plVar5[0xd] + 0x10 );
   lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4 ));
   if (lVar4 == lVar3) {
      return param_2;
   }

   return param_1;
}
/* __gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >
   std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsCoopMat()
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsCoopMat()
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>
   >(__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >, __gnu_cxx::__normal_iterator<glslang::TTypeLoc*,
   std::vector<glslang::TTypeLoc, glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsCoopMat()
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsCoopMat()
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>,
   std::random_access_iterator_tag) [clone .isra.0] */long *std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsCoopMat()const::_lambda(glslang::TType_const*)_1_>(glslang::TType::containsCoopMat()const::_lambda(glslang::TType_const*)_1_)const::_lambda(glslang::TTypeLoc_const&)_1_>(long *param_1, long *param_2) {
   long *plVar1;
   char cVar2;
   long lVar3;
   long lVar4;
   long *plVar5;
   lVar4 = (long)param_2 - (long)param_1;
   if (0 < lVar4 >> 7) {
      plVar5 = param_1 + ( lVar4 >> 7 ) * 0x10;
      do {
         plVar1 = (long*)*param_1;
         if (( *(byte*)( (long)plVar1 + 10 ) & 0x20 ) != 0) {
            return param_1;
         }

         if (( *(byte*)( (long)plVar1 + 10 ) & 0x40 ) != 0) {
            return param_1;
         }

         if (*(code**)( *plVar1 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_00104a85:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsCoopMat()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsCoopMat ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  return param_1;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( *plVar1 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00104a85;
         }

         plVar1 = (long*)param_1[4];
         if (( ( *(byte*)( (long)plVar1 + 10 ) & 0x20 ) != 0 ) || ( ( *(byte*)( (long)plVar1 + 10 ) & 0x40 ) != 0 )) goto LAB_001049e2;
         if (*(code**)( *plVar1 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_001049c5:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsCoopMat()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsCoopMat ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  LAB_001049e2:return param_1 + 4;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( *plVar1 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_001049c5;
         }

         plVar1 = (long*)param_1[8];
         if (( ( *(byte*)( (long)plVar1 + 10 ) & 0x20 ) != 0 ) || ( ( *(byte*)( (long)plVar1 + 10 ) & 0x40 ) != 0 )) goto LAB_00104a28;
         if (*(code**)( *plVar1 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_00104a05:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsCoopMat()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsCoopMat ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  LAB_00104a28:return param_1 + 8;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( *plVar1 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00104a05;
         }

         plVar1 = (long*)param_1[0xc];
         if (( ( *(byte*)( (long)plVar1 + 10 ) & 0x20 ) != 0 ) || ( ( *(byte*)( (long)plVar1 + 10 ) & 0x40 ) != 0 )) goto LAB_00104a68;
         if (*(code**)( *plVar1 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_00104a45:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsCoopMat()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsCoopMat ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  LAB_00104a68:return param_1 + 0xc;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( *plVar1 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00104a45;
         }

         param_1 = param_1 + 0x10;
      }
 while ( param_1 != plVar5 );
      lVar4 = (long)param_2 - (long)param_1;
   }

   lVar4 = lVar4 >> 5;
   if (lVar4 != 2) {
      if (lVar4 != 3) {
         if (lVar4 != 1) {
            return param_2;
         }

         goto LAB_00104b29;
      }

      plVar5 = (long*)*param_1;
      if (( *(byte*)( (long)plVar5 + 10 ) & 0x20 ) != 0) {
         return param_1;
      }

      if (( *(byte*)( (long)plVar5 + 10 ) & 0x40 ) != 0) {
         return param_1;
      }

      if (*(code**)( *plVar5 + 0x128 ) == glslang::TType::isStruct) {
         if (( byte )((char)plVar5[1] - 0xfU) < 2) {
            LAB_00104bcf:lVar4 = *(long*)( plVar5[0xd] + 0x10 );
            lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsCoopMat()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsCoopMat ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4 ));
            if (lVar4 != lVar3) {
               return param_1;
            }

         }

      }
 else {
         cVar2 = ( **(code**)( *plVar5 + 0x128 ) )(plVar5);
         if (cVar2 != '\0') goto LAB_00104bcf;
      }

      param_1 = param_1 + 4;
   }

   plVar5 = (long*)*param_1;
   if (( *(byte*)( (long)plVar5 + 10 ) & 0x20 ) != 0) {
      return param_1;
   }

   if (( *(byte*)( (long)plVar5 + 10 ) & 0x40 ) != 0) {
      return param_1;
   }

   if (*(code**)( *plVar5 + 0x128 ) == glslang::TType::isStruct) {
      if (( byte )((char)plVar5[1] - 0xfU) < 2) {
         LAB_00104b91:lVar4 = *(long*)( plVar5[0xd] + 0x10 );
         lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsCoopMat()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsCoopMat ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4 ));
         if (lVar4 != lVar3) {
            return param_1;
         }

      }

   }
 else {
      cVar2 = ( **(code**)( *plVar5 + 0x128 ) )(plVar5);
      if (cVar2 != '\0') goto LAB_00104b91;
   }

   param_1 = param_1 + 4;
   LAB_00104b29:plVar5 = (long*)*param_1;
   if (( *(byte*)( (long)plVar5 + 10 ) & 0x20 ) != 0) {
      return param_1;
   }

   if (( *(byte*)( (long)plVar5 + 10 ) & 0x40 ) != 0) {
      return param_1;
   }

   if (*(code**)( *plVar5 + 0x128 ) == glslang::TType::isStruct) {
      if (1 < ( byte )((char)plVar5[1] - 0xfU)) {
         return param_2;
      }

   }
 else {
      cVar2 = ( **(code**)( *plVar5 + 0x128 ) )(plVar5);
      if (cVar2 == '\0') {
         return param_2;
      }

   }

   lVar4 = *(long*)( plVar5[0xd] + 0x10 );
   lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsCoopMat()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsCoopMat ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4 ));
   if (lVar4 == lVar3) {
      return param_2;
   }

   return param_1;
}
/* __gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >
   std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsUnsizedArray()
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsUnsizedArray()
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>
   >(__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >, __gnu_cxx::__normal_iterator<glslang::TTypeLoc*,
   std::vector<glslang::TTypeLoc, glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsUnsizedArray()
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsUnsizedArray()
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>,
   std::random_access_iterator_tag) [clone .isra.0] */long *std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsUnsizedArray()const::_lambda(glslang::TType_const*)_1_>(glslang::TType::containsUnsizedArray()const::_lambda(glslang::TType_const*)_1_)const::_lambda(glslang::TTypeLoc_const&)_1_>(long *param_1, long *param_2) {
   long *plVar1;
   char cVar2;
   long lVar3;
   long lVar4;
   long *plVar5;
   lVar4 = (long)param_2 - (long)param_1;
   if (0 < lVar4 >> 7) {
      plVar5 = param_1 + ( lVar4 >> 7 ) * 0x10;
      do {
         plVar1 = (long*)*param_1;
         lVar4 = *plVar1;
         if (*(code**)( lVar4 + 0xf8 ) == glslang::TType::isUnsizedArray) {
            if (*(code**)( lVar4 + 0xe8 ) != glslang::TType::isArray) {
               cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar1);
               if (cVar2 != '\0') {
                  lVar3 = plVar1[0xc];
                  goto LAB_00104c7b;
               }

               goto LAB_00104ca9;
            }

            lVar3 = plVar1[0xc];
            if (lVar3 != 0) {
               LAB_00104c7b:if (**(int**)( *(long*)( lVar3 + 8 ) + 8 ) == 0) {
                  return param_1;
               }

               goto LAB_00104ca9;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0xf8 ) )(plVar1);
            if (cVar2 != '\0') {
               return param_1;
            }

            LAB_00104ca9:lVar4 = *plVar1;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_00104f25:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsUnsizedArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsUnsizedArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  return param_1;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00104f25;
         }

         plVar1 = (long*)param_1[4];
         lVar4 = *plVar1;
         if (*(code**)( lVar4 + 0xf8 ) == glslang::TType::isUnsizedArray) {
            if (*(code**)( lVar4 + 0xe8 ) != glslang::TType::isArray) {
               cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar1);
               if (cVar2 != '\0') {
                  lVar3 = plVar1[0xc];
                  goto LAB_00104cf8;
               }

               goto LAB_00104d21;
            }

            lVar3 = plVar1[0xc];
            if (lVar3 != 0) {
               LAB_00104cf8:if (**(int**)( *(long*)( lVar3 + 8 ) + 8 ) == 0) goto LAB_00104d08;
               goto LAB_00104d21;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0xf8 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00104d08;
            LAB_00104d21:lVar4 = *plVar1;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_00104f5d:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsUnsizedArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsUnsizedArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  LAB_00104d08:return param_1 + 4;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00104f5d;
         }

         plVar1 = (long*)param_1[8];
         lVar4 = *plVar1;
         if (*(code**)( lVar4 + 0xf8 ) == glslang::TType::isUnsizedArray) {
            if (*(code**)( lVar4 + 0xe8 ) != glslang::TType::isArray) {
               cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar1);
               if (cVar2 != '\0') {
                  lVar3 = plVar1[0xc];
                  goto LAB_00104d70;
               }

               goto LAB_00104d99;
            }

            lVar3 = plVar1[0xc];
            if (lVar3 != 0) {
               LAB_00104d70:if (**(int**)( *(long*)( lVar3 + 8 ) + 8 ) == 0) goto LAB_00104d7e;
               goto LAB_00104d99;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0xf8 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00104d7e;
            LAB_00104d99:lVar4 = *plVar1;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_00104f8d:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsUnsizedArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsUnsizedArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  LAB_00104d7e:return param_1 + 8;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00104f8d;
         }

         plVar1 = (long*)param_1[0xc];
         lVar4 = *plVar1;
         if (*(code**)( lVar4 + 0xf8 ) == glslang::TType::isUnsizedArray) {
            if (*(code**)( lVar4 + 0xe8 ) != glslang::TType::isArray) {
               cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar1);
               if (cVar2 != '\0') {
                  lVar3 = plVar1[0xc];
                  goto LAB_00104de8;
               }

               goto LAB_00104e09;
            }

            lVar3 = plVar1[0xc];
            if (lVar3 != 0) {
               LAB_00104de8:if (**(int**)( *(long*)( lVar3 + 8 ) + 8 ) == 0) goto LAB_00104df6;
               goto LAB_00104e09;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0xf8 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00104df6;
            LAB_00104e09:lVar4 = *plVar1;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_00104fbd:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsUnsizedArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsUnsizedArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  LAB_00104df6:return param_1 + 0xc;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00104fbd;
         }

         param_1 = param_1 + 0x10;
      }
 while ( param_1 != plVar5 );
      lVar4 = (long)param_2 - (long)param_1;
   }

   lVar4 = lVar4 >> 5;
   if (lVar4 == 2) {
      LAB_001050d7:plVar5 = (long*)*param_1;
      lVar4 = *plVar5;
      if (*(code**)( lVar4 + 0xf8 ) == glslang::TType::isUnsizedArray) {
         if (*(code**)( lVar4 + 0xe8 ) != glslang::TType::isArray) {
            cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar5);
            if (cVar2 != '\0') {
               lVar3 = plVar5[0xc];
               goto LAB_0010510f;
            }

            goto LAB_00105121;
         }

         lVar3 = plVar5[0xc];
         if (lVar3 != 0) {
            LAB_0010510f:if (**(int**)( *(long*)( lVar3 + 8 ) + 8 ) == 0) {
               return param_1;
            }

            goto LAB_00105121;
         }

      }
 else {
         cVar2 = ( **(code**)( lVar4 + 0xf8 ) )(plVar5);
         if (cVar2 != '\0') {
            return param_1;
         }

         LAB_00105121:lVar4 = *plVar5;
      }

      if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
         if (( byte )((char)plVar5[1] - 0xfU) < 2) {
            LAB_00105169:lVar4 = *(long*)( plVar5[0xd] + 0x10 );
            lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsUnsizedArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsUnsizedArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4 ));
            if (lVar4 != lVar3) {
               return param_1;
            }

         }

      }
 else {
         cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar5);
         if (cVar2 != '\0') goto LAB_00105169;
      }

      param_1 = param_1 + 4;
   }
 else {
      if (lVar4 == 3) {
         plVar5 = (long*)*param_1;
         lVar4 = *plVar5;
         if (*(code**)( lVar4 + 0xf8 ) == glslang::TType::isUnsizedArray) {
            if (*(code**)( lVar4 + 0xe8 ) != glslang::TType::isArray) {
               cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar5);
               if (cVar2 != '\0') {
                  lVar3 = plVar5[0xc];
                  goto LAB_00105095;
               }

               goto LAB_001050a7;
            }

            lVar3 = plVar5[0xc];
            if (lVar3 != 0) {
               LAB_00105095:if (**(int**)( *(long*)( lVar3 + 8 ) + 8 ) == 0) {
                  return param_1;
               }

               goto LAB_001050a7;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0xf8 ) )(plVar5);
            if (cVar2 != '\0') {
               return param_1;
            }

            LAB_001050a7:lVar4 = *plVar5;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar5[1] - 0xfU) < 2) {
               LAB_001051fa:lVar4 = *(long*)( plVar5[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsUnsizedArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsUnsizedArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  return param_1;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar5);
            if (cVar2 != '\0') goto LAB_001051fa;
         }

         param_1 = param_1 + 4;
         goto LAB_001050d7;
      }

      if (lVar4 != 1) {
         return param_2;
      }

   }

   plVar5 = (long*)*param_1;
   lVar4 = *plVar5;
   if (*(code**)( lVar4 + 0xf8 ) == glslang::TType::isUnsizedArray) {
      if (*(code**)( lVar4 + 0xe8 ) == glslang::TType::isArray) {
         lVar3 = plVar5[0xc];
         if (lVar3 == 0) goto LAB_00104ebf;
      }
 else {
         cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar5);
         if (cVar2 == '\0') goto LAB_00104ebb;
         lVar3 = plVar5[0xc];
      }

      if (**(int**)( *(long*)( lVar3 + 8 ) + 8 ) == 0) {
         return param_1;
      }

   }
 else {
      cVar2 = ( **(code**)( lVar4 + 0xf8 ) )(plVar5);
      if (cVar2 != '\0') {
         return param_1;
      }

   }

   LAB_00104ebb:lVar4 = *plVar5;
   LAB_00104ebf:if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
      if (1 < ( byte )((char)plVar5[1] - 0xfU)) {
         return param_2;
      }

   }
 else {
      cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar5);
      if (cVar2 == '\0') {
         return param_2;
      }

   }

   lVar4 = *(long*)( plVar5[0xd] + 0x10 );
   lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsUnsizedArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsUnsizedArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4 ));
   if (lVar4 == lVar3) {
      return param_2;
   }

   return param_1;
}
/* __gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >
   std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsStructure()
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsStructure()
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>
   >(__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >, __gnu_cxx::__normal_iterator<glslang::TTypeLoc*,
   std::vector<glslang::TTypeLoc, glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsStructure()
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsStructure()
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>,
   std::random_access_iterator_tag) [clone .isra.0] */long *std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsStructure()const::_lambda(glslang::TType_const*)_1_>(glslang::TType::containsStructure()const::_lambda(glslang::TType_const*)_1_)const::_lambda(glslang::TTypeLoc_const&)_1_>(long *param_1, long *param_2, long *param_3) {
   long *plVar1;
   char cVar2;
   long lVar3;
   code *pcVar4;
   long lVar5;
   long *plVar6;
   long lVar7;
   lVar7 = (long)param_2 - (long)param_1;
   if (0 < lVar7 >> 7) {
      plVar1 = param_1;
      LAB_00105280:do {
         plVar6 = plVar1;
         plVar1 = (long*)*plVar6;
         lVar5 = *plVar1;
         if (plVar1 == param_3) {
            LAB_001052d0:if (*(code**)( lVar5 + 0x128 ) == glslang::TType::isStruct) {
               if (( byte )((char)plVar1[1] - 0xfU) < 2) {
                  LAB_001052ed:lVar5 = *(long*)( plVar1[0xd] + 0x10 );
                  lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsStructure()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsStructure ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar5,param_3 ));
                  if (lVar5 != lVar3) {
                     return plVar6;
                  }

               }

            }
 else {
               cVar2 = ( **(code**)( lVar5 + 0x128 ) )(plVar1);
               if (cVar2 != '\0') goto LAB_001052ed;
            }

         }
 else {
            if (*(code**)( lVar5 + 0x128 ) != glslang::TType::isStruct) {
               cVar2 = ( **(code**)( lVar5 + 0x128 ) )(plVar1);
               if (cVar2 != '\0') {
                  return plVar6;
               }

               lVar5 = *plVar1;
               goto LAB_001052d0;
            }

            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               return plVar6;
            }

         }

         plVar1 = (long*)plVar6[4];
         lVar5 = *plVar1;
         if (plVar1 == param_3) {
            LAB_00105350:if (*(code**)( lVar5 + 0x128 ) == glslang::TType::isStruct) {
               if (( byte )((char)plVar1[1] - 0xfU) < 2) {
                  LAB_0010536d:lVar5 = *(long*)( plVar1[0xd] + 0x10 );
                  lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsStructure()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsStructure ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar5,param_3 ));
                  if (lVar5 != lVar3) {
                     LAB_00105336:return plVar6 + 4;
                  }

               }

            }
 else {
               cVar2 = ( **(code**)( lVar5 + 0x128 ) )(plVar1);
               if (cVar2 != '\0') goto LAB_0010536d;
            }

         }
 else {
            if (*(code**)( lVar5 + 0x128 ) != glslang::TType::isStruct) {
               cVar2 = ( **(code**)( lVar5 + 0x128 ) )(plVar1);
               if (cVar2 != '\0') goto LAB_00105336;
               lVar5 = *plVar1;
               goto LAB_00105350;
            }

            if (( byte )((char)plVar1[1] - 0xfU) < 2) goto LAB_00105336;
         }

         plVar1 = (long*)plVar6[8];
         lVar5 = *plVar1;
         if (plVar1 == param_3) {
            LAB_001053d0:if (*(code**)( lVar5 + 0x128 ) == glslang::TType::isStruct) {
               if (( byte )((char)plVar1[1] - 0xfU) < 2) {
                  LAB_001053ed:lVar5 = *(long*)( plVar1[0xd] + 0x10 );
                  lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsStructure()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsStructure ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar5,param_3 ));
                  if (lVar5 != lVar3) {
                     LAB_001053b6:return plVar6 + 8;
                  }

               }

            }
 else {
               cVar2 = ( **(code**)( lVar5 + 0x128 ) )(plVar1);
               if (cVar2 != '\0') goto LAB_001053ed;
            }

         }
 else {
            if (*(code**)( lVar5 + 0x128 ) != glslang::TType::isStruct) {
               cVar2 = ( **(code**)( lVar5 + 0x128 ) )(plVar1);
               if (cVar2 != '\0') goto LAB_001053b6;
               lVar5 = *plVar1;
               goto LAB_001053d0;
            }

            if (( byte )((char)plVar1[1] - 0xfU) < 2) goto LAB_001053b6;
         }

         plVar1 = (long*)plVar6[0xc];
         lVar5 = *plVar1;
         if (plVar1 == param_3) {
            LAB_00105450:if (*(code**)( lVar5 + 0x128 ) == glslang::TType::isStruct) {
               if (1 < ( byte )((char)plVar1[1] - 0xfU)) goto LAB_0010548a;
            }
 else {
               cVar2 = ( **(code**)( lVar5 + 0x128 ) )(plVar1);
               if (cVar2 == '\0') {
                  plVar1 = plVar6 + 0x10;
                  if (plVar6 + 0x10 == param_1 + ( lVar7 >> 7 ) * 0x10) break;
                  goto LAB_00105280;
               }

            }

            lVar5 = *(long*)( plVar1[0xd] + 0x10 );
            lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsStructure()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsStructure ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar5,param_3 ));
            if (lVar5 != lVar3) {
               LAB_00105436:return plVar6 + 0xc;
            }

         }
 else {
            if (*(code**)( lVar5 + 0x128 ) != glslang::TType::isStruct) {
               cVar2 = ( **(code**)( lVar5 + 0x128 ) )(plVar1);
               if (cVar2 != '\0') goto LAB_00105436;
               lVar5 = *plVar1;
               goto LAB_00105450;
            }

            if (( byte )((char)plVar1[1] - 0xfU) < 2) goto LAB_00105436;
         }

         LAB_0010548a:plVar1 = plVar6 + 0x10;
      }
 while ( plVar6 + 0x10 != param_1 + ( lVar7 >> 7 ) * 0x10 );
      param_1 = plVar6 + 0x10;
      lVar7 = (long)param_2 - (long)param_1;
   }

   lVar7 = lVar7 >> 5;
   if (lVar7 != 2) {
      if (lVar7 != 3) {
         if (lVar7 != 1) {
            return param_2;
         }

         goto LAB_001054c2;
      }

      plVar1 = (long*)*param_1;
      pcVar4 = *(code**)( *plVar1 + 0x128 );
      if (param_3 == plVar1) {
         LAB_00105602:if (pcVar4 == glslang::TType::isStruct) {
            cVar2 = (char)plVar1[1];
            goto LAB_001055d9;
         }

         cVar2 = ( *pcVar4 )(plVar1);
         if (cVar2 != '\0') goto LAB_001056db;
      }
 else {
         if (pcVar4 != glslang::TType::isStruct) {
            cVar2 = ( *pcVar4 )(plVar1);
            if (cVar2 != '\0') {
               return param_1;
            }

            pcVar4 = *(code**)( *plVar1 + 0x128 );
            goto LAB_00105602;
         }

         cVar2 = (char)plVar1[1];
         if (( byte )(cVar2 - 0xfU) < 2) {
            return param_1;
         }

         LAB_001055d9:if (( byte )(cVar2 - 0xfU) < 2) {
            LAB_001056db:lVar7 = *(long*)( plVar1[0xd] + 0x10 );
            lVar5 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsStructure()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsStructure ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar7,param_3 ));
            if (lVar7 != lVar5) {
               return param_1;
            }

         }

      }

      param_1 = param_1 + 4;
   }

   plVar1 = (long*)*param_1;
   lVar7 = *plVar1;
   if (plVar1 == param_3) {
      LAB_00105624:if (*(code**)( lVar7 + 0x128 ) == glslang::TType::isStruct) {
         if (( byte )((char)plVar1[1] - 0xfU) < 2) {
            LAB_00105645:lVar7 = *(long*)( plVar1[0xd] + 0x10 );
            lVar5 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsStructure()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsStructure ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar7,param_3 ));
            if (lVar7 != lVar5) {
               return param_1;
            }

         }

      }
 else {
         cVar2 = ( **(code**)( lVar7 + 0x128 ) )(plVar1);
         if (cVar2 != '\0') goto LAB_00105645;
      }

   }
 else {
      if (*(code**)( lVar7 + 0x128 ) != glslang::TType::isStruct) {
         cVar2 = ( **(code**)( lVar7 + 0x128 ) )(plVar1);
         if (cVar2 != '\0') {
            return param_1;
         }

         lVar7 = *plVar1;
         goto LAB_00105624;
      }

      if (( byte )((char)plVar1[1] - 0xfU) < 2) {
         return param_1;
      }

   }

   param_1 = param_1 + 4;
   LAB_001054c2:plVar1 = (long*)*param_1;
   lVar7 = *plVar1;
   if (plVar1 != param_3) {
      if (*(code**)( lVar7 + 0x128 ) == glslang::TType::isStruct) {
         if (1 < ( byte )((char)plVar1[1] - 0xfU)) {
            return param_2;
         }

         return param_1;
      }

      cVar2 = ( **(code**)( lVar7 + 0x128 ) )(plVar1);
      if (cVar2 != '\0') {
         return param_1;
      }

      lVar7 = *plVar1;
   }

   if (*(code**)( lVar7 + 0x128 ) == glslang::TType::isStruct) {
      if (1 < ( byte )((char)plVar1[1] - 0xfU)) {
         return param_2;
      }

   }
 else {
      cVar2 = ( **(code**)( lVar7 + 0x128 ) )(plVar1);
      if (cVar2 == '\0') {
         return param_2;
      }

   }

   lVar7 = *(long*)( plVar1[0xd] + 0x10 );
   lVar5 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsStructure()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsStructure ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar7,param_3 ));
   if (lVar7 == lVar5) {
      return param_2;
   }

   return param_1;
}
/* __gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >
   std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsArray()
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsArray()
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>
   >(__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >, __gnu_cxx::__normal_iterator<glslang::TTypeLoc*,
   std::vector<glslang::TTypeLoc, glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsArray()
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsArray()
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>,
   std::random_access_iterator_tag) [clone .isra.0] */long *std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsArray()const::_lambda(glslang::TType_const*)_1_>(glslang::TType::containsArray()const::_lambda(glslang::TType_const*)_1_)const::_lambda(glslang::TTypeLoc_const&)_1_>(long *param_1, long *param_2) {
   long *plVar1;
   char cVar2;
   long lVar3;
   long lVar4;
   long *plVar5;
   lVar4 = (long)param_2 - (long)param_1;
   if (0 < lVar4 >> 7) {
      plVar5 = param_1 + ( lVar4 >> 7 ) * 0x10;
      do {
         plVar1 = (long*)*param_1;
         lVar4 = *plVar1;
         if (*(code**)( lVar4 + 0xe8 ) == glslang::TType::isArray) {
            if (plVar1[0xc] != 0) {
               return param_1;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar1);
            if (cVar2 != '\0') {
               return param_1;
            }

            lVar4 = *plVar1;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_0010595d:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  return param_1;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_0010595d;
         }

         plVar1 = (long*)param_1[4];
         lVar4 = *plVar1;
         if (*(code**)( lVar4 + 0xe8 ) == glslang::TType::isArray) {
            if (plVar1[0xc] != 0) goto LAB_001058d3;
         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_001058d3;
            lVar4 = *plVar1;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_001058b5:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  LAB_001058d3:return param_1 + 4;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_001058b5;
         }

         plVar1 = (long*)param_1[8];
         lVar4 = *plVar1;
         if (*(code**)( lVar4 + 0xe8 ) == glslang::TType::isArray) {
            if (plVar1[0xc] != 0) goto LAB_0010590b;
         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_0010590b;
            lVar4 = *plVar1;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_001058ed:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  LAB_0010590b:return param_1 + 8;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_001058ed;
         }

         plVar1 = (long*)param_1[0xc];
         lVar4 = *plVar1;
         if (*(code**)( lVar4 + 0xe8 ) == glslang::TType::isArray) {
            if (plVar1[0xc] != 0) goto LAB_00105943;
         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00105943;
            lVar4 = *plVar1;
         }

         if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar1[1] - 0xfU) < 2) {
               LAB_00105925:lVar4 = *(long*)( plVar1[0xd] + 0x10 );
               lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar1[0xd] + 8 ),lVar4 ));
               if (lVar4 != lVar3) {
                  LAB_00105943:return param_1 + 0xc;
               }

            }

         }
 else {
            cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar1);
            if (cVar2 != '\0') goto LAB_00105925;
         }

         param_1 = param_1 + 0x10;
      }
 while ( param_1 != plVar5 );
      lVar4 = (long)param_2 - (long)param_1;
   }

   lVar4 = lVar4 >> 5;
   if (lVar4 != 2) {
      if (lVar4 != 3) {
         if (lVar4 != 1) {
            return param_2;
         }

         goto LAB_00105a2e;
      }

      plVar5 = (long*)*param_1;
      lVar4 = *plVar5;
      if (*(code**)( lVar4 + 0xe8 ) == glslang::TType::isArray) {
         if (plVar5[0xc] != 0) {
            return param_1;
         }

      }
 else {
         cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar5);
         if (cVar2 != '\0') {
            return param_1;
         }

         lVar4 = *plVar5;
      }

      if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
         if (( byte )((char)plVar5[1] - 0xfU) < 2) {
            LAB_00105bcc:lVar4 = *(long*)( plVar5[0xd] + 0x10 );
            lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4 ));
            if (lVar4 != lVar3) {
               return param_1;
            }

         }

      }
 else {
         cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar5);
         if (cVar2 != '\0') goto LAB_00105bcc;
      }

      param_1 = param_1 + 4;
   }

   plVar5 = (long*)*param_1;
   lVar4 = *plVar5;
   if (*(code**)( lVar4 + 0xe8 ) == glslang::TType::isArray) {
      if (plVar5[0xc] != 0) {
         return param_1;
      }

   }
 else {
      cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar5);
      if (cVar2 != '\0') {
         return param_1;
      }

      lVar4 = *plVar5;
   }

   if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
      if (( byte )((char)plVar5[1] - 0xfU) < 2) {
         LAB_00105b73:lVar4 = *(long*)( plVar5[0xd] + 0x10 );
         lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4 ));
         if (lVar4 != lVar3) {
            return param_1;
         }

      }

   }
 else {
      cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar5);
      if (cVar2 != '\0') goto LAB_00105b73;
   }

   param_1 = param_1 + 4;
   LAB_00105a2e:plVar5 = (long*)*param_1;
   lVar4 = *plVar5;
   if (*(code**)( lVar4 + 0xe8 ) == glslang::TType::isArray) {
      if (plVar5[0xc] != 0) {
         return param_1;
      }

   }
 else {
      cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(plVar5);
      if (cVar2 != '\0') {
         return param_1;
      }

      lVar4 = *plVar5;
   }

   if (*(code**)( lVar4 + 0x128 ) == glslang::TType::isStruct) {
      if (1 < ( byte )((char)plVar5[1] - 0xfU)) {
         return param_2;
      }

   }
 else {
      cVar2 = ( **(code**)( lVar4 + 0x128 ) )(plVar5);
      if (cVar2 == '\0') {
         return param_2;
      }

   }

   lVar4 = *(long*)( plVar5[0xd] + 0x10 );
   lVar3 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar4 ));
   if (lVar4 == lVar3) {
      return param_2;
   }

   return param_1;
}
/* bool glslang::TType::contains<glslang::TType::containsArray() const::{lambda(glslang::TType
   const*)#1}>(glslang::TType::containsArray() const::{lambda(glslang::TType const*)#1}) const
   [clone .isra.0] */bool glslang::TType::contains<glslang::TType::containsArray()const::_lambda(glslang::TType_const *)_1_ > ( long *param_1)

{
  char cVar1;
  long lVar2;
  long lVar3;
  
  lVar2 = *param_1;
  if (*(code **)(lVar2 + 0xe8) == isArray) {
    if (param_1[0xc] != 0) {
      return true;
    }
  }
  else {
    cVar1 = (**(code **)(lVar2 + 0xe8))();
    if (cVar1 != '\0') {
      return true;
    }
    lVar2 = *param_1;
  }
  if (*(code **)(lVar2 + 0x128) == isStruct) {
    if ((byte)((char)param_1[1] - 0xfU) < 2) {
LAB_00105c41:
      lVar2 = *(long *)(param_1[0xd] + 0x10);
      lVar3 = std::
              __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsArray()const::_lambda(glslang::TType_const*)_1_>(glslang::TType::containsArray()const::_lambda(glslang::TType_const*)_1_)const::_lambda(glslang::TTypeLoc_const&)_1_>>
                        (*(undefined8 *)(param_1[0xd] + 8),lVar2);
      return lVar2 != lVar3;
    }
  }
  else {
    cVar1 = (**(code **)(lVar2 + 0x128))(param_1);
    if (cVar1 != '\0') goto LAB_00105c41;
  }
  return false;
} )(lVar6 != 3)(lVar6 != 1) = (long*)*param_1 ;pcVar1 = *(code**)( *plVar7 + 0x148 );if (pcVar1 == glslang::TType::isBuiltIn) {
   pcVar1 = *(code**)( *plVar7 + 0x58 );
   if (pcVar1 == glslang::TType::getQualifier) {
      plVar5 = plVar7 + 2;
   }
 else {
      plVar5 = (long*)( *pcVar1 )(plVar7);
   }

   if (0x7f < *(ushort*)( plVar5 + 1 )) {
      return param_1;
   }

}
 else {
   cVar2 = ( *pcVar1 )(plVar7);
   if (cVar2 != '\0') {
      return param_1;
   }

}
if (*(code**)( *plVar7 + 0x128 ) == glslang::TType::isStruct) {
   if (( byte )((char)plVar7[1] - 0xfU) < 2) {
      LAB_00106206:lVar6 = *(long*)( plVar7[0xd] + 0x10 );
      lVar4 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBuiltIn()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBuiltIn ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar7[0xd] + 8 ),lVar6 ));
      if (lVar6 != lVar4) {
         return param_1;
      }

   }

}
 else {
   cVar2 = ( **(code**)( *plVar7 + 0x128 ) )(plVar7);
   if (cVar2 != '\0') goto LAB_00106206;
}
param_1 = param_1 + 4;}plVar7 = (long*)*param_1;pcVar1 = *(code**)( *plVar7 + 0x148 );if (pcVar1 == glslang::TType::isBuiltIn) {
   pcVar1 = *(code**)( *plVar7 + 0x58 );
   if (pcVar1 == glslang::TType::getQualifier) {
      plVar5 = plVar7 + 2;
   }
 else {
      plVar5 = (long*)( *pcVar1 )(plVar7);
   }

   if (0x7f < *(ushort*)( plVar5 + 1 )) {
      return param_1;
   }

}
 else {
   cVar2 = ( *pcVar1 )(plVar7);
   if (cVar2 != '\0') {
      return param_1;
   }

}
if (*(code**)( *plVar7 + 0x128 ) == glslang::TType::isStruct) {
   if (( byte )((char)plVar7[1] - 0xfU) < 2) {
      LAB_0010618f:lVar6 = *(long*)( plVar7[0xd] + 0x10 );
      lVar4 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBuiltIn()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBuiltIn ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar7[0xd] + 8 ),lVar6 ));
      if (lVar6 != lVar4) {
         return param_1;
      }

   }

}
 else {
   cVar2 = ( **(code**)( *plVar7 + 0x128 ) )(plVar7);
   if (cVar2 != '\0') goto LAB_0010618f;
}
param_1 = param_1 + 4;LAB_00106008:plVar7 = (long*)*param_1;pcVar1 = *(code**)( *plVar7 + 0x148 );if (pcVar1 == glslang::TType::isBuiltIn) {
   pcVar1 = *(code**)( *plVar7 + 0x58 );
   if (pcVar1 == glslang::TType::getQualifier) {
      plVar5 = plVar7 + 2;
   }
 else {
      plVar5 = (long*)( *pcVar1 )(plVar7);
   }

   if (0x7f < *(ushort*)( plVar5 + 1 )) {
      return param_1;
   }

}
 else {
   cVar2 = ( *pcVar1 )(plVar7);
   if (cVar2 != '\0') {
      return param_1;
   }

}
if (*(code**)( *plVar7 + 0x128 ) == glslang::TType::isStruct) {
   if (1 < ( byte )((char)plVar7[1] - 0xfU)) {
      return param_2;
   }

}
 else {
   cVar2 = ( **(code**)( *plVar7 + 0x128 ) )(plVar7);
   if (cVar2 == '\0') {
      return param_2;
   }

}
lVar6 = *(long*)( plVar7[0xd] + 0x10 );lVar4 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBuiltIn()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBuiltIn ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar7[0xd] + 8 ),lVar6 ));if (lVar6 == lVar4) {
   return param_2;
}
return param_1;}/* std::_Function_handler<bool (glslang::TType const&, glslang::TType const&, glslang::TType
   const&), glslang::TParseContext::findFunctionExplicitTypes(glslang::TSourceLoc const&,
   glslang::TFunction const&, bool&)::{lambda(glslang::TType const&, glslang::TType const&,
   glslang::TType const&)#1}>::_M_invoke(std::_Any_data const&, glslang::TType const&,
   glslang::TType const&, glslang::TType const&) */uint std::_Function_handler<bool(glslang::TType_const &, glslang::TType_const &, glslang::TType_const &),glslang::TParseContext::findFunctionExplicitTypes(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::{lambda(glslang::TType_const&,glslang::TType_const&,glslang::TType_const&)#1}>::_M_invoke(_Any_data *param_1, TType *param_2, TType *param_3, TType *param_4) {
   char cVar1;
   uint uVar2;
   uint uVar3;
   uint uVar4;
   uint uVar5;
   uint uVar6;
   uVar2 = glslang::TType::operator ==(param_2, param_4);
   if ((char)uVar2 == '\0') {
      cVar1 = glslang::TType::operator ==(param_2, param_3);
      if (cVar1 == '\0') {
         if (*(code**)( *(long*)param_2 + 0x38 ) == glslang::TType::getBasicType) {
            uVar6 = (uint)(byte)param_2[8];
         }
 else {
            uVar6 = ( **(code**)( *(long*)param_2 + 0x38 ) )(param_2);
         }

         if (*(code**)( *(long*)param_3 + 0x38 ) == glslang::TType::getBasicType) {
            uVar5 = (uint)(byte)param_3[8];
         }
 else {
            uVar5 = ( **(code**)( *(long*)param_3 + 0x38 ) )(param_3);
         }

         if (*(code**)( *(long*)param_4 + 0x38 ) == glslang::TType::getBasicType) {
            uVar4 = (uint)(byte)param_4[8];
         }
 else {
            uVar4 = ( **(code**)( *(long*)param_4 + 0x38 ) )(param_4);
         }

         uVar3 = glslang::TIntermediate::isIntegralPromotion(*(undefined8*)( *(long*)param_1 + 0x38 ), uVar6, uVar5);
         if ((char)uVar3 == '\0') {
            uVar3 = glslang::TIntermediate::isFPPromotion(*(undefined8*)( *(long*)param_1 + 0x38 ), uVar6, uVar5);
         }

         cVar1 = glslang::TIntermediate::isIntegralPromotion(*(undefined8*)( *(long*)param_1 + 0x38 ), uVar6, uVar4);
         if (( cVar1 == '\0' ) && ( cVar1 = glslang::TIntermediate::isFPPromotion(*(undefined8*)( *(long*)param_1 + 0x38 ), uVar6, uVar4) ),cVar1 == '\0') {
            if ((char)uVar3 == '\0') {
               cVar1 = glslang::TIntermediate::isIntegralConversion(*(undefined8*)( *(long*)param_1 + 0x38 ), uVar6, uVar5);
               uVar2 = uVar3;
               if (( cVar1 == '\0' ) && ( cVar1 = glslang::TIntermediate::isFPConversion(*(undefined8*)( *(long*)param_1 + 0x38 ), uVar6, uVar5) ),cVar1 == '\0') {
                  uVar2 = glslang::TIntermediate::isFPIntegralConversion(*(undefined8*)( *(long*)param_1 + 0x38 ), uVar6, uVar5);
                  uVar2 = uVar2 ^ 1;
               }

               cVar1 = glslang::TIntermediate::isIntegralConversion(*(undefined8*)( *(long*)param_1 + 0x38 ), uVar6, uVar4);
               if (( cVar1 == '\0' ) && ( cVar1 = glslang::TIntermediate::isFPConversion(*(undefined8*)( *(long*)param_1 + 0x38 ), uVar6, uVar4) ),cVar1 == '\0') {
                  uVar6 = glslang::TIntermediate::isFPIntegralConversion(*(undefined8*)( *(long*)param_1 + 0x38 ), uVar6, uVar4);
                  uVar2 = uVar6 & uVar2;
               }

            }

         }
 else {
            uVar2 = uVar3 ^ 1;
         }

      }

   }
 else {
      uVar2 = glslang::TType::operator ==(param_2, param_3);
      uVar2 = uVar2 ^ 1;
   }

   return uVar2;
}
/* glslang::TParseContext::findFunctionExplicitTypes(glslang::TSourceLoc const&, glslang::TFunction
   const&, bool&)::{lambda(glslang::TType const&, glslang::TType const&, glslang::TOperator,
   int)#1}::TEMPNAMEPLACEHOLDERVALUE(glslang::TType const&, glslang::TType const&,
   glslang::TOperator, int) const [clone .isra.0] */ulong glslang::TParseContext::findFunctionExplicitTypes(glslang::TSourceLoc_const &, glslang::TFunction_const &, bool &) {
   lambda(glslang::TType_const&,glslang::TType_const&,glslang::TOperator,int)#1
}
::operator ()(long *param_1, TType *param_2, TType *param_3) {
   undefined8 uVar1;
   char cVar2;
   uint uVar3;
   uint uVar4;
   long lVar5;
   code *pcVar6;
   ulong uVar7;
   long in_FS_OFFSET;
   TType local_178[160];
   TType local_d8[152];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   cVar2 = TType::operator ==(param_2, param_3);
   if (cVar2 == '\0') {
      uVar3 = TType::coopMatParameterOK(param_2, param_3);
      uVar7 = (ulong)uVar3;
      if ((char)uVar3 != '\0') goto LAB_001064ac;
      pcVar6 = *(code**)( *(long*)param_2 + 0xe8 );
      if ((char)param_1[1] == '\0') {
         LAB_001065ba:if (pcVar6 == TType::isArray) goto LAB_001065c3;
         cVar2 = ( *pcVar6 )(param_2);
         if (cVar2 == '\0') goto LAB_001065ce;
      }
 else {
         if (pcVar6 != TType::isArray) {
            cVar2 = ( *pcVar6 )(param_2);
            if (cVar2 != '\0') goto LAB_00106522;
            goto LAB_001065b0;
         }

         if (*(long*)( param_2 + 0x60 ) != 0) {
            LAB_00106522:pcVar6 = *(code**)( *(long*)param_3 + 0xf8 );
            if (pcVar6 == TType::isUnsizedArray) {
               pcVar6 = *(code**)( *(long*)param_3 + 0xe8 );
               if (pcVar6 == TType::isArray) {
                  lVar5 = *(long*)( param_3 + 0x60 );
                  if (lVar5 != 0) {
                     LAB_00106556:if (**(int**)( *(long*)( lVar5 + 8 ) + 8 ) == 0) goto LAB_00106564;
                  }

               }
 else {
                  cVar2 = ( *pcVar6 )(param_3);
                  if (cVar2 != '\0') {
                     lVar5 = *(long*)( param_3 + 0x60 );
                     goto LAB_00106556;
                  }

               }

            }
 else {
               cVar2 = ( *pcVar6 )(param_3);
               if (cVar2 == '\0') goto LAB_001065b0;
               LAB_00106564:TType::TType(local_178, param_2, 0, false);
               TType::TType(local_d8, param_3, 0, false);
               cVar2 = TType::operator ==(local_178, local_d8);
               if (cVar2 != '\0') goto LAB_001064ac;
            }

            LAB_001065b0:pcVar6 = *(code**)( *(long*)param_2 + 0xe8 );
            goto LAB_001065ba;
         }

         LAB_001065c3:if (*(long*)( param_2 + 0x60 ) == 0) {
            LAB_001065ce:if (*(code**)( *(long*)param_3 + 0xe8 ) == TType::isArray) {
               if (*(long*)( param_3 + 0x60 ) == 0) {
                  LAB_001065ed:cVar2 = TType::sameElementShape(param_2, param_3, (int*)0x0, (int*)0x0);
                  if (cVar2 != '\0') {
                     if (( ( ( (byte)param_2[10] & 0x20 ) == 0 ) && ( ( (byte)param_2[10] & 0x40 ) == 0 ) ) || ( ( ( (byte)param_3[10] & 0x20 ) == 0 && ( ( (byte)param_3[10] & 0x40 ) == 0 ) ) )) {
                        uVar1 = *(undefined8*)( *param_1 + 0x38 );
                        if (*(code**)( *(long*)param_3 + 0x38 ) == TType::getBasicType) {
                           uVar3 = (uint)(byte)param_3[8];
                        }
 else {
                           uVar3 = ( **(code**)( *(long*)param_3 + 0x38 ) )(param_3);
                        }

                        if (*(code**)( *(long*)param_2 + 0x38 ) == TType::getBasicType) {
                           uVar4 = (uint)(byte)param_2[8];
                        }
 else {
                           uVar4 = ( **(code**)( *(long*)param_2 + 0x38 ) )(param_2);
                        }

                        if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                           uVar7 = glslang::TIntermediate::canImplicitlyPromote(uVar1, uVar4, uVar3, 0);
                           return uVar7;
                        }

                     }
 else if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                        uVar7 = TType::sameCoopMatBaseType(param_2, param_3);
                        return uVar7;
                     }

                     goto LAB_0010676e;
                  }

               }

            }
 else {
               cVar2 = ( **(code**)( *(long*)param_3 + 0xe8 ) )(param_3);
               if (cVar2 == '\0') goto LAB_001065ed;
            }

         }

      }

   }
 else {
      LAB_001064ac:uVar7 = 1;
   }

   if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return uVar7;
   }

   LAB_0010676e:/* WARNING: Subroutine does not return */__stack_chk_fail();
}
/* std::_Function_handler<bool (glslang::TType const&, glslang::TType const&, glslang::TOperator,
   int), glslang::TParseContext::findFunctionExplicitTypes(glslang::TSourceLoc const&,
   glslang::TFunction const&, bool&)::{lambda(glslang::TType const&, glslang::TType const&,
   glslang::TOperator, int)#1}>::_M_invoke(std::_Any_data const&, glslang::TType const&,
   glslang::TType const&, glslang::TOperator&&, int&&) */void std::_Function_handler<bool(glslang::TType_const&,glslang::TType_const&,glslang::TOperator,int),glslang::TParseContext::findFunctionExplicitTypes(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::{lambda(glslang::TType_const&,glslang::TType_const&,glslang::TOperator,int)#1}>
     ::_M_invoke(_Any_data *param_1,TType *param_2,TType *param_3,TOperator *param_4,int *param_5)

{
  glslang::TParseContext::
  findFunctionExplicitTypes(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::
  {lambda(glslang::TType_const&,glslang::TType_const&,glslang::TOperator,int)#1}::operator ()()return;}/* std::_Function_handler<bool (glslang::TType const&, glslang::TType const&, glslang::TType
   const&), glslang::TParseContext::findFunction400(glslang::TSourceLoc const&, glslang::TFunction
   const&, bool&)::{lambda(glslang::TType const&, glslang::TType const&, glslang::TType
   const&)#1}>::_M_invoke(std::_Any_data const&, glslang::TType const&, glslang::TType const&,
   glslang::TType const&) */bool std::_Function_handler<bool(glslang::TType_const &, glslang::TType_const &, glslang::TType_const &),glslang::TParseContext::findFunction400(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::{lambda(glslang::TType_const&,glslang::TType_const&,glslang::TType_const&)#1}>::_M_invoke(_Any_data *param_1, TType *param_2, TType *param_3, TType *param_4) {
   char cVar1;
   byte bVar2;
   int iVar3;
   uint uVar4;
   long lVar5;
   cVar1 = glslang::TType::operator ==(param_2, param_4);
   if (cVar1 != '\0') {
      bVar2 = glslang::TType::operator ==(param_2, param_3);
      return (bool)( bVar2 ^ 1 );
   }

   cVar1 = glslang::TType::operator ==(param_2, param_3);
   if (cVar1 != '\0') {
      return false;
   }

   if (*(code**)( *(long*)param_2 + 0x38 ) == glslang::TType::getBasicType) {
      uVar4 = (uint)(byte)param_2[8];
   }
 else {
      uVar4 = ( **(code**)( *(long*)param_2 + 0x38 ) )(param_2);
   }

   lVar5 = *(long*)param_4;
   if (uVar4 == 1) {
      if (*(code**)( lVar5 + 0x38 ) == glslang::TType::getBasicType) {
         uVar4 = (uint)(byte)param_4[8];
         if (param_4[8] != (TType)0x2) goto LAB_00106819;
         LAB_0010685f:if (*(code**)( *(long*)param_3 + 0x38 ) == glslang::TType::getBasicType) {
            uVar4 = (uint)(byte)param_3[8];
         }
 else {
            uVar4 = ( **(code**)( *(long*)param_3 + 0x38 ) )(param_3);
         }

         if (uVar4 != 2) {
            return true;
         }

      }
 else {
         iVar3 = ( **(code**)( lVar5 + 0x38 ) )(param_4);
         if (iVar3 == 2) goto LAB_0010685f;
      }

      lVar5 = *(long*)param_4;
   }

   if (*(code**)( lVar5 + 0x38 ) == glslang::TType::getBasicType) {
      uVar4 = (uint)(byte)param_4[8];
   }
 else {
      uVar4 = ( **(code**)( lVar5 + 0x38 ) )(param_4);
   }

   LAB_00106819:if (uVar4 != 1) {
      return false;
   }

   if (*(code**)( *(long*)param_3 + 0x38 ) == glslang::TType::getBasicType) {
      uVar4 = (uint)(byte)param_3[8];
   }
 else {
      uVar4 = ( **(code**)( *(long*)param_3 + 0x38 ) )(param_3);
   }

   return uVar4 == 2;
}
/* glslang::TParseContext::findFunction400(glslang::TSourceLoc const&, glslang::TFunction const&,
   bool&)::{lambda(glslang::TType const&, glslang::TType const&, glslang::TOperator,
   int)#1}::TEMPNAMEPLACEHOLDERVALUE(glslang::TType const&, glslang::TType const&,
   glslang::TOperator, int) const [clone .isra.0] */ulong glslang::TParseContext::findFunction400(glslang::TSourceLoc_const &, glslang::TFunction_const &, bool &) {
   lambda(glslang::TType_const&,glslang::TType_const&,glslang::TOperator,int)#1
}
::operator ()(long *param_1, TType *param_2, TType *param_3) {
   undefined8 uVar1;
   char cVar2;
   uint uVar3;
   uint uVar4;
   long lVar5;
   code *pcVar6;
   ulong uVar7;
   long in_FS_OFFSET;
   TType local_178[160];
   TType local_d8[152];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   cVar2 = TType::operator ==(param_2, param_3);
   if (cVar2 == '\0') {
      uVar3 = TType::coopMatParameterOK(param_2, param_3);
      uVar7 = (ulong)uVar3;
      if ((char)uVar3 != '\0') goto LAB_001068fc;
      pcVar6 = *(code**)( *(long*)param_2 + 0xe8 );
      if ((char)param_1[1] == '\0') {
         LAB_00106a0a:if (pcVar6 == TType::isArray) goto LAB_00106a13;
         cVar2 = ( *pcVar6 )(param_2);
         if (cVar2 == '\0') goto LAB_00106a1e;
      }
 else {
         if (pcVar6 != TType::isArray) {
            cVar2 = ( *pcVar6 )(param_2);
            if (cVar2 != '\0') goto LAB_00106972;
            goto LAB_00106a00;
         }

         if (*(long*)( param_2 + 0x60 ) != 0) {
            LAB_00106972:pcVar6 = *(code**)( *(long*)param_3 + 0xf8 );
            if (pcVar6 == TType::isUnsizedArray) {
               pcVar6 = *(code**)( *(long*)param_3 + 0xe8 );
               if (pcVar6 == TType::isArray) {
                  lVar5 = *(long*)( param_3 + 0x60 );
                  if (lVar5 != 0) {
                     LAB_001069a6:if (**(int**)( *(long*)( lVar5 + 8 ) + 8 ) == 0) goto LAB_001069b4;
                  }

               }
 else {
                  cVar2 = ( *pcVar6 )(param_3);
                  if (cVar2 != '\0') {
                     lVar5 = *(long*)( param_3 + 0x60 );
                     goto LAB_001069a6;
                  }

               }

            }
 else {
               cVar2 = ( *pcVar6 )(param_3);
               if (cVar2 == '\0') goto LAB_00106a00;
               LAB_001069b4:TType::TType(local_178, param_2, 0, false);
               TType::TType(local_d8, param_3, 0, false);
               cVar2 = TType::operator ==(local_178, local_d8);
               if (cVar2 != '\0') goto LAB_001068fc;
            }

            LAB_00106a00:pcVar6 = *(code**)( *(long*)param_2 + 0xe8 );
            goto LAB_00106a0a;
         }

         LAB_00106a13:if (*(long*)( param_2 + 0x60 ) == 0) {
            LAB_00106a1e:if (*(code**)( *(long*)param_3 + 0xe8 ) == TType::isArray) {
               if (*(long*)( param_3 + 0x60 ) == 0) {
                  LAB_00106a3d:cVar2 = TType::sameElementShape(param_2, param_3, (int*)0x0, (int*)0x0);
                  if (cVar2 != '\0') {
                     if (( ( ( (byte)param_2[10] & 0x20 ) == 0 ) && ( ( (byte)param_2[10] & 0x40 ) == 0 ) ) || ( ( ( (byte)param_3[10] & 0x20 ) == 0 && ( ( (byte)param_3[10] & 0x40 ) == 0 ) ) )) {
                        uVar1 = *(undefined8*)( *param_1 + 0x38 );
                        if (*(code**)( *(long*)param_3 + 0x38 ) == TType::getBasicType) {
                           uVar3 = (uint)(byte)param_3[8];
                        }
 else {
                           uVar3 = ( **(code**)( *(long*)param_3 + 0x38 ) )(param_3);
                        }

                        if (*(code**)( *(long*)param_2 + 0x38 ) == TType::getBasicType) {
                           uVar4 = (uint)(byte)param_2[8];
                        }
 else {
                           uVar4 = ( **(code**)( *(long*)param_2 + 0x38 ) )(param_2);
                        }

                        if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                           uVar7 = glslang::TIntermediate::canImplicitlyPromote(uVar1, uVar4, uVar3, 0);
                           return uVar7;
                        }

                     }
 else if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                        uVar7 = TType::sameCoopMatBaseType(param_2, param_3);
                        return uVar7;
                     }

                     goto LAB_00106bbe;
                  }

               }

            }
 else {
               cVar2 = ( **(code**)( *(long*)param_3 + 0xe8 ) )(param_3);
               if (cVar2 == '\0') goto LAB_00106a3d;
            }

         }

      }

   }
 else {
      LAB_001068fc:uVar7 = 1;
   }

   if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return uVar7;
   }

   LAB_00106bbe:/* WARNING: Subroutine does not return */__stack_chk_fail();
}
/* std::_Function_handler<bool (glslang::TType const&, glslang::TType const&, glslang::TOperator,
   int), glslang::TParseContext::findFunction400(glslang::TSourceLoc const&, glslang::TFunction
   const&, bool&)::{lambda(glslang::TType const&, glslang::TType const&, glslang::TOperator,
   int)#1}>::_M_invoke(std::_Any_data const&, glslang::TType const&, glslang::TType const&,
   glslang::TOperator&&, int&&) */void std::_Function_handler<bool(glslang::TType_const&,glslang::TType_const&,glslang::TOperator,int),glslang::TParseContext::findFunction400(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::{lambda(glslang::TType_const&,glslang::TType_const&,glslang::TOperator,int)#1}>
     ::_M_invoke(_Any_data *param_1,TType *param_2,TType *param_3,TOperator *param_4,int *param_5)

{
  glslang::TParseContext::
  findFunction400(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::
  {lambda(glslang::TType_const&,glslang::TType_const&,glslang::TOperator,int)#1}::operator ()()return;}/* glslang::TParseContext::~TParseContext() */void glslang::TParseContext::~TParseContext(TParseContext *this) {
   void *pvVar1;
   void *pvVar2;
   void *pvVar3;
   void *pvVar4;
   *(undefined***)this = &PTR__TParseContext_00168190;
   if (*(void**)( this + 0x7538 ) != (void*)0x0) {
      operator_delete__(*(void**)( this + 0x7538 ));
   }

   std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>const*,std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator < std::pair < unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>> > std::less<glslang::TVector<glslang::TTypeLoc>const*>,std::allocator<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less < unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>> >> ::_M_erase(*(_Rb_tree_node**)( this + 0x75d8 ));
   pvVar3 = *(void**)( this + 0x75a8 );
   while (pvVar3 != (void*)0x0) {
      std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>const*,std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator < std::pair < unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>> > std::less<glslang::TVector<glslang::TTypeLoc>const*>,std::allocator<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less < unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>> >> ::_M_erase(*(_Rb_tree_node**)( (long)pvVar3 + 0x18 ));
      pvVar1 = *(void**)( (long)pvVar3 + 0x10 );
      pvVar4 = *(void**)( (long)pvVar3 + 0x38 );
      while (pvVar4 != (void*)0x0) {
         std::_Rb_tree<unsigned_long,std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>,std::_Select1st<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>::_M_erase(*(_Rb_tree_node**)( (long)pvVar4 + 0x18 ));
         pvVar2 = *(void**)( (long)pvVar4 + 0x10 );
         operator_delete(pvVar4, 0x30);
         pvVar4 = pvVar2;
      }
;
      operator_delete(pvVar3, 0x58);
      pvVar3 = pvVar1;
   }
;
   pvVar3 = *(void**)( this + 0x7558 );
   while (pvVar3 != (void*)0x0) {
      std::_Rb_tree<long_long,long_long,std::_Identity<long_long>,std::less<long_long>,std::allocator<long_long>>::_M_erase(*(_Rb_tree_node**)( (long)pvVar3 + 0x18 ));
      pvVar1 = *(void**)( (long)pvVar3 + 0x10 );
      operator_delete(pvVar3, 0x28);
      pvVar3 = pvVar1;
   }
;
   TParseContextBase::~TParseContextBase((TParseContextBase*)this);
   return;
}
/* glslang::TParseContext::~TParseContext() */void glslang::TParseContext::~TParseContext(TParseContext *this) {
   ~TParseContext(this)
   ;;
   operator_delete(this, 0x7618);
   return;
}
/* glslang::TParseContext::parserError(char const*) */void glslang::TParseContext::parserError(TParseContext *this, char *param_1) {
   long lVar1;
   int iVar2;
   long lVar3;
   lVar1 = *(long*)( this + 0xd8 );
   if (( *(char*)( lVar1 + 0x59 ) != '\0' ) && ( *(int*)( this + 0xd4 ) != 0 )) {
      lVar3 = lVar1 + 0x40;
      if (*(char*)( lVar1 + 0x58 ) == '\0') {
         lVar3 = *(long*)( lVar1 + 0x30 );
         iVar2 = ( *(int*)( lVar1 + 8 ) - *(int*)( lVar1 + 0x3c ) ) + -1;
         if (*(int*)( lVar1 + 0x20 ) < iVar2) {
            iVar2 = *(int*)( lVar1 + 0x20 );
         }

         if (0 < iVar2) {
            lVar3 = lVar3 + (long)iVar2 * 0x18;
         }

      }

      /* WARNING: Could not recover jumptable at 0x00106d6f. Too many branches */
      /* WARNING: Treating indirect jump as call */
      ( **(code**)( *(long*)this + 0x158 ) )(this, lVar3, "compilation terminated", &_LC1);
      return;
   }

   lVar3 = lVar1 + 0x40;
   if (*(char*)( lVar1 + 0x58 ) == '\0') {
      lVar3 = *(long*)( lVar1 + 0x30 );
      iVar2 = ( *(int*)( lVar1 + 8 ) - *(int*)( lVar1 + 0x3c ) ) + -1;
      if (*(int*)( lVar1 + 0x20 ) < iVar2) {
         iVar2 = *(int*)( lVar1 + 0x20 );
      }

      if (0 < iVar2) {
         lVar3 = lVar3 + (long)iVar2 * 0x18;
      }

   }

   /* WARNING: Could not recover jumptable at 0x00106d2c. Too many branches */
   /* WARNING: Treating indirect jump as call */
   ( **(code**)( *(long*)this + 0x158 ) )(this, lVar3, &_LC1, &_LC1, param_1);
   return;
}
/* glslang::TParseContext::handleIndexLimits(glslang::TSourceLoc const&, glslang::TIntermTyped*,
   glslang::TIntermTyped*) */void glslang::TParseContext::handleIndexLimits(TParseContext *this, TSourceLoc *param_1, TIntermTyped *param_2, TIntermTyped *param_3) {
   undefined8 *puVar1;
   undefined8 *puVar2;
   char cVar3;
   byte bVar4;
   uint uVar5;
   long lVar6;
   ulong uVar7;
   long lVar8;
   long lVar9;
   ulong uVar10;
   TIntermTyped *pTVar11;
   undefined8 *puVar12;
   lVar6 = *(long*)( this + 0x768 );
   if (*(char*)( lVar6 + 6 ) == '\0') {
      if (*(code**)( *(long*)param_2 + 0x100 ) == TIntermTyped::getBasicType) {
         uVar5 = (uint)(byte)param_2[0x28];
      }
 else {
         uVar5 = ( **(code**)( *(long*)param_2 + 0x100 ) )(param_2);
      }

      if (uVar5 != 0xe) {
         lVar6 = *(long*)( this + 0x768 );
         goto LAB_00106de7;
      }

      goto LAB_00106f24;
   }

   LAB_00106de7:if (*(char*)( lVar6 + 3 ) == '\0') {
      if (*(code**)( *(long*)param_2 + 0x108 ) == TIntermTyped::getQualifier) {
         pTVar11 = param_2 + 0x30;
      }
 else {
         pTVar11 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0x108 ) )(param_2);
      }

      if (( ( (byte)pTVar11[8] & 0x7f ) - 5 < 2 ) && ( *(int*)( this + 0x1c ) != 0 )) goto LAB_00106f24;
      lVar6 = *(long*)( this + 0x768 );
   }

   if (*(char*)( lVar6 + 4 ) == '\0') {
      if (*(code**)( *(long*)param_2 + 0x108 ) == TIntermTyped::getQualifier) {
         pTVar11 = param_2 + 0x30;
      }
 else {
         pTVar11 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0x108 ) )(param_2);
      }

      if (( ( 0x1b < ( byte )((byte)pTVar11[8] & 0x7f) ) || ( ( 0xe300008UL >> ( ( ulong )((byte)pTVar11[8] & 0x7f) & 0x3f ) & 1 ) == 0 ) ) || ( *(int*)( this + 0x1c ) != 0 )) {
         LAB_00106f08:lVar6 = *(long*)( this + 0x768 );
         goto LAB_00106f10;
      }

      if (*(code**)( *(long*)param_2 + 0xf0 ) == TIntermTyped::getType) {
         pTVar11 = param_2 + 0x20;
      }
 else {
         pTVar11 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
      }

      if (*(code**)( *(long*)pTVar11 + 0xe0 ) == TType::isMatrix) {
         if ((byte)pTVar11[9] < 0x10) {
            LAB_00106eb7:pTVar11 = param_2 + 0x20;
            if (*(code**)( *(long*)param_2 + 0xf0 ) != TIntermTyped::getType) {
               pTVar11 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
            }

            if (*(code**)( *(long*)pTVar11 + 0xd8 ) == TType::isVector) {
               if (1 < ( (byte)pTVar11[9] & 0xf )) goto LAB_00106f24;
               bVar4 = (byte)pTVar11[10] >> 4 & 1;
            }
 else {
               bVar4 = ( **(code**)( *(long*)pTVar11 + 0xd8 ) )();
            }

            if (bVar4 == 0) goto LAB_00106f08;
         }

      }
 else {
         cVar3 = ( **(code**)( *(long*)pTVar11 + 0xe0 ) )();
         if (cVar3 == '\0') goto LAB_00106eb7;
      }

   }
 else {
      LAB_00106f10:if (*(char*)( lVar6 + 8 ) == '\0') {
         lVar6 = ( **(code**)( *(long*)param_2 + 0x28 ) )(param_2);
         if (lVar6 != 0) goto LAB_00106f24;
         lVar6 = *(long*)( this + 0x768 );
      }

      if (*(char*)( lVar6 + 7 ) == '\0') {
         if (*(code**)( *(long*)param_2 + 0xf0 ) == TIntermTyped::getType) {
            pTVar11 = param_2 + 0x20;
         }
 else {
            pTVar11 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
         }

         if (*(code**)( *(long*)pTVar11 + 0x58 ) == TType::getQualifier) {
            pTVar11 = pTVar11 + 0x10;
         }
 else {
            pTVar11 = (TIntermTyped*)( **(code**)( *(long*)pTVar11 + 0x58 ) )();
         }

         if (1 < ( (byte)pTVar11[8] & 0x7f ) - 5) {
            if (*(code**)( *(long*)param_2 + 0xf0 ) == TIntermTyped::getType) {
               pTVar11 = param_2 + 0x20;
            }
 else {
               pTVar11 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
            }

            if (*(code**)( *(long*)pTVar11 + 0x58 ) == TType::getQualifier) {
               pTVar11 = pTVar11 + 0x10;
            }
 else {
               pTVar11 = (TIntermTyped*)( **(code**)( *(long*)pTVar11 + 0x58 ) )();
            }

            if (( 0x1b < ( byte )((byte)pTVar11[8] & 0x7f) ) || ( ( 0xe300008UL >> ( ( ulong )((byte)pTVar11[8] & 0x7f) & 0x3f ) & 1 ) == 0 )) {
               if (*(code**)( *(long*)param_2 + 0xf0 ) == TIntermTyped::getType) {
                  pTVar11 = param_2 + 0x20;
               }
 else {
                  pTVar11 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
               }

               if (*(code**)( *(long*)pTVar11 + 0x58 ) == TType::getQualifier) {
                  pTVar11 = pTVar11 + 0x10;
               }
 else {
                  pTVar11 = (TIntermTyped*)( **(code**)( *(long*)pTVar11 + 0x58 ) )();
               }

               if (( 0x1e < ( byte )((byte)pTVar11[8] & 0x7f) ) || ( ( 0x71c00010UL >> ( ( ulong )((byte)pTVar11[8] & 0x7f) & 0x3f ) & 1 ) == 0 )) {
                  if (*(code**)( *(long*)param_2 + 0xf0 ) == TIntermTyped::getType) {
                     pTVar11 = param_2 + 0x20;
                  }
 else {
                     pTVar11 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
                  }

                  if (*(code**)( *(long*)pTVar11 + 0x58 ) == TType::getQualifier) {
                     pTVar11 = pTVar11 + 0x10;
                  }
 else {
                     pTVar11 = (TIntermTyped*)( **(code**)( *(long*)pTVar11 + 0x58 ) )();
                  }

                  if (( ( (byte)pTVar11[8] & 0x7f ) != 2 ) && ( ( (byte)pTVar11[0xc] & 1 ) == 0 )) goto LAB_00106f24;
               }

            }

         }

         lVar6 = *(long*)( this + 0x768 );
      }

      if (*(char*)( lVar6 + 5 ) != '\0') {
         return;
      }

      if (*(code**)( *(long*)param_2 + 0xf0 ) == TIntermTyped::getType) {
         pTVar11 = param_2 + 0x20;
      }
 else {
         pTVar11 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
      }

      if (*(code**)( *(long*)pTVar11 + 0x58 ) == TType::getQualifier) {
         pTVar11 = pTVar11 + 0x10;
      }
 else {
         pTVar11 = (TIntermTyped*)( **(code**)( *(long*)pTVar11 + 0x58 ) )();
      }

      if (( 0x1b < ( byte )((byte)pTVar11[8] & 0x7f) ) || ( ( 0xe300008UL >> ( ( ulong )((byte)pTVar11[8] & 0x7f) & 0x3f ) & 1 ) == 0 )) {
         if (*(code**)( *(long*)param_2 + 0xf0 ) == TIntermTyped::getType) {
            pTVar11 = param_2 + 0x20;
         }
 else {
            pTVar11 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
         }

         if (*(code**)( *(long*)pTVar11 + 0x58 ) == TType::getQualifier) {
            pTVar11 = pTVar11 + 0x10;
         }
 else {
            pTVar11 = (TIntermTyped*)( **(code**)( *(long*)pTVar11 + 0x58 ) )();
         }

         if (0x1e < ( byte )((byte)pTVar11[8] & 0x7f)) {
            return;
         }

         if (( 0x71c00010UL >> ( ( ulong )((byte)pTVar11[8] & 0x7f) & 0x3f ) & 1 ) == 0) {
            return;
         }

      }

   }

   LAB_00106f24:puVar1 = *(undefined8**)( this + 0x7588 );
   if (puVar1 != *(undefined8**)( this + 0x7590 )) {
      *puVar1 = param_3;
      *(undefined8**)( this + 0x7588 ) = puVar1 + 1;
      return;
   }

   puVar2 = *(undefined8**)( this + 0x7580 );
   puVar12 = (undefined8*)( (long)puVar1 - (long)puVar2 );
   uVar7 = (long)puVar12 >> 3;
   if (uVar7 == 0xfffffffffffffff) {
      /* WARNING: Subroutine does not return */
      std::__throw_length_error("vector::_M_realloc_insert");
   }

   if (puVar1 == puVar2) {
      uVar10 = uVar7 + 1;
      if (0xfffffffffffffffe < uVar7) goto LAB_001072c8;
      if (0xfffffffffffffff < uVar10) {
         uVar10 = 0xfffffffffffffff;
      }

      lVar6 = uVar10 * 8;
      LAB_00107287:lVar8 = glslang::TPoolAllocator::allocate(*(ulong*)( this + 0x7578 ));
      *(TIntermTyped**)( lVar8 + (long)puVar12 ) = param_3;
      lVar6 = lVar8 + lVar6;
      lVar9 = lVar8 + 8;
      if (puVar1 == puVar2) goto LAB_00107157;
   }
 else {
      uVar10 = uVar7 * 2;
      if (uVar10 < uVar7) {
         LAB_001072c8:lVar6 = 0x7ffffffffffffff8;
         goto LAB_00107287;
      }

      if (uVar10 != 0) {
         if (0xfffffffffffffff < uVar10) {
            uVar10 = 0xfffffffffffffff;
         }

         lVar6 = uVar10 * 8;
         goto LAB_00107287;
      }

      *puVar12 = param_3;
      lVar8 = 0;
      lVar6 = 0;
   }

   lVar9 = 0;
   do {
      *(undefined8*)( lVar8 + lVar9 ) = *(undefined8*)( (long)puVar2 + lVar9 );
      lVar9 = lVar9 + 8;
   }
 while ( lVar9 != (long)puVar1 - (long)puVar2 );
   lVar9 = lVar8 + 8 + lVar9;
   LAB_00107157:*(long*)( this + 0x7580 ) = lVar8;
   *(long*)( this + 0x7588 ) = lVar9;
   *(long*)( this + 0x7590 ) = lVar6;
   return;
}
/* glslang::TParseContext::isIoResizeArray(glslang::TType const&) const */byte glslang::TParseContext::isIoResizeArray(TParseContext *this, TType *param_1) {
   char cVar1;
   int iVar2;
   long lVar3;
   TType *pTVar4;
   if (*(code**)( *(long*)param_1 + 0xe8 ) == TType::isArray) {
      if (*(long*)( param_1 + 0x60 ) == 0) {
         return 0;
      }

   }
 else {
      cVar1 = ( **(code**)( *(long*)param_1 + 0xe8 ) )(param_1);
      if (cVar1 == '\0') {
         return 0;
      }

   }

   iVar2 = *(int*)( this + 0x1c );
   if (iVar2 == 3) {
      if (*(code**)( *(long*)param_1 + 0x58 ) == TType::getQualifier) {
         if (( (byte)param_1[0x18] & 0x7f ) != 3) {
            return 0;
         }

         return 1;
      }

      lVar3 = ( **(code**)( *(long*)param_1 + 0x58 ) )(param_1);
      if (( *(byte*)( lVar3 + 8 ) & 0x7f ) == 3) {
         return 1;
      }

      iVar2 = *(int*)( this + 0x1c );
   }

   if (iVar2 == 1) {
      if (*(code**)( *(long*)param_1 + 0x58 ) == TType::getQualifier) {
         if (( (byte)param_1[0x18] & 0x7f ) != 4) {
            return 0;
         }

         LAB_001074da:pTVar4 = param_1 + 0x10;
         LAB_001074de:if (( (byte)pTVar4[0xd] & 0x10 ) == 0) {
            return 1;
         }

      }
 else {
         lVar3 = ( **(code**)( *(long*)param_1 + 0x58 ) )(param_1);
         if (( *(byte*)( lVar3 + 8 ) & 0x7f ) == 4) {
            if (*(code**)( *(long*)param_1 + 0x58 ) == TType::getQualifier) goto LAB_001074da;
            pTVar4 = (TType*)( **(code**)( *(long*)param_1 + 0x58 ) )(param_1);
            goto LAB_001074de;
         }

      }

      iVar2 = *(int*)( this + 0x1c );
   }

   if (iVar2 == 4) {
      if (*(code**)( *(long*)param_1 + 0x58 ) == TType::getQualifier) {
         if (( (byte)param_1[0x18] & 0x7f ) != 3) {
            return 0;
         }

         LAB_0010742d:if ((char)param_1[0x1c] < '\0') {
            return 1;
         }

         LAB_00107433:pTVar4 = param_1 + 0x10;
         LAB_00107437:if (( (byte)pTVar4[0xd] & 1 ) != 0) {
            return 1;
         }

      }
 else {
         lVar3 = ( **(code**)( *(long*)param_1 + 0x58 ) )(param_1);
         if (( *(byte*)( lVar3 + 8 ) & 0x7f ) == 3) {
            if (*(code**)( *(long*)param_1 + 0x58 ) == TType::getQualifier) goto LAB_0010742d;
            lVar3 = ( **(code**)( *(long*)param_1 + 0x58 ) )(param_1);
            if (*(char*)( lVar3 + 0xc ) < '\0') {
               return 1;
            }

            if (*(code**)( *(long*)param_1 + 0x58 ) == TType::getQualifier) goto LAB_00107433;
            pTVar4 = (TType*)( **(code**)( *(long*)param_1 + 0x58 ) )(param_1);
            goto LAB_00107437;
         }

      }

      iVar2 = *(int*)( this + 0x1c );
   }

   if (iVar2 != 0xd) {
      return 0;
   }

   if (*(code**)( *(long*)param_1 + 0x58 ) == TType::getQualifier) {
      if (( (byte)param_1[0x18] & 0x7f ) != 4) {
         return 0;
      }

   }
 else {
      lVar3 = ( **(code**)( *(long*)param_1 + 0x58 ) )(param_1);
      if (( *(byte*)( lVar3 + 8 ) & 0x7f ) != 4) {
         return 0;
      }

      if (*(code**)( *(long*)param_1 + 0x58 ) != TType::getQualifier) {
         pTVar4 = (TType*)( **(code**)( *(long*)param_1 + 0x58 ) )(param_1);
         goto LAB_0010746f;
      }

   }

   pTVar4 = param_1 + 0x10;
   LAB_0010746f:return (byte)pTVar4[0xd] >> 3 & 1 ^ 1;
}
/* glslang::TParseContext::fixIoArraySize(glslang::TSourceLoc const&, glslang::TType&) */void glslang::TParseContext::fixIoArraySize(TParseContext *this, TSourceLoc *param_1, TType *param_2) {
   char cVar1;
   int iVar2;
   code *pcVar3;
   long lVar4;
   TType *pTVar5;
   int *piVar6;
   pcVar3 = *(code**)( *(long*)param_2 + 0xe8 );
   if (pcVar3 == TType::isArray) {
      if (*(long*)( param_2 + 0x60 ) == 0) {
         return;
      }

      pcVar3 = *(code**)( *(long*)param_2 + 0x50 );
      if (pcVar3 == TType::getQualifier) goto LAB_00107602;
      LAB_0010767c:pTVar5 = (TType*)( *pcVar3 )(param_2);
   }
 else {
      cVar1 = ( *pcVar3 )(param_2);
      if (cVar1 == '\0') {
         return;
      }

      pcVar3 = *(code**)( *(long*)param_2 + 0x50 );
      if (pcVar3 != TType::getQualifier) goto LAB_0010767c;
      LAB_00107602:pTVar5 = param_2 + 0x10;
   }

   if (( (byte)pTVar5[0xd] & 0x10 ) != 0) {
      return;
   }

   if ((int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 ) < 4) {
      return;
   }

   if (*(code**)( *(long*)param_2 + 0x50 ) == TType::getQualifier) {
      if (( (byte)param_2[0x18] & 0x7f ) != 3) {
         return;
      }

      LAB_0010763b:pTVar5 = param_2 + 0x10;
   }
 else {
      lVar4 = ( **(code**)( *(long*)param_2 + 0x50 ) )(param_2);
      if (( *(byte*)( lVar4 + 8 ) & 0x7f ) != 3) {
         return;
      }

      if (*(code**)( *(long*)param_2 + 0x50 ) == TType::getQualifier) goto LAB_0010763b;
      pTVar5 = (TType*)( **(code**)( *(long*)param_2 + 0x50 ) )(param_2);
   }

   if (( (byte)pTVar5[0xd] & 0x10 ) != 0) {
      return;
   }

   if (1 < *(int*)( this + 0x1c ) - 1U) {
      return;
   }

   if (*(code**)( *(long*)param_2 + 0x78 ) == TType::getOuterArraySize) {
      iVar2 = **(int**)( *(long*)( *(long*)( param_2 + 0x60 ) + 8 ) + 8 );
   }
 else {
      iVar2 = ( **(code**)( *(long*)param_2 + 0x78 ) )(param_2);
   }

   if (iVar2 == *(int*)( this + 0x6b4 )) {
      return;
   }

   pcVar3 = *(code**)( *(long*)param_2 + 0xf0 );
   if (pcVar3 == TType::isSizedArray) {
      pcVar3 = *(code**)( *(long*)param_2 + 0xe8 );
      if (( pcVar3 == TType::isArray ) || ( cVar1 = ( *pcVar3 )(param_2) ),cVar1 != '\0') {
         lVar4 = *(long*)( param_2 + 0x60 );
         piVar6 = *(int**)( *(long*)( lVar4 + 8 ) + 8 );
         if (*piVar6 == 0) {
            iVar2 = *(int*)( this + 0x6b4 );
            goto LAB_0010771f;
         }

         LAB_00107733:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "tessellation input array size must be gl_MaxPatchVertices or implicitly sized", &_LC38, &_LC1);
      }

   }
 else {
      cVar1 = ( *pcVar3 )(param_2);
      if (cVar1 != '\0') goto LAB_00107733;
   }

   lVar4 = *(long*)( param_2 + 0x60 );
   iVar2 = *(int*)( this + 0x6b4 );
   piVar6 = *(int**)( *(long*)( lVar4 + 8 ) + 8 );
   LAB_0010771f:*piVar6 = iVar2;
   *(undefined1*)( lVar4 + 0x14 ) = 0;
   return;
}
/* glslang::TParseContext::ioArrayCheck(glslang::TSourceLoc const&, glslang::TType const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const&)
    */void glslang::TParseContext::ioArrayCheck(TParseContext *this, TSourceLoc *param_1, TType *param_2, basic_string *param_3) {
   char cVar1;
   TQualifier *pTVar2;
   char *pcVar3;
   if (*(code**)( *(long*)param_2 + 0xe8 ) == TType::isArray) {
      if (*(long*)( param_2 + 0x60 ) != 0) {
         return;
      }

   }
 else {
      cVar1 = ( **(code**)( *(long*)param_2 + 0xe8 ) )(param_2);
      if (cVar1 != '\0') {
         return;
      }

   }

   if (3 < (int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 )) {
      if (*(code**)( *(long*)param_2 + 0x58 ) == TType::getQualifier) {
         pTVar2 = (TQualifier*)( param_2 + 0x10 );
         cVar1 = TQualifier::isArrayedIo(pTVar2, *(undefined4*)( this + 0x1c ));
         if (cVar1 == '\0') {
            return;
         }

      }
 else {
         pTVar2 = (TQualifier*)( **(code**)( *(long*)param_2 + 0x58 ) )(param_2);
         cVar1 = TQualifier::isArrayedIo(pTVar2, *(undefined4*)( this + 0x1c ));
         if (cVar1 == '\0') {
            return;
         }

         if (*(code**)( *(long*)param_2 + 0x58 ) == TType::getQualifier) {
            pTVar2 = (TQualifier*)( param_2 + 0x10 );
         }
 else {
            pTVar2 = (TQualifier*)( **(code**)( *(long*)param_2 + 0x58 ) )(param_2);
         }

      }

      if (pTVar2[0x2f] == (TQualifier)0x0) {
         switch ((byte)param_2[0x18] & 0x7f) {
            case 0:
        pcVar3 = "temp";
        break;
            case 1:
        pcVar3 = "global";
        break;
            case 2:
        pcVar3 = "const";
        break;
            case 3:
            case 0x10:
        pcVar3 = "in";
        break;
            case 4:
            case 0x11:
        pcVar3 = "out";
        break;
            case 5:
        pcVar3 = "uniform";
        break;
            case 6:
        pcVar3 = "buffer";
        break;
            case 7:
        pcVar3 = "shared";
        break;
            case 8:
        pcVar3 = "spirv_storage_class";
        break;
            case 9:
        pcVar3 = "rayPayloadNV";
        break;
            case 10:
        pcVar3 = "rayPayloadInNV";
        break;
            case 0xb:
        pcVar3 = "hitAttributeNV";
        break;
            case 0xc:
        pcVar3 = "callableDataNV";
        break;
            case 0xd:
        pcVar3 = "callableDataInNV";
        break;
            case 0xe:
        pcVar3 = "hitObjectAttributeNV";
        break;
            case 0xf:
        pcVar3 = "taskPayloadSharedEXT";
        break;
            case 0x12:
        pcVar3 = "inout";
        break;
            case 0x13:
        pcVar3 = "const (read only)";
        break;
            case 0x14:
        pcVar3 = "gl_VertexId";
        break;
            case 0x15:
        pcVar3 = "gl_InstanceId";
        break;
            case 0x16:
        pcVar3 = "gl_Position";
        break;
            case 0x17:
        pcVar3 = "gl_PointSize";
        break;
            case 0x18:
        pcVar3 = "gl_ClipVertex";
        break;
            case 0x19:
        pcVar3 = "gl_FrontFacing";
        break;
            case 0x1a:
        pcVar3 = "gl_FragCoord";
        break;
            case 0x1b:
        pcVar3 = "gl_PointCoord";
        break;
            case 0x1c:
        pcVar3 = "fragColor";
        break;
            case 0x1d:
        pcVar3 = "gl_FragDepth";
        break;
            case 0x1e:
        pcVar3 = "gl_FragStencilRefARB";
        break;
            default:
        pcVar3 = "unknown qualifier";
         }

         /* WARNING: Could not recover jumptable at 0x001078a3. Too many branches */
         /* WARNING: Treating indirect jump as call */
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "type must be an array:", pcVar3, *(undefined8*)( param_3 + 8 ), *(code**)( *(long*)this + 0x158 ));
         return;
      }

   }

   return;
}
/* glslang::TParseContext::checkIoArrayConsistency(glslang::TSourceLoc const&, int, char const*,
   glslang::TType&, std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const&) */void glslang::TParseContext::checkIoArrayConsistency(TParseContext *this, TSourceLoc *param_1, int param_2, char *param_3, TType *param_4, basic_string *param_5) {
   char cVar1;
   int iVar2;
   int *piVar3;
   long lVar4;
   long lVar5;
   char *pcVar6;
   undefined8 uVar7;
   code *UNRECOVERED_JUMPTABLE;
   lVar4 = *(long*)param_4;
   if (*(code**)( lVar4 + 0xf8 ) == TType::isUnsizedArray) {
      if (*(code**)( lVar4 + 0xe8 ) == TType::isArray) {
         lVar5 = *(long*)( param_4 + 0x60 );
         if (lVar5 == 0) goto LAB_00107a7c;
      }
 else {
         cVar1 = ( **(code**)( lVar4 + 0xe8 ) )(param_4);
         if (cVar1 == '\0') goto LAB_00107a79;
         lVar5 = *(long*)( param_4 + 0x60 );
      }

      piVar3 = *(int**)( *(long*)( lVar5 + 8 ) + 8 );
      if (*piVar3 == 0) {
         LAB_00107a57:*piVar3 = param_2;
         *(undefined1*)( lVar5 + 0x14 ) = 0;
         return;
      }

   }
 else {
      cVar1 = ( **(code**)( lVar4 + 0xf8 ) )(param_4);
      if (cVar1 != '\0') {
         lVar5 = *(long*)( param_4 + 0x60 );
         piVar3 = *(int**)( *(long*)( lVar5 + 8 ) + 8 );
         goto LAB_00107a57;
      }

   }

   LAB_00107a79:lVar4 = *(long*)param_4;
   LAB_00107a7c:if (*(code**)( lVar4 + 0x78 ) == TType::getOuterArraySize) {
      iVar2 = **(int**)( *(long*)( *(long*)( param_4 + 0x60 ) + 8 ) + 8 );
   }
 else {
      iVar2 = ( **(code**)( lVar4 + 0x78 ) )(param_4);
   }

   if (param_2 == iVar2) {
      return;
   }

   iVar2 = *(int*)( this + 0x1c );
   if (iVar2 == 3) {
      uVar7 = *(undefined8*)( param_5 + 8 );
      pcVar6 = "inconsistent input primitive for array size of";
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
   }
 else if (iVar2 == 1) {
      uVar7 = *(undefined8*)( param_5 + 8 );
      pcVar6 = "inconsistent output number of vertices for array size of";
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
   }
 else if (iVar2 == 4) {
      if (*(code**)( *(long*)param_4 + 0x78 ) == TType::getOuterArraySize) {
         iVar2 = **(int**)( *(long*)( *(long*)( param_4 + 0x60 ) + 8 ) + 8 );
      }
 else {
         iVar2 = ( **(code**)( *(long*)param_4 + 0x78 ) )(param_4);
      }

      if (iVar2 <= param_2) {
         return;
      }

      uVar7 = *(undefined8*)( param_5 + 8 );
      pcVar6 = " cannot be greater than 3 for pervertexEXT";
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
   }
 else {
      if (iVar2 != 0xd) {
         return;
      }

      uVar7 = *(undefined8*)( param_5 + 8 );
      pcVar6 = "inconsistent output array size of";
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
   }

   /* WARNING: Could not recover jumptable at 0x00107b3f. Too many branches */
   /* WARNING: Treating indirect jump as call */
   ( *UNRECOVERED_JUMPTABLE )(this, param_1, pcVar6, param_3, uVar7, UNRECOVERED_JUMPTABLE);
   return;
}
/* glslang::TParseContext::blockMemberExtensionCheck(glslang::TSourceLoc const&,
   glslang::TIntermTyped const*, int, std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const&) */void glslang::TParseContext::blockMemberExtensionCheck(TParseContext *this, TSourceLoc *param_1, TIntermTyped *param_2, int param_3, basic_string *param_4) {
   TSymbolTable *this_00;
   undefined8 uVar1;
   char cVar2;
   int iVar3;
   uint uVar4;
   long lVar5;
   long *plVar6;
   long lVar7;
   basic_string *pbVar8;
   code *UNRECOVERED_JUMPTABLE;
   ulong uVar9;
   code *pcVar10;
   long lVar11;
   lVar5 = ( **(code**)( *(long*)param_2 + 0xa0 ) )(param_2);
   if (lVar5 == 0) {
      plVar6 = (long*)( **(code**)( *(long*)param_2 + 0xc0 ) )(param_2);
   }
 else {
      plVar6 = (long*)( **(code**)( *(long*)param_2 + 0xa0 ) )();
      if (*(code**)( *plVar6 + 400 ) == TIntermBinary::getLeft) {
         plVar6 = (long*)plVar6[0x18];
      }
 else {
         plVar6 = (long*)( **(code**)( *plVar6 + 400 ) )();
      }

      plVar6 = (long*)( **(code**)( *plVar6 + 0x60 ) )();
   }

   if (plVar6 == (long*)0x0) {
      return;
   }

   this_00 = *(TSymbolTable**)( this + 0xe8 );
   if (*(code**)( *plVar6 + 400 ) == TIntermSymbol::getName_abi_cxx11_) {
      pbVar8 = (basic_string*)( plVar6 + 0x19 );
   }
 else {
      pbVar8 = (basic_string*)( **(code**)( *plVar6 + 400 ) )();
   }

   plVar6 = (long*)TSymbolTable::find(this_00, pbVar8, (bool*)0x0, (bool*)0x0, (int*)0x0);
   if (plVar6 == (long*)0x0) {
      return;
   }

   plVar6 = (long*)( **(code**)( *plVar6 + 0x50 ) )(plVar6);
   if (plVar6 == (long*)0x0) {
      return;
   }

   UNRECOVERED_JUMPTABLE = *(code**)( *plVar6 + 0xf8 );
   if (UNRECOVERED_JUMPTABLE == TVariable::hasMemberExtensions) {
      if (plVar6[0x1c] == 0) {
         return;
      }

      UNRECOVERED_JUMPTABLE = *(code**)( *plVar6 + 0x100 );
      if (UNRECOVERED_JUMPTABLE != TVariable::getNumMemberExtensions) goto LAB_00107df0;
      lVar5 = plVar6[0x1c];
      LAB_00107ce2:lVar5 = (long)param_3 * 0x20 + *(long*)( lVar5 + 8 );
      iVar3 = (int)( *(long*)( lVar5 + 0x10 ) - *(long*)( lVar5 + 8 ) >> 3 );
   }
 else {
      cVar2 = ( *UNRECOVERED_JUMPTABLE )(plVar6);
      if (cVar2 == '\0') {
         return;
      }

      UNRECOVERED_JUMPTABLE = *(code**)( *plVar6 + 0x100 );
      if (UNRECOVERED_JUMPTABLE == TVariable::getNumMemberExtensions) {
         lVar5 = plVar6[0x1c];
         if (lVar5 == 0) {
            return;
         }

         goto LAB_00107ce2;
      }

      LAB_00107df0:iVar3 = ( *UNRECOVERED_JUMPTABLE )(plVar6, param_3);
   }

   if (iVar3 < 1) {
      return;
   }

   uVar1 = *(undefined8*)( param_4 + 8 );
   UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x28 );
   pcVar10 = *(code**)( *plVar6 + 0x108 );
   if (pcVar10 == TVariable::getMemberExtensions) {
      pcVar10 = *(code**)( *plVar6 + 0x100 );
      lVar7 = (long)param_3 * 0x20 + *(long*)( plVar6[0x1c] + 8 );
      lVar5 = *(long*)( lVar7 + 8 );
      lVar11 = lVar5;
      if (pcVar10 != TVariable::getNumMemberExtensions) {
         LAB_00107e38:uVar4 = ( *pcVar10 )(plVar6, param_3);
         uVar9 = (ulong)uVar4;
         goto LAB_00107d5a;
      }

   }
 else {
      lVar5 = ( *pcVar10 )(plVar6, param_3);
      pcVar10 = *(code**)( *plVar6 + 0x100 );
      if (pcVar10 != TVariable::getNumMemberExtensions) goto LAB_00107e38;
      if (plVar6[0x1c] == 0) {
         uVar9 = 0;
         goto LAB_00107d5a;
      }

      lVar7 = (long)param_3 * 0x20 + *(long*)( plVar6[0x1c] + 8 );
      lVar11 = *(long*)( lVar7 + 8 );
   }

   uVar9 = *(long*)( lVar7 + 0x10 ) - lVar11 >> 3;
   LAB_00107d5a:/* WARNING: Could not recover jumptable at 0x00107d71. Too many branches *//* WARNING: Treating indirect jump as call */( *UNRECOVERED_JUMPTABLE )(this, param_1, uVar9, lVar5, uVar1, UNRECOVERED_JUMPTABLE);
   return;
}
/* glslang::TParseContext::computeBuiltinPrecisions(glslang::TIntermTyped&, glslang::TFunction
   const&) */void glslang::TParseContext::computeBuiltinPrecisions(TParseContext *this, TIntermTyped *param_1, TFunction *param_2) {
   uint uVar1;
   long *plVar2;
   long *plVar3;
   code *pcVar4;
   long lVar5;
   long *plVar6;
   long *plVar7;
   uint uVar8;
   TFunction *pTVar9;
   byte bVar10;
   uint uVar11;
   ulong uVar12;
   uint local_50;
   plVar2 = (long*)( **(code**)( *(long*)param_1 + 0x20 ) )(param_1);
   if (plVar2 == (long*)0x0) {
      return;
   }

   plVar3 = (long*)( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
   if (plVar3 == (long*)0x0) {
      plVar3 = (long*)( **(code**)( *(long*)param_1 + 0x30 ) )(param_1);
      if (plVar3 == (long*)0x0) {
         uVar8 = 0;
         uVar11 = 0;
         goto LAB_00107fe3;
      }

      if (*(code**)( *plVar3 + 400 ) == TIntermAggregate::getSequence) {
         plVar7 = plVar3 + 0x18;
      }
 else {
         plVar7 = (long*)( **(code**)( *plVar3 + 400 ) )(plVar3);
      }

      lVar5 = plVar7[1];
      uVar8 = *(uint*)( plVar3 + 0x17 );
      if (uVar8 == 0x2b2) {
         local_50 = 1;
         LAB_001082e4:uVar12 = 0;
         uVar11 = 0;
         while (true) {
            plVar6 = (long*)( **(code**)( **(long**)( lVar5 + uVar12 * 8 ) + 0x18 ) )();
            if (*(code**)( *plVar6 + 0x108 ) == TIntermTyped::getQualifier) {
               plVar6 = plVar6 + 6;
            }
 else {
               plVar6 = (long*)( **(code**)( *plVar6 + 0x108 ) )();
            }

            uVar8 = *(byte*)( (long)plVar6 + 0xb ) >> 1 & 7;
            if (uVar11 < uVar8) {
               uVar11 = uVar8;
            }

            if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
               lVar5 = *(long*)( param_2 + 0x30 ) + (long)(int)uVar12 * 0x18;
            }
 else {
               lVar5 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, uVar12 & 0xffffffff);
            }

            pcVar4 = *(code**)( **(long**)( lVar5 + 8 ) + 0x50 );
            if (pcVar4 == TType::getQualifier) {
               plVar6 = *(long**)( lVar5 + 8 ) + 2;
            }
 else {
               plVar6 = (long*)( *pcVar4 )();
            }

            uVar8 = *(byte*)( (long)plVar6 + 0xb ) >> 1 & 7;
            if (uVar11 < uVar8) {
               uVar11 = uVar8;
            }

            uVar12 = uVar12 + 1;
            if (local_50 <= (uint)uVar12) break;
            lVar5 = plVar7[1];
         }
;
         uVar8 = *(uint*)( plVar3 + 0x17 );
         LAB_001083eb:if (( uVar8 - 0x276 < 0x36 ) || ( uVar8 - 0x25c < 4 )) {
            plVar3 = (long*)( **(code**)( **(long**)plVar7[1] + 0x18 ) )();
            if (*(code**)( *plVar3 + 0x108 ) == TIntermTyped::getQualifier) {
               plVar3 = plVar3 + 6;
            }
 else {
               plVar3 = (long*)( **(code**)( *plVar3 + 0x108 ) )();
            }

            uVar8 = *(byte*)( (long)plVar3 + 0xb ) >> 1 & 7;
            goto LAB_00107fe3;
         }

      }
 else {
         if (0x2b2 < uVar8) {
            local_50 = 2;
            if (uVar8 != 0x2b3) {
               LAB_00108454:local_50 = ( uint )(plVar7[2] - lVar5 >> 3);
               if (local_50 == 0) {
                  uVar11 = 0;
                  goto LAB_001080d5;
               }

            }

            goto LAB_001082e4;
         }

         if (uVar8 < 0x128) {
            local_50 = 1;
            if (uVar8 < 0x125) goto LAB_00108454;
            goto LAB_001082e4;
         }

         uVar11 = 0;
         if (uVar8 != 0x1cf) {
            uVar11 = ( uint )(plVar7[2] - lVar5 >> 3);
            local_50 = uVar11;
            if (uVar11 != 0) goto LAB_001082e4;
            goto LAB_001083eb;
         }

      }

      LAB_001080d5:if (*(code**)( *(long*)param_2 + 0x60 ) == TFunction::getType) {
         pTVar9 = param_2 + 0x48;
      }
 else {
         pTVar9 = (TFunction*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
      }

      if (*(code**)( *(long*)pTVar9 + 0x38 ) == TType::getBasicType) {
         uVar1 = (uint)(byte)pTVar9[8];
      }
 else {
         uVar1 = ( **(code**)( *(long*)pTVar9 + 0x38 ) )();
      }

      uVar8 = 0;
      if (uVar1 != 0xc) {
         if (*(code**)( *(long*)param_2 + 0x60 ) == TFunction::getType) {
            pTVar9 = param_2 + 0x48;
         }
 else {
            pTVar9 = (TFunction*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
         }

         if (*(code**)( *(long*)pTVar9 + 0x58 ) == TType::getQualifier) {
            pTVar9 = pTVar9 + 0x10;
         }
 else {
            pTVar9 = (TFunction*)( **(code**)( *(long*)pTVar9 + 0x58 ) )();
         }

         if (( (byte)pTVar9[0xb] & 0xe ) == 0) {
            uVar8 = uVar11 & 7;
         }
 else {
            if (*(code**)( *(long*)param_2 + 0x60 ) == TFunction::getType) {
               pTVar9 = param_2 + 0x48;
            }
 else {
               pTVar9 = (TFunction*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
            }

            if (*(code**)( *(long*)pTVar9 + 0x58 ) == TType::getQualifier) {
               pTVar9 = pTVar9 + 0x10;
            }
 else {
               pTVar9 = (TFunction*)( **(code**)( *(long*)pTVar9 + 0x58 ) )();
            }

            uVar8 = (byte)pTVar9[0xb] >> 1 & 7;
         }

      }

      LAB_00107fe3:bVar10 = (byte)uVar8;
      lVar5 = *plVar2;
      pcVar4 = *(code**)( lVar5 + 0x108 );
      if (pcVar4 != TIntermTyped::getQualifier) {
         LAB_001081af:plVar3 = (long*)( *pcVar4 )(plVar2);
         lVar5 = *plVar2;
         goto LAB_00107ffa;
      }

   }
 else {
      if (*(code**)( *plVar3 + 0x188 ) == TIntermUnary::getOperand) {
         plVar3 = (long*)plVar3[0x18];
      }
 else {
         plVar3 = (long*)( **(code**)( *plVar3 + 0x188 ) )(plVar3);
      }

      if (*(code**)( *plVar3 + 0xf0 ) == TIntermTyped::getType) {
         plVar3 = plVar3 + 4;
      }
 else {
         plVar3 = (long*)( **(code**)( *plVar3 + 0xf0 ) )();
      }

      if (*(code**)( *plVar3 + 0x58 ) == TType::getQualifier) {
         plVar3 = plVar3 + 2;
      }
 else {
         plVar3 = (long*)( **(code**)( *plVar3 + 0x58 ) )();
      }

      uVar8 = *(byte*)( (long)plVar3 + 0xb ) >> 1 & 7;
      if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
         lVar5 = *(long*)( param_2 + 0x30 );
      }
 else {
         lVar5 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
      }

      pcVar4 = *(code**)( **(long**)( lVar5 + 8 ) + 0x50 );
      if (pcVar4 == TType::getQualifier) {
         plVar3 = *(long**)( lVar5 + 8 ) + 2;
      }
 else {
         plVar3 = (long*)( *pcVar4 )();
      }

      uVar11 = *(byte*)( (long)plVar3 + 0xb ) >> 1 & 7;
      if ((byte)uVar11 < (byte)uVar8) {
         uVar11 = uVar8;
      }

      if (*(code**)( *(long*)param_2 + 0x60 ) == TFunction::getType) {
         pTVar9 = param_2 + 0x48;
      }
 else {
         pTVar9 = (TFunction*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
      }

      if (*(code**)( *(long*)pTVar9 + 0x38 ) == TType::getBasicType) {
         uVar8 = (uint)(byte)pTVar9[8];
      }
 else {
         uVar8 = ( **(code**)( *(long*)pTVar9 + 0x38 ) )();
      }

      if (uVar8 == 0xc) {
         uVar8 = 0;
         goto LAB_00107fe3;
      }

      if (*(code**)( *(long*)param_2 + 0x60 ) == TFunction::getType) {
         pTVar9 = param_2 + 0x48;
      }
 else {
         pTVar9 = (TFunction*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
      }

      if (*(code**)( *(long*)pTVar9 + 0x58 ) == TType::getQualifier) {
         pTVar9 = pTVar9 + 0x10;
      }
 else {
         pTVar9 = (TFunction*)( **(code**)( *(long*)pTVar9 + 0x58 ) )();
      }

      uVar8 = uVar11;
      if (( (byte)pTVar9[0xb] & 0xe ) == 0) goto LAB_00107fe3;
      if (*(code**)( *(long*)param_2 + 0x60 ) == TFunction::getType) {
         pTVar9 = param_2 + 0x48;
      }
 else {
         pTVar9 = (TFunction*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
      }

      if (*(code**)( *(long*)pTVar9 + 0x58 ) == TType::getQualifier) {
         pTVar9 = pTVar9 + 0x10;
      }
 else {
         pTVar9 = (TFunction*)( **(code**)( *(long*)pTVar9 + 0x58 ) )();
      }

      lVar5 = *plVar2;
      pcVar4 = *(code**)( lVar5 + 0x108 );
      bVar10 = (byte)pTVar9[0xb] >> 1 & 7;
      if (pcVar4 != TIntermTyped::getQualifier) goto LAB_001081af;
   }

   plVar3 = plVar2 + 6;
   LAB_00107ffa:*(byte*)( (long)plVar3 + 0xb ) = *(byte*)( (long)plVar3 + 0xb ) & 0xf1;
   if (uVar11 != 0) {
      ( **(code**)( lVar5 + 0x128 ) )(plVar2, uVar11);
      *(uint*)( (long)plVar2 + 0xbc ) = uVar11;
      lVar5 = *plVar2;
   }

   if (*(code**)( lVar5 + 0x108 ) == TIntermTyped::getQualifier) {
      plVar2 = plVar2 + 6;
   }
 else {
      plVar2 = (long*)( **(code**)( lVar5 + 0x108 ) )(plVar2);
   }

   *(byte*)( (long)plVar2 + 0xb ) = *(byte*)( (long)plVar2 + 0xb ) & 0xf1 | bVar10 * '\x02';
   return;
}
/* glslang::TParseContext::checkLocation(glslang::TSourceLoc const&, glslang::TOperator) */void glslang::TParseContext::checkLocation(TParseContext *this, undefined8 param_1, int param_3) {
   char *pcVar1;
   code *UNRECOVERED_JUMPTABLE;
   if (param_3 == 0x1cc) {
      if (*(int*)( this + 0x1c ) != 4) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "beginInvocationInterlockARB() must be in a fragment shader", &_LC1);
      }

      if (this[0x500] == (TParseContext)0x0) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "beginInvocationInterlockARB() must be in main()", &_LC1);
      }
 else if (this[0x131] != (TParseContext)0x0) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "beginInvocationInterlockARB() cannot be placed after a return from main()", &_LC1);
      }

      if (0 < *(int*)( this + 0x120 )) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "beginInvocationInterlockARB() cannot be placed within flow control", &_LC1);
      }

      if (0 < *(int*)( this + 0x1b8 )) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "beginInvocationInterlockARB() must only be called once", &_LC1);
      }

      if (0 < *(int*)( this + 0x1bc )) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "beginInvocationInterlockARB() must be called before endInvocationInterlockARB()", &_LC1);
      }

      *(int*)( this + 0x1b8 ) = *(int*)( this + 0x1b8 ) + 1;
      if (*(int*)( *(long*)( this + 0x38 ) + 0x324 ) == 0) {
         *(undefined4*)( *(long*)( this + 0x38 ) + 0x324 ) = 1;
         return;
      }

   }
 else {
      if (param_3 == 0x1cd) {
         if (*(int*)( this + 0x1c ) != 4) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "endInvocationInterlockARB() must be in a fragment shader", &_LC1);
         }

         if (this[0x500] == (TParseContext)0x0) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "endInvocationInterlockARB() must be in main()", &_LC1);
         }
 else if (this[0x131] != (TParseContext)0x0) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "endInvocationInterlockARB() cannot be placed after a return from main()", &_LC1);
         }

         if (0 < *(int*)( this + 0x120 )) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "endInvocationInterlockARB() cannot be placed within flow control", &_LC1);
         }

         if (0 < *(int*)( this + 0x1bc )) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "endInvocationInterlockARB() must only be called once", &_LC1);
         }

         if (*(int*)( this + 0x1b8 ) == 0) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "beginInvocationInterlockARB() must be called before endInvocationInterlockARB()", &_LC1);
         }

         *(int*)( this + 0x1bc ) = *(int*)( this + 0x1bc ) + 1;
         return;
      }

      if (( param_3 == 0x134 ) && ( *(int*)( this + 0x1c ) == 1 )) {
         if (0 < *(int*)( this + 0x120 )) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "tessellation control barrier() cannot be placed within flow control", &_LC1);
         }

         if (this[0x500] == (TParseContext)0x0) {
            pcVar1 = "tessellation control barrier() must be in main()";
            UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         }
 else {
            if (this[0x131] == (TParseContext)0x0) {
               return;
            }

            pcVar1 = "tessellation control barrier() cannot be placed after a return from main()";
            UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         }

         /* WARNING: Could not recover jumptable at 0x00108898. Too many branches */
         /* WARNING: Treating indirect jump as call */
         ( *UNRECOVERED_JUMPTABLE )(this, param_1, pcVar1, &_LC1, &_LC1, UNRECOVERED_JUMPTABLE);
         return;
      }

   }

   return;
}
/* glslang::TParseContext::addInputArgumentConversions(glslang::TFunction const&, TIntermNode*&)
   const */void glslang::TParseContext::addInputArgumentConversions(TParseContext *this, TFunction *param_1, TIntermNode **param_2) {
   byte bVar1;
   code *pcVar2;
   undefined8 uVar3;
   char cVar4;
   int iVar5;
   long *plVar6;
   long *plVar7;
   long lVar8;
   TIntermNode *pTVar9;
   TType *pTVar10;
   long *plVar11;
   int iVar12;
   long lVar13;
   long lVar14;
   long lVar15;
   lVar15 = 0;
   lVar14 = 0;
   plVar6 = (long*)( **(code**)( *(long*)*param_2 + 0x30 ) )();
   lVar8 = *(long*)param_1;
   LAB_00108900:do {
      iVar5 = (int)lVar14;
      if (*(code**)( lVar8 + 0x120 ) == TFunction::getParamCount) {
         iVar12 = (int)( *(long*)( param_1 + 0x38 ) - *(long*)( param_1 + 0x30 ) >> 3 ) * -0x55555555;
         if (iVar12 <= iVar5) {
            return;
         }

      }
 else {
         iVar12 = ( **(code**)( lVar8 + 0x120 ) )(param_1);
         if (iVar12 <= iVar5) {
            return;
         }

         if (*(code**)( *(long*)param_1 + 0x120 ) == TFunction::getParamCount) {
            iVar12 = (int)( *(long*)( param_1 + 0x38 ) - *(long*)( param_1 + 0x30 ) >> 3 ) * -0x55555555;
         }
 else {
            iVar12 = ( **(code**)( *(long*)param_1 + 0x120 ) )(param_1);
         }

      }

      if (( iVar12 == 1 ) || ( plVar6 == (long*)0x0 )) {
         plVar7 = (long*)( **(code**)( *(long*)*param_2 + 0x18 ) )();
      }
 else {
         if (*(code**)( *plVar6 + 400 ) == TIntermAggregate::getSequence) {
            plVar7 = plVar6 + 0x18;
         }
 else {
            plVar7 = (long*)( **(code**)( *plVar6 + 400 ) )(plVar6);
         }

         plVar7 = (long*)( **(code**)( **(long**)( plVar7[1] + lVar14 * 8 ) + 0x18 ) )();
      }

      if (*(code**)( *plVar7 + 0xf0 ) == TIntermTyped::getType) {
         pTVar10 = (TType*)( plVar7 + 4 );
      }
 else {
         pTVar10 = (TType*)( **(code**)( *plVar7 + 0xf0 ) )(plVar7);
      }

      if (*(code**)( *(long*)param_1 + 0x140 ) == TFunction::operator []) {
         lVar8 = *(long*)( param_1 + 0x30 ) + lVar15;
      }
 else {
         lVar8 = ( **(code**)( *(long*)param_1 + 0x140 ) )(param_1, iVar5);
      }

      cVar4 = TType::operator ==(*(TType**)( lVar8 + 8 ), pTVar10);
      lVar8 = *(long*)param_1;
      if (cVar4 == '\0') {
         if (*(code**)( lVar8 + 0x140 ) == TFunction::operator []) {
            lVar8 = *(long*)( param_1 + 0x30 ) + lVar15;
         }
 else {
            lVar8 = ( **(code**)( lVar8 + 0x140 ) )(param_1, iVar5);
         }

         pcVar2 = *(code**)( **(long**)( lVar8 + 8 ) + 0x50 );
         if (pcVar2 == TType::getQualifier) {
            plVar11 = *(long**)( lVar8 + 8 ) + 2;
         }
 else {
            plVar11 = (long*)( *pcVar2 )();
         }

         if (( ( *(byte*)( plVar11 + 1 ) & 0x7f ) != 0x10 ) && ( 1 < ( ( *(byte*)( plVar11 + 1 ) & 0x7f ) + 0x6e & 0x7f ) )) {
            LAB_00108ba0:lVar8 = *(long*)param_1;
            lVar14 = lVar14 + 1;
            lVar15 = lVar15 + 0x18;
            goto LAB_00108900;
         }

         lVar8 = *(long*)param_1;
         if (*(code**)( lVar8 + 0x140 ) == TFunction::operator []) {
            lVar13 = *(long*)( param_1 + 0x30 ) + lVar15;
         }
 else {
            lVar13 = ( **(code**)( lVar8 + 0x140 ) )(param_1, iVar5);
            lVar8 = *(long*)param_1;
         }

         bVar1 = *(byte*)( *(long*)( lVar13 + 8 ) + 10 );
         if (( ( bVar1 & 0x20 ) == 0 ) && ( ( bVar1 & 0x40 ) == 0 )) {
            uVar3 = *(undefined8*)( this + 0x38 );
            if (*(code**)( lVar8 + 0x140 ) == TFunction::operator []) {
               lVar8 = *(long*)( param_1 + 0x30 ) + lVar15;
            }
 else {
               lVar8 = ( **(code**)( lVar8 + 0x140 ) )(param_1, iVar5);
            }

            pTVar9 = (TIntermNode*)glslang::TIntermediate::addConversion(uVar3, 4, *(undefined8*)( lVar8 + 8 ), plVar7);
            lVar8 = *(long*)param_1;
            if (pTVar9 != (TIntermNode*)0x0) {
               if (*(code**)( lVar8 + 0x120 ) == TFunction::getParamCount) {
                  iVar5 = (int)( *(long*)( param_1 + 0x38 ) - *(long*)( param_1 + 0x30 ) >> 3 ) * -0x55555555;
               }
 else {
                  iVar5 = ( **(code**)( lVar8 + 0x120 ) )(param_1);
               }

               if (( iVar5 == 1 ) || ( plVar6 == (long*)0x0 )) {
                  *param_2 = pTVar9;
                  goto LAB_00108ba0;
               }

               if (*(code**)( *plVar6 + 400 ) == TIntermAggregate::getSequence) {
                  plVar7 = plVar6 + 0x18;
               }
 else {
                  plVar7 = (long*)( **(code**)( *plVar6 + 400 ) )(plVar6);
               }

               *(TIntermNode**)( plVar7[1] + lVar14 * 8 ) = pTVar9;
               lVar8 = *(long*)param_1;
            }

         }

      }

      lVar14 = lVar14 + 1;
      lVar15 = lVar15 + 0x18;
   }
 while ( true );
}
/* glslang::TParseContext::addAssign(glslang::TSourceLoc const&, glslang::TOperator,
   glslang::TIntermTyped*, glslang::TIntermTyped*) */void glslang::TParseContext::addAssign(TParseContext *this, undefined8 param_1, int param_3, long *param_4, long *param_5) {
   uint uVar1;
   if (param_3 - 0x24aU < 2) {
      if ((char)param_4[5] == '\x12') {
         ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_EXT_buffer_reference2, "+= and -= on a buffer reference");
      }

   }
 else if (param_3 == 0x249) {
      if (*(code**)( *param_4 + 0x100 ) == TIntermTyped::getBasicType) {
         uVar1 = ( uint ) * (byte*)( param_4 + 5 );
      }
 else {
         uVar1 = ( **(code**)( *param_4 + 0x100 ) )(param_4);
      }

      if (uVar1 == 0xe) {
         if (*(code**)( *param_5 + 0x100 ) == TIntermTyped::getBasicType) {
            uVar1 = ( uint ) * (byte*)( param_5 + 5 );
         }
 else {
            uVar1 = ( **(code**)( *param_5 + 0x100 ) )(param_5);
         }

         if (uVar1 == 0xe) {
            ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_ARB_bindless_texture, "sampler assignment for bindless texture");
         }

      }

   }

   glslang::TIntermediate::addAssign(*(undefined8*)( this + 0x38 ), param_3, param_4, param_5, param_1);
   return;
}
/* glslang::TParseContext::memorySemanticsCheck(glslang::TSourceLoc const&, glslang::TFunction
   const&, glslang::TIntermOperator const&) */void glslang::TParseContext::memorySemanticsCheck(TParseContext *this, TSourceLoc *param_1, TFunction *param_2, TIntermOperator *param_3) {
   code *UNRECOVERED_JUMPTABLE;
   uint uVar1;
   int iVar2;
   long *plVar3;
   long *plVar4;
   long lVar5;
   ulong uVar6;
   long lVar7;
   uint uVar8;
   uint uVar9;
   uint uVar10;
   uint uVar11;
   bool bVar12;
   uint local_5c;
   uint local_50;
   uint local_4c;
   uint local_40;
   plVar3 = (long*)( **(code**)( *(long*)param_3 + 0x90 ) )(param_3);
   if (*(code**)( *plVar3 + 0x198 ) == TIntermAggregate::getSequence) {
      plVar3 = plVar3 + 0x18;
   }
 else {
      plVar3 = (long*)( **(code**)( *plVar3 + 0x198 ) )();
   }

   plVar4 = (long*)( **(code**)( **(long**)plVar3[1] + 0x18 ) )();
   if (*(code**)( *plVar4 + 0x100 ) == TIntermTyped::getBasicType) {
      uVar10 = ( uint ) * (byte*)( plVar4 + 5 );
   }
 else {
      uVar10 = ( **(code**)( *plVar4 + 0x100 ) )(plVar4);
   }

   uVar6 = 0;
   if (uVar10 == 0xe) {
      if (*(code**)( *plVar4 + 0xf0 ) == TIntermTyped::getType) {
         plVar4 = plVar4 + 4;
      }
 else {
         plVar4 = (long*)( **(code**)( *plVar4 + 0xf0 ) )(plVar4);
      }

      if (*(code**)( *plVar4 + 0x40 ) == TType::getSampler) {
         plVar4 = plVar4 + 0x10;
      }
 else {
         plVar4 = (long*)( **(code**)( *plVar4 + 0x40 ) )();
      }

      uVar10 = *(uint*)( param_3 + 0xb8 );
      uVar6 = ( ulong )(*(byte*)( (long)plVar4 + 2 ) >> 2 & 1);
      bVar12 = uVar10 == 0x1b6;
      if (!bVar12) goto LAB_00108dfd;
      LAB_00108f70:lVar7 = ( **(code**)( **(long**)( plVar3[1] + 0x10 ) + 0x28 ) )();
      local_40 = **(uint**)( *(long*)( lVar7 + 0xc0 ) + 8 );
      plVar3 = *(long**)( plVar3[1] + 0x18 );
      LAB_00108f99:lVar7 = ( **(code**)( *plVar3 + 0x28 ) )();
      uVar8 = **(uint**)( *(long*)( lVar7 + 0xc0 ) + 8 );
      local_5c = 0;
      uVar10 = local_40;
      uVar11 = uVar8;
      LAB_00108fb8:if (( ( uVar8 & 2 ) != 0 ) && ( ( *(int*)( param_3 + 0xb8 ) == 0x1b7 || ( *(int*)( param_3 + 0xb8 ) == 0x269 ) ) )) {
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            lVar7 = *(long*)( param_2 + 8 );
         }
 else {
            lVar7 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
         }

         ( *UNRECOVERED_JUMPTABLE )(this, param_1, "gl_SemanticsAcquire must not be used with (image) atomic store", *(undefined8*)( lVar7 + 8 ), &_LC1);
      }

      if (( ( uVar8 & 4 ) != 0 ) && ( ( *(int*)( param_3 + 0xb8 ) == 0x1b6 || ( *(int*)( param_3 + 0xb8 ) == 0x268 ) ) )) {
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            lVar7 = *(long*)( param_2 + 8 );
         }
 else {
            lVar7 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
         }

         ( *UNRECOVERED_JUMPTABLE )(this, param_1, "gl_SemanticsRelease must not be used with (image) atomic load", *(undefined8*)( lVar7 + 8 ), &_LC1);
      }

      local_4c = uVar8 & 0x200c;
      uVar9 = uVar8 & 0xe;
      uVar1 = uVar8 & 0x400a;
      local_50 = uVar8 & 0x8000;
      if (( ( uVar8 & 8 ) != 0 ) && ( ( *(int*)( param_3 + 0xb8 ) - 0x1b6U < 2 || ( *(int*)( param_3 + 0xb8 ) - 0x268U < 2 ) ) )) {
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            lVar7 = *(long*)( param_2 + 8 );
         }
 else {
            lVar7 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
         }

         ( *UNRECOVERED_JUMPTABLE )(this, param_1, "gl_SemanticsAcquireRelease must not be used with (image) atomic load/store", *(undefined8*)( lVar7 + 8 ), &_LC1);
      }

      if (( uVar11 & 0xffff1ff1 ) != 0) {
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            lVar7 = *(long*)( param_2 + 8 );
         }
 else {
            lVar7 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
         }

         ( *UNRECOVERED_JUMPTABLE )(this, param_1, "Invalid semantics value", *(undefined8*)( lVar7 + 8 ), &_LC1);
      }

      if (( uVar10 & 0xffffe6bf ) != 0) {
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            lVar7 = *(long*)( param_2 + 8 );
         }
 else {
            lVar7 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
         }

         ( *UNRECOVERED_JUMPTABLE )(this, param_1, "Invalid storage class semantics value", *(undefined8*)( lVar7 + 8 ), &_LC1);
      }

      uVar10 = *(uint*)( param_3 + 0xb8 );
   }
 else {
      uVar10 = *(uint*)( param_3 + 0xb8 );
      bVar12 = uVar10 == 0x1b6;
      if (bVar12) goto LAB_00108f70;
      LAB_00108dfd:if (uVar10 < 0x1b6 || bVar12) {
         if (uVar10 != 0x135) {
            if (uVar10 < 0x136) {
               if (uVar10 == 0x134) goto LAB_00108f70;
            }
 else {
               if (uVar10 == 0x1b5) {
                  lVar7 = ( **(code**)( **(long**)( plVar3[1] + 0x20 ) + 0x28 ) )();
                  local_40 = **(uint**)( *(long*)( lVar7 + 0xc0 ) + 8 );
                  lVar7 = ( **(code**)( **(long**)( plVar3[1] + 0x28 ) + 0x28 ) )();
                  uVar8 = **(uint**)( *(long*)( lVar7 + 0xc0 ) + 8 );
                  lVar7 = ( **(code**)( **(long**)( plVar3[1] + 0x30 ) + 0x28 ) )();
                  uVar10 = **(uint**)( *(long*)( lVar7 + 0xc0 ) + 8 );
                  lVar7 = ( **(code**)( **(long**)( plVar3[1] + 0x38 ) + 0x28 ) )();
                  local_5c = **(uint**)( *(long*)( lVar7 + 0xc0 ) + 8 );
                  uVar11 = local_5c | uVar8;
                  uVar10 = uVar10 | local_40;
                  goto LAB_00108fb8;
               }

               if (0x1ac < uVar10) goto LAB_001097bc;
            }

            goto LAB_00109694;
         }

         lVar7 = ( **(code**)( **(long**)( plVar3[1] + 8 ) + 0x28 ) )();
         local_40 = **(uint**)( *(long*)( lVar7 + 0xc0 ) + 8 );
         plVar3 = *(long**)( plVar3[1] + 0x10 );
         goto LAB_00108f99;
      }

      if (uVar10 == 0x267) {
         lVar7 = ( uVar6 + 5 ) * 8;
         lVar5 = ( **(code**)( **(long**)( plVar3[1] + ( uVar6 + 5 ) * 8 ) + 0x28 ) )();
         local_40 = **(uint**)( *(long*)( lVar5 + 0xc0 ) + 8 );
         lVar5 = ( **(code**)( **(long**)( plVar3[1] + 8 + lVar7 ) + 0x28 ) )();
         uVar8 = **(uint**)( *(long*)( lVar5 + 0xc0 ) + 8 );
         lVar5 = ( **(code**)( **(long**)( plVar3[1] + 0x10 + lVar7 ) + 0x28 ) )();
         uVar10 = **(uint**)( *(long*)( lVar5 + 0xc0 ) + 8 );
         lVar7 = ( **(code**)( **(long**)( plVar3[1] + 0x18 + lVar7 ) + 0x28 ) )();
         local_5c = **(uint**)( *(long*)( lVar7 + 0xc0 ) + 8 );
         uVar11 = local_5c | uVar8;
         uVar10 = uVar10 | local_40;
         goto LAB_00108fb8;
      }

      if (uVar10 < 0x268) {
         if (uVar10 == 0x1b7) {
            LAB_001097bc:lVar7 = ( **(code**)( **(long**)( plVar3[1] + 0x18 ) + 0x28 ) )();
            local_40 = **(uint**)( *(long*)( lVar7 + 0xc0 ) + 8 );
            plVar3 = *(long**)( plVar3[1] + 0x20 );
            goto LAB_00108f99;
         }

         if (uVar10 - 0x260 < 7) {
            LAB_00109677:lVar7 = uVar6 + 4;
            goto LAB_00108e25;
         }

      }
 else {
         if (uVar10 == 0x268) {
            lVar7 = uVar6 + 3;
            LAB_00108e25:lVar5 = ( **(code**)( **(long**)( plVar3[1] + lVar7 * 8 ) + 0x28 ) )();
            local_40 = **(uint**)( *(long*)( lVar5 + 0xc0 ) + 8 );
            plVar3 = *(long**)( plVar3[1] + 8 + lVar7 * 8 );
            goto LAB_00108f99;
         }

         if (uVar10 == 0x269) goto LAB_00109677;
      }

      LAB_00109694:local_40 = 0;
      uVar9 = 0;
      uVar8 = 0;
      local_5c = 0;
      local_4c = 0;
      uVar1 = 0;
      local_50 = 0;
   }

   if (uVar10 == 0x135) {
      if (( uVar9 == 0 ) || ( ( uVar9 - 1 & uVar9 ) != 0 )) {
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            lVar7 = *(long*)( param_2 + 8 );
         }
 else {
            lVar7 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
         }

         ( *UNRECOVERED_JUMPTABLE )(this, param_1, "Semantics must include exactly one of gl_SemanticsRelease, gl_SemanticsAcquire, or gl_SemanticsAcquireRelease", *(undefined8*)( lVar7 + 8 ), &_LC1);
         LAB_001091c8:uVar10 = *(uint*)( param_3 + 0xb8 );
         if (uVar10 != 0x135) goto joined_r0x001093be;
      }

      LAB_00109360:if (local_40 != 0) goto LAB_00109243;
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
      if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
         lVar7 = *(long*)( param_2 + 8 );
      }
 else {
         lVar7 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
      }

      ( *UNRECOVERED_JUMPTABLE )(this, param_1, "Storage class semantics must not be zero", *(undefined8*)( lVar7 + 8 ), &_LC1);
      uVar10 = *(uint*)( param_3 + 0xb8 );
   }
 else if (( uVar9 == 0 ) || ( ( uVar9 - 1 & uVar9 ) == 0 )) {
      if (( local_5c & 0xe ) != 0) goto LAB_001092fd;
   }
 else {
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
      if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
         lVar7 = *(long*)( param_2 + 8 );
      }
 else {
         lVar7 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
      }

      ( *UNRECOVERED_JUMPTABLE )(this, param_1, "Semantics must not include multiple of gl_SemanticsRelease, gl_SemanticsAcquire, or gl_SemanticsAcquireRelease", *(undefined8*)( lVar7 + 8 ), &_LC1);
      if (( local_5c & 0xe ) == 0) goto LAB_001091c8;
      LAB_001092fd:if (( ( local_5c & 0xe ) - 1 & local_5c & 0xe ) == 0) goto LAB_001091c8;
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
      if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
         lVar7 = *(long*)( param_2 + 8 );
      }
 else {
         lVar7 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
      }

      ( *UNRECOVERED_JUMPTABLE )(this, param_1, "semUnequal must not include multiple of gl_SemanticsRelease, gl_SemanticsAcquire, or gl_SemanticsAcquireRelease", *(undefined8*)( lVar7 + 8 ), &_LC1);
      uVar10 = *(uint*)( param_3 + 0xb8 );
      if (uVar10 == 0x135) goto LAB_00109360;
   }

   joined_r0x001093be:if (uVar10 == 0x134) {
      if (( uVar8 == 0 ) || ( local_40 != 0 )) goto LAB_00109243;
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
      if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
         lVar7 = *(long*)( param_2 + 8 );
      }
 else {
         lVar7 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
      }

      ( *UNRECOVERED_JUMPTABLE )(this, param_1, "Storage class semantics must not be zero", *(undefined8*)( lVar7 + 8 ), &_LC1);
      uVar10 = *(uint*)( param_3 + 0xb8 );
   }

   if (( ( uVar10 == 0x267 ) || ( uVar10 == 0x1b5 ) ) && ( ( local_5c & 0xc ) != 0 )) {
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
      if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
         lVar7 = *(long*)( param_2 + 8 );
      }
 else {
         lVar7 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
      }

      ( *UNRECOVERED_JUMPTABLE )(this, param_1, "semUnequal must not be gl_SemanticsRelease or gl_SemanticsAcquireRelease", *(undefined8*)( lVar7 + 8 ), &_LC1);
   }

   LAB_00109243:if (local_4c == 0x2000) {
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
      if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
         lVar7 = *(long*)( param_2 + 8 );
      }
 else {
         lVar7 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
      }

      ( *UNRECOVERED_JUMPTABLE )(this, param_1, "gl_SemanticsMakeAvailable requires gl_SemanticsRelease or gl_SemanticsAcquireRelease", *(undefined8*)( lVar7 + 8 ), &_LC1);
   }

   if (uVar1 == 0x4000) {
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
      if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
         lVar7 = *(long*)( param_2 + 8 );
      }
 else {
         lVar7 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
      }

      ( *UNRECOVERED_JUMPTABLE )(this, param_1, "gl_SemanticsMakeVisible requires gl_SemanticsAcquire or gl_SemanticsAcquireRelease", *(undefined8*)( lVar7 + 8 ), &_LC1);
   }

   iVar2 = *(int*)( param_3 + 0xb8 );
   if (( local_50 != 0 ) && ( iVar2 - 0x134U < 2 )) {
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
      if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
         lVar7 = *(long*)( param_2 + 8 );
      }
 else {
         lVar7 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
      }

      ( *UNRECOVERED_JUMPTABLE )(this, param_1, "gl_SemanticsVolatile must not be used with memoryBarrier or controlBarrier", *(undefined8*)( lVar7 + 8 ), &_LC1);
      iVar2 = *(int*)( param_3 + 0xb8 );
   }

   if (( ( iVar2 == 0x1b5 ) || ( iVar2 == 0x267 ) ) && ( ( ( uVar8 ^ local_5c ) & 0x8000 ) != 0 )) {
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
      if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
         lVar7 = *(long*)( param_2 + 8 );
      }
 else {
         lVar7 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
      }

      /* WARNING: Could not recover jumptable at 0x00109496. Too many branches */
      /* WARNING: Treating indirect jump as call */
      ( *UNRECOVERED_JUMPTABLE )(this, param_1, "semEqual and semUnequal must either both include gl_SemanticsVolatile or neither", *(undefined8*)( lVar7 + 8 ), &_LC1);
      return;
   }

   return;
}
/* glslang::TParseContext::samplerConstructorLocationCheck(glslang::TSourceLoc const&, char const*,
   TIntermNode*) */void glslang::TParseContext::samplerConstructorLocationCheck(TParseContext *this, TSourceLoc *param_1, char *param_2, TIntermNode *param_3) {
   long lVar1;
   lVar1 = ( **(code**)( *(long*)param_3 + 0x20 ) )(param_3);
   if (lVar1 != 0) {
      lVar1 = ( **(code**)( *(long*)param_3 + 0x20 ) )(param_3);
      if (*(int*)( lVar1 + 0xb8 ) == 0x242) {
         /* WARNING: Could not recover jumptable at 0x001099be. Too many branches */
         /* WARNING: Treating indirect jump as call */
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "sampler constructor must appear at point of use", param_2, &_LC1, *(code**)( *(long*)this + 0x158 ));
         return;
      }

   }

   return;
}
/* glslang::TParseContext::userFunctionCallCheck(glslang::TSourceLoc const&,
   glslang::TIntermAggregate&) */void glslang::TParseContext::userFunctionCallCheck(TParseContext *this, TSourceLoc *param_1, TIntermAggregate *param_2) {
   long lVar1;
   TIntermAggregate *pTVar2;
   long lVar3;
   long lVar4;
   if (*(code**)( *(long*)param_2 + 400 ) == TIntermAggregate::getSequence) {
      pTVar2 = param_2 + 0xc0;
   }
 else {
      pTVar2 = (TIntermAggregate*)( **(code**)( *(long*)param_2 + 400 ) )();
   }

   lVar3 = *(long*)( pTVar2 + 8 );
   if (0 < (int)( *(long*)( pTVar2 + 0x10 ) - lVar3 >> 3 )) {
      lVar4 = 0;
      do {
         lVar1 = lVar4 * 8;
         lVar4 = lVar4 + 1;
         samplerConstructorLocationCheck(this, param_1, "call argument", *(TIntermNode**)( lVar3 + lVar1 ));
         lVar3 = *(long*)( pTVar2 + 8 );
      }
 while ( (int)lVar4 < (int)( *(long*)( pTVar2 + 0x10 ) - lVar3 >> 3 ) );
   }

   return;
}
/* glslang::TParseContext::handlePrecisionQualifier(glslang::TSourceLoc const&,
   glslang::TQualifier&, glslang::TPrecisionQualifier) */void glslang::TParseContext::handlePrecisionQualifier(TParseContext *this, undefined8 param_2_00, long param_2, byte param_4) {
   if (this[0x7378] != (TParseContext)0x0) {
      *(byte*)( param_2 + 0xb ) = *(byte*)( param_2 + 0xb ) & 0xf1 | ( param_4 & 7 ) * '\x02';
   }

   return;
}
/* glslang::TParseContext::checkPrecisionQualifier(glslang::TSourceLoc const&,
   glslang::TPrecisionQualifier) */void glslang::TParseContext::checkPrecisionQualifier(long *param_1, undefined8 param_2) {
   if (*(char*)( (long)param_1 + 0x7379 ) != '\0') {
      ( **(code**)( *param_1 + 0x160 ) )(param_1, param_2, "all default precisions are highp; use precision statements to quiet warning, e.g.:\n         \"precision mediump int; precision highp float;\"", &_LC1);
      *(undefined1*)( (long)param_1 + 0x7379 ) = 0;
      return;
   }

   return;
}
/* glslang::TParseContext::assignError(glslang::TSourceLoc const&, char const*,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >) */void glslang::TParseContext::assignError(TParseContext *this, undefined8 param_1, undefined8 param_2, long param_4, long param_5) {
   ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, &_LC1, param_2, "cannot convert from \'%s\' to \'%s\'", *(undefined8*)( param_5 + 8 ), *(undefined8*)( param_4 + 8 ));
   return;
}
/* glslang::TParseContext::unaryOpError(glslang::TSourceLoc const&, char const*,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >) */void glslang::TParseContext::unaryOpError(TParseContext *this, undefined8 param_1, undefined8 param_2, long param_4) {
   ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, " wrong operand type", param_2, "no operation \'%s\' exists that takes an operand of type %s (or there is no acceptable conversion)", param_2, *(undefined8*)( param_4 + 8 ));
   return;
}
/* glslang::TParseContext::binaryOpError(glslang::TSourceLoc const&, char const*,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >) */void glslang::TParseContext::binaryOpError(TParseContext *this, undefined8 param_1, undefined8 param_2, long param_4, long param_5) {
   ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, " wrong operand types:", param_2, "no operation \'%s\' exists that takes a left-hand operand of type \'%s\' and a right operand of type \'%s\' (or there is no acceptable conversion)", param_2, *(undefined8*)( param_4 + 8 ), *(undefined8*)( param_5 + 8 ));
   return;
}
/* glslang::TParseContext::constantValueCheck(glslang::TIntermTyped*, char const*) */void glslang::TParseContext::constantValueCheck(TParseContext *this, TIntermTyped *param_1, char *param_2) {
   code *UNRECOVERED_JUMPTABLE;
   TIntermTyped *pTVar1;
   if (*(code**)( *(long*)param_1 + 0x108 ) == TIntermTyped::getQualifier) {
      pTVar1 = param_1 + 0x30;
   }
 else {
      pTVar1 = (TIntermTyped*)( **(code**)( *(long*)param_1 + 0x108 ) )(param_1);
   }

   if (( ( (byte)pTVar1[8] & 0x7f ) != 2 ) && ( ( (byte)pTVar1[0xc] & 1 ) == 0 )) {
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
      if ((code*)**(undefined8**)param_1 == TIntermNode::getLoc) {
         pTVar1 = param_1 + 8;
      }
 else {
         pTVar1 = (TIntermTyped*)( *(code*)**(undefined8**)param_1 )(param_1);
      }

      /* WARNING: Could not recover jumptable at 0x00109c07. Too many branches */
      /* WARNING: Treating indirect jump as call */
      ( *UNRECOVERED_JUMPTABLE )(this, pTVar1, "constant expression required", param_2, &_LC1, UNRECOVERED_JUMPTABLE);
      return;
   }

   return;
}
/* glslang::TParseContext::integerCheck(glslang::TIntermTyped const*, char const*) */void glslang::TParseContext::integerCheck(TParseContext *this, TIntermTyped *param_1, char *param_2) {
   code *UNRECOVERED_JUMPTABLE;
   char cVar1;
   uint uVar2;
   TIntermTyped *pTVar3;
   undefined8 *puVar4;
   if (*(code**)( *(long*)param_1 + 0x100 ) == TIntermTyped::getBasicType) {
      uVar2 = (uint)(byte)param_1[0x28];
   }
 else {
      uVar2 = ( **(code**)( *(long*)param_1 + 0x100 ) )(param_1);
   }

   if (uVar2 - 8 < 2) {
      LAB_00109c83:puVar4 = *(undefined8**)param_1;
      if ((code*)puVar4[0x2c] == TIntermTyped::isScalar) {
         if (( ( ( ( (byte)param_1[0x29] & 0xf ) < 2 ) && ( ( (byte)param_1[0x2a] & 0x10 ) == 0 ) ) && ( (byte)param_1[0x29] < 0x10 ) ) && ( ( 1 < ( byte )((char)param_1[0x28] - 0xfU) && ( *(long*)( param_1 + 0x80 ) == 0 ) ) )) {
            return;
         }

         goto LAB_00109ca8;
      }

      cVar1 = ( *(code*)puVar4[0x2c] )(param_1);
      if (cVar1 != '\0') {
         return;
      }

   }
 else {
      cVar1 = glslang::TIntermediate::canImplicitlyPromote(*(undefined8*)( this + 0x38 ), uVar2, 8, 0);
      if (cVar1 != '\0') goto LAB_00109c83;
      cVar1 = glslang::TIntermediate::canImplicitlyPromote(*(undefined8*)( this + 0x38 ), uVar2, 9, 0);
      if (cVar1 != '\0') goto LAB_00109c83;
   }

   puVar4 = *(undefined8**)param_1;
   LAB_00109ca8:UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
   if ((code*)*puVar4 == TIntermNode::getLoc) {
      pTVar3 = param_1 + 8;
   }
 else {
      pTVar3 = (TIntermTyped*)( *(code*)*puVar4 )(param_1);
   }

   /* WARNING: Could not recover jumptable at 0x00109ced. Too many branches */
   /* WARNING: Treating indirect jump as call */
   ( *UNRECOVERED_JUMPTABLE )(this, pTVar3, "scalar integer expression required", param_2, &_LC1, UNRECOVERED_JUMPTABLE);
   return;
}
/* glslang::TParseContext::globalCheck(glslang::TSourceLoc const&, char const*) */void glslang::TParseContext::globalCheck(TParseContext *this, TSourceLoc *param_1, char *param_2) {
   if (4 < (int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 )) {
      /* WARNING: Could not recover jumptable at 0x00109dd8. Too many branches */
      /* WARNING: Treating indirect jump as call */
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "not allowed in nested scope", param_2, &_LC1, *(code**)( *(long*)this + 0x158 ));
      return;
   }

   return;
}
/* glslang::TParseContext::reservedErrorCheck(glslang::TSourceLoc const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const&)
    */void glslang::TParseContext::reservedErrorCheck(TParseContext *this, TSourceLoc *param_1, basic_string *param_2) {
   if ((int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 ) < 4) {
      return;
   }

   reservedErrorCheck(this, param_1, param_2);
   return;
}
/* glslang::TParseContext::builtInName(std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const&) */bool glslang::TParseContext::builtInName(TParseContext *this, basic_string *param_1) {
   ulong uVar1;
   int iVar2;
   size_t __n;
   uVar1 = *(ulong*)( param_1 + 0x10 );
   if (uVar1 != 0) {
      __n = 3;
      if (uVar1 < 4) {
         __n = uVar1;
      }

      iVar2 = memcmp(*(void**)( param_1 + 8 ), &_LC61, __n);
      if (iVar2 == 0) {
         return (int)__n == 3;
      }

   }

   return false;
}
/* glslang::TParseContext::voidErrorCheck(glslang::TSourceLoc const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const&,
   glslang::TBasicType) */undefined8 glslang::TParseContext::voidErrorCheck(TParseContext *this, undefined8 param_1, long param_2, int param_4) {
   if (param_4 != 0) {
      return 0;
   }

   ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "illegal use of type \'void\'", *(undefined8*)( param_2 + 8 ), &_LC1);
   return 1;
}
/* glslang::TParseContext::boolCheck(glslang::TSourceLoc const&, glslang::TIntermTyped const*) */void glslang::TParseContext::boolCheck(TParseContext *this, TSourceLoc *param_1, TIntermTyped *param_2) {
   char cVar1;
   byte bVar2;
   uint uVar3;
   long lVar4;
   if (*(code**)( *(long*)param_2 + 0x100 ) == TIntermTyped::getBasicType) {
      uVar3 = (uint)(byte)param_2[0x28];
   }
 else {
      uVar3 = ( **(code**)( *(long*)param_2 + 0x100 ) )(param_2);
   }

   if (uVar3 == 0xc) {
      lVar4 = *(long*)param_2;
      if (*(code**)( lVar4 + 0x150 ) == TIntermTyped::isArray) {
         if (*(long*)( param_2 + 0x80 ) != 0) goto LAB_00109ef3;
      }
 else {
         cVar1 = ( **(code**)( lVar4 + 0x150 ) )(param_2);
         if (cVar1 != '\0') goto LAB_00109ef3;
         lVar4 = *(long*)param_2;
      }

      if (*(code**)( lVar4 + 0x148 ) == TIntermTyped::isMatrix) {
         if (0xf < (byte)param_2[0x29]) goto LAB_00109ef3;
      }
 else {
         cVar1 = ( **(code**)( lVar4 + 0x148 ) )(param_2);
         if (cVar1 != '\0') goto LAB_00109ef3;
         lVar4 = *(long*)param_2;
      }

      if (*(code**)( lVar4 + 0x158 ) == TIntermTyped::isVector) {
         if (1 < ( (byte)param_2[0x29] & 0xf )) goto LAB_00109ef3;
         bVar2 = (byte)param_2[0x2a] >> 4 & 1;
      }
 else {
         bVar2 = ( **(code**)( lVar4 + 0x158 ) )(param_2);
      }

      if (bVar2 == 0) {
         return;
      }

   }

   LAB_00109ef3:/* WARNING: Could not recover jumptable at 0x00109f1a. Too many branches *//* WARNING: Treating indirect jump as call */( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "boolean expression expected", &_LC1, &_LC1, *(code**)( *(long*)this + 0x158 ));
   return;
}
/* glslang::TParseContext::boolCheck(glslang::TSourceLoc const&, glslang::TPublicType const&) */void glslang::TParseContext::boolCheck(TParseContext *this, TSourceLoc *param_1, TPublicType *param_2) {
   if (( ( ( *(int*)param_2 == 0xc ) && ( *(long*)( param_2 + 0xc0 ) == 0 ) ) && ( (byte)param_2[0xb8] < 0x20 ) ) && ( ( (byte)param_2[0xb8] & 0xf ) < 2 )) {
      return;
   }

   /* WARNING: Could not recover jumptable at 0x0010a046. Too many branches */
   /* WARNING: Treating indirect jump as call */
   ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "boolean expression expected", &_LC1, &_LC1, *(code**)( *(long*)this + 0x158 ));
   return;
}
/* glslang::TParseContext::transparentOpaqueCheck(glslang::TSourceLoc const&, glslang::TType const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const&)
    */void glslang::TParseContext::transparentOpaqueCheck(TParseContext *this, TSourceLoc *param_1, TType *param_2, basic_string *param_3) {
   TType TVar1;
   code *pcVar2;
   long lVar3;
   char cVar4;
   long lVar5;
   TType *pTVar6;
   if (this[0x1c1] != (TParseContext)0x0) {
      return;
   }

   if (*(code**)( *(long*)param_2 + 0x58 ) == TType::getQualifier) {
      pTVar6 = param_2 + 0x10;
   }
 else {
      pTVar6 = (TType*)( **(code**)( *(long*)param_2 + 0x58 ) )(param_2);
   }

   if (( (byte)pTVar6[8] & 0x7f ) == 5) {
      pcVar2 = *(code**)( *(long*)param_2 + 0x1c8 );
      if (pcVar2 == TType::containsNonOpaque) {
         TVar1 = param_2[8];
         if (( 0xc < (byte)TVar1 ) && ( TVar1 != (TType)0x12 )) {
            pcVar2 = *(code**)( *(long*)param_2 + 0x128 );
            if (pcVar2 == TType::isStruct) {
               if (1 < ( byte )((char)TVar1 - 0xfU)) {
                  return;
               }

            }
 else {
               cVar4 = ( *pcVar2 )(param_2);
               if (cVar4 == '\0') {
                  return;
               }

            }

            lVar3 = *(long*)( *(long*)( param_2 + 0x68 ) + 0x10 );
            lVar5 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsNonOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsNonOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_2 + 0x68 ) + 8 ),lVar3 ));
            if (lVar3 == lVar5) {
               return;
            }

         }

      }
 else {
         cVar4 = ( *pcVar2 )(param_2);
         if (cVar4 == '\0') {
            return;
         }

      }

      if (( 0 < *(int*)( this + 0x28 ) ) && ( this[0x30] == (TParseContext)0x0 )) {
         ( **(code**)( *(long*)this + 0x138 ) )(this, param_1, "non-opaque uniforms outside a block");
      }

      if (0 < *(int*)( this + 0x2c )) {
         if (*(code**)( *(long*)param_2 + 0x58 ) == TType::getQualifier) {
            pTVar6 = param_2 + 0x10;
         }
 else {
            pTVar6 = (TType*)( **(code**)( *(long*)param_2 + 0x58 ) )(param_2);
         }

         if (( ( ~*(ushort *)(pTVar6 + 0x1c) & 0xfff ) == 0 ) && ( *(char*)( *(long*)( this + 0x38 ) + 0x4d1 ) == '\0' )) {
            /* WARNING: Could not recover jumptable at 0x0010a1bc. Too many branches */
            /* WARNING: Treating indirect jump as call */
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "non-opaque uniform variables need a layout(location=L)", *(undefined8*)( param_3 + 8 ), &_LC1, *(code**)( *(long*)this + 0x158 ));
            return;
         }

      }

   }

   return;
}
/* glslang::TParseContext::computeSamplerTypeIndex(glslang::TSampler&) */int glslang::TParseContext::computeSamplerTypeIndex(TParseContext *this, TSampler *param_1) {
   TSampler TVar1;
   TVar1 = param_1[2];
   return ( ( uint )(byte) * param_1 + ( ( (byte)param_1[3] >> 5 & 1 ) + ( ( (byte)TVar1 >> 1 & 1 ) + ( ( (byte)TVar1 >> 3 & 1 ) + ( ( (byte)TVar1 >> 2 & 1 ) + ( (byte)TVar1 & 1 ) * 2 ) * 2 ) * 2 ) * 2 ) * 0x18 ) * 9 + (uint)(byte)param_1[1];
}
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address *//* glslang::TParseContext::setPrecisionDefaults() */void glslang::TParseContext::setPrecisionDefaults(TParseContext *this) {
   undefined8 uVar1;
   undefined8 uVar2;
   undefined8 uVar3;
   int iVar4;
   TParseContext *pTVar5;
   TParseContext *pTVar6;
   ulong uVar7;
   undefined8 *puVar8;
   TParseContext TVar9;
   TSampler *pTVar10;
   long in_FS_OFFSET;
   undefined4 local_14;
   long local_10;
   local_10 = *(long*)( in_FS_OFFSET + 0x28 );
   *(undefined8*)( this + 0x560 ) = 0;
   *(undefined8*)( this + 0x5b8 ) = 0;
   puVar8 = (undefined8*)( ( ulong )(this + 0x568) & 0xfffffffffffffff8 );
   for (uVar7 = ( ulong )(( (int)this - (int)(undefined8*)( ( ulong )(this + 0x568) & 0xfffffffffffffff8 ) ) + 0x5c0U >> 3); uVar7 != 0; uVar7 = uVar7 - 1) {
      *puVar8 = 0;
      puVar8 = puVar8 + 1;
   }

   pTVar5 = (TParseContext*)memset(this + 0x770, 0, 0x6c00);
   uVar1 = _LC374;
   if (this[0x7378] != (TParseContext)0x0) {
      TVar9 = this[0x1c1];
      if (*(int*)( this + 0xc ) == 8) {
         pTVar10 = (TSampler*)&local_14;
         local_14 = local_14 & 0xdff00000 | 0x201;
         pTVar5 = this;
         iVar4 = computeSamplerTypeIndex(this, pTVar10);
         local_14._0_2_ = CONCAT11(4, local_14._0_1_);
         *(undefined4*)( this + (long)iVar4 * 4 + 0x770 ) = 1;
         iVar4 = computeSamplerTypeIndex(pTVar5, pTVar10);
         *(undefined4*)( this + (long)iVar4 * 4 + 0x770 ) = 1;
         local_14 = local_14 & 0xdfff00ff | 0x20000200;
         iVar4 = computeSamplerTypeIndex(pTVar5, pTVar10);
         *(undefined4*)( this + (long)iVar4 * 4 + 0x770 ) = 1;
         uVar1 = _LC374;
         if (TVar9 == (TParseContext)0x0) {
            if (*(int*)( this + 0x1c ) == 4) {
               *(undefined8*)( this + 0x580 ) = _LC373;
            }
 else {
               *(undefined4*)( this + 0x564 ) = 3;
               *(undefined8*)( this + 0x580 ) = uVar1;
            }

         }

      }
 else if (TVar9 == (TParseContext)0x0) {
         *(undefined4*)( this + 0x564 ) = 3;
         uVar3 = _UNK_00168668;
         uVar2 = _LC374;
         *(undefined8*)( this + 0x580 ) = uVar1;
         do {
            *(undefined8*)pTVar5 = uVar2;
            *(undefined8*)( pTVar5 + 8 ) = uVar3;
            pTVar6 = pTVar5 + 0x20;
            *(undefined8*)( pTVar5 + 0x10 ) = uVar2;
            *(undefined8*)( pTVar5 + 0x18 ) = uVar3;
            pTVar5 = pTVar6;
         }
 while ( this + 0x7370 != pTVar6 );
      }

      *(undefined8*)( this + 0x594 ) = _LC376;
   }

   if (local_10 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::setDefaultPrecision(glslang::TSourceLoc const&, glslang::TPublicType&,
   glslang::TPrecisionQualifier) */void glslang::TParseContext::setDefaultPrecision(TParseContext *this, undefined8 param_1, int *param_2, int param_4) {
   int iVar1;
   char *pcVar2;
   iVar1 = *param_2;
   if (iVar1 == 0xe) {
      iVar1 = computeSamplerTypeIndex(this, (TSampler*)( param_2 + 1 ));
      *(int*)( this + (long)iVar1 * 4 + 0x770 ) = param_4;
      return;
   }

   if (( iVar1 == 8 ) || ( iVar1 == 1 )) {
      if (( (char)param_2[0x2e] == '\x01' ) && ( ( *(long*)( param_2 + 0x30 ) == 0 && ( *(long*)( param_2 + 0x32 ) == 0 ) ) )) {
         *(int*)( this + (long)iVar1 * 4 + 0x560 ) = param_4;
         if (iVar1 == 8) {
            *(int*)( this + 0x584 ) = param_4;
            this[0x737a] = (TParseContext)0x1;
            if (this[0x737b] == (TParseContext)0x0) {
               return;
            }

         }
 else {
            this[0x737b] = (TParseContext)0x1;
            if (this[0x737a] == (TParseContext)0x0) {
               return;
            }

         }

         this[0x7379] = (TParseContext)0x0;
         return;
      }

   }
 else if (iVar1 == 0xd) {
      if (param_4 == 3) {
         return;
      }

      /* WARNING: Could not recover jumptable at 0x0010a457. Too many branches */
      /* WARNING: Treating indirect jump as call */
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply highp to atomic_uint", "precision", &_LC1, *(code**)( *(long*)this + 0x158 ));
      return;
   }

   switch (iVar1) {
      case 0:
    pcVar2 = "void";
    break;
      case 1:
    pcVar2 = "float";
    break;
      case 2:
    pcVar2 = "double";
    break;
      case 3:
    pcVar2 = "float16_t";
    break;
      case 4:
    pcVar2 = "int8_t";
    break;
      case 5:
    pcVar2 = "uint8_t";
    break;
      case 6:
    pcVar2 = "int16_t";
    break;
      case 7:
    pcVar2 = "uint16_t";
    break;
      case 8:
    pcVar2 = "int";
    break;
      case 9:
    pcVar2 = "uint";
    break;
      case 10:
    pcVar2 = "int64_t";
    break;
      case 0xb:
    pcVar2 = "uint64_t";
    break;
      case 0xc:
    pcVar2 = "bool";
    break;
      default:
    pcVar2 = "unknown type";
    break;
      case 0xf:
    pcVar2 = "structure";
    break;
      case 0x10:
    pcVar2 = "block";
    break;
      case 0x11:
    pcVar2 = "accelerationStructureNV";
    break;
      case 0x12:
    pcVar2 = "reference";
    break;
      case 0x13:
    pcVar2 = "rayQueryEXT";
    break;
      case 0x15:
    pcVar2 = "coopmat";
    break;
      case 0x16:
    pcVar2 = "spirv_type";
    break;
      case 0x17:
    pcVar2 = "string";
   }

   /* WARNING: Could not recover jumptable at 0x0010a527. Too many branches */
   /* WARNING: Treating indirect jump as call */
   ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot apply precision statement to this type; use \'float\', \'int\' or a sampler type", pcVar2, &_LC1, *(code**)( *(long*)this + 0x158 ));
   return;
}
/* glslang::TParseContext::getDefaultPrecision(glslang::TPublicType&) */undefined4 glslang::TParseContext::getDefaultPrecision(TParseContext *this, TPublicType *param_1) {
   TPublicType TVar1;
   if (*(int*)param_1 == 0xe) {
      TVar1 = param_1[6];
      return *(undefined4*)( this + (long)(int)( (uint)(byte)param_1[5] + ( (uint)(byte)param_1[4] + ( ( (byte)param_1[7] >> 5 & 1 ) + ( ( (byte)TVar1 >> 1 & 1 ) + ( ( (byte)TVar1 >> 3 & 1 ) + ( ( (byte)TVar1 >> 2 & 1 ) + ( (byte)TVar1 & 1 ) * 2 ) * 2 ) * 2 ) * 2 ) * 0x18 ) * 9 ) * 4 + 0x770 );
   }

   return *(undefined4*)( this + (long)*(int*)param_1 * 4 + 0x560 );
}
/* glslang::TParseContext::precisionQualifierCheck(glslang::TSourceLoc const&, glslang::TBasicType,
   glslang::TQualifier&, bool) */void glslang::TParseContext::precisionQualifierCheck(TParseContext *this, undefined8 param_1, uint param_3, long param_4, char param_5) {
   byte bVar1;
   char *pcVar2;
   char *pcVar3;
   code *pcVar4;
   if (( this[0x7378] == (TParseContext)0x0 ) || ( this[0x1c1] != (TParseContext)0x0 )) {
      return;
   }

   if (param_3 == 0xd) {
      if (( *(byte*)( param_4 + 0xb ) & 0xe ) != 0) {
         if (( *(byte*)( param_4 + 0xb ) & 0xe ) == 6) {
            return;
         }

         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "atomic counters can only be highp", "atomic_uint", &_LC1);
         if (param_5 != '\0') {
            return;
         }

         bVar1 = *(byte*)( param_4 + 0xb );
         goto LAB_0010a841;
      }

      if (param_5 != '\0') {
         return;
      }

      if (( (byte)this[0xd0] & 1 ) != 0) {
         pcVar4 = *(code**)( *(long*)this + 0x160 );
         goto switchD_0010a875_caseD_d;
      }

      pcVar4 = *(code**)( *(long*)this + 0x158 );
      switchD_0010aa2c_caseD_d:pcVar2 = "atomic_uint";
   }
 else {
      if (param_5 != '\0') {
         return;
      }

      bVar1 = *(byte*)( param_4 + 0xb );
      if (( 0xe < param_3 ) || ( ( 0x4302UL >> ( (ulong)param_3 & 0x3f ) & 1 ) == 0 )) {
         if (( bVar1 & 0xe ) == 0) {
            return;
         }

         switch ((ulong)param_3) {
            case 0:
        pcVar2 = "void";
        break;
            default:
        pcVar2 = "unknown type";
        break;
            case 2:
        pcVar2 = "double";
        break;
            case 3:
        pcVar2 = "float16_t";
        break;
            case 4:
        pcVar2 = "int8_t";
        break;
            case 5:
        pcVar2 = "uint8_t";
        break;
            case 6:
        pcVar2 = "int16_t";
        break;
            case 7:
        pcVar2 = "uint16_t";
        break;
            case 8:
        pcVar2 = "int";
        break;
            case 9:
        pcVar2 = "uint";
        break;
            case 10:
        pcVar2 = "int64_t";
        break;
            case 0xb:
        pcVar2 = "uint64_t";
        break;
            case 0xc:
        pcVar2 = "bool";
        break;
            case 0xe:
        pcVar2 = "sampler/image";
        break;
            case 0xf:
        pcVar2 = "structure";
        break;
            case 0x10:
        pcVar2 = "block";
        break;
            case 0x11:
        pcVar2 = "accelerationStructureNV";
        break;
            case 0x12:
        pcVar2 = "reference";
        break;
            case 0x13:
        pcVar2 = "rayQueryEXT";
        break;
            case 0x15:
        pcVar2 = "coopmat";
        break;
            case 0x16:
        pcVar2 = "spirv_type";
        break;
            case 0x17:
        pcVar2 = "string";
         }

         /* WARNING: Could not recover jumptable at 0x0010a898. Too many branches */
         /* WARNING: Treating indirect jump as call */
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "type cannot have precision qualifier", pcVar2, &_LC1, *(code**)( *(long*)this + 0x158 ));
         return;
      }

      LAB_0010a841:if (( bVar1 & 0xe ) != 0) {
         return;
      }

      if (( (byte)this[0xd0] & 1 ) != 0) {
         pcVar4 = *(code**)( *(long*)this + 0x160 );
         switch (param_3) {
            default:
        pcVar2 = "float";
        break;
            case 2:
        pcVar2 = "double";
        break;
            case 3:
        pcVar2 = "float16_t";
        break;
            case 4:
        pcVar2 = "int8_t";
        break;
            case 5:
        pcVar2 = "uint8_t";
        break;
            case 6:
        pcVar2 = "int16_t";
        break;
            case 7:
        pcVar2 = "uint16_t";
        break;
            case 8:
        pcVar2 = "int";
        break;
            case 9:
        pcVar2 = "uint";
        break;
            case 10:
        pcVar2 = "int64_t";
        break;
            case 0xb:
        pcVar2 = "uint64_t";
        break;
            case 0xc:
        pcVar2 = "bool";
        break;
            case 0xd:
switchD_0010a875_caseD_d:
        pcVar2 = "atomic_uint";
        break;
            case 0xe:
        pcVar2 = "sampler/image";
         }

         pcVar3 = "substituting \'mediump\'";
         goto LAB_0010a7bf;
      }

      pcVar4 = *(code**)( *(long*)this + 0x158 );
      switch (param_3) {
         case 2:
      pcVar2 = "double";
      break;
         case 3:
      pcVar2 = "float16_t";
      break;
         case 4:
      pcVar2 = "int8_t";
      break;
         case 5:
      pcVar2 = "uint8_t";
      break;
         case 6:
      pcVar2 = "int16_t";
      break;
         case 7:
      pcVar2 = "uint16_t";
      break;
         case 8:
      pcVar2 = "int";
      break;
         case 9:
      pcVar2 = "uint";
      break;
         case 10:
      pcVar2 = "int64_t";
      break;
         case 0xb:
      pcVar2 = "uint64_t";
      break;
         case 0xc:
      pcVar2 = "bool";
      break;
         case 0xd:
      goto switchD_0010aa2c_caseD_d;
         case 0xe:
      pcVar2 = "sampler/image";
      break;
         default:
      pcVar2 = "float";
      }

   }

   pcVar3 = "";
   LAB_0010a7bf:( *pcVar4 )(this, param_1, "type requires declaration of default precision qualifier", pcVar2, pcVar3);
   *(byte*)( param_4 + 0xb ) = *(byte*)( param_4 + 0xb ) & 0xf1 | 4;
   *(undefined4*)( this + (long)(int)param_3 * 4 + 0x560 ) = 2;
   return;
}
/* glslang::TParseContext::containsFieldWithBasicType(glslang::TType const&, glslang::TBasicType) */undefined8 glslang::TParseContext::containsFieldWithBasicType(TParseContext *this, long *param_1, uint param_3) {
   long lVar1;
   char cVar2;
   uint uVar3;
   long lVar4;
   ulong uVar5;
   if (*(code**)( *param_1 + 0x38 ) == TType::getBasicType) {
      uVar3 = ( uint ) * (byte*)( param_1 + 1 );
      if (param_3 != *(byte*)( param_1 + 1 )) {
         LAB_0010ab02:if (uVar3 == 0xf) {
            lVar1 = param_1[0xd];
            lVar4 = *(long*)( lVar1 + 8 );
            if (*(long*)( lVar1 + 0x10 ) != lVar4) {
               uVar5 = 0;
               do {
                  cVar2 = containsFieldWithBasicType(this, *(undefined8*)( lVar4 + uVar5 * 0x20 ), param_3);
                  if (cVar2 != '\0') {
                     return 1;
                  }

                  lVar4 = *(long*)( lVar1 + 8 );
                  uVar5 = ( ulong )((int)uVar5 + 1);
               }
 while ( uVar5 < ( ulong )(*(long*)( lVar1 + 0x10 ) - lVar4 >> 5) );
            }

         }

         return 0;
      }

   }
 else {
      uVar3 = ( **(code**)( *param_1 + 0x38 ) )(param_1);
      if (param_3 != uVar3) {
         if (*(code**)( *param_1 + 0x38 ) == TType::getBasicType) {
            uVar3 = ( uint ) * (byte*)( param_1 + 1 );
         }
 else {
            uVar3 = ( **(code**)( *param_1 + 0x38 ) )(param_1);
         }

         goto LAB_0010ab02;
      }

   }

   return 1;
}
/* glslang::TParseContext::arraySizeCheck(glslang::TSourceLoc const&, glslang::TIntermTyped*,
   glslang::TArraySize&, char const*, bool) */void glslang::TParseContext::arraySizeCheck(TParseContext *this, TSourceLoc *param_1, TIntermTyped *param_2, TArraySize *param_3, char *param_4, bool param_5) {
   int iVar1;
   uint uVar2;
   int iVar3;
   long lVar4;
   TIntermTyped *pTVar5;
   long *plVar6;
   undefined8 uVar7;
   char *pcVar8;
   code *UNRECOVERED_JUMPTABLE;
   lVar4 = *(long*)param_2;
   *(undefined8*)( param_3 + 8 ) = 0;
   lVar4 = ( **(code**)( lVar4 + 0x28 ) )(param_2);
   if (lVar4 == 0) {
      lVar4 = *(long*)param_2;
      if (*(code**)( lVar4 + 0x108 ) == TIntermTyped::getQualifier) {
         pTVar5 = param_2 + 0x30;
      }
 else {
         pTVar5 = (TIntermTyped*)( **(code**)( lVar4 + 0x108 ) )(param_2);
         lVar4 = *(long*)param_2;
      }

      if (( (byte)pTVar5[0xc] & 1 ) != 0) {
         *(TIntermTyped**)( param_3 + 8 ) = param_2;
         lVar4 = ( **(code**)( lVar4 + 0x60 ) )(param_2);
         if (( ( lVar4 == 0 ) || ( lVar4 = lVar4 == 0 ) ) || ( (int)( *(long*)( lVar4 + 0x10 ) - (long)*(int**)( lVar4 + 8 ) >> 4 ) < 1 )) {
            LAB_0010adf0:iVar3 = 1;
         }
 else {
            iVar3 = **(int**)( lVar4 + 8 );
         }

         goto LAB_0010abe9;
      }

      lVar4 = ( **(code**)( lVar4 + 0x38 ) )(param_2);
      if (lVar4 != 0) {
         lVar4 = ( **(code**)( *(long*)param_2 + 0x38 ) )(param_2);
         if (*(int*)( lVar4 + 0xb8 ) == 600) {
            plVar6 = (long*)( **(code**)( *(long*)param_2 + 0x38 ) )(param_2);
            if (*(code**)( *plVar6 + 0x188 ) == TIntermUnary::getOperand) {
               plVar6 = (long*)plVar6[0x18];
            }
 else {
               plVar6 = (long*)( **(code**)( *plVar6 + 0x188 ) )();
            }

            if (*(code**)( *plVar6 + 0xf0 ) == TIntermTyped::getType) {
               plVar6 = plVar6 + 4;
            }
 else {
               plVar6 = (long*)( **(code**)( *plVar6 + 0xf0 ) )();
            }

            if (( *(byte*)( (long)plVar6 + 10 ) & 0x20 ) != 0) {
               uVar7 = ( **(code**)( *(long*)param_2 + 0x38 ) )(param_2);
               *(undefined8*)( param_3 + 8 ) = uVar7;
               goto LAB_0010adf0;
            }

         }

      }

      *(undefined4*)param_3 = 1;
      LAB_0010ac8b:pcVar8 = "must be a constant integer expression";
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
      LAB_0010ac9d:/* WARNING: Could not recover jumptable at 0x0010acbd. Too many branches *//* WARNING: Treating indirect jump as call */( *UNRECOVERED_JUMPTABLE )(this, param_1, param_4, &_LC1, pcVar8, UNRECOVERED_JUMPTABLE);
      return;
   }

   iVar3 = **(int**)( *(long*)( lVar4 + 0xc0 ) + 8 );
   LAB_0010abe9:*(int*)param_3 = iVar3;
   if (*(code**)( *(long*)param_2 + 0x100 ) == TIntermTyped::getBasicType) {
      uVar2 = (uint)(byte)param_2[0x28];
      if (param_2[0x28] != (TIntermTyped)0x8) {
         LAB_0010ac0e:if (uVar2 != 9) goto LAB_0010ac8b;
      }

   }
 else {
      iVar1 = ( **(code**)( *(long*)param_2 + 0x100 ) )(param_2);
      if (iVar1 != 8) {
         if (*(code**)( *(long*)param_2 + 0x100 ) == TIntermTyped::getBasicType) {
            uVar2 = (uint)(byte)param_2[0x28];
         }
 else {
            uVar2 = ( **(code**)( *(long*)param_2 + 0x100 ) )(param_2);
         }

         goto LAB_0010ac0e;
      }

   }

   if (param_5) {
      if (iVar3 < 0) {
         pcVar8 = "must be a non-negative integer";
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         goto LAB_0010ac9d;
      }

   }
 else if (iVar3 < 1) {
      pcVar8 = "must be a positive integer";
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
      goto LAB_0010ac9d;
   }

   return;
}
/* glslang::TParseContext::arrayQualifierError(glslang::TSourceLoc const&, glslang::TQualifier
   const&) */undefined8 glslang::TParseContext::arrayQualifierError(TParseContext *this, TSourceLoc *param_1, TQualifier *param_2) {
   byte bVar1;
   int iVar2;
   bVar1 = (byte)param_2[8] & 0x7f;
   iVar2 = (int)param_1;
   if (bVar1 == 2) {
      glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar2, 1, (char*)0x78, "GL_3DL_array_objects");
      glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar2, 8, (char*)0x12c, (char*)0x0);
      bVar1 = (byte)param_2[8] & 0x7f;
   }

   if (( bVar1 == 3 ) && ( *(int*)( this + 0x1c ) == 0 )) {
      glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar2, (char*)0xfffffff7);
      glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar2, 1, (char*)0x96, (char*)0x0);
      return 0;
   }

   return 0;
}
/* glslang::TParseContext::arrayError(glslang::TSourceLoc const&, glslang::TType const&) */undefined8 glslang::TParseContext::arrayError(TParseContext *this, TSourceLoc *param_1, TType *param_2) {
   byte bVar1;
   char cVar2;
   long lVar3;
   int iVar4;
   iVar4 = (int)param_1;
   if (*(code**)( *(long*)param_2 + 0x58 ) == TType::getQualifier) {
      if (( (byte)param_2[0x18] & 0x7f ) == 4) {
         LAB_0010af40:if (*(int*)( this + 0x1c ) != 0) goto LAB_0010af4c;
         if (( ( *(long*)( param_2 + 0x60 ) != 0 ) && ( lVar3 = *(long*)( *(long*)( param_2 + 0x60 ) + 8 ) ),lVar3 != 0 )) {
            LAB_0010b046:glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar4, (char*)0xfffffff7);
            goto LAB_0010af4c;
         }

         lVar3 = *(long*)param_2;
         if (*(code**)( lVar3 + 0x128 ) != TType::isStruct) {
            cVar2 = ( **(code**)( lVar3 + 0x128 ) )(param_2);
            if (cVar2 == '\0') goto LAB_0010af4c;
            goto LAB_0010b046;
         }

         if (( byte )((char)param_2[8] - 0xfU) < 2) goto LAB_0010b046;
         goto LAB_0010af4f;
      }

      if (( (byte)param_2[0x18] & 0x7f ) != 3) {
         return 0;
      }

      LAB_0010af67:if (*(int*)( this + 0x1c ) != 4) goto LAB_0010af72;
      if (( ( *(long*)( param_2 + 0x60 ) != 0 ) && ( lVar3 = *(long*)( *(long*)( param_2 + 0x60 ) + 8 ) ),lVar3 != 0 )) {
         LAB_0010b08a:glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar4, (char*)0xfffffff7);
         goto LAB_0010af72;
      }

      lVar3 = *(long*)param_2;
      if (*(code**)( lVar3 + 0x128 ) != TType::isStruct) {
         cVar2 = ( **(code**)( lVar3 + 0x128 ) )(param_2);
         if (cVar2 == '\0') goto LAB_0010af72;
         goto LAB_0010b08a;
      }

      if (( byte )((char)param_2[8] - 0xfU) < 2) goto LAB_0010b08a;
   }
 else {
      lVar3 = ( **(code**)( *(long*)param_2 + 0x58 ) )(param_2);
      if (( *(byte*)( lVar3 + 8 ) & 0x7f ) == 4) goto LAB_0010af40;
      LAB_0010af4c:lVar3 = *(long*)param_2;
      LAB_0010af4f:if (*(code**)( lVar3 + 0x58 ) == TType::getQualifier) {
         bVar1 = (byte)param_2[0x18] & 0x7f;
         if (bVar1 != 3) goto LAB_0010af85;
         goto LAB_0010af67;
      }

      lVar3 = ( **(code**)( lVar3 + 0x58 ) )(param_2);
      if (( *(byte*)( lVar3 + 8 ) & 0x7f ) == 3) goto LAB_0010af67;
      LAB_0010af72:lVar3 = *(long*)param_2;
   }

   if (*(code**)( lVar3 + 0x58 ) == TType::getQualifier) {
      bVar1 = (byte)param_2[0x18] & 0x7f;
   }
 else {
      lVar3 = ( **(code**)( lVar3 + 0x58 ) )(param_2);
      bVar1 = *(byte*)( lVar3 + 8 ) & 0x7f;
   }

   LAB_0010af85:if (( ( bVar1 == 4 ) && ( *(int*)( this + 0x1c ) == 4 ) ) && ( ( *(long*)( param_2 + 0x60 ) != 0 && ( ( lVar3 = *(long*)( *(long*)( param_2 + 0x60 ) + 8 ) ),lVar3 != 0 && ( 1 < (int)( *(long*)( lVar3 + 0x10 ) - *(long*)( lVar3 + 8 ) >> 4 ) ) ) ) )) {
      glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar4, (char*)0xfffffff7);
   }

   return 0;
}
/* glslang::TParseContext::arraySizeRequiredCheck(glslang::TSourceLoc const&, glslang::TArraySizes
   const&) */void glslang::TParseContext::arraySizeRequiredCheck(TParseContext *this, TSourceLoc *param_1, TArraySizes *param_2) {
   int *piVar1;
   int *piVar2;
   int iVar3;
   if (this[0x1c1] != (TParseContext)0x0) {
      return;
   }

   piVar1 = *(int**)( *(long*)( param_2 + 8 ) + 8 );
   if (*piVar1 != 0) {
      iVar3 = (int)( *(long*)( *(long*)( param_2 + 8 ) + 0x10 ) - (long)piVar1 >> 4 );
      if (iVar3 < 2) {
         return;
      }

      piVar2 = piVar1 + 4;
      while (*piVar2 != 0) {
         piVar2 = piVar2 + 4;
         if (piVar2 == piVar1 + ( ulong )(iVar3 - 2) * 4 + 8) {
            return;
         }

      }
;
   }

   /* WARNING: Could not recover jumptable at 0x0010b19c. Too many branches */
   /* WARNING: Treating indirect jump as call */
   ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "array size required", &_LC1, &_LC1, *(code**)( *(long*)this + 0x158 ));
   return;
}
/* glslang::TParseContext::arraySizesCheck(glslang::TSourceLoc const&, glslang::TQualifier const&,
   glslang::TArraySizes*, glslang::TIntermTyped const*, bool) [clone .part.0] */void glslang::TParseContext::arraySizesCheck(TParseContext *this, TSourceLoc *param_1, TQualifier *param_2, TArraySizes *param_3, TIntermTyped *param_4, bool param_5) {
   uint uVar1;
   code *pcVar2;
   byte bVar3;
   char cVar4;
   int *piVar5;
   long *plVar6;
   long lVar7;
   TIntermTyped *pTVar8;
   long lVar9;
   int iVar10;
   undefined1 *puVar11;
   if (param_4 != (TIntermTyped*)0x0) {
      if (*(code**)( *(long*)param_4 + 0xf0 ) == TIntermTyped::getType) {
         pTVar8 = param_4 + 0x20;
      }
 else {
         pTVar8 = (TIntermTyped*)( **(code**)( *(long*)param_4 + 0xf0 ) )(param_4);
      }

      pcVar2 = *(code**)( *(long*)pTVar8 + 0xf8 );
      if (pcVar2 == TType::isUnsizedArray) {
         pcVar2 = *(code**)( *(long*)pTVar8 + 0xe8 );
         if (pcVar2 == TType::isArray) {
            lVar7 = *(long*)( pTVar8 + 0x60 );
            if (lVar7 == 0) {
               return;
            }

         }
 else {
            cVar4 = ( *pcVar2 )(pTVar8);
            if (cVar4 == '\0') {
               return;
            }

            lVar7 = *(long*)( pTVar8 + 0x60 );
         }

         if (**(int**)( *(long*)( lVar7 + 8 ) + 8 ) != 0) {
            return;
         }

      }
 else {
         cVar4 = ( *pcVar2 )(pTVar8);
         if (cVar4 == '\0') {
            return;
         }

      }

      /* WARNING: Could not recover jumptable at 0x0010b25b. Too many branches */
      /* WARNING: Treating indirect jump as call */
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "array initializer must be sized", &_LC38, &_LC1, *(code**)( *(long*)this + 0x158 ));
      return;
   }

   lVar7 = *(long*)( param_3 + 8 );
   if (lVar7 != 0) {
      piVar5 = *(int**)( lVar7 + 8 );
      lVar9 = *(long*)( lVar7 + 0x10 ) - (long)piVar5;
      for (iVar10 = 1; piVar5 = piVar5 + 4,iVar10 < (int)( lVar9 >> 4 ); iVar10 = iVar10 + 1) {
         if (*piVar5 == 0) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "only outermost dimension of an array of arrays can be implicitly sized", &_LC38, &_LC1);
            lVar7 = *(long*)( param_3 + 8 );
            if (lVar7 == 0) goto LAB_0010b3a0;
            lVar9 = *(long*)( lVar7 + 8 );
            iVar10 = (int)( *(long*)( lVar7 + 0x10 ) - lVar9 >> 4 );
            if (1 < iVar10) {
               piVar5 = (int*)( lVar9 + 0x10 );
               do {
                  if (*piVar5 == 0) {
                     *piVar5 = 1;
                  }

                  piVar5 = piVar5 + 4;
               }
 while ( piVar5 != (int*)( lVar9 + 0x20 + ( ulong )(iVar10 - 2) * 0x10 ) );
            }

            break;
         }

      }

      plVar6 = (long*)( *(long*)( lVar7 + 8 ) + 0x18 );
      for (iVar10 = 1; iVar10 < (int)( *(long*)( lVar7 + 0x10 ) - *(long*)( lVar7 + 8 ) >> 4 ); iVar10 = iVar10 + 1) {
         if (*plVar6 != 0) {
            if (( ( ( (byte)param_2[8] & 0x7e ) != 0 ) && ( bVar3 = (byte)param_2[8] & 0x7f ),bVar3 != 7 )) &&( bVar3 != 2 )(**(code**)( *(long*)this + 0x158 ))(this, param_1, "only outermost dimension of an array of arrays can be a specialization constant", &_LC38, &_LC1);
         }

         break;
      }

      plVar6 = plVar6 + 2;
   }

}
LAB_0010b3a0:if (*(int*)( this + 0xc ) != 8) {
   return;
}
uVar1 = *(uint*)( this + 0x1c );bVar3 = (byte)param_2[8] & 0x7f;if (uVar1 == 3) {
   if (bVar3 == 3) {
      if (0x13f < *(int*)( this + 0x18 )) {
         return;
      }

      lVar7 = *(long*)this;
      puVar11 = AEP_geometry_shader;
      LAB_0010b3f5:cVar4 = ( **(code**)( lVar7 + 0x48 ) )(this, 2, puVar11);
      if (cVar4 != '\0') {
         return;
      }

      bVar3 = (byte)param_2[8] & 0x7f;
   }

}
 else if (uVar1 < 4) {
   if (uVar1 == 1) {
      if (bVar3 == 3) {
         LAB_0010b3de:if (0x13f < *(int*)( this + 0x18 )) {
            return;
         }

         lVar7 = *(long*)this;
         puVar11 = AEP_tessellation_shader;
         goto LAB_0010b3f5;
      }

      if (bVar3 == 4) goto LAB_0010b4c0;
   }
 else if (uVar1 == 2) {
      if (bVar3 == 3) {
         LAB_0010b4c0:if (( (byte)param_2[0xd] & 0x10 ) != 0) goto LAB_0010b41d;
         goto LAB_0010b3de;
      }

      if (bVar3 == 4) goto LAB_0010b3de;
   }

}
 else if (( uVar1 == 0xd ) && ( bVar3 == 4 )) {
   if (0x13f < *(int*)( this + 0x18 )) {
      return;
   }

   lVar7 = *(long*)this;
   puVar11 = AEP_mesh_shader;
   goto LAB_0010b3f5;
}
if (( bVar3 == 6 ) && ( param_5 )) {
   return;
}
LAB_0010b41d:arraySizeRequiredCheck(this, param_1, param_3);return;}/* glslang::TParseContext::structArrayCheck(glslang::TSourceLoc const&, glslang::TType const&) */void glslang::TParseContext::structArrayCheck(TParseContext *this, TSourceLoc *param_1, TType *param_2) {
   long lVar1;
   long *plVar2;
   char cVar3;
   code *pcVar4;
   TArraySizes *pTVar5;
   long lVar6;
   long lVar7;
   long lVar8;
   lVar1 = *(long*)( param_2 + 0x68 );
   lVar7 = *(long*)( lVar1 + 0x10 );
   lVar6 = *(long*)( lVar1 + 8 );
   if (0 < (int)( lVar7 - lVar6 >> 5 )) {
      lVar8 = 0;
      do {
         plVar2 = *(long**)( lVar6 + lVar8 * 0x20 );
         pcVar4 = *(code**)( *plVar2 + 0xe8 );
         if (pcVar4 == TType::isArray) {
            if (plVar2[0xc] != 0) {
               pcVar4 = *(code**)( *plVar2 + 0x98 );
               if (pcVar4 == TType::getArraySizes) goto LAB_0010b533;
               LAB_0010b599:pTVar5 = (TArraySizes*)( *pcVar4 )(plVar2);
               goto LAB_0010b537;
            }

         }
 else {
            cVar3 = ( *pcVar4 )(plVar2);
            if (cVar3 != '\0') {
               pcVar4 = *(code**)( *plVar2 + 0x98 );
               if (pcVar4 != TType::getArraySizes) goto LAB_0010b599;
               LAB_0010b533:pTVar5 = (TArraySizes*)plVar2[0xc];
               LAB_0010b537:arraySizeRequiredCheck(this, (TSourceLoc*)( lVar8 * 0x20 + *(long*)( lVar1 + 8 ) + 8 ), pTVar5);
            }

            lVar6 = *(long*)( lVar1 + 8 );
            lVar7 = *(long*)( lVar1 + 0x10 );
         }

         lVar8 = lVar8 + 1;
      }
 while ( (int)lVar8 < (int)( lVar7 - lVar6 >> 5 ) );
   }

   return;
}
/* glslang::TParseContext::arraySizesCheck(glslang::TSourceLoc const&, glslang::TQualifier const&,
   glslang::TArraySizes*, glslang::TIntermTyped const*, bool) */void glslang::TParseContext::arraySizesCheck(TParseContext *this, TSourceLoc *param_1, TQualifier *param_2, TArraySizes *param_3, TIntermTyped *param_4, bool param_5) {
   if (this[0x1c1] == (TParseContext)0x0) {
      arraySizesCheck(this, param_1, param_2, param_3, param_4, param_5);
      return;
   }

   return;
}
/* glslang::TParseContext::arrayOfArrayVersionCheck(glslang::TSourceLoc const&, glslang::TArraySizes
   const*) */void glslang::TParseContext::arrayOfArrayVersionCheck(TParseContext *this, TSourceLoc *param_1, TArraySizes *param_2) {
   long lVar1;
   int iVar2;
   if (param_2 == (TArraySizes*)0x0) {
      return;
   }

   lVar1 = *(long*)( param_2 + 8 );
   if (( lVar1 != 0 ) && ( (int)( *(long*)( lVar1 + 0x10 ) - *(long*)( lVar1 + 8 ) >> 4 ) == 1 )) {
      return;
   }

   iVar2 = (int)param_1;
   glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar2, (char*)0xe);
   glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar2, 8, (char*)0x136, (char*)0x0);
   glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar2, 6, (char*)0x1ae, (char*)0x0);
   return;
}
/* glslang::TParseContext::isRuntimeLength(glslang::TIntermTyped const&) const */undefined4 glslang::TParseContext::isRuntimeLength(TParseContext *this, TIntermTyped *param_1) {
   int iVar1;
   int iVar2;
   long *plVar3;
   long lVar4;
   long *plVar5;
   TIntermTyped *pTVar6;
   if (*(code**)( *(long*)param_1 + 0xf0 ) == TIntermTyped::getType) {
      pTVar6 = param_1 + 0x20;
   }
 else {
      pTVar6 = (TIntermTyped*)( **(code**)( *(long*)param_1 + 0xf0 ) )(param_1);
   }

   if (*(code**)( *(long*)pTVar6 + 0x58 ) == TType::getQualifier) {
      pTVar6 = pTVar6 + 0x10;
   }
 else {
      pTVar6 = (TIntermTyped*)( **(code**)( *(long*)pTVar6 + 0x58 ) )();
   }

   if (( ( ( (byte)pTVar6[8] & 0x7f ) == 6 ) && ( plVar3 = (long*)( **(code**)( *(long*)param_1 + 0xa0 ) )(param_1) ),plVar3 != (long*)0x0 )) {
      if (*(code**)( *plVar3 + 0x198 ) == TIntermBinary::getRight) {
         plVar5 = (long*)plVar3[0x19];
      }
 else {
         plVar5 = (long*)( **(code**)( *plVar3 + 0x198 ) )(plVar3);
      }

      lVar4 = ( **(code**)( *plVar5 + 0x28 ) )();
      iVar1 = **(int**)( *(long*)( lVar4 + 0xc0 ) + 8 );
      if (*(code**)( *plVar3 + 400 ) == TIntermBinary::getLeft) {
         plVar3 = (long*)plVar3[0x18];
         if ((char)plVar3[5] != '\x12') {
            LAB_0010b774:if (*(code**)( *plVar3 + 0xf0 ) == TIntermTyped::getType) {
               plVar3 = plVar3 + 4;
            }
 else {
               plVar3 = (long*)( **(code**)( *plVar3 + 0xf0 ) )();
            }

            iVar2 = (int)( *(long*)( plVar3[0xd] + 0x10 ) - *(long*)( plVar3[0xd] + 8 ) >> 5 ) + -1;
            return CONCAT31(( int3 )((uint)iVar2 >> 8), iVar2 == iVar1);
         }

      }
 else {
         lVar4 = ( **(code**)( *plVar3 + 400 ) )(plVar3);
         if (*(char*)( lVar4 + 0x28 ) != '\x12') {
            if (*(code**)( *plVar3 + 400 ) == TIntermBinary::getLeft) {
               plVar3 = (long*)plVar3[0x18];
            }
 else {
               plVar3 = (long*)( **(code**)( *plVar3 + 400 ) )(plVar3);
            }

            goto LAB_0010b774;
         }

      }

   }

   return 0;
}
/* glslang::TParseContext::checkRuntimeSizable(glslang::TSourceLoc const&, glslang::TIntermTyped
   const&) */void glslang::TParseContext::checkRuntimeSizable(TParseContext *this, TSourceLoc *param_1, TIntermTyped *param_2) {
   char cVar1;
   cVar1 = isRuntimeLength(this, param_2);
   if (cVar1 == '\0') {
      checkRuntimeSizable(this, param_1, param_2);
      return;
   }

   return;
}
/* glslang::TParseContext::checkAndResizeMeshViewDim(glslang::TSourceLoc const&, glslang::TType&,
   bool) */void glslang::TParseContext::checkAndResizeMeshViewDim(TParseContext *this, TSourceLoc *param_1, TType *param_2, bool param_3) {
   int iVar1;
   char cVar2;
   TType *pTVar3;
   long lVar4;
   char *pcVar5;
   char *pcVar6;
   code *UNRECOVERED_JUMPTABLE;
   long lVar7;
   int iVar8;
   if (*(code**)( *(long*)param_2 + 0x50 ) == TType::getQualifier) {
      pTVar3 = param_2 + 0x10;
   }
 else {
      pTVar3 = (TType*)( **(code**)( *(long*)param_2 + 0x50 ) )(param_2);
   }

   if (( (byte)pTVar3[0xd] & 4 ) == 0) {
      return;
   }

   if (param_3) {
      lVar4 = *(long*)param_2;
      if (*(code**)( lVar4 + 0xe8 ) == TType::isArray) {
         if (*(long*)( param_2 + 0x60 ) == 0) {
            LAB_0010b9b8:pcVar5 = "perviewNV";
            pcVar6 = "requires a view array dimension";
            UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
            goto LAB_0010b9d8;
         }

      }
 else {
         cVar2 = ( **(code**)( lVar4 + 0xe8 ) )(param_2);
         if (cVar2 == '\0') goto LAB_0010b9b8;
         lVar4 = *(long*)param_2;
      }

      if (this[0x1c1] == (TParseContext)0x0) {
         iVar8 = *(int*)( this + 0x72c );
         lVar7 = 0;
      }
 else {
         lVar7 = 0;
         iVar8 = 4;
      }

   }
 else {
      if (( ( *(long*)( param_2 + 0x60 ) == 0 ) || ( lVar4 = *(long*)( *(long*)( param_2 + 0x60 ) + 8 ) ),lVar4 == 0 )) goto LAB_0010b9b8;
      lVar4 = *(long*)param_2;
      if (this[0x1c1] == (TParseContext)0x0) {
         iVar8 = *(int*)( this + 0x72c );
         lVar7 = 0x10;
      }
 else {
         lVar7 = 0x10;
         iVar8 = 4;
      }

   }

   if (*(code**)( lVar4 + 0xa0 ) == TType::getArraySizes) {
      lVar4 = *(long*)( param_2 + 0x60 );
   }
 else {
      lVar4 = ( **(code**)( lVar4 + 0xa0 ) )(param_2);
   }

   iVar1 = *(int*)( *(long*)( *(long*)( lVar4 + 8 ) + 8 ) + lVar7 );
   if (iVar1 != 0) {
      if (iVar1 != iVar8) {
         pcVar5 = "[]";
         pcVar6 = "mesh view output array size must be gl_MaxMeshViewCountNV or implicitly sized";
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         LAB_0010b9d8:/* WARNING: Could not recover jumptable at 0x0010b9ee. Too many branches *//* WARNING: Treating indirect jump as call */( *UNRECOVERED_JUMPTABLE )(this, param_1, pcVar6, pcVar5, &_LC1, UNRECOVERED_JUMPTABLE);
         return;
      }

      if (iVar1 != 0) {
         return;
      }

   }

   if (*(code**)( *(long*)param_2 + 0xa0 ) == TType::getArraySizes) {
      lVar4 = *(long*)( param_2 + 0x60 );
   }
 else {
      lVar4 = ( **(code**)( *(long*)param_2 + 0xa0 ) )(param_2);
   }

   *(int*)( *(long*)( *(long*)( lVar4 + 8 ) + 8 ) + lVar7 ) = iVar8;
   return;
}
/* glslang::TParseContext::nonInitConstCheck(glslang::TSourceLoc const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >&,
   glslang::TType&) */void glslang::TParseContext::nonInitConstCheck(TParseContext *this, TSourceLoc *param_1, basic_string *param_2, TType *param_3) {
   TType TVar1;
   long lVar2;
   TType *pTVar3;
   if (*(code**)( *(long*)param_3 + 0x50 ) == TType::getQualifier) {
      TVar1 = param_3[0x18];
      if (( (byte)TVar1 & 0x7f ) != 2) {
         LAB_0010bacd:if (( (byte)TVar1 & 0x7f ) != 0x13) {
            return;
         }

      }

   }
 else {
      lVar2 = ( **(code**)( *(long*)param_3 + 0x50 ) )(param_3);
      if (( *(byte*)( lVar2 + 8 ) & 0x7f ) != 2) {
         if (*(code**)( *(long*)param_3 + 0x50 ) == TType::getQualifier) {
            TVar1 = param_3[0x18];
            goto LAB_0010bacd;
         }

         lVar2 = ( **(code**)( *(long*)param_3 + 0x50 ) )(param_3);
         if (( *(byte*)( lVar2 + 8 ) & 0x7f ) != 0x13) {
            return;
         }

      }

      if (*(code**)( *(long*)param_3 + 0x50 ) != TType::getQualifier) {
         pTVar3 = (TType*)( **(code**)( *(long*)param_3 + 0x50 ) )(param_3);
         goto LAB_0010bae4;
      }

   }

   pTVar3 = param_3 + 0x10;
   LAB_0010bae4:pTVar3[0x10] = ( TType )((byte)pTVar3[0x10] & 0xf0);
   *(undefined8*)( pTVar3 + 0x38 ) = 0xffffffff00000000;
   *(undefined8*)pTVar3 = 0;
   *(undefined8*)( pTVar3 + 0x14 ) = 0xffffffffffffffff;
   *(uint*)( pTVar3 + 0x1c ) = *(uint*)( pTVar3 + 0x1c ) & 0xffc00000 | 0x1fcfff;
   *(ulong*)( pTVar3 + 0x20 ) = *(ulong*)( pTVar3 + 0x20 ) | 0x7fffffffffffffff;
   pTVar3[0x30] = (TType)0x0;
   *(undefined4*)( pTVar3 + 0x34 ) = 0xfffff800;
   *(undefined8*)( pTVar3 + 0x40 ) = 0;
   *(ulong*)( pTVar3 + 0x28 ) = ( ulong )(( uint ) * (undefined8*)( pTVar3 + 0x28 ) & 0xfe000000) | 0x1ffffff;
   *(undefined2*)( pTVar3 + 0x48 ) = 0;
   *(ulong*)( pTVar3 + 8 ) = *(ulong*)( pTVar3 + 8 ) & 0x800000141fff0000;
   /* WARNING: Could not recover jumptable at 0x0010bb8e. Too many branches */
   /* WARNING: Treating indirect jump as call */
   ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "variables with qualifier \'const\' must be initialized", *(undefined8*)( param_2 + 8 ), &_LC1, *(code**)( *(long*)this + 0x158 ));
   return;
}
/* glslang::TParseContext::paramCheckFixStorage(glslang::TSourceLoc const&,
   glslang::TStorageQualifier const&, glslang::TType&) */void glslang::TParseContext::paramCheckFixStorage(TParseContext *this, TSourceLoc *param_1, TStorageQualifier *param_2, TType *param_3) {
   undefined4 uVar1;
   code *pcVar2;
   char *pcVar3;
   TType *pTVar4;
   uVar1 = *(undefined4*)param_2;
   pcVar2 = *(code**)( *(long*)param_3 + 0x50 );
   switch (uVar1) {
      case 0:
      case 1:
    if (pcVar2 == TType::getQualifier) {
      pTVar4 = param_3 + 0x10;
    }
    else {
      pTVar4 = (TType *)(*pcVar2)();
    }
    pTVar4[8] = (TType)((byte)pTVar4[8] & 0x80 | 0x10);
    return;
      case 2:
      case 0x13:
    if (pcVar2 == TType::getQualifier) {
      pTVar4 = param_3 + 0x10;
    }
    else {
      pTVar4 = (TType *)(*pcVar2)();
    }
    break;
      default:
    if (pcVar2 == TType::getQualifier) {
      pTVar4 = param_3 + 0x10;
    }
    else {
      pTVar4 = (TType *)(*pcVar2)();
      uVar1 = *(undefined4 *)param_2;
    }
    pTVar4[8] = (TType)((byte)pTVar4[8] & 0x80 | 0x10);
    switch(uVar1) {
    case 0:
      pcVar3 = "temp";
      break;
    case 1:
      pcVar3 = "global";
      break;
    case 2:
      pcVar3 = "const";
      break;
    case 3:
    case 0x10:
      pcVar3 = "in";
      break;
    case 4:
    case 0x11:
      pcVar3 = "out";
      break;
    case 5:
      pcVar3 = "uniform";
      break;
    case 6:
      pcVar3 = "buffer";
      break;
    case 7:
      pcVar3 = "shared";
      break;
    case 8:
      pcVar3 = "spirv_storage_class";
      break;
    case 9:
      pcVar3 = "rayPayloadNV";
      break;
    case 10:
      pcVar3 = "rayPayloadInNV";
      break;
    case 0xb:
      pcVar3 = "hitAttributeNV";
      break;
    case 0xc:
      pcVar3 = "callableDataNV";
      break;
    case 0xd:
      pcVar3 = "callableDataInNV";
      break;
    case 0xe:
      pcVar3 = "hitObjectAttributeNV";
      break;
    case 0xf:
      pcVar3 = "taskPayloadSharedEXT";
      break;
    case 0x12:
      pcVar3 = "inout";
      break;
    case 0x13:
      pcVar3 = "const (read only)";
      break;
    case 0x14:
      pcVar3 = "gl_VertexId";
      break;
    case 0x15:
      pcVar3 = "gl_InstanceId";
      break;
    case 0x16:
      pcVar3 = "gl_Position";
      break;
    case 0x17:
      pcVar3 = "gl_PointSize";
      break;
    case 0x18:
      pcVar3 = "gl_ClipVertex";
      break;
    case 0x19:
      pcVar3 = "gl_FrontFacing";
      break;
    case 0x1a:
      pcVar3 = "gl_FragCoord";
      break;
    case 0x1b:
      pcVar3 = "gl_PointCoord";
      break;
    case 0x1c:
      pcVar3 = "fragColor";
      break;
    case 0x1d:
      pcVar3 = "gl_FragDepth";
      break;
    case 0x1e:
      pcVar3 = "gl_FragStencilRefARB";
      break;
    default:
      pcVar3 = "unknown qualifier";
    }
                    /* WARNING: Could not recover jumptable at 0x0010bd20. Too many branches */
                    /* WARNING: Treating indirect jump as call */
    (**(code **)(*(long *)this + 0x158))
              (this,param_1,"storage qualifier not allowed on function parameter",pcVar3,&_LC1,
               *(code **)(*(long *)this + 0x158));
    return;
      case 0x10:
      case 0x11:
      case 0x12:
      case 0x1f:
    if (pcVar2 == TType::getQualifier) {
      pTVar4 = param_3 + 0x10;
    }
    else {
      pTVar4 = (TType *)(*pcVar2)();
    }
    pTVar4[8] = (TType)((byte)pTVar4[8] & 0x80 | (byte)uVar1 & 0x7f);
    return;
   }

   pTVar4[8] = ( TType )((byte)pTVar4[8] & 0x80 | 0x13);
   return;
}
/* glslang::TParseContext::nestedBlockCheck(glslang::TSourceLoc const&) */void glslang::TParseContext::nestedBlockCheck(TParseContext *this, TSourceLoc *param_1) {
   if (( *(int*)( this + 0x118 ) < 1 ) && ( *(int*)( this + 0x11c ) < 1 )) {
      *(int*)( this + 0x11c ) = *(int*)( this + 0x11c ) + 1;
      return;
   }

   ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot nest a block definition inside a structure or block", &_LC1);
   *(int*)( this + 0x11c ) = *(int*)( this + 0x11c ) + 1;
   return;
}
/* glslang::TParseContext::nestedStructCheck(glslang::TSourceLoc const&) */void glslang::TParseContext::nestedStructCheck(TParseContext *this, TSourceLoc *param_1) {
   if (( *(int*)( this + 0x118 ) < 1 ) && ( *(int*)( this + 0x11c ) < 1 )) {
      *(int*)( this + 0x118 ) = *(int*)( this + 0x118 ) + 1;
      return;
   }

   ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot nest a structure definition inside a structure or block", &_LC1);
   *(int*)( this + 0x118 ) = *(int*)( this + 0x118 ) + 1;
   return;
}
/* glslang::TParseContext::arrayObjectCheck(glslang::TSourceLoc const&, glslang::TType const&, char
   const*) */void glslang::TParseContext::arrayObjectCheck(TSourceLoc *param_1, TType *param_2, char *param_3) {
   char cVar1;
   long lVar2;
   long lVar3;
   lVar2 = *(long*)param_3;
   if (*(code**)( lVar2 + 0x198 ) == TType::containsArray) {
      if (*(code**)( lVar2 + 0xe8 ) == TType::isArray) {
         if (*(long*)( param_3 + 0x60 ) != 0) goto LAB_0010c022;
      }
 else {
         cVar1 = ( **(code**)( lVar2 + 0xe8 ) )(param_3);
         if (cVar1 != '\0') goto LAB_0010c022;
         lVar2 = *(long*)param_3;
      }

      if (*(code**)( lVar2 + 0x128 ) == TType::isStruct) {
         if (1 < ( byte )(param_3[8] - 0xfU)) {
            return;
         }

      }
 else {
         cVar1 = ( **(code**)( lVar2 + 0x128 ) )(param_3);
         if (cVar1 == '\0') {
            return;
         }

      }

      lVar2 = *(long*)( *(long*)( param_3 + 0x68 ) + 0x10 );
      lVar3 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_3 + 0x68 ) + 8 ),lVar2 ));
      if (lVar2 == lVar3) {
         return;
      }

   }
 else {
      cVar1 = ( **(code**)( lVar2 + 0x198 ) )(param_3);
      if (cVar1 == '\0') {
         return;
      }

   }

   LAB_0010c022:glslang::TParseVersions::profileRequires(param_1, (int)param_2, 1, (char*)0x78, "GL_3DL_array_objects");
   glslang::TParseVersions::profileRequires(param_1, (int)param_2, 8, (char*)0x12c, (char*)0x0);
   return;
}
/* glslang::TParseContext::opaqueCheck(glslang::TSourceLoc const&, glslang::TType const&, char
   const*) */void glslang::TParseContext::opaqueCheck(TParseContext *this, TSourceLoc *param_1, TType *param_2, char *param_3) {
   char cVar1;
   cVar1 = containsFieldWithBasicType(this, param_2, 0xe);
   if (cVar1 != '\0') {
      cVar1 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_ARB_bindless_texture");
      if (cVar1 == '\0') {
         /* WARNING: Could not recover jumptable at 0x0010c0fd. Too many branches */
         /* WARNING: Treating indirect jump as call */
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can\'t use with samplers or structs containing samplers", param_3, &_LC1, *(code**)( *(long*)this + 0x158 ));
         return;
      }

   }

   return;
}
/* glslang::TParseContext::referenceCheck(glslang::TSourceLoc const&, glslang::TType const&, char
   const*) */void glslang::TParseContext::referenceCheck(TParseContext *this, TSourceLoc *param_1, TType *param_2, char *param_3) {
   char cVar1;
   cVar1 = containsFieldWithBasicType(this, param_2, 0x12);
   if (cVar1 != '\0') {
      /* WARNING: Could not recover jumptable at 0x0010c159. Too many branches */
      /* WARNING: Treating indirect jump as call */
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can\'t use with reference types", param_3, &_LC1, *(code**)( *(long*)this + 0x158 ));
      return;
   }

   return;
}
/* glslang::TParseContext::storage16BitAssignmentCheck(glslang::TSourceLoc const&, glslang::TType
   const&, char const*) */void glslang::TParseContext::storage16BitAssignmentCheck(TParseContext *this, TSourceLoc *param_1, TType *param_2, char *param_3) {
   TType TVar1;
   char cVar2;
   int iVar3;
   uint uVar4;
   long lVar5;
   code *pcVar6;
   if (*(code**)( *(long*)param_2 + 0x38 ) == TType::getBasicType) {
      uVar4 = (uint)(byte)param_2[8];
   }
 else {
      uVar4 = ( **(code**)( *(long*)param_2 + 0x38 ) )(param_2);
   }

   if (( uVar4 == 0xf ) && ( cVar2 = containsFieldWithBasicType(this, param_2, 3) ),cVar2 != '\0') {
      ( **(code**)( *(long*)this + 0xa8 ) )(this, param_1, param_3, "can\'t use with structs containing float16");
   }

   lVar5 = *(long*)param_2;
   if (*(code**)( lVar5 + 0xe8 ) == TType::isArray) {
      if (*(long*)( param_2 + 0x60 ) == 0) goto LAB_0010c1d7;
      LAB_0010c4f0:if (*(code**)( lVar5 + 0x38 ) != TType::getBasicType) {
         iVar3 = ( **(code**)( lVar5 + 0x38 ) )(param_2);
         if (iVar3 == 3) {
            LAB_0010c509:( **(code**)( *(long*)this + 0xa8 ) )(this, param_1, param_3, "can\'t use with arrays containing float16");
         }

         pcVar6 = *(code**)( *(long*)param_2 + 0x38 );
         if (pcVar6 != TType::getBasicType) goto LAB_0010c533;
         goto LAB_0010c1e4;
      }

      TVar1 = param_2[8];
      if (TVar1 == (TType)0x3) goto LAB_0010c509;
      LAB_0010c1e8:if (TVar1 == (TType)0xf) {
         LAB_0010c541:cVar2 = containsFieldWithBasicType(this, param_2, 6);
         if (cVar2 != '\0') {
            ( **(code**)( *(long*)this + 0xc0 ) )(this, param_1, param_3, "can\'t use with structs containing int16");
         }

      }

   }
 else {
      cVar2 = ( **(code**)( lVar5 + 0xe8 ) )(param_2);
      lVar5 = *(long*)param_2;
      if (cVar2 != '\0') goto LAB_0010c4f0;
      LAB_0010c1d7:pcVar6 = *(code**)( lVar5 + 0x38 );
      if (pcVar6 == TType::getBasicType) {
         LAB_0010c1e4:TVar1 = param_2[8];
         goto LAB_0010c1e8;
      }

      LAB_0010c533:iVar3 = ( *pcVar6 )(param_2);
      if (iVar3 == 0xf) goto LAB_0010c541;
   }

   lVar5 = *(long*)param_2;
   if (*(code**)( lVar5 + 0xe8 ) == TType::isArray) {
      if (*(long*)( param_2 + 0x60 ) == 0) goto LAB_0010c20f;
      LAB_0010c450:if (*(code**)( lVar5 + 0x38 ) != TType::getBasicType) {
         iVar3 = ( **(code**)( lVar5 + 0x38 ) )(param_2);
         if (iVar3 == 6) {
            LAB_0010c469:( **(code**)( *(long*)this + 0xc0 ) )(this, param_1, param_3, "can\'t use with arrays containing int16");
         }

         pcVar6 = *(code**)( *(long*)param_2 + 0x38 );
         if (pcVar6 != TType::getBasicType) goto LAB_0010c493;
         goto LAB_0010c21c;
      }

      TVar1 = param_2[8];
      if (TVar1 == (TType)0x6) goto LAB_0010c469;
      LAB_0010c220:if (TVar1 == (TType)0xf) {
         LAB_0010c4a1:cVar2 = containsFieldWithBasicType(this, param_2, 7);
         if (cVar2 != '\0') {
            ( **(code**)( *(long*)this + 0xc0 ) )(this, param_1, param_3, "can\'t use with structs containing uint16");
         }

      }

   }
 else {
      cVar2 = ( **(code**)( lVar5 + 0xe8 ) )(param_2);
      lVar5 = *(long*)param_2;
      if (cVar2 != '\0') goto LAB_0010c450;
      LAB_0010c20f:pcVar6 = *(code**)( lVar5 + 0x38 );
      if (pcVar6 == TType::getBasicType) {
         LAB_0010c21c:TVar1 = param_2[8];
         goto LAB_0010c220;
      }

      LAB_0010c493:iVar3 = ( *pcVar6 )(param_2);
      if (iVar3 == 0xf) goto LAB_0010c4a1;
   }

   lVar5 = *(long*)param_2;
   if (*(code**)( lVar5 + 0xe8 ) == TType::isArray) {
      if (*(long*)( param_2 + 0x60 ) == 0) goto LAB_0010c247;
      LAB_0010c3b8:if (*(code**)( lVar5 + 0x38 ) != TType::getBasicType) {
         iVar3 = ( **(code**)( lVar5 + 0x38 ) )(param_2);
         if (iVar3 == 7) {
            LAB_0010c3d1:( **(code**)( *(long*)this + 0xc0 ) )(this, param_1, param_3, "can\'t use with arrays containing uint16");
         }

         pcVar6 = *(code**)( *(long*)param_2 + 0x38 );
         if (pcVar6 != TType::getBasicType) goto LAB_0010c3fb;
         goto LAB_0010c254;
      }

      TVar1 = param_2[8];
      if (TVar1 == (TType)0x7) goto LAB_0010c3d1;
      LAB_0010c258:if (TVar1 == (TType)0xf) {
         LAB_0010c409:cVar2 = containsFieldWithBasicType(this, param_2, 4);
         if (cVar2 != '\0') {
            ( **(code**)( *(long*)this + 0xd8 ) )(this, param_1, param_3, "can\'t use with structs containing int8");
         }

      }

   }
 else {
      cVar2 = ( **(code**)( lVar5 + 0xe8 ) )(param_2);
      lVar5 = *(long*)param_2;
      if (cVar2 != '\0') goto LAB_0010c3b8;
      LAB_0010c247:pcVar6 = *(code**)( lVar5 + 0x38 );
      if (pcVar6 == TType::getBasicType) {
         LAB_0010c254:TVar1 = param_2[8];
         goto LAB_0010c258;
      }

      LAB_0010c3fb:iVar3 = ( *pcVar6 )(param_2);
      if (iVar3 == 0xf) goto LAB_0010c409;
   }

   lVar5 = *(long*)param_2;
   if (*(code**)( lVar5 + 0xe8 ) == TType::isArray) {
      if (*(long*)( param_2 + 0x60 ) == 0) goto LAB_0010c277;
      LAB_0010c2e4:if (*(code**)( lVar5 + 0x38 ) != TType::getBasicType) {
         iVar3 = ( **(code**)( lVar5 + 0x38 ) )(param_2);
         if (iVar3 == 4) {
            LAB_0010c2f9:( **(code**)( *(long*)this + 0xd8 ) )(this, param_1, param_3, "can\'t use with arrays containing int8");
         }

         pcVar6 = *(code**)( *(long*)param_2 + 0x38 );
         if (pcVar6 != TType::getBasicType) goto LAB_0010c323;
         goto LAB_0010c284;
      }

      TVar1 = param_2[8];
      if (TVar1 == (TType)0x4) goto LAB_0010c2f9;
      LAB_0010c288:if (TVar1 != (TType)0xf) goto LAB_0010c291;
      LAB_0010c331:cVar2 = containsFieldWithBasicType(this, param_2, 5);
      if (cVar2 == '\0') goto LAB_0010c291;
      ( **(code**)( *(long*)this + 0xd8 ) )(this, param_1, param_3, "can\'t use with structs containing uint8");
      lVar5 = *(long*)param_2;
      pcVar6 = *(code**)( lVar5 + 0xe8 );
      if (pcVar6 != TType::isArray) goto LAB_0010c380;
      LAB_0010c2a4:if (*(long*)( param_2 + 0x60 ) == 0) {
         return;
      }

      pcVar6 = *(code**)( lVar5 + 0x38 );
      if (pcVar6 != TType::getBasicType) {
         LAB_0010c648:uVar4 = ( *pcVar6 )(param_2);
         goto LAB_0010c2bc;
      }

   }
 else {
      cVar2 = ( **(code**)( lVar5 + 0xe8 ) )(param_2);
      lVar5 = *(long*)param_2;
      if (cVar2 != '\0') goto LAB_0010c2e4;
      LAB_0010c277:pcVar6 = *(code**)( lVar5 + 0x38 );
      if (pcVar6 == TType::getBasicType) {
         LAB_0010c284:TVar1 = param_2[8];
         goto LAB_0010c288;
      }

      LAB_0010c323:iVar3 = ( *pcVar6 )(param_2);
      if (iVar3 == 0xf) goto LAB_0010c331;
      LAB_0010c291:lVar5 = *(long*)param_2;
      pcVar6 = *(code**)( lVar5 + 0xe8 );
      if (pcVar6 == TType::isArray) goto LAB_0010c2a4;
      LAB_0010c380:cVar2 = ( *pcVar6 )(param_2);
      if (cVar2 == '\0') {
         return;
      }

      pcVar6 = *(code**)( *(long*)param_2 + 0x38 );
      if (pcVar6 != TType::getBasicType) goto LAB_0010c648;
   }

   uVar4 = (uint)(byte)param_2[8];
   LAB_0010c2bc:if (uVar4 != 5) {
      return;
   }

   /* WARNING: Could not recover jumptable at 0x0010c5f9. Too many branches */
   /* WARNING: Treating indirect jump as call */
   ( **(code**)( *(long*)this + 0xd8 ) )(this, param_1, param_3, "can\'t use with arrays containing uint8");
   return;
}
/* glslang::TParseContext::handleReturnValue(glslang::TSourceLoc const&, glslang::TIntermTyped*) */undefined8 glslang::TParseContext::handleReturnValue(TParseContext *this, TSourceLoc *param_1, TIntermTyped *param_2) {
   code *pcVar1;
   char cVar2;
   byte bVar3;
   uint uVar4;
   undefined8 uVar5;
   long *plVar6;
   TType *pTVar7;
   char *pcVar8;
   TIntermTyped *pTVar9;
   long lVar10;
   if (*(code**)( *(long*)param_2 + 0xf0 ) == TIntermTyped::getType) {
      pTVar9 = param_2 + 0x20;
   }
 else {
      pTVar9 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
   }

   storage16BitAssignmentCheck(this, param_1, (TType*)pTVar9, "return");
   this[0x130] = (TParseContext)0x1;
   pcVar1 = *(code**)( **(long**)( this + 0x128 ) + 0x38 );
   if (pcVar1 == TType::getBasicType) {
      uVar4 = ( uint ) * (byte*)( *(long**)( this + 0x128 ) + 1 );
   }
 else {
      uVar4 = ( *pcVar1 )();
   }

   if (uVar4 == 0) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "void function cannot return a value", "return", &_LC1);
      uVar5 = glslang::TIntermediate::addBranch(*(undefined8*)( this + 0x38 ), 0x1d5, param_1);
      goto LAB_0010c724;
   }

   if (*(code**)( *(long*)param_2 + 0xf0 ) == TIntermTyped::getType) {
      pTVar9 = param_2 + 0x20;
   }
 else {
      pTVar9 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
   }

   cVar2 = TType::operator ==(*(TType**)( this + 0x128 ), (TType*)pTVar9);
   if (cVar2 == '\0') {
      plVar6 = (long*)glslang::TIntermediate::addConversion(*(undefined8*)( this + 0x38 ), 0x1d5, *(undefined8*)( this + 0x128 ), param_2);
      if (plVar6 != (long*)0x0) {
         if (*(code**)( *plVar6 + 0xf0 ) == TIntermTyped::getType) {
            pTVar7 = (TType*)( plVar6 + 4 );
         }
 else {
            pTVar7 = (TType*)( **(code**)( *plVar6 + 0xf0 ) )(plVar6);
         }

         cVar2 = TType::operator ==(*(TType**)( this + 0x128 ), pTVar7);
         if (cVar2 == '\0') {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot convert return value to function return type", "return", &_LC1);
         }

         if (*(int*)( this + 0x18 ) < 0x1a4) {
            ( **(code**)( *(long*)this + 0x160 ) )(this, param_1, "type conversion on return values was not explicitly allowed until version 420", "return", &_LC1);
         }

         uVar5 = glslang::TIntermediate::addBranch(*(undefined8*)( this + 0x38 ), 0x1d5, plVar6, param_1);
         goto LAB_0010c724;
      }

      lVar10 = *(long*)this;
      pcVar8 = "type does not match, or is not convertible to, the function\'s return type";
      LAB_0010c9e0:( **(code**)( lVar10 + 0x158 ) )(this, param_1, pcVar8, "return", &_LC1);
   }
 else {
      if (*(code**)( *(long*)param_2 + 0xf0 ) == TIntermTyped::getType) {
         pTVar9 = param_2 + 0x20;
      }
 else {
         pTVar9 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
      }

      pcVar1 = *(code**)( *(long*)pTVar9 + 0x168 );
      if (pcVar1 == TType::isTexture) {
         if (pTVar9[8] == (TIntermTyped)0xe) {
            pcVar1 = *(code**)( *(long*)pTVar9 + 0x40 );
            if (pcVar1 == TType::getSampler) {
               pTVar9 = pTVar9 + 0x80;
            }
 else {
               pTVar9 = (TIntermTyped*)( *pcVar1 )();
            }

            if (( (byte)pTVar9[2] & 0x20 ) == 0) {
               bVar3 = (byte)pTVar9[2] & 8;
               goto joined_r0x0010c974;
            }

         }

         LAB_0010c7d8:pTVar9 = param_2 + 0x20;
         if (*(code**)( *(long*)param_2 + 0xf0 ) != TIntermTyped::getType) {
            pTVar9 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
         }

         pcVar1 = *(code**)( *(long*)pTVar9 + 0x158 );
         if (pcVar1 == TType::isImage) {
            if (pTVar9[8] == (TIntermTyped)0xe) {
               pcVar1 = *(code**)( *(long*)pTVar9 + 0x40 );
               if (pcVar1 == TType::getSampler) {
                  pTVar9 = pTVar9 + 0x80;
               }
 else {
                  pTVar9 = (TIntermTyped*)( *pcVar1 )();
               }

               if (( ( (byte)pTVar9[2] & 8 ) != 0 ) && ( 1 < ( byte )((char)pTVar9[1] - 7U) )) goto LAB_0010c97a;
            }

         }
 else {
            cVar2 = ( *pcVar1 )();
            if (cVar2 != '\0') goto LAB_0010c97a;
         }

      }
 else {
         bVar3 = ( *pcVar1 )();
         joined_r0x0010c974:if (bVar3 == 0) goto LAB_0010c7d8;
         LAB_0010c97a:if (*(int*)( this + 0x20 ) == 0) {
            cVar2 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_ARB_bindless_texture");
            if (cVar2 == '\0') {
               lVar10 = *(long*)this;
               pcVar8 = "sampler or image can be used as return type only when the extension GL_ARB_bindless_texture enabled";
               goto LAB_0010c9e0;
            }

         }
 else {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "sampler or image cannot be used as return type when generating SPIR-V", "return", &_LC1);
         }

      }

   }

   uVar5 = glslang::TIntermediate::addBranch(*(undefined8*)( this + 0x38 ), 0x1d5, param_2, param_1);
   LAB_0010c724:pcVar1 = *(code**)( **(long**)( this + 0x128 ) + 0x58 );
   if (pcVar1 == TType::getQualifier) {
      plVar6 = *(long**)( this + 0x128 ) + 2;
   }
 else {
      plVar6 = (long*)( *pcVar1 )();
   }

   glslang::TIntermBranch::updatePrecision(uVar5, *(byte*)( (long)plVar6 + 0xb ) >> 1 & 7);
   return uVar5;
}
/* glslang::TParseContext::specializationCheck(glslang::TSourceLoc const&, glslang::TType const&,
   char const*) */void glslang::TParseContext::specializationCheck(TParseContext *this, TSourceLoc *param_1, TType *param_2, char *param_3) {
   char cVar1;
   long lVar2;
   long lVar3;
   lVar2 = *(long*)param_2;
   if (*(code**)( lVar2 + 0x1d0 ) != TType::containsSpecializationSize) {
      cVar1 = ( **(code**)( lVar2 + 0x1d0 ) )(param_2);
      if (cVar1 == '\0') {
         return;
      }

      goto LAB_0010cb03;
   }

   if (*(code**)( lVar2 + 0xe8 ) == TType::isArray) {
      lVar3 = *(long*)( param_2 + 0x60 );
      if (lVar3 != 0) {
         LAB_0010caf4:if (*(long*)( *(long*)( *(long*)( lVar3 + 8 ) + 8 ) + 8 ) != 0) goto LAB_0010cb03;
         goto LAB_0010cb38;
      }

   }
 else {
      cVar1 = ( **(code**)( lVar2 + 0xe8 ) )(param_2);
      if (cVar1 != '\0') {
         lVar3 = *(long*)( param_2 + 0x60 );
         goto LAB_0010caf4;
      }

      LAB_0010cb38:lVar2 = *(long*)param_2;
   }

   if (*(code**)( lVar2 + 0x128 ) == TType::isStruct) {
      if (1 < ( byte )((char)param_2[8] - 0xfU)) {
         return;
      }

   }
 else {
      cVar1 = ( **(code**)( lVar2 + 0x128 ) )(param_2);
      if (cVar1 == '\0') {
         return;
      }

   }

   lVar2 = *(long*)( *(long*)( param_2 + 0x68 ) + 0x10 );
   lVar3 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSpecializationSize()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsSpecializationSize ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_2 + 0x68 ) + 8 ),lVar2 ));
   if (lVar2 == lVar3) {
      return;
   }

   LAB_0010cb03:/* WARNING: Could not recover jumptable at 0x0010cb31. Too many branches *//* WARNING: Treating indirect jump as call */( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can\'t use with types containing arrays sized with a specialization constant", param_3, &_LC1, *(code**)( *(long*)this + 0x158 ));
   return;
}
/* glslang::TParseContext::structTypeCheck(glslang::TSourceLoc const&, glslang::TPublicType&) */void glslang::TParseContext::structTypeCheck(TParseContext *this, TSourceLoc *param_1, TPublicType *param_2) {
   long *plVar1;
   byte bVar2;
   byte bVar3;
   byte bVar4;
   long lVar5;
   code *pcVar6;
   long *plVar7;
   code *pcVar8;
   undefined8 uVar9;
   long *plVar10;
   long lVar11;
   long lVar12;
   ulong uVar13;
   lVar5 = *(long*)( *(long*)( param_2 + 200 ) + 0x68 );
   lVar11 = *(long*)( lVar5 + 8 );
   if (lVar11 != *(long*)( lVar5 + 0x10 )) {
      uVar13 = 0;
      do {
         lVar12 = uVar13 * 0x20;
         pcVar6 = *(code**)( **(long**)( lVar11 + lVar12 ) + 0x50 );
         if (pcVar6 == TType::getQualifier) {
            plVar10 = *(long**)( lVar11 + lVar12 ) + 2;
         }
 else {
            plVar10 = (long*)( *pcVar6 )();
            lVar11 = *(long*)( lVar5 + 8 );
         }

         bVar2 = *(byte*)( (long)plVar10 + 0xb );
         plVar1 = (long*)( lVar11 + lVar12 ) + 1;
         if (( ( ( ( ( bVar2 & 0x20 ) != 0 ) || ( bVar3 = *(byte*)( (long)plVar10 + 0xd )(bVar3 & 0x10) != 0 ) ) || ( ( bVar3 & 0x20 ) != 0 ) ) || ( ( bVar4 = *(byte*)( (long)plVar10 + 0xc ) ),(char)bVar4 < '\0' || ( ( bVar3 & 1 ) != 0 ) ) )) {
            plVar7 = *(long**)( lVar11 + lVar12 );
            pcVar6 = *(code**)( *(long*)this + 0x158 );
            pcVar8 = *(code**)( *plVar7 + 0x30 );
            if (pcVar8 == TType::getFieldName_abi_cxx11_) {
               lVar11 = plVar7[0xe];
            }
 else {
               lVar11 = ( *pcVar8 )();
            }

            ( *pcVar6 )(this, plVar1, "cannot use storage or interpolation qualifiers on structure members", *(undefined8*)( lVar11 + 8 ), &_LC1);
            lVar11 = *(long*)( lVar5 + 8 );
         }

         bVar2 = *(byte*)( (long)plVar10 + 0xe );
         if (( ( ( (char)bVar2 < '\0' ) || ( ( bVar2 & 0x40 ) != 0 ) ) || ( ( bVar2 & 0x20 ) != 0 ) ) || ( ( ( ( ( ( bVar2 & 0x10 ) != 0 || ( ( bVar2 & 8 ) != 0 ) ) || ( ( ( bVar2 & 2 ) != 0 || ( ( ( bVar2 & 4 ) != 0 || ( ( *(byte*)( (long)plVar10 + 0xd ) & 0x40 ) != 0 ) ) ) ) ) ) || ( (char)*(byte*)( (long)plVar10 + 0xd ) < '\0' ) ) || ( ( ( bVar2 & 1 ) != 0 || ( bVar2 = *(byte*)( (long)plVar10 + 0xf )(bVar2 & 1) != 0 ) ) ) ) )) {
            pcVar6 = *(code**)( *(long*)this + 0x158 );
            pcVar8 = *(code**)( **(long**)( lVar11 + lVar12 ) + 0x30 );
            if (pcVar8 == TType::getFieldName_abi_cxx11_) {
               lVar11 = ( *(long**)( lVar11 + lVar12 ) )[0xe];
            }
 else {
               lVar11 = ( *pcVar8 )();
            }

            ( *pcVar6 )(this, plVar1, "cannot use memory qualifiers on structure members", *(undefined8*)( lVar11 + 8 ), &_LC1);
            lVar11 = *(long*)( lVar5 + 8 );
            bVar2 = *(byte*)( (long)plVar10 + 0xf );
         }

         if (( ( ( ( ( bVar2 & 0x70 ) != 0 ) || ( ( *(byte*)( plVar10 + 2 ) & 0xf ) != 0 ) ) || ( *(int*)( (long)plVar10 + 0x14 ) != -1 ) ) || ( ( ( (short)plVar10[4] != -1 || ( ( *(uint*)( (long)plVar10 + 0x1c ) & 0x3f8000 ) != 0x1f8000 ) ) || ( ( (int)plVar10[3] != -1 || ( ( ( ~*(ushort *)((long)plVar10 + 0x1c) & 0xfff ) != 0 || ( ( *(byte*)( (long)plVar10 + 0x1d ) & 0x70 ) != 0x40 ) ) ) ) ) ) ) ) || ( ( *(char*)( (long)plVar10 + 0x22 ) != -1 || ( ( ( ( ( *(char*)( (long)plVar10 + 0x23 ) != -1 || ( *(char*)( (long)plVar10 + 0x2c ) != '\0' ) ) || ( (char)plVar10[7] != '\0' ) ) || ( ( *(char*)( (long)plVar10 + 0x2d ) != '\0' || ( *(char*)( (long)plVar10 + 0x2e ) != '\0' ) ) ) ) || ( ( ( ~*(byte *)((long)plVar10 + 0x24) & 0xf ) != 0 || ( ( ( ~*(uint *)((long)plVar10 + 0x24) & 0x3fff0 ) != 0 || ( ( ~*(ushort *)((long)plVar10 + 0x26) & 0x7ffc ) != 0 ) ) ) ) ) ) ) ) )) {
            pcVar6 = *(code**)( *(long*)this + 0x158 );
            pcVar8 = *(code**)( **(long**)( lVar11 + lVar12 ) + 0x30 );
            if (pcVar8 == TType::getFieldName_abi_cxx11_) {
               lVar11 = ( *(long**)( lVar11 + lVar12 ) )[0xe];
            }
 else {
               lVar11 = ( *pcVar8 )();
            }

            ( *pcVar6 )(this, plVar1, "cannot use layout qualifiers on structure members", *(undefined8*)( lVar11 + 8 ), &_LC1);
            *(ushort*)( (long)plVar10 + 0xf ) = *(ushort*)( (long)plVar10 + 0xf ) & 0xf08f;
            *(undefined8*)( (long)plVar10 + 0x34 ) = 0xfffff800;
            *(undefined2*)( plVar10 + 9 ) = 0;
            uVar9 = _LC291;
            *(undefined1*)( plVar10 + 6 ) = 0;
            *(undefined8*)( (long)plVar10 + 0x14 ) = uVar9;
            *(uint*)( (long)plVar10 + 0x1c ) = *(uint*)( (long)plVar10 + 0x1c ) & 0xffc00000 | 0x1fcfff;
            plVar10[4] = plVar10[4] | 0x7fffffffffffffff;
            plVar10[5] = ( ulong )((uint)plVar10[5] & 0xfe000000) | 0x1ffffff;
            lVar11 = *(long*)( lVar5 + 8 );
         }

         if (( *(byte*)( (long)plVar10 + 0xb ) & 0x10 ) != 0) {
            pcVar6 = *(code**)( *(long*)this + 0x158 );
            pcVar8 = *(code**)( **(long**)( lVar11 + lVar12 ) + 0x30 );
            if (pcVar8 == TType::getFieldName_abi_cxx11_) {
               lVar11 = ( *(long**)( lVar11 + lVar12 ) )[0xe];
            }
 else {
               lVar11 = ( *pcVar8 )();
            }

            ( *pcVar6 )(this, plVar1, "cannot use invariant qualifier on structure members", *(undefined8*)( lVar11 + 8 ), &_LC1);
            lVar11 = *(long*)( lVar5 + 8 );
         }

         uVar13 = ( ulong )((int)uVar13 + 1);
      }
 while ( uVar13 < ( ulong )(*(long*)( lVar5 + 0x10 ) - lVar11 >> 5) );
   }

   return;
}
/* glslang::TParseContext::inductiveLoopCheck(glslang::TSourceLoc const&, TIntermNode*,
   glslang::TIntermLoop*) */void glslang::TParseContext::inductiveLoopCheck(TParseContext *this, TSourceLoc *param_1, TIntermNode *param_2, TIntermLoop *param_3) {
   _Rb_tree_node_base *p_Var1;
   bool bVar2;
   byte bVar3;
   char cVar4;
   int iVar5;
   uint uVar6;
   long lVar7;
   long *plVar8;
   _Rb_tree_node_base *p_Var9;
   long *plVar10;
   long *plVar11;
   TSymbolTable *pTVar12;
   TSymbolTable *pTVar13;
   char *pcVar14;
   _Rb_tree_node_base *p_Var15;
   code *UNRECOVERED_JUMPTABLE;
   bool local_50;
   if (( param_2 != (TIntermNode*)0x0 ) && ( lVar7 = ( **(code**)( *(long*)param_2 + 0x30 ) )(param_2) ),lVar7 != 0) {
      plVar8 = (long*)( **(code**)( *(long*)param_2 + 0x30 ) )(param_2);
      if (*(code**)( *plVar8 + 400 ) == TIntermAggregate::getSequence) {
         plVar8 = plVar8 + 0x18;
      }
 else {
         plVar8 = (long*)( **(code**)( *plVar8 + 400 ) )(plVar8);
      }

      if (plVar8[2] - plVar8[1] == 8) {
         plVar8 = (long*)( **(code**)( *(long*)param_2 + 0x30 ) )(param_2);
         if (*(code**)( *plVar8 + 400 ) == TIntermAggregate::getSequence) {
            plVar8 = plVar8 + 0x18;
         }
 else {
            plVar8 = (long*)( **(code**)( *plVar8 + 400 ) )();
         }

         plVar8 = (long*)( **(code**)( **(long**)plVar8[1] + 0x40 ) )();
         if (plVar8 != (long*)0x0) {
            if (*(code**)( *plVar8 + 0xf0 ) == TIntermTyped::getType) {
               plVar10 = plVar8 + 4;
            }
 else {
               plVar10 = (long*)( **(code**)( *plVar8 + 0xf0 ) )(plVar8);
            }

            UNRECOVERED_JUMPTABLE = *(code**)( *plVar10 + 0xc0 );
            if (UNRECOVERED_JUMPTABLE == TType::isScalar) {
               UNRECOVERED_JUMPTABLE = *(code**)( *plVar10 + 0xd8 );
               if (UNRECOVERED_JUMPTABLE == TType::isVector) {
                  if (1 < ( *(byte*)( (long)plVar10 + 9 ) & 0xf )) goto LAB_0010d0dd;
                  bVar3 = *(byte*)( (long)plVar10 + 10 ) >> 4 & 1;
               }
 else {
                  bVar3 = ( *UNRECOVERED_JUMPTABLE )(plVar10);
               }

               if (bVar3 == 0) {
                  lVar7 = *plVar10;
                  if (*(code**)( lVar7 + 0xe0 ) == TType::isMatrix) {
                     if (*(byte*)( (long)plVar10 + 9 ) < 0x10) {
                        LAB_0010d189:if (*(code**)( lVar7 + 0x128 ) == TType::isStruct) {
                           if (1 < ( byte )((char)plVar10[1] - 0xfU)) {
                              LAB_0010d1b1:if (*(code**)( lVar7 + 0xe8 ) == TType::isArray) {
                                 if (plVar10[0xc] == 0) {
                                    LAB_0010d1f5:if (*(code**)( *plVar8 + 0x100 ) == TIntermTyped::getBasicType) {
                                       uVar6 = ( uint ) * (byte*)( plVar8 + 5 );
                                       if (*(byte*)( plVar8 + 5 ) != 8) {
                                          LAB_0010d218:if (uVar6 != 1) goto LAB_0010d0dd;
                                       }

                                    }
 else {
                                       iVar5 = ( **(code**)( *plVar8 + 0x100 ) )(plVar8);
                                       if (iVar5 != 8) {
                                          if (*(code**)( *plVar8 + 0x100 ) == TIntermTyped::getBasicType) {
                                             uVar6 = ( uint ) * (byte*)( plVar8 + 5 );
                                          }
 else {
                                             uVar6 = ( **(code**)( *plVar8 + 0x100 ) )(plVar8);
                                          }

                                          goto LAB_0010d218;
                                       }

                                    }

                                    if ((int)plVar8[0x17] == 0x249) {
                                       if (*(code**)( *plVar8 + 400 ) == TIntermBinary::getLeft) {
                                          plVar10 = (long*)plVar8[0x18];
                                       }
 else {
                                          plVar10 = (long*)( **(code**)( *plVar8 + 400 ) )(plVar8);
                                       }

                                       lVar7 = ( **(code**)( *plVar10 + 0x60 ) )();
                                       if (lVar7 != 0) {
                                          if (*(code**)( *plVar8 + 0x198 ) == TIntermBinary::getRight) {
                                             plVar10 = (long*)plVar8[0x19];
                                          }
 else {
                                             plVar10 = (long*)( **(code**)( *plVar8 + 0x198 ) )(plVar8);
                                          }

                                          lVar7 = ( **(code**)( *plVar10 + 0x28 ) )();
                                          if (lVar7 != 0) {
                                             if (*(code**)( *plVar8 + 400 ) == TIntermBinary::getLeft) {
                                                plVar8 = (long*)plVar8[0x18];
                                             }
 else {
                                                plVar8 = (long*)( **(code**)( *plVar8 + 400 ) )(plVar8);
                                             }

                                             plVar8 = (long*)( **(code**)( *plVar8 + 0x60 ) )();
                                             if (*(code**)( *plVar8 + 0x180 ) == TIntermSymbol::getId) {
                                                pTVar12 = (TSymbolTable*)plVar8[0x17];
                                             }
 else {
                                                pTVar12 = (TSymbolTable*)( **(code**)( *plVar8 + 0x180 ) )();
                                             }

                                             p_Var1 = (_Rb_tree_node_base*)( this + 0x7550 );
                                             p_Var9 = *(_Rb_tree_node_base**)( this + 0x7558 );
                                             p_Var15 = p_Var1;
                                             if (*(_Rb_tree_node_base**)( this + 0x7558 ) == (_Rb_tree_node_base*)0x0) {
                                                LAB_0010d6c1:if (p_Var15 != *(_Rb_tree_node_base**)( this + 0x7560 )) {
                                                   lVar7 = std::_Rb_tree_decrement(p_Var15);
                                                   lVar7 = *(long*)( lVar7 + 0x20 );
                                                   goto LAB_0010d315;
                                                }

                                                LAB_0010d31a:local_50 = true;
                                                if (p_Var1 != p_Var15) {
                                                   local_50 = (long)pTVar12 < *(long*)( p_Var15 + 0x20 );
                                                }

                                                p_Var9 = (_Rb_tree_node_base*)operator_new(0x28);
                                                *(TSymbolTable**)( p_Var9 + 0x20 ) = pTVar12;
                                                std::_Rb_tree_insert_and_rebalance(local_50, p_Var9, p_Var15, p_Var1);
                                                *(long*)( this + 0x7570 ) = *(long*)( this + 0x7570 ) + 1;
                                             }
 else {
                                                do {
                                                   p_Var15 = p_Var9;
                                                   lVar7 = *(long*)( p_Var15 + 0x20 );
                                                   p_Var9 = *(_Rb_tree_node_base**)( p_Var15 + 0x18 );
                                                   if ((long)pTVar12 < lVar7) {
                                                      p_Var9 = *(_Rb_tree_node_base**)( p_Var15 + 0x10 );
                                                   }

                                                }
 while ( p_Var9 != (_Rb_tree_node_base*)0x0 );
                                                if ((long)pTVar12 < lVar7) goto LAB_0010d6c1;
                                                LAB_0010d315:if (lVar7 < (long)pTVar12) goto LAB_0010d31a;
                                             }

                                             if (( *(long**)( param_3 + 0x28 ) != (long*)0x0 ) && ( plVar8 = (long*)( **(code**)( **(long**)( param_3 + 0x28 ) + 0x40 ) )() ),plVar8 != (long*)0x0) {
                                                uVar6 = *(uint*)( plVar8 + 0x17 );
                                                if (uVar6 < 0xa8) {
                                                   bVar2 = uVar6 < 0xa6;
                                                }
 else {
                                                   bVar2 = 3 < uVar6 - 0xaa;
                                                }

                                                if (*(code**)( *plVar8 + 400 ) == TIntermBinary::getLeft) {
                                                   plVar10 = (long*)plVar8[0x18];
                                                }
 else {
                                                   plVar10 = (long*)( **(code**)( *plVar8 + 400 ) )(plVar8);
                                                }

                                                lVar7 = ( **(code**)( *plVar10 + 0x60 ) )();
                                                if (lVar7 != 0) {
                                                   if (*(code**)( *plVar8 + 400 ) == TIntermBinary::getLeft) {
                                                      plVar10 = (long*)plVar8[0x18];
                                                   }
 else {
                                                      plVar10 = (long*)( **(code**)( *plVar8 + 400 ) )(plVar8);
                                                   }

                                                   plVar10 = (long*)( **(code**)( *plVar10 + 0x60 ) )();
                                                   if (*(code**)( *plVar10 + 0x180 ) == TIntermSymbol::getId) {
                                                      pTVar13 = (TSymbolTable*)plVar10[0x17];
                                                   }
 else {
                                                      pTVar13 = (TSymbolTable*)( **(code**)( *plVar10 + 0x180 ) )();
                                                   }

                                                   if (pTVar12 == pTVar13) {
                                                      if (*(code**)( *plVar8 + 0x198 ) == TIntermBinary::getRight) {
                                                         plVar8 = (long*)plVar8[0x19];
                                                      }
 else {
                                                         plVar8 = (long*)( **(code**)( *plVar8 + 0x198 ) )(plVar8);
                                                      }

                                                      lVar7 = ( **(code**)( *plVar8 + 0x28 ) )();
                                                      if (!bVar2 && lVar7 != 0) {
                                                         if (*(long**)( param_3 + 0x30 ) != (long*)0x0) {
                                                            plVar8 = (long*)( **(code**)( **(long**)( param_3 + 0x30 ) + 0x38 ) )();
                                                            plVar10 = (long*)( **(code**)( **(long**)( param_3 + 0x30 ) + 0x40 ) )();
                                                            if (plVar10 != (long*)0x0 || plVar8 != (long*)0x0) {
                                                               lVar7 = ( **(code**)( **(long**)( param_3 + 0x30 ) + 0x20 ) )();
                                                               uVar6 = *(uint*)( lVar7 + 0xb8 );
                                                               if (uVar6 < 0xe) {
                                                                  if (0xb < uVar6) goto LAB_0010d7c3;
                                                                  LAB_0010d4ae:bVar2 = true;
                                                                  if (plVar10 != (long*)0x0) goto LAB_0010d4bc;
                                                                  LAB_0010d54b:bVar2 = true;
                                                                  LAB_0010d550:if (*(code**)( *plVar8 + 0x188 ) == TIntermUnary::getOperand) {
                                                                     plVar10 = (long*)plVar8[0x18];
                                                                  }
 else {
                                                                     plVar10 = (long*)( **(code**)( *plVar8 + 0x188 ) )(plVar8);
                                                                  }

                                                                  lVar7 = ( **(code**)( *plVar10 + 0x60 ) )();
                                                                  if (lVar7 != 0) {
                                                                     if (*(code**)( *plVar8 + 0x188 ) == TIntermUnary::getOperand) {
                                                                        plVar8 = (long*)plVar8[0x18];
                                                                     }
 else {
                                                                        plVar8 = (long*)( **(code**)( *plVar8 + 0x188 ) )(plVar8);
                                                                     }

                                                                     plVar8 = (long*)( **(code**)( *plVar8 + 0x60 ) )();
                                                                     if (*(code**)( *plVar8 + 0x180 ) == TIntermSymbol::getId) {
                                                                        pTVar13 = (TSymbolTable*)plVar8[0x17];
                                                                     }
 else {
                                                                        pTVar13 = (TSymbolTable*)( **(code**)( *plVar8 + 0x180 ) )(plVar8);
                                                                     }

                                                                     if (pTVar12 == pTVar13) goto LAB_0010d5ca;
                                                                  }

                                                               }
 else {
                                                                  if (1 < uVar6 - 0x24a) goto LAB_0010d4ae;
                                                                  LAB_0010d7c3:bVar2 = false;
                                                                  if (plVar10 == (long*)0x0) goto LAB_0010d550;
                                                                  LAB_0010d4bc:if (*(code**)( *plVar10 + 400 ) == TIntermBinary::getLeft) {
                                                                     plVar11 = (long*)plVar10[0x18];
                                                                  }
 else {
                                                                     plVar11 = (long*)( **(code**)( *plVar10 + 400 ) )(plVar10);
                                                                  }

                                                                  lVar7 = ( **(code**)( *plVar11 + 0x60 ) )();
                                                                  if (lVar7 == 0) {
                                                                     LAB_0010d542:if (plVar8 == (long*)0x0) goto LAB_0010d6f8;
                                                                     goto LAB_0010d54b;
                                                                  }

                                                                  if (*(code**)( *plVar10 + 400 ) == TIntermBinary::getLeft) {
                                                                     plVar11 = (long*)plVar10[0x18];
                                                                  }
 else {
                                                                     plVar11 = (long*)( **(code**)( *plVar10 + 400 ) )(plVar10);
                                                                  }

                                                                  plVar11 = (long*)( **(code**)( *plVar11 + 0x60 ) )();
                                                                  if (*(code**)( *plVar11 + 0x180 ) == TIntermSymbol::getId) {
                                                                     pTVar13 = (TSymbolTable*)plVar11[0x17];
                                                                  }
 else {
                                                                     pTVar13 = (TSymbolTable*)( **(code**)( *plVar11 + 0x180 ) )();
                                                                  }

                                                                  if (pTVar12 != pTVar13) goto LAB_0010d542;
                                                                  plVar10 = (long*)( **(code**)( *plVar10 + 0x198 ) )(plVar10);
                                                                  lVar7 = ( **(code**)( *plVar10 + 0x28 ) )(plVar10);
                                                                  if (lVar7 == 0) goto LAB_0010d542;
                                                                  if (plVar8 != (long*)0x0) goto LAB_0010d550;
                                                                  LAB_0010d5ca:if (!bVar2) {
                                                                     glslang::TParseContext::inductiveLoopBodyCheck((TIntermNode*)this, *(longlong*)( param_3 + 0x20 ), pTVar12);
                                                                     return;
                                                                  }

                                                               }

                                                            }

                                                         }

                                                         LAB_0010d6f8:pcVar14 = "inductive-loop termination requires the form \"loop-index++, loop-index--, loop-index += constant-expression, or loop-index -= constant-expression\"";
                                                         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                                                         goto LAB_0010d11f;
                                                      }

                                                   }

                                                }

                                             }

                                             pcVar14 = "inductive-loop condition requires the form \"loop-index <comparison-op> constant-expression\"";
                                             UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                                             goto LAB_0010d11f;
                                          }

                                       }

                                    }

                                    goto LAB_0010d100;
                                 }

                              }
 else {
                                 cVar4 = ( **(code**)( lVar7 + 0xe8 ) )(plVar10);
                                 if (cVar4 == '\0') goto LAB_0010d1f5;
                              }

                           }

                        }
 else {
                           cVar4 = ( **(code**)( lVar7 + 0x128 ) )(plVar10);
                           if (cVar4 == '\0') {
                              lVar7 = *plVar10;
                              goto LAB_0010d1b1;
                           }

                        }

                     }

                  }
 else {
                     cVar4 = ( **(code**)( lVar7 + 0xe0 ) )(plVar10);
                     if (cVar4 == '\0') {
                        lVar7 = *plVar10;
                        goto LAB_0010d189;
                     }

                  }

               }

            }
 else {
               cVar4 = ( *UNRECOVERED_JUMPTABLE )(plVar10);
               if (cVar4 != '\0') goto LAB_0010d1f5;
            }

            LAB_0010d0dd:pcVar14 = "inductive loop requires a scalar \'int\' or \'float\' loop index";
            UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
            goto LAB_0010d11f;
         }

      }

   }

   LAB_0010d100:pcVar14 = "inductive-loop init-declaration requires the form \"type-specifier loop-index = constant-expression\"";
   UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
   LAB_0010d11f:/* WARNING: Could not recover jumptable at 0x0010d135. Too many branches *//* WARNING: Treating indirect jump as call */( *UNRECOVERED_JUMPTABLE )(this, param_1, pcVar14, "limitations", &_LC1, UNRECOVERED_JUMPTABLE);
   return;
}
/* glslang::TParseContext::limitCheck(glslang::TSourceLoc const&, int, char const*, char const*) */void glslang::TParseContext::limitCheck(TParseContext *this, TSourceLoc *param_1, int param_2, char *param_3, char *param_4) {
   TSymbolTable *this_00;
   size_t sVar1;
   long *plVar2;
   long in_FS_OFFSET;
   undefined8 local_68;
   undefined1 *local_60;
   undefined1 local_50[16];
   long local_40;
   this_00 = *(TSymbolTable**)( this + 0xe8 );
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   local_68 = glslang::GetThreadPoolAllocator();
   local_60 = local_50;
   if (param_3 == (char*)0x0) {
      /* WARNING: Subroutine does not return */
      std::__throw_logic_error("basic_string: construction from null is not valid");
   }

   sVar1 = strlen(param_3);
   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>((basic_string*)&local_68, param_3, param_3 + sVar1);
   plVar2 = (long*)TSymbolTable::find(this_00, (basic_string*)&local_68, (bool*)0x0, (bool*)0x0, (int*)0x0);
   plVar2 = (long*)( **(code**)( *plVar2 + 0x48 ) )(plVar2);
   if (*(code**)( *plVar2 + 0xb8 ) == TVariable::getConstArray) {
      plVar2 = plVar2 + 0x19;
   }
 else {
      plVar2 = (long*)( **(code**)( *plVar2 + 0xb8 ) )();
   }

   if (**(int**)( plVar2[1] + 8 ) < param_2) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "must be less than or equal to", param_4, "%s (%d)", param_3, **(int**)( plVar2[1] + 8 ));
   }

   if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::arrayLimitCheck(glslang::TSourceLoc const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const&,
   int) */void glslang::TParseContext::arrayLimitCheck(TParseContext *this, TSourceLoc *param_1, basic_string *param_2, int param_3) {
   ulong __n;
   long *__s1;
   int iVar1;
   char *pcVar2;
   int iVar3;
   char *pcVar4;
   __n = *(ulong*)( param_2 + 0x10 );
   __s1 = *(long**)( param_2 + 8 );
   iVar3 = (int)__n;
   if (__n < 0xc) {
      if (__n == 0) {
         return;
      }

      iVar1 = memcmp(__s1, "gl_TexCoord", __n);
      if (iVar1 == 0) {
         pcVar4 = "gl_TexCoord array size";
         pcVar2 = "gl_MaxTextureCoords";
         if (iVar3 == 0xb) goto LAB_0010dac1;
      }

      LAB_0010da06:iVar1 = memcmp(__s1, "gl_ClipDistance", __n);
      if (( iVar1 == 0 ) && ( iVar3 == 0xf )) {
         pcVar4 = "gl_ClipDistance array size";
         pcVar2 = "gl_MaxClipDistances";
         goto LAB_0010dac1;
      }

      iVar1 = memcmp(__s1, "gl_CullDistance", __n);
      if (iVar1 != 0) {
         LAB_0010da3a:iVar1 = memcmp(__s1, "gl_ClipDistancePerViewNV", __n);
         if (( iVar1 == 0 ) && ( iVar3 == 0x18 )) {
            pcVar4 = "gl_ClipDistancePerViewNV array size";
            pcVar2 = "gl_MaxClipDistances";
            goto LAB_0010dac1;
         }

         iVar1 = memcmp(__s1, "gl_CullDistancePerViewNV", __n);
         if (iVar1 != 0) {
            return;
         }

         goto LAB_0010da72;
      }

      LAB_0010dc0c:pcVar4 = "gl_CullDistance array size";
      if (iVar3 != 0xf) goto LAB_0010db78;
   }
 else {
      if (( *__s1 != 0x6f437865545f6c67 ) || ( *(int*)( (long)__s1 + 7 ) != 0x64726f6f )) {
         if (0xf < __n) goto LAB_0010db50;
         goto LAB_0010da06;
      }

      if (( (long)( __n - 0xb ) < 0x80000000 ) && ( -0x80000001 < (long)( __n - 0xb ) )) {
         if (__n < 0x10) goto LAB_0010da06;
         iVar1 = memcmp(__s1, "gl_ClipDistance", 0xf);
         if (iVar1 != 0) {
            LAB_0010db64:if (( *__s1 != 0x446c6c75435f6c67 ) || ( *(long*)( (long)__s1 + 7 ) != 0x65636e6174736944 )) goto LAB_0010db78;
            if (( 0x7fffffff < (long)( __n - 0xf ) ) || ( (long)( __n - 0xf ) < -0x80000000 )) goto LAB_0010db82;
            goto LAB_0010dc0c;
         }

         LAB_0010dc64:if (-0x80000001 < (long)( __n - 0xf )) goto LAB_0010db64;
         if (( *__s1 == 0x446c6c75435f6c67 ) && ( *(long*)( (long)__s1 + 7 ) == 0x65636e6174736944 )) goto LAB_0010db82;
         LAB_0010db78:if (__n < 0x19) goto LAB_0010da3a;
      }
 else {
         LAB_0010db50:if (( *__s1 != 0x4470696c435f6c67 ) || ( *(long*)( (long)__s1 + 7 ) != 0x65636e6174736944 )) goto LAB_0010db64;
         if ((long)( __n - 0xf ) < 0x80000000) goto LAB_0010dc64;
      }

      LAB_0010db82:if (( *__s1 == 0x4470696c435f6c67 && __s1[1] == 0x5065636e61747369 ) && ( __s1[2] == 0x564e776569567265 )) {
         if (0x7fffffff < (long)( __n - 0x18 )) {
            return;
         }

         if ((long)( __n - 0x18 ) < -0x80000000) {
            return;
         }

      }

      if (*__s1 != 0x446c6c75435f6c67 || __s1[1] != 0x5065636e61747369) {
         return;
      }

      if (__s1[2] != 0x564e776569567265) {
         return;
      }

      if (0x7fffffff < (long)( __n - 0x18 )) {
         return;
      }

      if ((long)( __n - 0x18 ) < -0x80000000) {
         return;
      }

      LAB_0010da72:if (iVar3 != 0x18) {
         return;
      }

      pcVar4 = "gl_CullDistancePerViewNV array size";
   }

   pcVar2 = "gl_MaxCullDistances";
   LAB_0010dac1:limitCheck(this, param_1, param_3, pcVar2, pcVar4);
   return;
}
/* glslang::TParseContext::mergeObjectLayoutQualifiers(glslang::TQualifier&, glslang::TQualifier
   const&, bool) */void glslang::TParseContext::mergeObjectLayoutQualifiers(TParseContext *this, TQualifier *param_1, TQualifier *param_2, bool param_3) {
   if (( (byte)param_2[0xf] & 0x70 ) != 0) {
      param_1[0xf] = ( TQualifier )((byte)param_2[0xf] & 0x70 | (byte)param_1[0xf] & 0x8f);
   }

   if (( (byte)param_2[0x10] & 0xf ) != 0) {
      param_1[0x10] = ( TQualifier )((byte)param_2[0x10] & 0xf | (byte)param_1[0x10] & 0xf0);
   }

   if (param_2[0x23] != (TQualifier)0xff) {
      param_1[0x23] = param_2[0x23];
   }

   if (param_2[0x2c] != (TQualifier)0x0) {
      param_1[0x2c] = param_2[0x2c];
   }

   if (( (byte)param_2[0x24] & 0xf ) != 0xf) {
      param_1[0x24] = ( TQualifier )((byte)param_2[0x24] & 0xf | (byte)param_1[0x24] & 0xf0);
   }

   if (( ~*(ushort *)(param_2 + 0x2a) & 0x1f8 ) != 0) {
      *(ushort*)( param_1 + 0x2a ) = *(ushort*)( param_2 + 0x2a ) & 0x1f8 | *(ushort*)( param_1 + 0x2a ) & 0xfe07;
   }

   if (*(int*)( param_2 + 0x18 ) != -1) {
      *(int*)( param_1 + 0x18 ) = *(int*)( param_2 + 0x18 );
   }

   if (!param_3) {
      if (( *(ushort*)( param_2 + 0x1c ) & 0xfff ) != 0xfff) {
         *(ushort*)( param_1 + 0x1c ) = *(ushort*)( param_2 + 0x1c ) & 0xfff | *(ushort*)( param_1 + 0x1c ) & 0xf000;
      }

      if (*(int*)( param_2 + 0x14 ) != -1) {
         *(int*)( param_1 + 0x14 ) = *(int*)( param_2 + 0x14 );
      }

      if (( *(uint*)( param_2 + 0x1c ) & 0x3f8000 ) != 0x1f8000) {
         *(uint*)( param_1 + 0x1c ) = *(uint*)( param_2 + 0x1c ) & 0x3f8000 | *(uint*)( param_1 + 0x1c ) & 0xffc07fff;
      }

      if (*(short*)( param_2 + 0x20 ) != -1) {
         *(short*)( param_1 + 0x20 ) = *(short*)( param_2 + 0x20 );
      }

      if (( ~*(uint *)(param_2 + 0x28) & 0x7ff00 ) != 0) {
         *(uint*)( param_1 + 0x28 ) = *(uint*)( param_2 + 0x28 ) & 0x7ff00 | *(uint*)( param_1 + 0x28 ) & 0xfff800ff;
      }

      if (( (byte)param_2[0x1d] & 0x70 ) != 0x40) {
         param_1[0x1d] = ( TQualifier )((byte)param_2[0x1d] & 0x70 | (byte)param_1[0x1d] & 0x8f);
      }

      if (param_2[0x22] != (TQualifier)0xff) {
         param_1[0x22] = param_2[0x22];
      }

      if (( ~*(uint *)(param_2 + 0x24) & 0x3fff0 ) != 0) {
         *(uint*)( param_1 + 0x24 ) = *(uint*)( param_2 + 0x24 ) & 0x3fff0 | *(uint*)( param_1 + 0x24 ) & 0xfffc000f;
      }

      if (( ~*(ushort *)(param_2 + 0x26) & 0x7ffc ) != 0) {
         *(ushort*)( param_1 + 0x26 ) = *(ushort*)( param_2 + 0x26 ) & 0x7ffc | *(ushort*)( param_1 + 0x26 ) & 0x8003;
      }

      if (param_2[0x28] != (TQualifier)0xff) {
         param_1[0x28] = param_2[0x28];
      }

      if (param_2[0x2d] != (TQualifier)0x0) {
         param_1[0x2d] = (TQualifier)0x1;
      }

      if (param_2[0x2e] != (TQualifier)0x0) {
         param_1[0x2e] = (TQualifier)0x1;
      }

      if (param_2[0x2f] != (TQualifier)0x0) {
         param_1[0x2f] = (TQualifier)0x1;
      }

      if (param_2[0x30] != (TQualifier)0x0) {
         param_1[0x30] = (TQualifier)0x1;
      }

      if (*(int*)( param_2 + 0x34 ) != -0x800) {
         *(int*)( param_1 + 0x34 ) = *(int*)( param_2 + 0x34 );
      }

      if (param_2[0x38] != (TQualifier)0x0) {
         param_1[0x38] = (TQualifier)0x1;
      }

      if (param_2[0x39] != (TQualifier)0x0) {
         param_1[0x39] = (TQualifier)0x1;
      }

      if (param_2[0x3a] != (TQualifier)0x0) {
         param_1[0x3a] = (TQualifier)0x1;
      }

      if (param_2[0x48] != (TQualifier)0x0) {
         param_1[0x48] = (TQualifier)0x1;
      }

      if (param_2[0x49] != (TQualifier)0x0) {
         param_1[0x49] = (TQualifier)0x1;
      }

      if ((char)param_2[0xc] < '\0') {
         param_1[0xc] = ( TQualifier )((byte)param_1[0xc] | 0x80);
      }

      if (( (byte)param_2[0xd] & 1 ) != 0) {
         param_1[0xd] = ( TQualifier )((byte)param_1[0xd] | 1);
      }

      if (param_2[0x3b] != (TQualifier)0x0) {
         param_1[0x3b] = (TQualifier)0x1;
      }

   }

   return;
}
/* glslang::TParseContext::layoutMemberLocationArrayCheck(glslang::TSourceLoc const&, bool,
   glslang::TArraySizes*) */void glslang::TParseContext::layoutMemberLocationArrayCheck(TParseContext *this, TSourceLoc *param_1, bool param_2, TArraySizes *param_3) {
   long lVar1;
   byte bVar2;
   if (( param_3 != (TArraySizes*)0x0 ) && ( param_2 )) {
      lVar1 = *(long*)( param_3 + 8 );
      if (lVar1 != 0) {
         bVar2 = TQualifier::isArrayedIo((TQualifier*)( this + 0x510 ), *(undefined4*)( this + 0x1c ));
         if ((int)(uint)bVar2 < (int)( *(long*)( lVar1 + 0x10 ) - *(long*)( lVar1 + 8 ) >> 4 )) {
            /* WARNING: Could not recover jumptable at 0x0010df9f. Too many branches */
            /* WARNING: Treating indirect jump as call */
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot use in a block array where new locations are needed for each block element", "location", &_LC1, *(code**)( *(long*)this + 0x158 ));
            return;
         }

      }

      return;
   }

   return;
}
/* glslang::TParseContext::layoutQualifierCheck(glslang::TSourceLoc const&, glslang::TQualifier
   const&) */void glslang::TParseContext::layoutQualifierCheck(TParseContext *this, TSourceLoc *param_1, TQualifier *param_2) {
   TQualifier TVar1;
   byte bVar2;
   uint uVar3;
   ulong uVar4;
   int iVar5;
   long in_FS_OFFSET;
   bool bVar6;
   char *pcVar7;
   char *pcVar8;
   char *local_48;
   char *pcStack_40;
   long local_30;
   local_30 = *(long*)( in_FS_OFFSET + 0x28 );
   TVar1 = param_2[8];
   pcVar7 = "GL_ARB_separate_shader_objects";
   pcVar8 = "GL_ARB_explicit_attrib_location";
   iVar5 = (int)param_1;
   if (( (byte)TVar1 & 0x7f ) == 7) {
      if (( ( ( ( ( ( (byte)param_2[0xf] & 0x70 ) != 0 ) || ( ( (byte)param_2[0x10] & 0xf ) != 0 ) ) || ( *(int*)( param_2 + 0x14 ) != -1 ) ) || ( ( ( *(short*)( param_2 + 0x20 ) != -1 || ( ( *(uint*)( param_2 + 0x1c ) & 0x3f8000 ) != 0x1f8000 ) ) || ( ( *(int*)( param_2 + 0x18 ) != -1 || ( ( ( ~*(ushort *)(param_2 + 0x1c) & 0xfff ) != 0 || ( ( (byte)param_2[0x1d] & 0x70 ) != 0x40 ) ) ) ) ) ) ) ) || ( ( param_2[0x22] != (TQualifier)0xff || ( ( ( ( ( param_2[0x23] != (TQualifier)0xff || ( param_2[0x2c] != (TQualifier)0x0 ) ) || ( param_2[0x38] != (TQualifier)0x0 ) ) || ( ( param_2[0x2d] != (TQualifier)0x0 || ( param_2[0x2e] != (TQualifier)0x0 ) ) ) ) || ( ( ~(byte)param_2[0x24] & 0xf ) != 0 ) ) ) ) ) ) || ( ( ( ~*(uint *)(param_2 + 0x24) & 0x3fff0 ) != 0 || ( ( ~*(ushort *)(param_2 + 0x26) & 0x7ffc ) != 0 ) ) )) {
         if (*(int*)( this + 0x20 ) - 1U < 0x103ff) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "shared block requires at least SPIR-V 1.4", "shared block", &_LC1, *(long*)this, "GL_ARB_separate_shader_objects", "GL_ARB_explicit_attrib_location");
         }

         glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar5, 0xe, (char*)0x0, "GL_EXT_shared_memory_block");
         goto LAB_0010e017;
      }

      LAB_0010e484:uVar3 = (uint)(byte)TVar1;
      if (param_2[0x22] != (TQualifier)0xff) {
         bVar2 = (byte)TVar1 & 0x7f;
         if (bVar2 == 4) goto LAB_0010e6fc;
         if (bVar2 < 5) {
            if (bVar2 == 3) goto LAB_0010e3a1;
         }
 else if (( bVar2 + 0x7b & 0x7f ) < 2) {
            LAB_0010e05c:glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar5, (char*)0xf);
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar5, -9, (char*)0x14a, "GL_ARB_explicit_attrib_location");
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar5, -9, (char*)0x1ae, "GL_ARB_explicit_uniform_location");
            goto LAB_0010e0b7;
         }

         goto LAB_0010e0d9;
      }

   }
 else {
      LAB_0010e017:if (( (byte)param_2[0x1d] & 0x70 ) == 0x40) {
         if (( *(ushort*)( param_2 + 0x1c ) & 0xfff ) == 0xfff) goto LAB_0010e480;
         TVar1 = param_2[8];
         bVar2 = (byte)TVar1 & 0x7f;
         bVar6 = bVar2 == 4;
         if (!bVar6) goto LAB_0010e04b;
         LAB_0010e6fc:if (( *(int*)( this + 0xc ) == 8 ) && ( *(int*)( this + 0x18 ) < 0x136 )) {
            glslang::TParseVersions::requireStage(this, param_1, 4, "location qualifier on output");
         }
 else {
            glslang::TParseVersions::requireStage(this, param_1, 0xffffffdf);
         }

         if (*(int*)( this + 0x1c ) == 4) {
            local_48 = pcVar7;
            pcStack_40 = pcVar8;
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar5, -9, 0x14a, (char**)0x2, (char*)&local_48);
            LAB_0010e410:glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar5, 8, (char*)0x12c, (char*)0x0);
            uVar3 = (uint)(byte)param_2[8];
         }
 else {
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar5, -9, (char*)0x19a, "GL_ARB_separate_shader_objects");
            LAB_0010e0b7:glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar5, 8, (char*)0x136, (char*)0x0);
            uVar3 = (uint)(byte)param_2[8];
         }

      }
 else {
         if (( ( ( *(ushort*)( param_2 + 0x1c ) & 0xfff ) == 0xfff ) && ( ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "must specify \'location\' to use \'component\'", "component", &_LC1),( ~*(ushort *)(param_2 + 0x1c) & 0xfff ) == 0 ) ) && ( ( (byte)param_2[0x1d] & 0x70 ) == 0x40 )) {
            LAB_0010e480:TVar1 = param_2[8];
            goto LAB_0010e484;
         }

         TVar1 = param_2[8];
         bVar2 = (byte)TVar1 & 0x7f;
         bVar6 = bVar2 == 4;
         if (bVar6) goto LAB_0010e6fc;
         LAB_0010e04b:uVar3 = (uint)(byte)TVar1;
         if (bVar2 < 4 || bVar6) {
            if (bVar2 != 3) goto LAB_0010e0d3;
            LAB_0010e3a1:if (( *(int*)( this + 0xc ) == 8 ) && ( *(int*)( this + 0x18 ) < 0x136 )) {
               glslang::TParseVersions::requireStage(this, param_1, 0, "location qualifier on input");
            }
 else {
               glslang::TParseVersions::requireStage(this, param_1, 0xffffffdf);
            }

            if (*(int*)( this + 0x1c ) != 0) {
               glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar5, -9, (char*)0x19a, "GL_ARB_separate_shader_objects");
               goto LAB_0010e0b7;
            }

            local_48 = pcVar7;
            pcStack_40 = pcVar8;
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar5, -9, 0x14a, (char**)0x2, (char*)&local_48);
            goto LAB_0010e410;
         }

         if (( bVar2 + 0x7b & 0x7f ) < 2) goto LAB_0010e05c;
      }

      LAB_0010e0d3:TVar1 = SUB41(uVar3, 0);
      if (param_2[0x22] != (TQualifier)0xff) {
         LAB_0010e0d9:if (( (byte)TVar1 & 0x7f ) != 4) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be used on an output", "index", &_LC1);
         }

         if (( ~*(ushort *)(param_2 + 0x1c) & 0xfff ) == 0) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be used with an explicit location", "index", &_LC1);
         }

         uVar3 = (uint)(byte)param_2[8];
      }

   }

   if (( ( *(short*)( param_2 + 0x20 ) != -1 ) && ( 1 < ( uVar3 & 0x7f ) - 5 ) ) && ( ( (byte)param_2[0xd] & 8 ) == 0 )) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "requires uniform or buffer storage qualifier", "binding", &_LC1);
      uVar3 = (uint)(byte)param_2[8];
   }

   if (param_2[0x23] == (TQualifier)0xff) {
      LAB_0010e56c:if (( ~(byte)param_2[0x24] & 0xf ) != 0) {
         LAB_0010e57b:uVar4 = ( ulong )(uVar3 & 0x7f);
         if (( byte )(uVar3 & 0x7f) < 0x1f) goto LAB_0010e196;
         goto LAB_0010e589;
      }

      LAB_0010e640:if (( ( ~*(uint *)(param_2 + 0x24) & 0x3fff0 ) != 0 ) || ( ( ~*(ushort *)(param_2 + 0x26) & 0x7ffc ) != 0 )) goto LAB_0010e57b;
   }
 else {
      uVar4 = ( ulong )(uVar3 & 0x7f);
      if (( 0x1e < ( byte )(uVar3 & 0x7f) ) || ( ( 0x71c00010UL >> ( uVar4 & 0x3f ) & 1 ) == 0 )) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be used on an output", "stream", &_LC1);
         uVar3 = (uint)(byte)param_2[8];
         goto LAB_0010e56c;
      }

      if (( ~(byte)param_2[0x24] & 0xf ) == 0) goto LAB_0010e640;
      LAB_0010e196:if (( 0x71c00010UL >> ( uVar4 & 0x3f ) & 1 ) == 0) {
         LAB_0010e589:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be used on an output", "xfb layout qualifier", &_LC1);
         uVar3 = (uint)(byte)param_2[8];
      }

   }

   TVar1 = SUB41(uVar3, 0);
   if (( ( (byte)param_2[0xf] & 0x70 ) == 0 ) && ( ( (byte)param_2[0x10] & 0xf ) == 0 )) {
      if (( ( ( ( *(int*)( param_2 + 0x14 ) != -1 ) || ( *(short*)( param_2 + 0x20 ) != -1 ) ) || ( ( *(uint*)( param_2 + 0x1c ) & 0x3f8000 ) != 0x1f8000 ) ) || ( *(int*)( param_2 + 0x18 ) != -1 ) ) && ( ( 2 < ( uVar3 & 0x7f ) - 5 && ( ( (byte)param_2[0xd] & 8 ) == 0 ) ) )) {
         LAB_0010e503:if (( *(int*)( param_2 + 0x14 ) != -1 ) || ( *(int*)( param_2 + 0x18 ) != -1 )) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "offset/align can only be used on a uniform or buffer", "layout", &_LC1);
         }

         TVar1 = param_2[8];
      }

   }
 else if (( 2 < ( uVar3 & 0x7f ) - 5 ) && ( ( (byte)param_2[0xd] & 8 ) == 0 )) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "matrix or packing qualifiers can only be used on a uniform or buffer", "layout", &_LC1);
      goto LAB_0010e503;
   }

   if (param_2[0x2d] != (TQualifier)0x0) {
      if (( (byte)TVar1 & 0x7f ) != 5) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be used with a uniform", "push_constant", &_LC1);
      }

      if (( *(uint*)( param_2 + 0x1c ) & 0x3f8000 ) != 0x1f8000) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot be used with push_constant", &_LC477, &_LC1);
      }

      if (*(short*)( param_2 + 0x20 ) != -1) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot be used with push_constant", "binding", &_LC1);
      }

      TVar1 = param_2[8];
   }

   if (param_2[0x2e] == (TQualifier)0x0) {
      LAB_0010e2b8:bVar2 = (byte)TVar1 & 0x7f;
      if (param_2[0x38] == (TQualifier)0x0) {
         LAB_0010e362:if (bVar2 == 0x1f) {
            if (( *(uint*)( param_2 + 0x1c ) & 0x3f8000 ) == 0x1f8000) goto LAB_0010e83f;
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot be used with tileImageEXT", &_LC477, &_LC1);
            if (( ~*(ushort *)(param_2 + 0x1c) & 0xfff ) == 0) goto LAB_0010e84f;
            bVar2 = (byte)param_2[8] & 0x7f;
         }

      }
 else {
         if (bVar2 != 6) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be used with a buffer", "shaderRecordNV", &_LC1);
         }

         LAB_0010e2f1:if (*(short*)( param_2 + 0x20 ) != -1) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot be used with shaderRecordNV", "binding", &_LC1);
         }

         if (( *(uint*)( param_2 + 0x1c ) & 0x3f8000 ) != 0x1f8000) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot be used with shaderRecordNV", &_LC477, &_LC1);
            bVar2 = (byte)param_2[8] & 0x7f;
            goto LAB_0010e362;
         }

         bVar2 = (byte)param_2[8] & 0x7f;
         if (bVar2 == 0x1f) {
            LAB_0010e83f:if (( ~*(ushort *)(param_2 + 0x1c) & 0xfff ) != 0) goto LAB_0010e372;
            LAB_0010e84f:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be used with an explicit location", "tileImageEXT", &_LC1);
            bVar2 = (byte)param_2[8] & 0x7f;
         }

      }

      if (( bVar2 == 0xb ) && ( ( ( ( ( ( ( (byte)param_2[0xf] & 0x70 ) != 0 || ( ( (byte)param_2[0x10] & 0xf ) != 0 ) ) || ( ( *(int*)( param_2 + 0x14 ) != -1 || ( ( ( *(short*)( param_2 + 0x20 ) != -1 || ( ( *(uint*)( param_2 + 0x1c ) & 0x3f8000 ) != 0x1f8000 ) ) || ( *(int*)( param_2 + 0x18 ) != -1 ) ) ) ) ) ) || ( ( ( ~*(ushort *)(param_2 + 0x1c) & 0xfff ) != 0 || ( ( (byte)param_2[0x1d] & 0x70 ) != 0x40 ) ) ) ) || ( param_2[0x22] != (TQualifier)0xff ) ) || ( ( ( ( param_2[0x23] != (TQualifier)0xff || ( param_2[0x2c] != (TQualifier)0x0 ) ) || ( ( param_2[0x38] != (TQualifier)0x0 || ( ( ( param_2[0x2d] != (TQualifier)0x0 || ( param_2[0x2e] != (TQualifier)0x0 ) ) || ( ( ~(byte)param_2[0x24] & 0xf ) != 0 ) ) ) ) ) ) || ( ( ( ~*(uint *)(param_2 + 0x24) & 0x3fff0 ) != 0 || ( ( ~*(ushort *)(param_2 + 0x26) & 0x7ffc ) != 0 ) ) ) ) ) ) )) {
         if (local_30 == *(long*)( in_FS_OFFSET + 0x28 )) {
            /* WARNING: Could not recover jumptable at 0x0010e6d6. Too many branches */
            /* WARNING: Treating indirect jump as call */
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot apply layout qualifiers to hitAttributeNV variable", "hitAttributeNV", &_LC1, *(code**)( *(long*)this + 0x158 ));
            return;
         }

         goto LAB_0010eae6;
      }

   }
 else {
      if (( (byte)TVar1 & 0x7f ) != 6) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be used with buffer", "buffer_reference", &_LC1);
         TVar1 = param_2[8];
         goto LAB_0010e2b8;
      }

      if (param_2[0x38] != (TQualifier)0x0) goto LAB_0010e2f1;
   }

   LAB_0010e372:if (local_30 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return;
   }

   LAB_0010eae6:/* WARNING: Subroutine does not return */__stack_chk_fail();
}
/* glslang::TParseContext::checkNoShaderLayouts(glslang::TSourceLoc const&,
   glslang::TShaderQualifiers const&) */void glslang::TParseContext::checkNoShaderLayouts(TParseContext *this, TSourceLoc *param_1, TShaderQualifiers *param_2) {
   int iVar1;
   undefined *puVar2;
   char *pcVar3;
   long lVar4;
   TShaderQualifiers *pTVar5;
   if (*(int*)param_2 != 0) {
      switch (*(int*)param_2) {
         case 1:
      pcVar3 = "points";
      break;
         case 2:
      pcVar3 = "lines";
      break;
         case 3:
      pcVar3 = "lines_adjacency";
      break;
         case 4:
      pcVar3 = "line_strip";
      break;
         case 5:
      pcVar3 = "triangles";
      break;
         case 6:
      pcVar3 = "triangles_adjacency";
      break;
         case 7:
      pcVar3 = "triangle_strip";
      break;
         case 8:
      pcVar3 = "quads";
      break;
         case 9:
      pcVar3 = "isolines";
      break;
         default:
      pcVar3 = "none";
      }

      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to a standalone qualifier", pcVar3, &_LC1);
   }

   iVar1 = *(int*)( param_2 + 0x10 );
   if (iVar1 != 0) {
      pcVar3 = "fractional_even_spacing";
      if (( ( iVar1 != 2 ) && ( pcVar3 = "fractional_odd_spacing" ),iVar1 != 3 )) {
         pcVar3 = "none";
      }

      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to a standalone qualifier", pcVar3, &_LC1);
   }

   iVar1 = *(int*)( param_2 + 0x14 );
   if (iVar1 != 0) {
      puVar2 = &_LC499;
      if (( iVar1 != 1 ) && ( puVar2 = iVar1 != 2 )) {
         puVar2 = &_LC273;
      }

      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to a standalone qualifier", puVar2, &_LC1);
   }

   if (param_2[0x18] != (TShaderQualifiers)0x0) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to a standalone qualifier", "point_mode", &_LC1);
   }

   if (*(int*)( param_2 + 8 ) != -1) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to a standalone qualifier", "invocations", &_LC1);
   }

   pTVar5 = param_2 + 0x1c;
   do {
      if (1 < *(int*)pTVar5) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to a standalone qualifier", "local_size", &_LC1);
      }

      if (*(int*)( pTVar5 + 0x10 ) != -1) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to a standalone qualifier", "local_size id", &_LC1);
      }

      pTVar5 = pTVar5 + 4;
   }
 while ( pTVar5 != param_2 + 0x28 );
   if (*(int*)( param_2 + 0xc ) != -1) {
      iVar1 = *(int*)( this + 0x1c );
      if (( iVar1 == 3 ) || ( iVar1 == 0xd )) {
         lVar4 = *(long*)this;
         pcVar3 = "max_vertices";
      }
 else {
         if (iVar1 != 1) goto LAB_0010ece5;
         lVar4 = *(long*)this;
         pcVar3 = "vertices";
      }

      ( **(code**)( lVar4 + 0x158 ) )(this, param_1, "can only apply to a standalone qualifier", pcVar3, &_LC1);
   }

   LAB_0010ece5:if (param_2[0x38] != (TShaderQualifiers)0x0) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to a standalone qualifier", "early_fragment_tests", &_LC1);
   }

   if (param_2[0x39] != (TShaderQualifiers)0x0) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to a standalone qualifier", "post_depth_coverage", &_LC1);
   }

   if (param_2[0x3b] != (TShaderQualifiers)0x0) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to a standalone qualifier", "non_coherent_color_attachment_readEXT", &_LC1);
   }

   if (param_2[0x3c] != (TShaderQualifiers)0x0) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to a standalone qualifier", "non_coherent_depth_attachment_readEXT", &_LC1);
   }

   if (param_2[0x3d] != (TShaderQualifiers)0x0) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to a standalone qualifier", "non_coherent_stencil_attachment_readEXT", &_LC1);
   }

   if (( *(int*)( param_2 + 0x58 ) != -1 ) && ( *(int*)( this + 0x1c ) == 0xd )) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to a standalone qualifier", "max_primitives", &_LC1);
   }

   if (param_2[0x48] != (TShaderQualifiers)0x0) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to a standalone qualifier", "blend equation", &_LC1);
   }

   if (*(int*)( param_2 + 0x4c ) != -1) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to a standalone qualifier", "num_views", &_LC1);
   }

   if (*(int*)( param_2 + 0x50 ) != 0) {
      switch (*(int*)( param_2 + 0x50 )) {
         case 1:
      pcVar3 = "pixel_interlock_ordered";
      break;
         case 2:
      pcVar3 = "pixel_interlock_unordered";
      break;
         case 3:
      pcVar3 = "sample_interlock_ordered";
      break;
         case 4:
      pcVar3 = "sample_interlock_unordered";
      break;
         case 5:
      pcVar3 = "shading_rate_interlock_ordered";
      break;
         case 6:
      pcVar3 = "shading_rate_interlock_unordered";
      break;
         default:
      pcVar3 = "none";
      }

      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to a standalone qualifier", pcVar3, &_LC1);
   }

   if (param_2[0x5c] == (TShaderQualifiers)0x0) {
      return;
   }

   /* WARNING: Could not recover jumptable at 0x0010eec4. Too many branches */
   /* WARNING: Treating indirect jump as call */
   ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be applied as standalone", "primitive_culling", &_LC1, *(code**)( *(long*)this + 0x158 ));
   return;
}
/* glslang::TParseContext::fixOffset(glslang::TSourceLoc const&, glslang::TSymbol&) */void glslang::TParseContext::fixOffset(TParseContext *this, TSourceLoc *param_1, TSymbol *param_2) {
   int *piVar1;
   ushort uVar2;
   code *pcVar3;
   char cVar4;
   int iVar5;
   long *plVar6;
   long lVar7;
   long *plVar8;
   int *piVar9;
   int iVar10;
   uint uVar11;
   plVar6 = (long*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
   if (*(code**)( *plVar6 + 0x58 ) == TType::getQualifier) {
      plVar6 = plVar6 + 2;
   }
 else {
      plVar6 = (long*)( **(code**)( *plVar6 + 0x58 ) )();
   }

   lVar7 = ( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
   if (*(char*)( lVar7 + 8 ) != '\r') {
      return;
   }

   uVar2 = *(ushort*)( plVar6 + 4 );
   if (uVar2 == 0xffff) {
      return;
   }

   if (*(int*)( this + 0x6d8 ) <= (int)(uint)uVar2) {
      return;
   }

   uVar11 = *(uint*)( (long)plVar6 + 0x14 );
   if (uVar11 == 0xffffffff) {
      uVar11 = *(uint*)( *(long*)( this + 0x7538 ) + (ulong)uVar2 * 4 );
   }

   if (( uVar11 & 3 ) != 0) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "atomic counters offset should align based on 4:", "offset", &_LC524, uVar11);
   }

   plVar8 = (long*)( **(code**)( *(long*)param_2 + 0x68 ) )(param_2);
   if (*(code**)( *plVar8 + 0x50 ) == TType::getQualifier) {
      plVar8 = plVar8 + 2;
   }
 else {
      plVar8 = (long*)( **(code**)( *plVar8 + 0x50 ) )();
   }

   lVar7 = *(long*)param_2;
   *(uint*)( (long)plVar8 + 0x14 ) = uVar11;
   plVar8 = (long*)( **(code**)( lVar7 + 0x60 ) )(param_2);
   if (*(code**)( *plVar8 + 0xe8 ) == TType::isArray) {
      if (plVar8[0xc] != 0) {
         LAB_0010f1e2:plVar8 = (long*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
         pcVar3 = *(code**)( *plVar8 + 0xf0 );
         if (pcVar3 == TType::isSizedArray) {
            pcVar3 = *(code**)( *plVar8 + 0xe8 );
            if (pcVar3 == TType::isArray) {
               lVar7 = plVar8[0xc];
               if (lVar7 != 0) {
                  LAB_0010f228:if (**(int**)( *(long*)( lVar7 + 8 ) + 8 ) != 0) goto LAB_0010f236;
               }

            }
 else {
               cVar4 = ( *pcVar3 )(plVar8);
               if (cVar4 != '\0') {
                  lVar7 = plVar8[0xc];
                  goto LAB_0010f228;
               }

            }

            LAB_0010f2a1:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "array must be explicitly sized", "atomic_uint", &_LC1);
         }
 else {
            cVar4 = ( *pcVar3 )(plVar8);
            if (cVar4 == '\0') goto LAB_0010f2a1;
            LAB_0010f236:plVar8 = (long*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
            if (*(code**)( *plVar8 + 0x98 ) == TType::getArraySizes) {
               lVar7 = plVar8[0xc];
            }
 else {
               lVar7 = ( **(code**)( *plVar8 + 0x98 ) )();
            }

            lVar7 = *(long*)( lVar7 + 8 );
            if (lVar7 != 0) {
               piVar9 = *(int**)( lVar7 + 8 );
               lVar7 = *(long*)( lVar7 + 0x10 ) - (long)piVar9;
               for (iVar10 = 1; piVar9 = piVar9 + 4,iVar10 < (int)( lVar7 >> 4 ); iVar10 = iVar10 + 1) {
                  if (*piVar9 == 0) goto LAB_0010f2a1;
               }

            }

            plVar8 = (long*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
            if (*(code**)( *plVar8 + 0x88 ) != TType::getCumulativeArraySize) {
               iVar10 = ( **(code**)( *plVar8 + 0x88 ) )(plVar8);
               iVar10 = iVar10 * 4;
               goto LAB_0010f15f;
            }

            lVar7 = *(long*)( plVar8[0xc] + 8 );
            if (lVar7 != 0) {
               piVar9 = *(int**)( lVar7 + 8 );
               iVar5 = (int)( *(long*)( lVar7 + 0x10 ) - (long)piVar9 >> 4 );
               if (iVar5 < 1) {
                  iVar10 = 1;
               }
 else {
                  iVar10 = 1;
                  piVar1 = piVar9 + ( ulong )(iVar5 - 1) * 4 + 4;
                  do {
                     iVar10 = iVar10 * *piVar9;
                     piVar9 = piVar9 + 4;
                  }
 while ( piVar9 != piVar1 );
               }

               iVar10 = iVar10 << 2;
               goto LAB_0010f15f;
            }

         }

      }

   }
 else {
      cVar4 = ( **(code**)( *plVar8 + 0xe8 ) )();
      if (cVar4 != '\0') goto LAB_0010f1e2;
   }

   iVar10 = 4;
   LAB_0010f15f:iVar5 = glslang::TIntermediate::addUsedOffsets((int)*(undefined8*)( this + 0x38 ), ( uint ) * (ushort*)( plVar6 + 4 ), uVar11);
   if (-1 < iVar5) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "atomic counters sharing the same offset:", "offset", &_LC524, iVar5);
   }

   *(uint*)( *(long*)( this + 0x7538 ) + ( ulong ) * (ushort*)( plVar6 + 4 ) * 4 ) = uVar11 + iVar10;
   return;
}
/* glslang::TParseContext::findFunctionExact(glslang::TSourceLoc const&, glslang::TFunction const&,
   bool&) */undefined8 glslang::TParseContext::findFunctionExact(TParseContext *this, TSourceLoc *param_1, TFunction *param_2, bool *param_3) {
   TSymbolTable *this_00;
   code *pcVar1;
   long *plVar2;
   undefined8 uVar3;
   TFunction *pTVar4;
   long lVar5;
   this_00 = *(TSymbolTable**)( this + 0xe8 );
   if (*(code**)( *(long*)param_2 + 0x30 ) == TFunction::getMangledName_abi_cxx11_) {
      pTVar4 = param_2 + 0xe8;
   }
 else {
      pTVar4 = (TFunction*)( **(code**)( *(long*)param_2 + 0x30 ) )(param_2);
   }

   plVar2 = (long*)TSymbolTable::find(this_00, (basic_string*)pTVar4, param_3, (bool*)0x0, (int*)0x0);
   if (plVar2 != (long*)0x0) {
      /* WARNING: Could not recover jumptable at 0x0010f3f1. Too many branches */
      /* WARNING: Treating indirect jump as call */
      uVar3 = ( **(code**)( *plVar2 + 0x38 ) )(plVar2);
      return uVar3;
   }

   pcVar1 = *(code**)( *(long*)this + 0x158 );
   if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
      lVar5 = *(long*)( param_2 + 8 );
   }
 else {
      lVar5 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
   }

   ( *pcVar1 )(this, param_1, "no matching overloaded function found", *(undefined8*)( lVar5 + 8 ), &_LC1);
   return 0;
}
/* glslang::TParseContext::findFunction120(glslang::TSourceLoc const&, glslang::TFunction const&,
   bool&) */long *__thiscallglslang::TParseContext::findFunction120(TParseContext *this, TSourceLoc *param_1, TFunction *param_2, bool *param_3) {
   undefined8 *puVar1;
   TSymbolTable *this_00;
   long *plVar2;
   TType *pTVar3;
   undefined8 uVar4;
   long *plVar5;
   long *plVar6;
   char cVar7;
   char cVar8;
   int iVar9;
   uint uVar10;
   uint uVar11;
   long *plVar12;
   code *pcVar13;
   long *plVar14;
   long lVar15;
   TFunction *pTVar16;
   long lVar17;
   int iVar18;
   long in_FS_OFFSET;
   long *local_88;
   undefined8 local_68;
   long *local_60;
   long *local_58;
   undefined8 local_50;
   long local_40;
   this_00 = *(TSymbolTable**)( this + 0xe8 );
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(code**)( *(long*)param_2 + 0x30 ) == TFunction::getMangledName_abi_cxx11_) {
      pTVar16 = param_2 + 0xe8;
   }
 else {
      pTVar16 = (TFunction*)( **(code**)( *(long*)param_2 + 0x30 ) )(param_2);
   }

   plVar12 = (long*)TSymbolTable::find(this_00, (basic_string*)pTVar16, param_3, (bool*)0x0, (int*)0x0);
   if (plVar12 != (long*)0x0) {
      if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
         /* WARNING: Could not recover jumptable at 0x0010f50a. Too many branches */
         /* WARNING: Treating indirect jump as call */
         plVar12 = (long*)( **(code**)( *plVar12 + 0x38 ) )();
         return plVar12;
      }

      goto LAB_0010fde7;
   }

   local_68 = glslang::GetThreadPoolAllocator();
   local_60 = (long*)0x0;
   local_58 = (long*)0x0;
   local_50 = 0;
   plVar12 = *(long**)( this + 0xe8 );
   if (*(code**)( *(long*)param_2 + 0x30 ) == TFunction::getMangledName_abi_cxx11_) {
      pTVar16 = param_2 + 0xe8;
   }
 else {
      pTVar16 = (TFunction*)( **(code**)( *(long*)param_2 + 0x30 ) )(param_2);
   }

   *param_3 = false;
   lVar15 = *plVar12;
   iVar18 = (int)( plVar12[1] - lVar15 >> 3 ) + -1;
   lVar17 = (long)iVar18 << 3;
   while (true) {
      iVar18 = iVar18 + -1;
      TSymbolTableLevel::findFunctionNameList(*(TSymbolTableLevel**)( lVar15 + lVar17 ), (basic_string*)pTVar16, (TVector*)&local_68);
      if (iVar18 < 3) break;
      if (local_58 != local_60) goto LAB_0010f5cb;
      lVar17 = lVar17 + -8;
      lVar15 = *plVar12;
   }
;
   if (local_58 == local_60) {
      *param_3 = true;
      lVar15 = (long)iVar18 << 3;
      do {
         puVar1 = (undefined8*)( *plVar12 + lVar15 );
         lVar15 = lVar15 + -8;
         TSymbolTableLevel::findFunctionNameList((TSymbolTableLevel*)*puVar1, (basic_string*)pTVar16, (TVector*)&local_68);
         iVar18 = iVar18 + -1;
      }
 while ( -1 < iVar18 );
      if (local_58 != local_60) goto LAB_0010f5cb;
      LAB_0010fa60:pcVar13 = *(code**)( *(long*)this + 0x158 );
      if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
         lVar15 = *(long*)( param_2 + 8 );
      }
 else {
         lVar15 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
      }

      ( *pcVar13 )(this, param_1, "no matching overloaded function found", *(undefined8*)( lVar15 + 8 ), &_LC1);
      local_88 = (long*)0x0;
   }
 else {
      LAB_0010f5cb:plVar5 = local_58;
      local_88 = (long*)0x0;
      plVar12 = local_60;
      do {
         plVar2 = (long*)*plVar12;
         if (*(code**)( *(long*)param_2 + 0x120 ) == TFunction::getParamCount) {
            iVar18 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
         }
 else {
            iVar18 = ( **(code**)( *(long*)param_2 + 0x120 ) )(param_2);
         }

         if (*(code**)( *plVar2 + 0x120 ) == TFunction::getParamCount) {
            iVar9 = (int)( plVar2[7] - plVar2[6] >> 3 ) * -0x55555555;
         }
 else {
            iVar9 = ( **(code**)( *plVar2 + 0x120 ) )(plVar2);
         }

         plVar6 = local_88;
         if (iVar18 == iVar9) {
            lVar15 = 0;
            iVar18 = 0;
            while (true) {
               if (*(code**)( *plVar2 + 0x120 ) == TFunction::getParamCount) {
                  iVar9 = (int)( plVar2[7] - plVar2[6] >> 3 ) * -0x55555555;
               }
 else {
                  iVar9 = ( **(code**)( *plVar2 + 0x120 ) )(plVar2);
               }

               if (iVar9 <= iVar18) break;
               if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                  lVar17 = *(long*)( param_2 + 0x30 ) + lVar15;
               }
 else {
                  lVar17 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, iVar18);
               }

               pTVar3 = *(TType**)( lVar17 + 8 );
               if (*(code**)( *plVar2 + 0x140 ) == TFunction::operator []) {
                  lVar17 = plVar2[6] + lVar15;
               }
 else {
                  lVar17 = ( **(code**)( *plVar2 + 0x140 ) )(plVar2, iVar18);
               }

               cVar7 = TType::operator ==(*(TType**)( lVar17 + 8 ), pTVar3);
               if (cVar7 == '\0') {
                  if (*(code**)( *plVar2 + 0x140 ) == TFunction::operator []) {
                     lVar17 = plVar2[6] + lVar15;
                  }
 else {
                     lVar17 = ( **(code**)( *plVar2 + 0x140 ) )(plVar2, iVar18);
                  }

                  pcVar13 = *(code**)( **(long**)( lVar17 + 8 ) + 0xe8 );
                  if (pcVar13 == TType::isArray) {
                     if (( *(long**)( lVar17 + 8 ) )[0xc] != 0) goto joined_r0x0010f96b;
                  }
 else {
                     cVar7 = ( *pcVar13 )();
                     if (cVar7 != '\0') goto joined_r0x0010f96b;
                  }

                  if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                     lVar17 = *(long*)( param_2 + 0x30 ) + lVar15;
                  }
 else {
                     lVar17 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, iVar18);
                  }

                  pcVar13 = *(code**)( **(long**)( lVar17 + 8 ) + 0xe8 );
                  if (pcVar13 == TType::isArray) {
                     if (( *(long**)( lVar17 + 8 ) )[0xc] != 0) goto joined_r0x0010f96b;
                     pcVar13 = *(code**)( *plVar2 + 0x140 );
                     if (pcVar13 != TFunction::operator []) goto LAB_0010fae5;
                     LAB_0010f768:lVar17 = plVar2[6] + lVar15;
                  }
 else {
                     cVar7 = ( *pcVar13 )();
                     if (cVar7 != '\0') goto joined_r0x0010f96b;
                     pcVar13 = *(code**)( *plVar2 + 0x140 );
                     if (pcVar13 == TFunction::operator []) goto LAB_0010f768;
                     LAB_0010fae5:lVar17 = ( *pcVar13 )(plVar2, iVar18);
                  }

                  pTVar3 = *(TType**)( lVar17 + 8 );
                  if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                     lVar17 = *(long*)( param_2 + 0x30 ) + lVar15;
                  }
 else {
                     lVar17 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, iVar18);
                  }

                  cVar7 = TType::sameElementShape(pTVar3, *(TType**)( lVar17 + 8 ), (int*)0x0, (int*)0x0);
                  if (cVar7 == '\0') goto joined_r0x0010f96b;
                  if (*(code**)( *plVar2 + 0x140 ) == TFunction::operator []) {
                     lVar17 = plVar2[6] + lVar15;
                  }
 else {
                     lVar17 = ( **(code**)( *plVar2 + 0x140 ) )(plVar2, iVar18);
                  }

                  pcVar13 = *(code**)( **(long**)( lVar17 + 8 ) + 0x50 );
                  if (pcVar13 == TType::getQualifier) {
                     plVar14 = *(long**)( lVar17 + 8 ) + 2;
                  }
 else {
                     plVar14 = (long*)( *pcVar13 )();
                  }

                  if (( ( *(byte*)( plVar14 + 1 ) & 0x7f ) == 0x10 ) || ( ( ( *(byte*)( plVar14 + 1 ) & 0x7f ) + 0x6e & 0x7f ) < 2 )) {
                     uVar4 = *(undefined8*)( this + 0x38 );
                     if (*(code**)( *plVar2 + 0x140 ) == TFunction::operator []) {
                        lVar17 = plVar2[6] + lVar15;
                     }
 else {
                        lVar17 = ( **(code**)( *plVar2 + 0x140 ) )(plVar2, iVar18);
                     }

                     pcVar13 = *(code**)( **(long**)( lVar17 + 8 ) + 0x38 );
                     if (pcVar13 == TType::getBasicType) {
                        uVar11 = ( uint ) * (byte*)( *(long**)( lVar17 + 8 ) + 1 );
                     }
 else {
                        uVar11 = ( *pcVar13 )();
                     }

                     if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                        lVar17 = *(long*)( param_2 + 0x30 ) + lVar15;
                     }
 else {
                        lVar17 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, iVar18);
                     }

                     pcVar13 = *(code**)( **(long**)( lVar17 + 8 ) + 0x38 );
                     if (pcVar13 == TType::getBasicType) {
                        uVar10 = ( uint ) * (byte*)( *(long**)( lVar17 + 8 ) + 1 );
                     }
 else {
                        uVar10 = ( *pcVar13 )();
                     }

                     cVar7 = glslang::TIntermediate::canImplicitlyPromote(uVar4, uVar10, uVar11, 0);
                  }

                  if (*(code**)( *plVar2 + 0x140 ) == TFunction::operator []) {
                     lVar17 = plVar2[6] + lVar15;
                  }
 else {
                     lVar17 = ( **(code**)( *plVar2 + 0x140 ) )(plVar2, iVar18);
                  }

                  pcVar13 = *(code**)( **(long**)( lVar17 + 8 ) + 0x50 );
                  if (pcVar13 == TType::getQualifier) {
                     plVar14 = *(long**)( lVar17 + 8 ) + 2;
                  }
 else {
                     plVar14 = (long*)( *pcVar13 )();
                  }

                  if (( *(byte*)( plVar14 + 1 ) & 0x7f ) - 0x11 < 2) {
                     uVar4 = *(undefined8*)( this + 0x38 );
                     if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                        lVar17 = *(long*)( param_2 + 0x30 ) + lVar15;
                     }
 else {
                        lVar17 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, iVar18);
                     }

                     pcVar13 = *(code**)( **(long**)( lVar17 + 8 ) + 0x38 );
                     if (pcVar13 == TType::getBasicType) {
                        uVar11 = ( uint ) * (byte*)( *(long**)( lVar17 + 8 ) + 1 );
                     }
 else {
                        uVar11 = ( *pcVar13 )();
                     }

                     if (*(code**)( *plVar2 + 0x140 ) == TFunction::operator []) {
                        lVar17 = plVar2[6] + lVar15;
                     }
 else {
                        lVar17 = ( **(code**)( *plVar2 + 0x140 ) )(plVar2, iVar18);
                     }

                     pcVar13 = *(code**)( **(long**)( lVar17 + 8 ) + 0x38 );
                     if (pcVar13 == TType::getBasicType) {
                        uVar10 = ( uint ) * (byte*)( *(long**)( lVar17 + 8 ) + 1 );
                     }
 else {
                        uVar10 = ( *pcVar13 )();
                     }

                     cVar8 = glslang::TIntermediate::canImplicitlyPromote(uVar4, uVar10, uVar11, 0);
                     if (cVar8 == '\0') goto joined_r0x0010f96b;
                  }

                  if (cVar7 == '\0') goto joined_r0x0010f96b;
               }

               iVar18 = iVar18 + 1;
               lVar15 = lVar15 + 0x18;
            }
;
            plVar6 = plVar2;
            if (local_88 != (long*)0x0) {
               pcVar13 = *(code**)( *(long*)this + 0x158 );
               if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                  lVar15 = *(long*)( param_2 + 8 );
               }
 else {
                  lVar15 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
               }

               ( *pcVar13 )(this, param_1, "ambiguous function signature match: multiple signatures match under implicit type conversion", *(undefined8*)( lVar15 + 8 ), &_LC1);
               plVar6 = local_88;
            }

         }

         joined_r0x0010f96b:local_88 = plVar6;
         plVar12 = plVar12 + 1;
      }
 while ( plVar5 != plVar12 );
      if (local_88 == (long*)0x0) goto LAB_0010fa60;
   }

   if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return local_88;
   }

   LAB_0010fde7:/* WARNING: Subroutine does not return */__stack_chk_fail();
}
/* glslang::TParseContext::findFunction400(glslang::TSourceLoc const&, glslang::TFunction const&,
   bool&) */long glslang::TParseContext::findFunction400(TParseContext *this, TSourceLoc *param_1, TFunction *param_2, bool *param_3) {
   undefined8 *puVar1;
   TSymbolTable *this_00;
   code *pcVar2;
   long lVar3;
   long *plVar4;
   long lVar5;
   TFunction *pTVar6;
   int iVar7;
   long lVar8;
   long in_FS_OFFSET;
   basic_string *local_f8;
   char local_c9;
   undefined8 local_c8;
   long local_c0;
   long local_b8;
   undefined8 local_b0;
   ulong local_a8;
   long local_a0;
   long local_98;
   long local_90;
   TParseContext *local_88;
   undefined1 local_80;
   code *local_78;
   code *pcStack_70;
   undefined1 local_68[16];
   code *local_58;
   code *pcStack_50;
   long local_40;
   this_00 = *(TSymbolTable**)( this + 0xe8 );
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(code**)( *(long*)param_2 + 0x30 ) == TFunction::getMangledName_abi_cxx11_) {
      pTVar6 = param_2 + 0xe8;
   }
 else {
      pTVar6 = (TFunction*)( **(code**)( *(long*)param_2 + 0x30 ) )(param_2);
   }

   plVar4 = (long*)TSymbolTable::find(this_00, (basic_string*)pTVar6, param_3, (bool*)0x0, (int*)0x0);
   if (plVar4 == (long*)0x0) {
      local_c8 = glslang::GetThreadPoolAllocator();
      plVar4 = *(long**)( this + 0xe8 );
      local_c0 = 0;
      local_b8 = 0;
      local_b0 = 0;
      if (*(code**)( *(long*)param_2 + 0x30 ) == TFunction::getMangledName_abi_cxx11_) {
         local_f8 = (basic_string*)( param_2 + 0xe8 );
      }
 else {
         local_f8 = (basic_string*)( **(code**)( *(long*)param_2 + 0x30 ) )(param_2);
      }

      lVar5 = *plVar4;
      *param_3 = false;
      iVar7 = (int)( plVar4[1] - lVar5 >> 3 ) + -1;
      lVar8 = (long)iVar7 << 3;
      while (true) {
         iVar7 = iVar7 + -1;
         TSymbolTableLevel::findFunctionNameList(*(TSymbolTableLevel**)( lVar5 + lVar8 ), local_f8, (TVector*)&local_c8);
         if (local_b8 != local_c0) break;
         if (iVar7 < 3) {
            if (local_b8 == local_c0) {
               lVar5 = (long)iVar7 << 3;
               *param_3 = true;
               do {
                  puVar1 = (undefined8*)( *plVar4 + lVar5 );
                  lVar5 = lVar5 + -8;
                  TSymbolTableLevel::findFunctionNameList((TSymbolTableLevel*)*puVar1, local_f8, (TVector*)&local_c8);
                  iVar7 = iVar7 + -1;
               }
 while ( -1 < iVar7 );
            }

            break;
         }

         lVar5 = *plVar4;
         lVar8 = lVar8 + -8;
      }
;
      lVar3 = local_b8;
      lVar8 = local_c0;
      local_80 = *param_3;
      local_68 = (undefined1[16])0x0;
      local_c9 = '\0';
      local_58 = std::_Function_handler<bool(glslang::TType_const &, glslang::TType_const &, glslang::TType_const &),glslang::TParseContext::findFunction400(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::{lambda(glslang::TType_const &, glslang::TType_const &, glslang::TType_const &)#1}>::_M_manager;
      pcStack_50 = std::_Function_handler<bool(glslang::TType_const &, glslang::TType_const &, glslang::TType_const &),glslang::TParseContext::findFunction400(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::{lambda(glslang::TType_const &, glslang::TType_const &, glslang::TType_const &)#1}>::_M_invoke;
      local_78 = std::_Function_handler<bool(glslang::TType_const &, glslang::TType_const &, glslang::TOperator, int),glslang::TParseContext::findFunction400(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::{lambda(glslang::TType_const &, glslang::TType_const &, glslang::TOperator, int)#1}>::_M_manager;
      pcStack_70 = std::_Function_handler<bool(glslang::TType_const &, glslang::TType_const &, glslang::TOperator, int),glslang::TParseContext::findFunction400(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::{lambda(glslang::TType_const &, glslang::TType_const &, glslang::TOperator, int)#1}>::_M_invoke;
      local_88 = this;
      local_a8 = glslang::GetThreadPoolAllocator();
      local_a0 = 0;
      local_98 = 0;
      local_90 = 0;
      lVar5 = 0;
      if (lVar3 - lVar8 != 0) {
         lVar5 = glslang::TPoolAllocator::allocate(local_a8);
      }

      local_90 = ( lVar3 - lVar8 ) + lVar5;
      local_98 = lVar5;
      if (lVar3 != lVar8) {
         local_98 = 0;
         do {
            *(undefined8*)( lVar5 + local_98 ) = *(undefined8*)( lVar8 + local_98 );
            local_98 = local_98 + 8;
         }
 while ( local_98 != lVar3 - lVar8 );
         local_98 = lVar5 + local_98;
      }

      local_a0 = lVar5;
      lVar5 = glslang::TParseContextBase::selectFunction(this, &local_a8, param_2, &local_88, local_68, &local_c9);
      if (local_78 != (code*)0x0) {
         ( *local_78 )(&local_88, &local_88, 3);
      }

      if (local_58 != (code*)0x0) {
         ( *local_58 )(local_68, local_68, 3);
      }

      if (lVar5 == 0) {
         pcVar2 = *(code**)( *(long*)this + 0x158 );
         if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            lVar8 = *(long*)( param_2 + 8 );
         }
 else {
            lVar8 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
         }

         ( *pcVar2 )(this, param_1, "no matching overloaded function found", *(undefined8*)( lVar8 + 8 ), &_LC1);
      }
 else if (local_c9 != '\0') {
         pcVar2 = *(code**)( *(long*)this + 0x158 );
         if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            lVar8 = *(long*)( param_2 + 8 );
         }
 else {
            lVar8 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
         }

         ( *pcVar2 )(this, param_1, "ambiguous best function under implicit type conversion", *(undefined8*)( lVar8 + 8 ), &_LC1);
      }

      if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
         return lVar5;
      }

   }
 else if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      /* WARNING: Could not recover jumptable at 0x0010fe95. Too many branches */
      /* WARNING: Treating indirect jump as call */
      lVar5 = ( **(code**)( *plVar4 + 0x38 ) )(plVar4);
      return lVar5;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::findFunctionExplicitTypes(glslang::TSourceLoc const&, glslang::TFunction
   const&, bool&) */long glslang::TParseContext::findFunctionExplicitTypes(TParseContext *this, TSourceLoc *param_1, TFunction *param_2, bool *param_3) {
   undefined8 *puVar1;
   TSymbolTable *this_00;
   code *pcVar2;
   long lVar3;
   long *plVar4;
   long lVar5;
   TFunction *pTVar6;
   int iVar7;
   long lVar8;
   long in_FS_OFFSET;
   basic_string *local_f8;
   char local_c9;
   undefined8 local_c8;
   long local_c0;
   long local_b8;
   undefined8 local_b0;
   ulong local_a8;
   long local_a0;
   long local_98;
   long local_90;
   TParseContext *local_88;
   undefined1 local_80;
   code *local_78;
   code *pcStack_70;
   TParseContext *local_68;
   undefined8 local_60;
   code *local_58;
   code *pcStack_50;
   long local_40;
   this_00 = *(TSymbolTable**)( this + 0xe8 );
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(code**)( *(long*)param_2 + 0x30 ) == TFunction::getMangledName_abi_cxx11_) {
      pTVar6 = param_2 + 0xe8;
   }
 else {
      pTVar6 = (TFunction*)( **(code**)( *(long*)param_2 + 0x30 ) )(param_2);
   }

   plVar4 = (long*)TSymbolTable::find(this_00, (basic_string*)pTVar6, param_3, (bool*)0x0, (int*)0x0);
   if (plVar4 == (long*)0x0) {
      local_c8 = glslang::GetThreadPoolAllocator();
      plVar4 = *(long**)( this + 0xe8 );
      local_c0 = 0;
      local_b8 = 0;
      local_b0 = 0;
      if (*(code**)( *(long*)param_2 + 0x30 ) == TFunction::getMangledName_abi_cxx11_) {
         local_f8 = (basic_string*)( param_2 + 0xe8 );
      }
 else {
         local_f8 = (basic_string*)( **(code**)( *(long*)param_2 + 0x30 ) )(param_2);
      }

      lVar5 = *plVar4;
      *param_3 = false;
      iVar7 = (int)( plVar4[1] - lVar5 >> 3 ) + -1;
      lVar8 = (long)iVar7 << 3;
      while (true) {
         iVar7 = iVar7 + -1;
         TSymbolTableLevel::findFunctionNameList(*(TSymbolTableLevel**)( lVar5 + lVar8 ), local_f8, (TVector*)&local_c8);
         if (local_b8 != local_c0) break;
         if (iVar7 < 3) {
            if (local_b8 == local_c0) {
               lVar5 = (long)iVar7 << 3;
               *param_3 = true;
               do {
                  puVar1 = (undefined8*)( *plVar4 + lVar5 );
                  lVar5 = lVar5 + -8;
                  TSymbolTableLevel::findFunctionNameList((TSymbolTableLevel*)*puVar1, local_f8, (TVector*)&local_c8);
                  iVar7 = iVar7 + -1;
               }
 while ( -1 < iVar7 );
            }

            break;
         }

         lVar5 = *plVar4;
         lVar8 = lVar8 + -8;
      }
;
      lVar3 = local_b8;
      lVar8 = local_c0;
      local_80 = *param_3;
      local_c9 = '\0';
      local_58 = std::_Function_handler<bool(glslang::TType_const &, glslang::TType_const &, glslang::TType_const &),glslang::TParseContext::findFunctionExplicitTypes(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::{lambda(glslang::TType_const &, glslang::TType_const &, glslang::TType_const &)#1}>::_M_manager;
      pcStack_50 = std::_Function_handler<bool(glslang::TType_const &, glslang::TType_const &, glslang::TType_const &),glslang::TParseContext::findFunctionExplicitTypes(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::{lambda(glslang::TType_const &, glslang::TType_const &, glslang::TType_const &)#1}>::_M_invoke;
      local_60 = 0;
      local_78 = std::_Function_handler<bool(glslang::TType_const &, glslang::TType_const &, glslang::TOperator, int),glslang::TParseContext::findFunctionExplicitTypes(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::{lambda(glslang::TType_const &, glslang::TType_const &, glslang::TOperator, int)#1}>::_M_manager;
      pcStack_70 = std::_Function_handler<bool(glslang::TType_const &, glslang::TType_const &, glslang::TOperator, int),glslang::TParseContext::findFunctionExplicitTypes(glslang::TSourceLoc_const&,glslang::TFunction_const&,bool&)::{lambda(glslang::TType_const &, glslang::TType_const &, glslang::TOperator, int)#1}>::_M_invoke;
      local_88 = this;
      local_68 = this;
      local_a8 = glslang::GetThreadPoolAllocator();
      local_a0 = 0;
      local_98 = 0;
      local_90 = 0;
      lVar5 = 0;
      if (lVar3 - lVar8 != 0) {
         lVar5 = glslang::TPoolAllocator::allocate(local_a8);
      }

      local_90 = ( lVar3 - lVar8 ) + lVar5;
      local_98 = lVar5;
      if (lVar3 != lVar8) {
         local_98 = 0;
         do {
            *(undefined8*)( lVar5 + local_98 ) = *(undefined8*)( lVar8 + local_98 );
            local_98 = local_98 + 8;
         }
 while ( local_98 != lVar3 - lVar8 );
         local_98 = lVar5 + local_98;
      }

      local_a0 = lVar5;
      lVar5 = glslang::TParseContextBase::selectFunction(this, &local_a8, param_2, &local_88, &local_68, &local_c9);
      if (local_78 != (code*)0x0) {
         ( *local_78 )(&local_88, &local_88, 3);
      }

      if (local_58 != (code*)0x0) {
         ( *local_58 )(&local_68, &local_68, 3);
      }

      if (lVar5 == 0) {
         pcVar2 = *(code**)( *(long*)this + 0x158 );
         if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            lVar8 = *(long*)( param_2 + 8 );
         }
 else {
            lVar8 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
         }

         ( *pcVar2 )(this, param_1, "no matching overloaded function found", *(undefined8*)( lVar8 + 8 ), &_LC1);
      }
 else if (local_c9 != '\0') {
         pcVar2 = *(code**)( *(long*)this + 0x158 );
         if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            lVar8 = *(long*)( param_2 + 8 );
         }
 else {
            lVar8 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
         }

         ( *pcVar2 )(this, param_1, "ambiguous best function under implicit type conversion", *(undefined8*)( lVar8 + 8 ), &_LC1);
      }

      if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
         return lVar5;
      }

   }
 else if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      /* WARNING: Could not recover jumptable at 0x001102a5. Too many branches */
      /* WARNING: Treating indirect jump as call */
      lVar5 = ( **(code**)( *plVar4 + 0x38 ) )(plVar4);
      return lVar5;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::findFunction(glslang::TSourceLoc const&, glslang::TFunction const&,
   bool&) */undefined8 glslang::TParseContext::findFunction(TParseContext *this, TSourceLoc *param_1, TFunction *param_2, bool *param_3) {
   void *__s2;
   ulong uVar1;
   void *__s;
   code *pcVar2;
   TSymbolTable *this_00;
   char cVar3;
   int iVar4;
   void *pvVar5;
   ulong uVar6;
   undefined8 uVar7;
   long lVar8;
   long *plVar9;
   long lVar10;
   long lVar11;
   ulong uVar12;
   long lVar13;
   code *pcVar14;
   long lVar15;
   long lVar16;
   long in_FS_OFFSET;
   long local_a0;
   undefined8 local_68;
   undefined1 *local_60;
   undefined1 local_50[16];
   long local_40;
   plVar9 = *(long**)( this + 0xe8 );
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
      local_a0 = *(long*)( param_2 + 8 );
      pcVar14 = TSymbol::getName_abi_cxx11_;
      if (*(char*)( (long)plVar9 + 0x21 ) == '\0') {
         LAB_00110686:lVar10 = *plVar9;
         lVar13 = (long)( (int)( plVar9[1] - lVar10 >> 3 ) + -1 );
         do {
            while (true) {
               lVar8 = *(long*)( lVar10 + lVar13 * 8 );
               lVar16 = *(long*)( lVar8 + 0x18 );
               lVar8 = lVar8 + 0x10;
               if (lVar16 == 0) break;
               __s2 = *(void**)( local_a0 + 8 );
               uVar1 = *(ulong*)( local_a0 + 0x10 );
               lVar15 = lVar8;
               do {
                  while (true) {
                     uVar12 = *(ulong*)( lVar16 + 0x30 );
                     uVar6 = uVar1;
                     if (uVar12 <= uVar1) {
                        uVar6 = uVar12;
                     }

                     if (( uVar6 != 0 ) && ( iVar4 = memcmp(*(void**)( lVar16 + 0x28 ), __s2, uVar6) ),iVar4 != 0) break;
                     lVar11 = uVar12 - uVar1;
                     if (lVar11 < 0x80000000) {
                        if (-0x80000001 < lVar11) {
                           iVar4 = (int)lVar11;
                           break;
                        }

                        goto LAB_00110700;
                     }

                     LAB_00110749:plVar9 = (long*)( lVar16 + 0x10 );
                     lVar15 = lVar16;
                     lVar16 = *plVar9;
                     if (*plVar9 == 0) goto LAB_00110755;
                  }
;
                  if (-1 < iVar4) goto LAB_00110749;
                  LAB_00110700:lVar16 = *(long*)( lVar16 + 0x18 );
               }
 while ( lVar16 != 0 );
               LAB_00110755:if (lVar8 == lVar15) break;
               uVar12 = *(ulong*)( lVar15 + 0x30 );
               __s = *(void**)( lVar15 + 0x28 );
               if (uVar12 == 0) {
                  if (uVar1 != 0) break;
                  LAB_00110909:pcVar2 = *(code**)( *(long*)this + 0x158 );
                  if (pcVar14 == TSymbol::getName_abi_cxx11_) {
                     lVar10 = *(long*)( param_2 + 8 );
                  }
 else {
                     lVar10 = ( *pcVar14 )(param_2);
                  }

                  ( *pcVar2 )(this, param_1, "can\'t use function syntax on variable", *(undefined8*)( lVar10 + 8 ), &_LC1);
                  if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                     return 0;
                  }

                  goto LAB_00110c25;
               }

               pvVar5 = memchr(__s, 0x28, uVar12);
               if (( pvVar5 == (void*)0x0 ) || ( uVar6 = uVar6 == 0xffffffffffffffff )) {
                  if (( uVar12 == uVar1 ) && ( iVar4 = iVar4 == 0 )) goto LAB_00110909;
                  break;
               }

               if (uVar6 < uVar12) {
                  uVar12 = uVar6;
               }

               uVar6 = uVar12;
               if (uVar1 <= uVar12) {
                  uVar6 = uVar1;
               }

               if (( ( ( uVar6 != 0 ) && ( iVar4 = memcmp(__s, __s2, uVar6) ),iVar4 != 0 ) ) || ( lVar8 = 0x7fffffff < lVar8 )) break;
               if (( (int)lVar8 == 0 ) || ( lVar13 = lVar13 + -1 ),(int)lVar13 < 0) goto LAB_001107c7;
            }
;
            lVar13 = lVar13 + -1;
         }
 while ( -1 < (int)lVar13 );
         goto LAB_001107c7;
      }

   }
 else {
      local_a0 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
      pcVar14 = *(code**)( *(long*)param_2 + 0x18 );
      if (*(char*)( (long)plVar9 + 0x21 ) == '\0') goto LAB_00110686;
      LAB_001107c7:if (pcVar14 == TSymbol::getName_abi_cxx11_) {
         local_a0 = *(long*)( param_2 + 8 );
      }
 else {
         local_a0 = ( *pcVar14 )(param_2);
      }

   }

   if (( ( *(long*)( local_a0 + 0x10 ) == 0xe ) && ( **(long**)( local_a0 + 8 ) == 0x6972506775626564 ) ) && ( *(long*)( (long)*(long**)( local_a0 + 8 ) + 6 ) == 0x54584566746e6972 )) {
      this_00 = *(TSymbolTable**)( this + 0xe8 );
      local_68 = glslang::GetThreadPoolAllocator();
      local_60 = local_50;
      std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>((basic_string*)&local_68, "debugPrintfEXT(");
      plVar9 = (long*)TSymbolTable::find(this_00, (basic_string*)&local_68, param_3, (bool*)0x0, (int*)0x0);
      if (plVar9 != (long*)0x0) {
         if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
            /* WARNING: Could not recover jumptable at 0x00110b7b. Too many branches */
            /* WARNING: Treating indirect jump as call */
            uVar7 = ( **(code**)( *plVar9 + 0x38 ) )();
            return uVar7;
         }

         goto LAB_00110c25;
      }

   }

   cVar3 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_EXT_shader_explicit_arithmetic_types");
   if (( ( ( ( cVar3 == '\0' ) && ( cVar3 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_EXT_shader_explicit_arithmetic_types_int8") ),cVar3 == '\0' ) ) && ( cVar3 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_EXT_shader_explicit_arithmetic_types_int16") ),cVar3 == '\0' )) &&( ( cVar3 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_EXT_shader_explicit_arithmetic_types_int32") ),cVar3 == '\0' && ( cVar3 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_EXT_shader_explicit_arithmetic_types_int64") ),cVar3 == '\0' ) && ( ( cVar3 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_EXT_shader_explicit_arithmetic_types_float16") ),cVar3 == '\0' && ( ( cVar3 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_EXT_shader_explicit_arithmetic_types_float32") ),cVar3 == '\0' && ( cVar3 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_EXT_shader_explicit_arithmetic_types_float64") ),cVar3 == '\0' ) )(*(int*)( this + 0xc ) == 8);
   goto LAB_00110a75;
   if (0x77 < *(int*)( this + 0x18 )) {
      if (*(int*)( this + 0x18 ) < 400) goto LAB_00110829;
      LAB_00110855:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
         uVar7 = findFunction400(this, param_1, param_2, param_3);
         return uVar7;
      }

      goto LAB_00110c25;
   }

   LAB_00110a96:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      uVar7 = findFunctionExact(this, param_1, param_2, param_3);
      return uVar7;
   }

}
else{if (*(int *)(this + 0xc) == 8) {
      if (0x135 < *(int *)(this + 0x18)) {
LAB_00110bae:
        if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
          uVar7 = findFunctionExplicitTypes(this,param_1,param_2,param_3);
          return uVar7;
        }
        goto LAB_00110c25;
      }
LAB_00110a75:
      cVar3 = (**(code **)(*(long *)this + 0x40))(this,"GL_EXT_shader_implicit_conversions");
      if ((cVar3 == '\0') || (*(int *)(this + 0x18) < 0x136)) goto LAB_00110a96;
    }else{if (*(int *)(this + 0x18) < 0x78) goto LAB_00110a96;
      if (399 < *(int *)(this + 0x18)) goto LAB_00110bae;LAB_00110829:cVar3 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_ARB_gpu_shader_fp64")(( cVar3 != '\0' ) || ( cVar3 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_ARB_gpu_shader5") ), cVar3 != '\0'))
      goto LAB_00110855;}(local_40 == *(long*)( in_FS_OFFSET + 0x28 )) = findFunction120(this, param_1, param_2, param_3);return uVar7;}
  }LAB_00110c25:/* WARNING: Subroutine does not return */__stack_chk_fail();}/* glslang::TParseContext::declareTypeDefaults(glslang::TSourceLoc const&, glslang::TPublicType
   const&) */void glslang::TParseContext::declareTypeDefaults(TParseContext *this, TSourceLoc *param_1, TPublicType *param_2) {
   ushort uVar1;
   if (*(int*)param_2 == 0xd) {
      uVar1 = *(ushort*)( param_2 + 0x28 );
      if (uVar1 != 0xffff) {
         if (*(uint*)( this + 0x6d8 ) <= (uint)uVar1) {
            /* WARNING: Could not recover jumptable at 0x00110dd3. Too many branches */
            /* WARNING: Treating indirect jump as call */
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "atomic_uint binding is too large", "binding", &_LC1, *(code**)( *(long*)this + 0x158 ));
            return;
         }

         if (*(int*)( param_2 + 0x1c ) == -1) {
            return;
         }

         *(int*)( *(long*)( this + 0x7538 ) + (ulong)uVar1 * 4 ) = *(int*)( param_2 + 0x1c );
         return;
      }

   }

   if (*(long*)( param_2 + 0xc0 ) != 0) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "expect an array name", &_LC1);
   }

   if (( ( ( ( ( ( ( ( (byte)param_2[0x17] & 0x70 ) != 0 ) || ( ( (byte)param_2[0x18] & 0xf ) != 0 ) ) || ( *(int*)( param_2 + 0x1c ) != -1 ) ) || ( ( *(short*)( param_2 + 0x28 ) != -1 || ( ( *(uint*)( param_2 + 0x24 ) & 0x3f8000 ) != 0x1f8000 ) ) ) ) || ( ( *(int*)( param_2 + 0x20 ) != -1 || ( ( ( ~*(ushort *)(param_2 + 0x24) & 0xfff ) != 0 || ( ( (byte)param_2[0x25] & 0x70 ) != 0x40 ) ) ) ) ) ) || ( param_2[0x2a] != (TPublicType)0xff ) ) || ( ( ( ( param_2[0x2b] != (TPublicType)0xff || ( param_2[0x34] != (TPublicType)0x0 ) ) || ( param_2[0x40] != (TPublicType)0x0 ) ) || ( ( ( param_2[0x35] != (TPublicType)0x0 || ( param_2[0x36] != (TPublicType)0x0 ) ) || ( ( ( ~(byte)param_2[0x2c] & 0xf ) != 0 || ( ( ( ~*(uint *)(param_2 + 0x2c) & 0x3fff0 ) != 0 || ( ( ~*(ushort *)(param_2 + 0x2e) & 0x7ffc ) != 0 ) ) ) ) ) ) ) ) ) ) && ( param_2[0x36] == (TPublicType)0x0 )) {
      /* WARNING: Could not recover jumptable at 0x00110cb4. Too many branches */
      /* WARNING: Treating indirect jump as call */
      ( **(code**)( *(long*)this + 0x160 ) )(this, param_1, "useless application of layout qualifier", "layout", &_LC1, *(code**)( *(long*)this + 0x160 ));
      return;
   }

   return;
}
/* glslang::TParseContext::coopMatTypeParametersCheck(glslang::TSourceLoc const&,
   glslang::TPublicType const&) */void glslang::TParseContext::coopMatTypeParametersCheck(TParseContext *this, TSourceLoc *param_1, TPublicType *param_2) {
   uint uVar1;
   long lVar2;
   uint *puVar3;
   char *pcVar4;
   if (this[0x1c1] != (TParseContext)0x0) {
      return;
   }

   if (( (byte)param_2[0xb9] & 0x20 ) != 0) {
      puVar3 = *(uint**)( param_2 + 0xe8 );
      if (puVar3 == (uint*)0x0) {
         /* WARNING: Could not recover jumptable at 0x00110ed2. Too many branches */
         /* WARNING: Treating indirect jump as call */
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "coopmat missing type parameters", &_LC1, &_LC1, *(code**)( *(long*)this + 0x158 ));
         return;
      }

      uVar1 = *puVar3;
      if (( 0x16 < uVar1 ) || ( ( 0x4003faUL >> ( (ulong)uVar1 & 0x3f ) & 1 ) == 0 )) {
         switch ((ulong)uVar1) {
            case 0:
        pcVar4 = "void";
        break;
            default:
        pcVar4 = "unknown type";
        break;
            case 2:
        pcVar4 = "double";
        break;
            case 3:
        pcVar4 = "float16_t";
        break;
            case 4:
        pcVar4 = "int8_t";
        break;
            case 5:
        pcVar4 = "uint8_t";
        break;
            case 6:
        pcVar4 = "int16_t";
        break;
            case 7:
        pcVar4 = "uint16_t";
        break;
            case 8:
        pcVar4 = "int";
        break;
            case 9:
        pcVar4 = "uint";
        break;
            case 10:
        pcVar4 = "int64_t";
        break;
            case 0xb:
        pcVar4 = "uint64_t";
        break;
            case 0xc:
        pcVar4 = "bool";
        break;
            case 0xd:
        pcVar4 = "atomic_uint";
        break;
            case 0xe:
        pcVar4 = "sampler/image";
        break;
            case 0xf:
        pcVar4 = "structure";
        break;
            case 0x10:
        pcVar4 = "block";
        break;
            case 0x11:
        pcVar4 = "accelerationStructureNV";
        break;
            case 0x12:
        pcVar4 = "reference";
        break;
            case 0x13:
        pcVar4 = "rayQueryEXT";
        break;
            case 0x15:
        pcVar4 = "coopmat";
        break;
            case 0x16:
        pcVar4 = "spirv_type";
        break;
            case 0x17:
        pcVar4 = "string";
         }

         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "coopmat invalid basic type", pcVar4, &_LC1);
         puVar3 = *(uint**)( param_2 + 0xe8 );
      }

      lVar2 = *(long*)( *(long*)( puVar3 + 2 ) + 8 );
      if (( lVar2 == 0 ) || ( (int)( *(long*)( lVar2 + 0x10 ) - *(long*)( lVar2 + 8 ) >> 4 ) != 4 )) {
         /* WARNING: Could not recover jumptable at 0x00110e67. Too many branches */
         /* WARNING: Treating indirect jump as call */
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "coopmat incorrect number of type parameters", &_LC1, &_LC1, *(code**)( *(long*)this + 0x158 ));
         return;
      }

      if (2 < *(uint*)( *(long*)( lVar2 + 8 ) + 0x30 )) {
         /* WARNING: Could not recover jumptable at 0x00110efa. Too many branches */
         /* WARNING: Treating indirect jump as call */
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "coopmat invalid matrix Use", &_LC1, &_LC1, *(code**)( *(long*)this + 0x158 ));
         return;
      }

   }

   return;
}
/* glslang::TParseContext::inheritGlobalDefaults(glslang::TQualifier&) const */void glslang::TParseContext::inheritGlobalDefaults(TParseContext *this, TQualifier *param_1) {
   if (( (byte)param_1[8] & 0x7f ) == 4) {
      if (( param_1[0x23] == (TQualifier)0xff ) && ( *(int*)( this + 0x1c ) == 3 )) {
         param_1[0x23] = *(TQualifier*)( this + 0x7493 );
      }

      if (( ~(byte)param_1[0x24] & 0xf ) == 0) {
         param_1[0x24] = ( TQualifier )((byte)param_1[0x24] & 0xf0 | (byte)this[0x7494] & 0xf);
         return;
      }

   }

   return;
}
/* glslang::TParseContext::makeInternalVariable(char const*, glslang::TType const&) const */void glslang::TParseContext::makeInternalVariable(TParseContext *this, char *param_1, TType *param_2) {
   long lVar1;
   TType TVar2;
   byte bVar3;
   undefined4 uVar4;
   undefined8 uVar5;
   ulong uVar6;
   undefined8 *puVar7;
   undefined8 uVar8;
   size_t sVar9;
   undefined8 *puVar10;
   byte bVar11;
   byte bVar12;
   uVar6 = glslang::GetThreadPoolAllocator();
   puVar7 = (undefined8*)glslang::TPoolAllocator::allocate(uVar6);
   uVar8 = glslang::GetThreadPoolAllocator();
   *puVar7 = uVar8;
   puVar7[1] = puVar7 + 3;
   if (param_1 != (char*)0x0) {
      sVar9 = strlen(param_1);
      std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(puVar7, param_1, param_1 + sVar9);
      uVar6 = glslang::GetThreadPoolAllocator();
      puVar10 = (undefined8*)glslang::TPoolAllocator::allocate(uVar6);
      *puVar10 = std::_Hash_bytes;
      puVar10[5] = &PTR__TType_00167f00;
      *(byte*)( puVar10 + 9 ) = *(byte*)( puVar10 + 9 ) & 0xf0;
      puVar10[1] = puVar7;
      *(uint*)( puVar10 + 6 ) = CONCAT22((short)( ( uint ) * (undefined4*)( puVar10 + 6 ) >> 0x10 ), 0x100) & 0xf800ffff;
      *(undefined8*)( (long)puVar10 + 0x6c ) = 0xfffff800;
      *(ulong*)( (long)puVar10 + 0x55 ) = *(ulong*)( (long)puVar10 + 0x55 ) & 0xffffff0000ffc07f | 0xffff001f80;
      puVar10[2] = 0;
      puVar10[0xc] = CONCAT71(( uint7 )((ulong)puVar10[0xc] >> 8) & 0xffffffff, 0xff);
      *(undefined2*)( puVar10 + 0x10 ) = 0;
      puVar10[3] = 0;
      *(uint*)( puVar10 + 0x15 ) = *(uint*)( puVar10 + 0x15 ) & 0x9fc00000;
      *(ulong*)( (long)puVar10 + 0x54 ) = *(ulong*)( (long)puVar10 + 0x54 ) & 0xffffffff8000 | 0xffff000000004fff;
      *(undefined1*)( puVar10 + 4 ) = 1;
      *(ulong*)( (long)puVar10 + 0x5c ) = *(ulong*)( (long)puVar10 + 0x5c ) | 0x1ffff007fffffff;
      puVar10[7] = 0;
      *(undefined8*)( (long)puVar10 + 0x4c ) = 0xffffffffffffffff;
      *(undefined1*)( puVar10 + 0xd ) = 0;
      *(undefined1*)( (long)puVar10 + 100 ) = 0;
      *(undefined4*)( (long)puVar10 + 0x74 ) = 0xffffffff;
      puVar10[0xf] = 0;
      *(undefined1(*) [16])( puVar10 + 0x16 ) = (undefined1[16])0x0;
      *(undefined1(*) [16])( puVar10 + 0x11 ) = (undefined1[16])0x0;
      *(undefined1(*) [16])( puVar10 + 0x13 ) = (undefined1[16])0x0;
      puVar10[8] = puVar10[8] & 0x8000000400000000;
      uVar8 = *(undefined8*)( param_2 + 0x10 );
      uVar5 = *(undefined8*)( param_2 + 0x18 );
      TVar2 = param_2[8];
      uVar4 = *(undefined4*)( param_2 + 0x80 );
      puVar10[0x19] = &PTR__TConstUnionArray_001680e8;
      puVar10[7] = uVar8;
      puVar10[8] = uVar5;
      uVar8 = *(undefined8*)( param_2 + 0x20 );
      uVar5 = *(undefined8*)( param_2 + 0x28 );
      *(undefined4*)( puVar10 + 0x15 ) = uVar4;
      puVar10[9] = uVar8;
      puVar10[10] = uVar5;
      uVar8 = *(undefined8*)( param_2 + 0x30 );
      uVar5 = *(undefined8*)( param_2 + 0x38 );
      *(TType*)( puVar10 + 6 ) = TVar2;
      puVar10[0xb] = uVar8;
      puVar10[0xc] = uVar5;
      uVar8 = *(undefined8*)( param_2 + 0x40 );
      uVar5 = *(undefined8*)( param_2 + 0x48 );
      *(undefined1*)( puVar10 + 0x18 ) = 0;
      puVar10[0xd] = uVar8;
      puVar10[0xe] = uVar5;
      uVar8 = *(undefined8*)( param_2 + 0x50 );
      uVar5 = *(undefined8*)( param_2 + 0x58 );
      puVar10[0x1a] = 0;
      puVar10[0xf] = uVar8;
      puVar10[0x10] = uVar5;
      TVar2 = param_2[9];
      puVar10[0x1b] = 0;
      puVar10[0x1c] = 0;
      *(undefined4*)( puVar10 + 0x1d ) = 0xffffffff;
      *(byte*)( (long)puVar10 + 0x31 ) = *(byte*)( (long)puVar10 + 0x31 ) & 0xf0 | (byte)TVar2 & 0xf;
      *(byte*)( (long)puVar10 + 0x31 ) = (byte)TVar2 & 0xf | (byte)param_2[9] & 0xf0;
      bVar3 = *(byte*)( (long)puVar10 + 0x32 );
      bVar11 = (byte)param_2[10] & 0xf;
      *(byte*)( (long)puVar10 + 0x32 ) = bVar3 & 0xf0 | bVar11;
      bVar12 = (byte)param_2[10] & 0x10;
      *(byte*)( (long)puVar10 + 0x32 ) = bVar3 & 0xe0 | bVar11 | bVar12;
      puVar10[0x11] = *(undefined8*)( param_2 + 0x60 );
      uVar5 = *(undefined8*)( param_2 + 0x78 );
      uVar8 = *(undefined8*)( param_2 + 0x68 );
      puVar10[0x13] = *(undefined8*)( param_2 + 0x70 );
      puVar10[0x14] = uVar5;
      puVar10[0x12] = uVar8;
      uVar8 = *(undefined8*)( param_2 + 0x90 );
      puVar10[0x16] = *(undefined8*)( param_2 + 0x88 );
      puVar10[0x17] = uVar8;
      TVar2 = param_2[10];
      *(byte*)( (long)puVar10 + 0x32 ) = bVar3 & 0xc0 | bVar11 | bVar12 | (byte)TVar2 & 0x20;
      *(byte*)( (long)puVar10 + 0x32 ) = bVar3 & 0x80 | bVar11 | bVar12 | (byte)TVar2 & 0x20 | (byte)param_2[10] & 0x40;
      *(ushort*)( (long)puVar10 + 0x32 ) = *(ushort*)( (long)puVar10 + 0x32 ) & 0xfc7f | *(ushort*)( param_2 + 10 ) & 0x380;
      *(byte*)( (long)puVar10 + 0x33 ) = *(byte*)( (long)puVar10 + 0x33 ) & 0xfb | (byte)param_2[0xb] & 4;
      lVar1 = *(long*)( *(long*)( this + 0xe8 ) + 0x18 ) + 1;
      *(long*)( *(long*)( this + 0xe8 ) + 0x18 ) = lVar1;
      puVar10[2] = lVar1;
      return;
   }

   /* WARNING: Subroutine does not return */
   std::__throw_logic_error("basic_string: construction from null is not valid");
}
/* glslang::TParseContext::addOutputArgumentConversions(glslang::TFunction const&,
   glslang::TIntermAggregate&) const */TIntermAggregate * __thiscall
glslang::TParseContext::addOutputArgumentConversions
          (TParseContext *this,TFunction *param_1,TIntermAggregate *param_2){
   code *pcVar1;
   TVariable *pTVar2;
   TIntermNode *pTVar3;
   long lVar4;
   char cVar5;
   int iVar6;
   uint uVar7;
   long *plVar8;
   long lVar9;
   long lVar10;
   TSourceLoc *pTVar11;
   TIntermAggregate *pTVar12;
   TSourceLoc *pTVar13;
   undefined8 uVar14;
   undefined8 uVar15;
   TSourceLoc *pTVar16;
   undefined8 uVar17;
   TType *pTVar18;
   undefined8 *puVar19;
   ulong uVar20;
   TIntermAggregate *pTVar21;
   undefined8 *puVar22;
   uint uVar23;
   ulong uVar24;
   long lVar25;
   long in_FS_OFFSET;
   TIntermNode *local_100;
   undefined **local_d8;
   undefined4 local_d0;
   long local_c8;
   long lStack_c0;
   long local_b8;
   long lStack_b0;
   long local_a8;
   long lStack_a0;
   long local_98;
   long lStack_90;
   long local_88;
   long lStack_80;
   long local_78;
   long local_70;
   long local_68;
   long lStack_60;
   undefined4 local_58;
   undefined1 local_50[16];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(code**)( *(long*)param_2 + 400 ) == TIntermAggregate::getSequence) {
      pTVar12 = param_2 + 0xc0;
   }
 else {
      pTVar12 = (TIntermAggregate*)( **(code**)( *(long*)param_2 + 400 ) )(param_2);
   }

   lVar25 = 0;
   uVar24 = 0;
   do {
      if (*(code**)( *(long*)param_1 + 0x120 ) == TFunction::getParamCount) {
         iVar6 = (int)( *(long*)( param_1 + 0x38 ) - *(long*)( param_1 + 0x30 ) >> 3 ) * -0x55555555;
      }
 else {
         iVar6 = ( **(code**)( *(long*)param_1 + 0x120 ) )(param_1);
      }

      if (iVar6 <= (int)uVar24) {
         if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return param_2;
         }

         goto LAB_00111ebb;
      }

      plVar8 = (long*)( **(code**)( **(long**)( *(long*)( pTVar12 + 8 ) + uVar24 * 8 ) + 0x18 ) )();
      if (*(code**)( *plVar8 + 0xf0 ) == TIntermTyped::getType) {
         pTVar18 = (TType*)( plVar8 + 4 );
      }
 else {
         pTVar18 = (TType*)( **(code**)( *plVar8 + 0xf0 ) )();
      }

      if (*(code**)( *(long*)param_1 + 0x140 ) == TFunction::operator []) {
         lVar9 = *(long*)( param_1 + 0x30 ) + lVar25;
      }
 else {
         lVar9 = ( **(code**)( *(long*)param_1 + 0x140 ) )(param_1, uVar24 & 0xffffffff);
      }

      cVar5 = TType::operator ==(*(TType**)( lVar9 + 8 ), pTVar18);
      if (cVar5 == '\0') {
         if (*(code**)( *(long*)param_1 + 0x140 ) == TFunction::operator []) {
            lVar9 = *(long*)( param_1 + 0x30 ) + lVar25;
         }
 else {
            lVar9 = ( **(code**)( *(long*)param_1 + 0x140 ) )(param_1, uVar24 & 0xffffffff);
         }

         pcVar1 = *(code**)( **(long**)( lVar9 + 8 ) + 0x50 );
         if (pcVar1 == TType::getQualifier) {
            plVar8 = *(long**)( lVar9 + 8 ) + 2;
         }
 else {
            plVar8 = (long*)( *pcVar1 )();
         }

         if (( *(byte*)( plVar8 + 1 ) & 0x7f ) - 0x11 < 2) {
            if (*(code**)( *(long*)param_2 + 0x100 ) == TIntermTyped::getBasicType) {
               uVar7 = (uint)(byte)param_2[0x28];
            }
 else {
               uVar7 = ( **(code**)( *(long*)param_2 + 0x100 ) )(param_2);
            }

            if (uVar7 == 0) {
               pTVar11 = (TSourceLoc*)0x0;
            }
 else {
               if (*(code**)( *(long*)param_2 + 0xf0 ) == TIntermTyped::getType) {
                  pTVar21 = param_2 + 0x20;
               }
 else {
                  pTVar21 = (TIntermAggregate*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
               }

               pTVar11 = (TSourceLoc*)makeInternalVariable(this, "tempReturn", (TType*)pTVar21);
               pTVar2 = *(TVariable**)( this + 0x38 );
               if ((code*)**(undefined8**)param_2 != TIntermNode::getLoc) {
                  ( *(code*)**(undefined8**)param_2 )(param_2);
               }

               uVar14 = glslang::TIntermediate::addSymbol(pTVar2, pTVar11);
               uVar17 = *(undefined8*)( this + 0x38 );
               if ((code*)**(undefined8**)param_2 == TIntermNode::getLoc) {
                  pTVar21 = param_2 + 8;
               }
 else {
                  pTVar21 = (TIntermAggregate*)( *(code*)**(undefined8**)param_2 )(param_2);
               }

               glslang::TIntermediate::addAssign(uVar17, 0x249, uVar14, param_2, pTVar21);
            }

            lVar25 = 0;
            uVar24 = 0;
            local_100 = (TIntermNode*)glslang::TIntermediate::makeAggregate(*(TIntermNode**)( this + 0x38 ));
            while (true) {
               uVar20 = uVar24 & 0xffffffff;
               if (*(code**)( *(long*)param_1 + 0x120 ) == TFunction::getParamCount) {
                  iVar6 = (int)( *(long*)( param_1 + 0x38 ) - *(long*)( param_1 + 0x30 ) >> 3 ) * -0x55555555;
               }
 else {
                  iVar6 = ( **(code**)( *(long*)param_1 + 0x120 ) )(param_1);
               }

               if (iVar6 <= (int)uVar24) break;
               lVar9 = uVar24 * 8;
               plVar8 = (long*)( **(code**)( **(long**)( *(long*)( pTVar12 + 8 ) + uVar24 * 8 ) + 0x18 ) )();
               if (*(code**)( *plVar8 + 0xf0 ) == TIntermTyped::getType) {
                  pTVar18 = (TType*)( plVar8 + 4 );
               }
 else {
                  pTVar18 = (TType*)( **(code**)( *plVar8 + 0xf0 ) )();
               }

               if (*(code**)( *(long*)param_1 + 0x140 ) == TFunction::operator []) {
                  lVar10 = *(long*)( param_1 + 0x30 ) + lVar25;
               }
 else {
                  lVar10 = ( **(code**)( *(long*)param_1 + 0x140 ) )(param_1, uVar20);
               }

               cVar5 = TType::operator ==(*(TType**)( lVar10 + 8 ), pTVar18);
               if (cVar5 == '\0') {
                  if (*(code**)( *(long*)param_1 + 0x140 ) == TFunction::operator []) {
                     lVar10 = *(long*)( param_1 + 0x30 ) + lVar25;
                  }
 else {
                     lVar10 = ( **(code**)( *(long*)param_1 + 0x140 ) )(param_1, uVar20);
                  }

                  pcVar1 = *(code**)( **(long**)( lVar10 + 8 ) + 0x50 );
                  if (pcVar1 == TType::getQualifier) {
                     plVar8 = *(long**)( lVar10 + 8 ) + 2;
                  }
 else {
                     plVar8 = (long*)( *pcVar1 )();
                  }

                  if (( *(byte*)( plVar8 + 1 ) & 0x7f ) - 0x11 < 2) {
                     local_d0 = local_d0 & 0xf81fffff;
                     local_d8 = &PTR__TType_00167f00;
                     local_50 = (undefined1[16])0x0;
                     if (*(code**)( *(long*)param_1 + 0x140 ) == TFunction::operator []) {
                        lVar10 = *(long*)( param_1 + 0x30 ) + lVar25;
                     }
 else {
                        lVar10 = ( **(code**)( *(long*)param_1 + 0x140 ) )(param_1, uVar20);
                     }

                     lVar10 = *(long*)( lVar10 + 8 );
                     local_58 = *(undefined4*)( lVar10 + 0x80 );
                     local_c8 = *(long*)( lVar10 + 0x10 );
                     lStack_c0 = *(long*)( lVar10 + 0x18 );
                     local_b8 = *(long*)( lVar10 + 0x20 );
                     lStack_b0 = *(long*)( lVar10 + 0x28 );
                     uVar23 = *(uint*)( lVar10 + 8 ) & 0x1fffff;
                     local_a8 = *(long*)( lVar10 + 0x30 );
                     lStack_a0 = *(long*)( lVar10 + 0x38 );
                     local_98 = *(long*)( lVar10 + 0x40 );
                     lStack_90 = *(long*)( lVar10 + 0x48 );
                     local_88 = *(long*)( lVar10 + 0x50 );
                     lStack_80 = *(long*)( lVar10 + 0x58 );
                     local_68 = *(long*)( lVar10 + 0x70 );
                     lStack_60 = *(long*)( lVar10 + 0x78 );
                     uVar7 = local_d0 >> 0x10;
                     local_70 = *(long*)( lVar10 + 0x68 );
                     local_78 = *(long*)( lVar10 + 0x60 );
                     local_50 = *(undefined1(*) [16])( lVar10 + 0x88 );
                     lVar4 = *(long*)( lVar10 + 0x88 );
                     local_d0._0_2_ = (undefined2)uVar23;
                     local_d0 = CONCAT22(*(ushort*)( lVar10 + 10 ) & 0x7e0 | (ushort)uVar7 & 0xf800 | ( ushort )(uVar23 >> 0x10), (undefined2)local_d0);
                     plVar8 = (long*)( **(code**)( **(long**)( *(long*)( pTVar12 + 8 ) + lVar9 ) + 0x18 ) )();
                     if (*(code**)( *plVar8 + 0xf0 ) == TIntermTyped::getType) {
                        plVar8 = plVar8 + 4;
                     }
 else {
                        plVar8 = (long*)( **(code**)( *plVar8 + 0xf0 ) )();
                     }

                     if (*(code**)( *plVar8 + 0x188 ) == TType::isParameterized) {
                        cVar5 = plVar8[0x11] != 0;
                     }
 else {
                        cVar5 = ( **(code**)( *plVar8 + 0x188 ) )();
                     }

                     if (( lVar4 == 0 ) && ( cVar5 != '\0' )) {
                        plVar8 = (long*)( **(code**)( **(long**)( *(long*)( pTVar12 + 8 ) + lVar9 ) + 0x18 ) )();
                        if (*(code**)( *plVar8 + 0xf0 ) == TIntermTyped::getType) {
                           plVar8 = plVar8 + 4;
                        }
 else {
                           plVar8 = (long*)( **(code**)( *plVar8 + 0xf0 ) )(plVar8);
                        }

                        local_58 = (undefined4)plVar8[0x10];
                        local_c8 = plVar8[2];
                        lStack_c0 = plVar8[3];
                        local_b8 = plVar8[4];
                        lStack_b0 = plVar8[5];
                        local_a8 = plVar8[6];
                        lStack_a0 = plVar8[7];
                        local_98 = plVar8[8];
                        lStack_90 = plVar8[9];
                        local_88 = plVar8[10];
                        lStack_80 = plVar8[0xb];
                        local_68 = plVar8[0xe];
                        lStack_60 = plVar8[0xf];
                        uVar7 = local_d0 >> 0x10;
                        local_70 = plVar8[0xd];
                        local_78 = plVar8[0xc];
                        local_50._8_8_ = plVar8[0x12];
                        local_d0._0_2_ = ( undefined2 )(*(uint*)( plVar8 + 1 ) & 0x1fffff);
                        local_d0 = CONCAT22(*(ushort*)( (long)plVar8 + 10 ) & 0x7e0 | (ushort)uVar7 & 0xf800 | ( ushort )(( *(uint*)( plVar8 + 1 ) & 0x1fffff ) >> 0x10), (undefined2)local_d0);
                        plVar8 = (long*)( **(code**)( **(long**)( *(long*)( pTVar12 + 8 ) + lVar9 ) + 0x18 ) )();
                        if (*(code**)( *plVar8 + 0xf0 ) == TIntermTyped::getType) {
                           plVar8 = plVar8 + 4;
                        }
 else {
                           plVar8 = (long*)( **(code**)( *plVar8 + 0xf0 ) )();
                        }

                        if (*(code**)( *plVar8 + 0xb0 ) == TType::getTypeParameters) {
                           puVar22 = (undefined8*)plVar8[0x11];
                        }
 else {
                           puVar22 = (undefined8*)( **(code**)( *plVar8 + 0xb0 ) )();
                        }

                        uVar20 = glslang::GetThreadPoolAllocator();
                        puVar19 = (undefined8*)glslang::TPoolAllocator::allocate(uVar20);
                        *(undefined1(*) [16])( puVar19 + 1 ) = (undefined1[16])0x0;
                        *(undefined4*)puVar19 = 0;
                        uVar17 = puVar22[1];
                        local_50._0_8_ = puVar19;
                        *puVar19 = *puVar22;
                        puVar19[1] = uVar17;
                        puVar19[2] = puVar22[2];
                     }

                     pTVar13 = (TSourceLoc*)makeInternalVariable(this, "tempArg", (TType*)&local_d8);
                     if (*(code**)( *(long*)pTVar13 + 0x68 ) == TVariable::getWritableType) {
                        pTVar16 = pTVar13 + 0x28;
                     }
 else {
                        pTVar16 = (TSourceLoc*)( **(code**)( *(long*)pTVar13 + 0x68 ) )(pTVar13);
                     }

                     if (*(code**)( *(long*)pTVar16 + 0x50 ) == TType::getQualifier) {
                        pTVar16 = pTVar16 + 0x10;
                     }
 else {
                        pTVar16 = (TSourceLoc*)( **(code**)( *(long*)pTVar16 + 0x50 ) )();
                     }

                     uVar17 = _LC291;
                     *(long*)pTVar16 = 0;
                     pTVar16[0x10] = ( TSourceLoc )((byte)pTVar16[0x10] & 0xf0);
                     *(long*)( pTVar16 + 0x38 ) = -0x100000000;
                     *(undefined8*)( pTVar16 + 0x14 ) = uVar17;
                     *(uint*)( pTVar16 + 0x1c ) = *(uint*)( pTVar16 + 0x1c ) & 0xffc00000 | 0x1fcfff;
                     *(ulong*)( pTVar16 + 0x20 ) = *(ulong*)( pTVar16 + 0x20 ) | 0x7fffffffffffffff;
                     pTVar16[0x30] = (TSourceLoc)0x0;
                     *(undefined4*)( pTVar16 + 0x34 ) = 0xfffff800;
                     *(long*)( pTVar16 + 0x40 ) = 0;
                     *(ulong*)( pTVar16 + 0x28 ) = ( ulong )(( uint ) * (long*)( pTVar16 + 0x28 ) & 0xfe000000) | 0x1ffffff;
                     *(undefined2*)( pTVar16 + 0x48 ) = 0;
                     *(ulong*)( pTVar16 + 8 ) = *(ulong*)( pTVar16 + 8 ) & 0x800000141fff0000;
                     pTVar2 = *(TVariable**)( this + 0x38 );
                     if ((code*)**(undefined8**)param_2 != TIntermNode::getLoc) {
                        ( *(code*)**(undefined8**)param_2 )(param_2);
                     }

                     uVar14 = glslang::TIntermediate::addSymbol(pTVar2, pTVar13);
                     uVar17 = *(undefined8*)( this + 0x38 );
                     puVar22 = (undefined8*)**(undefined8**)( *(long*)( pTVar12 + 8 ) + lVar9 );
                     if ((code*)*puVar22 == TIntermNode::getLoc) {
                        puVar19 = *(undefined8**)( *(long*)( pTVar12 + 8 ) + lVar9 ) + 1;
                     }
 else {
                        puVar19 = (undefined8*)( *(code*)*puVar22 )();
                        puVar22 = (undefined8*)**(undefined8**)( *(long*)( pTVar12 + 8 ) + lVar9 );
                     }

                     uVar15 = ( *(code*)puVar22[3] )();
                     pTVar16 = (TSourceLoc*)glslang::TIntermediate::addAssign(uVar17, 0x249, uVar15, uVar14, puVar19);
                     pTVar3 = *(TIntermNode**)( this + 0x38 );
                     if (*(code**)**(undefined8**)( *(long*)( pTVar12 + 8 ) + lVar9 ) != TIntermNode::getLoc) {
                        ( **(code**)**(undefined8**)( *(long*)( pTVar12 + 8 ) + lVar9 ) )();
                     }

                     local_100 = (TIntermNode*)glslang::TIntermediate::growAggregate(pTVar3, local_100, pTVar16);
                     pTVar2 = *(TVariable**)( this + 0x38 );
                     if ((code*)**(undefined8**)param_2 != TIntermNode::getLoc) {
                        ( *(code*)**(undefined8**)param_2 )(param_2);
                     }

                     uVar17 = glslang::TIntermediate::addSymbol(pTVar2, pTVar13);
                     *(undefined8*)( *(long*)( pTVar12 + 8 ) + lVar9 ) = uVar17;
                  }

               }

               uVar24 = uVar24 + 1;
               lVar25 = lVar25 + 0x18;
            }
;
            if (pTVar11 != (TSourceLoc*)0x0) {
               pTVar2 = *(TVariable**)( this + 0x38 );
               if ((code*)**(undefined8**)param_2 != TIntermNode::getLoc) {
                  ( *(code*)**(undefined8**)param_2 )(param_2);
               }

               pTVar11 = (TSourceLoc*)glslang::TIntermediate::addSymbol(pTVar2, pTVar11);
               pTVar3 = *(TIntermNode**)( this + 0x38 );
               if ((code*)**(undefined8**)param_2 != TIntermNode::getLoc) {
                  ( *(code*)**(undefined8**)param_2 )(param_2);
               }

               local_100 = (TIntermNode*)glslang::TIntermediate::growAggregate(pTVar3, local_100, pTVar11);
            }

            uVar17 = *(undefined8*)( this + 0x38 );
            puVar22 = *(undefined8**)param_2;
            if ((code*)*puVar22 == TIntermNode::getLoc) {
               pTVar12 = param_2 + 8;
            }
 else {
               pTVar12 = (TIntermAggregate*)( *(code*)*puVar22 )(param_2);
               puVar22 = *(undefined8**)param_2;
            }

            if ((code*)puVar22[0x1e] == TIntermTyped::getType) {
               pTVar21 = param_2 + 0x20;
            }
 else {
               pTVar21 = (TIntermAggregate*)( *(code*)puVar22[0x1e] )(param_2);
            }

            if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
               pTVar12 = (TIntermAggregate*)glslang::TIntermediate::setAggregateOperator(uVar17, local_100, 0xae, pTVar21, pTVar12);
               return pTVar12;
            }

            LAB_00111ebb:/* WARNING: Subroutine does not return */__stack_chk_fail();
         }

      }

      uVar24 = uVar24 + 1;
      lVar25 = lVar25 + 0x18;
   }
 while ( true );
}
/* glslang::TParseContext::constructBuiltIn(glslang::TType const&, glslang::TOperator,
   glslang::TIntermTyped*, glslang::TSourceLoc const&, bool) */undefined8 glslang::TParseContext::constructBuiltIn(long *param_1, long *param_2, int param_3, long *param_4, undefined8 param_5) {
   ulong uVar1;
   byte bVar2;
   char cVar3;
   char cVar4;
   undefined1 uVar5;
   undefined4 uVar6;
   uint uVar7;
   undefined8 uVar8;
   long *plVar9;
   uint uVar10;
   long lVar11;
   uint uVar12;
   long in_FS_OFFSET;
   undefined **local_d8;
   uint local_d0;
   undefined8 local_c8;
   ulong local_c0;
   byte local_b8;
   undefined8 local_b4;
   undefined1 local_ac;
   uint7 uStack_ab;
   undefined1 uStack_a4;
   undefined3 uStack_a3;
   undefined5 local_a0;
   undefined3 uStack_9b;
   undefined1 local_98;
   undefined8 local_94;
   undefined4 local_8c;
   undefined8 local_88;
   undefined2 local_80;
   undefined1 local_78[16];
   undefined1 local_68[16];
   uint local_58;
   undefined1 local_50[16];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(code**)( *param_4 + 0xf0 ) == TIntermTyped::getType) {
      plVar9 = param_4 + 4;
   }
 else {
      plVar9 = (long*)( **(code**)( *param_4 + 0xf0 ) )(param_4);
   }

   if (*(code**)( *plVar9 + 0xe0 ) == TType::isMatrix) {
      if (*(byte*)( (long)plVar9 + 9 ) < 0x10) goto joined_r0x001121d3;
   }
 else {
      cVar3 = ( **(code**)( *plVar9 + 0xe0 ) )();
      if (cVar3 == '\0') goto joined_r0x001121d3;
   }

   lVar11 = *param_2;
   if (*(code**)( lVar11 + 0xc0 ) == TType::isScalar) {
      if (*(code**)( lVar11 + 0xd8 ) == TType::isVector) {
         if (( *(byte*)( (long)param_2 + 9 ) & 0xf ) < 2) {
            bVar2 = *(byte*)( (long)param_2 + 10 );
            if (( bVar2 & 0x10 ) == 0) goto LAB_0011222c;
            LAB_00112450:bVar2 = bVar2 >> 4 & 1;
            goto LAB_00112456;
         }

      }
 else {
         cVar3 = ( **(code**)( lVar11 + 0xd8 ) )(param_2);
         lVar11 = *param_2;
         if (cVar3 == '\0') {
            LAB_0011222c:if (*(code**)( lVar11 + 0xe0 ) == TType::isMatrix) {
               if (*(byte*)( (long)param_2 + 9 ) < 0x10) {
                  LAB_001123ed:if (*(code**)( lVar11 + 0x128 ) == TType::isStruct) {
                     if (1 < ( byte )((char)param_2[1] - 0xfU)) {
                        LAB_00112413:if (*(code**)( lVar11 + 0xe8 ) == TType::isArray) {
                           if (param_2[0xc] == 0) goto LAB_00111fb3;
                        }
 else {
                           cVar3 = ( **(code**)( lVar11 + 0xe8 ) )(param_2);
                           if (cVar3 == '\0') goto LAB_0011232d;
                           lVar11 = *param_2;
                        }

                     }

                  }
 else {
                     cVar3 = ( **(code**)( lVar11 + 0x128 ) )(param_2);
                     lVar11 = *param_2;
                     if (cVar3 == '\0') goto LAB_00112413;
                  }

               }

            }
 else {
               cVar3 = ( **(code**)( lVar11 + 0xe0 ) )(param_2);
               lVar11 = *param_2;
               if (cVar3 == '\0') goto LAB_001123ed;
            }

         }

         LAB_00112246:if (*(code**)( lVar11 + 0xd8 ) != TType::isVector) {
            bVar2 = ( **(code**)( lVar11 + 0xd8 ) )(param_2);
            LAB_00112456:if (bVar2 == 0) goto joined_r0x001121d3;
            goto LAB_0011232d;
         }

         if (( *(byte*)( (long)param_2 + 9 ) & 0xf ) < 2) {
            bVar2 = *(byte*)( (long)param_2 + 10 );
            goto LAB_00112450;
         }

      }

   }
 else {
      cVar3 = ( **(code**)( lVar11 + 0xc0 ) )(param_2);
      if (cVar3 == '\0') {
         lVar11 = *param_2;
         goto LAB_00112246;
      }

      LAB_0011232d:lVar11 = *param_2;
   }

   LAB_00111fb3:if (*(code**)( lVar11 + 0x130 ) == TType::isFloatingDomain) {
      cVar3 = ( byte )((char)param_2[1] - 1U) < 3;
   }
 else {
      cVar3 = ( **(code**)( lVar11 + 0x130 ) )(param_2);
   }

   if (*(code**)( *param_4 + 0xf0 ) == TIntermTyped::getType) {
      plVar9 = param_4 + 4;
   }
 else {
      plVar9 = (long*)( **(code**)( *param_4 + 0xf0 ) )(param_4);
   }

   if (*(code**)( *plVar9 + 0x130 ) == TType::isFloatingDomain) {
      cVar4 = ( byte )((char)plVar9[1] - 1U) < 3;
   }
 else {
      cVar4 = ( **(code**)( *plVar9 + 0x130 ) )();
   }

   if (cVar3 != cVar4) {
      if (*(code**)( *param_4 + 0x158 ) == TIntermTyped::isVector) {
         uVar10 = 1;
         if (( *(byte*)( (long)param_4 + 0x29 ) & 0xf ) < 2) {
            uVar10 = *(byte*)( (long)param_4 + 0x2a ) >> 4 & 1;
         }

      }
 else {
         uVar10 = ( **(code**)( *param_4 + 0x158 ) )(param_4);
      }

      if (*(code**)( *param_2 + 0x60 ) == TType::getVectorSize) {
         uVar12 = *(byte*)( (long)param_2 + 9 ) & 0xf;
         uVar7 = uVar12;
      }
 else {
         uVar7 = ( **(code**)( *param_2 + 0x60 ) )(param_2);
         uVar10 = uVar10 & 0xff;
         uVar12 = uVar7 & 0xf;
      }

      if (*(code**)( *param_4 + 0x100 ) == TIntermTyped::getBasicType) {
         uVar5 = (undefined1)param_4[5];
      }
 else {
         uVar5 = ( **(code**)( *param_4 + 0x100 ) )(param_4);
         uVar10 = uVar10 & 0xff;
      }

      local_d0 = CONCAT31(local_d0._1_3_, uVar5);
      local_b8 = local_b8 & 0xf0;
      local_d8 = &PTR__TType_00167f00;
      local_80 = 0;
      local_50 = (undefined1[16])0x0;
      local_98 = 0;
      local_d0 = ( uVar7 == 1 & uVar10 ) << 0x14 | uVar12 << 8 | local_d0 & 0xf80000ff;
      local_78 = (undefined1[16])0x0;
      local_94 = 0xfffff800;
      local_68 = (undefined1[16])0x0;
      local_ac = 0xff;
      local_58 = local_58 & 0x9fc00000;
      local_8c = 0xffffffff;
      local_c8 = 0;
      uStack_9b = 0;
      local_b4 = 0xffffffffffffffff;
      uStack_ab = uStack_ab & 0xffc000 | 0xffffffff001fcf;
      uStack_a4 = 0xff;
      local_88 = 0;
      uVar1 = ( ulong )(CONCAT43((undefined4)local_a0, uStack_a3) & 0xfe07ff00ffffff) | 0x1ffffff7fffff;
      uStack_a3 = (undefined3)uVar1;
      local_a0 = ( undefined5 )(uVar1 >> 0x18);
      local_c0 = local_c0 & 0x8000000400000000;
      uVar6 = glslang::TIntermediate::mapTypeToConstructorOp((TType*)param_1[7]);
      constructBuiltIn(param_1, &local_d8, uVar6, param_4, param_5, 0);
   }

   joined_r0x001121d3:if (param_3 - 0x1dbU < 0x6d) {
      /* WARNING: Could not recover jumptable at 0x00111f53. Too many branches */
      /* WARNING: Treating indirect jump as call */
      uVar8 = ( *(code*)( &DAT_00155314 + *(int*)( &DAT_00155314 + ( ulong )(param_3 - 0x1db) * 4 ) ) )();
      return uVar8;
   }

   ( **(code**)( *param_1 + 0x158 ) )(param_1, param_5, "unsupported construction", &_LC1);
   if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return 0;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::inheritMemoryQualifiers(glslang::TQualifier const&, glslang::TQualifier&)
    */void glslang::TParseContext::inheritMemoryQualifiers(TParseContext *this, TQualifier *param_1, TQualifier *param_2) {
   TQualifier TVar1;
   if ((char)param_1[0xd] < '\0') {
      param_2[0xd] = ( TQualifier )((byte)param_2[0xd] | 0x80);
   }

   TVar1 = param_1[0xe];
   if (( (byte)TVar1 & 1 ) != 0) {
      param_2[0xe] = ( TQualifier )((byte)param_2[0xe] | 1);
      TVar1 = param_1[0xe];
   }

   if (( (byte)TVar1 & 2 ) != 0) {
      param_2[0xe] = ( TQualifier )((byte)param_2[0xe] | 2);
      TVar1 = param_1[0xe];
   }

   if (( (byte)TVar1 & 4 ) != 0) {
      param_2[0xe] = ( TQualifier )((byte)param_2[0xe] | 4);
   }

   if (( (byte)param_1[0xd] & 0x40 ) != 0) {
      param_2[0xd] = ( TQualifier )((byte)param_2[0xd] | 0x40);
   }

   return;
}
/* glslang::TParseContext::blockStorageRemap(glslang::TSourceLoc const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const*,
   glslang::TQualifier&) */void glslang::TParseContext::blockStorageRemap(TParseContext *this, TSourceLoc *param_1, basic_string *param_2, TQualifier *param_3) {
   int iVar1;
   iVar1 = TIntermediate::getBlockStorageOverride(*(TIntermediate**)( this + 0x38 ), *(char**)( param_2 + 8 ));
   if (iVar1 != 3) {
      param_3[0x2d] = ( TQualifier )(iVar1 == 2);
      if (iVar1 == 1) {
         param_3[8] = ( TQualifier )((byte)param_3[8] & 0x80 | 6);
         return;
      }

      if (iVar1 == 2) {
         param_3[8] = ( TQualifier )((byte)param_3[8] & 0x80 | 5);
         *(ulong*)( param_3 + 0x1d ) = *(ulong*)( param_3 + 0x1d ) & 0xffffff0000ffc07f | 0xffff001f80;
         return;
      }

      if (iVar1 == 0) {
         if (( (byte)param_3[0x10] & 0xf ) == 3) {
            param_3[0x10] = ( TQualifier )((byte)param_3[0x10] & 0xf0 | 2);
         }

         param_3[8] = ( TQualifier )((byte)param_3[8] & 0x80 | 5);
         return;
      }

   }

   return;
}
/* glslang::TParseContext::blockStageIoCheck(glslang::TSourceLoc const&, glslang::TQualifier const&)
    */void glslang::TParseContext::blockStageIoCheck(TParseContext *this, TSourceLoc *param_1, TQualifier *param_2) {
   int iVar1;
   int iVar2;
   long in_FS_OFFSET;
   char *local_38;
   char *pcStack_30;
   long local_20;
   local_20 = *(long*)( in_FS_OFFSET + 0x28 );
   local_38 = "GL_NV_ray_tracing";
   pcStack_30 = "GL_EXT_ray_tracing";
   iVar2 = (int)param_1;
   switch ((char)param_2[8] + 0x7dU & 0x7f) {
      case 0:
    glslang::TParseVersions::profileRequires
              ((TSourceLoc *)this,iVar2,-9,(char *)0x96,"GL_ARB_separate_shader_objects");
    glslang::TParseVersions::requireStage(this,param_1,0x201e,"input block");
    if (*(int *)(this + 0x1c) != 4) {
      if ((*(int *)(this + 0x1c) == 0xd) && (((byte)param_2[0xd] & 8) == 0)) {
        (**(code **)(*(long *)this + 0x158))
                  (this,param_1,"input blocks cannot be used in a mesh shader",&_LC71,&_LC1);
      }
      break;
    }
    goto LAB_001141cf;
      case 1:
    glslang::TParseVersions::profileRequires
              ((TSourceLoc *)this,iVar2,-9,(char *)0x96,"GL_ARB_separate_shader_objects");
    glslang::TParseVersions::requireStage(this,param_1,0x300f,"output block");
    iVar1 = *(int *)(this + 0x1c);
    if (iVar1 != 0) {
      if (iVar1 == 0xd) {
        if (((byte)param_2[0xd] & 8) != 0) {
          (**(code **)(*(long *)this + 0x158))
                    (this,param_1,"can only use on input blocks in mesh shader","taskNV",&_LC1);
        }
      }
      else if ((iVar1 == 0xc) && (((byte)param_2[0xd] & 8) == 0)) {
        (**(code **)(*(long *)this + 0x158))
                  (this,param_1,"output blocks cannot be used in a task shader",&_LC71,&_LC1);
      }
      break;
    }
    if (this[0x1c1] != (TParseContext)0x0) break;
LAB_001141cf:
    glslang::TParseVersions::profileRequires
              ((TSourceLoc *)this,iVar2,8,0x140,(char **)0x2,AEP_shader_io_blocks);
    break;
      case 2:
    glslang::TParseVersions::profileRequires((TSourceLoc *)this,iVar2,8,(char *)0x12c,(char *)0x0);
    glslang::TParseVersions::profileRequires
              ((TSourceLoc *)this,iVar2,1,(char *)0x8c,"GL_ARB_uniform_buffer_object");
    if ((((byte)this[0x520] & 0xf) == 3) && (this[0x53d] == (TParseContext)0x0)) {
      (**(code **)(*(long *)this + 0x28))
                (this,param_1,1,&E_GL_EXT_scalar_block_layout,
                 "std430 requires the buffer storage qualifier");
    }
    break;
      case 3:
    glslang::TParseVersions::requireProfile((TSourceLoc *)this,iVar2,(char *)0xe);
    glslang::TParseVersions::profileRequires
              ((TSourceLoc *)this,iVar2,6,(char *)0x1ae,"GL_ARB_shader_storage_buffer_object");
    glslang::TParseVersions::profileRequires((TSourceLoc *)this,iVar2,8,(char *)0x136,(char *)0x0);
    break;
      case 4:
    if (*(int *)(this + 0x20) - 1U < 0x103ff) {
      (**(code **)(*(long *)this + 0x158))
                (this,param_1,"shared block requires at least SPIR-V 1.4","shared block",&_LC1);
    }
    glslang::TParseVersions::profileRequires
              ((TSourceLoc *)this,iVar2,0xe,(char *)0x0,"GL_EXT_shared_memory_block");
    break;
      default:
    (**(code **)(*(long *)this + 0x158))
              (this,param_1,"only uniform, buffer, in, or out blocks are supported",
               *(undefined8 *)(*(long *)(this + 0x508) + 8),&_LC1);
    break;
      case 6:
    glslang::TParseVersions::profileRequires
              ((TSourceLoc *)this,iVar2,-9,0x1cc,(char **)0x2,(char *)&local_38);
    glslang::TParseVersions::requireStage(this,param_1,0x740,"rayPayloadNV block");
    break;
      case 7:
    glslang::TParseVersions::profileRequires
              ((TSourceLoc *)this,iVar2,-9,0x1cc,(char **)0x2,(char *)&local_38);
    glslang::TParseVersions::requireStage(this,param_1,0x700,"rayPayloadInNV block");
    break;
      case 8:
    glslang::TParseVersions::profileRequires
              ((TSourceLoc *)this,iVar2,-9,0x1cc,(char **)0x2,(char *)&local_38);
    glslang::TParseVersions::requireStage(this,param_1,0x380,"hitAttributeNV block");
    break;
      case 9:
    glslang::TParseVersions::profileRequires
              ((TSourceLoc *)this,iVar2,-9,0x1cc,(char **)0x2,(char *)&local_38);
    glslang::TParseVersions::requireStage(this,param_1,0xe40,"callableDataNV block");
    break;
      case 10:
    glslang::TParseVersions::profileRequires
              ((TSourceLoc *)this,iVar2,-9,0x1cc,(char **)0x2,(char *)&local_38);
    glslang::TParseVersions::requireStage(this,param_1,0x800,"callableDataInNV block");
    break;
      case 0xb:
    glslang::TParseVersions::profileRequires
              ((TSourceLoc *)this,iVar2,-9,(char *)0x1cc,"GL_NV_shader_invocation_reorder");
    glslang::TParseVersions::requireStage(this,param_1,0x640,"hitObjectAttributeNV block");
   }

   if (local_20 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::blockQualifierCheck(glslang::TSourceLoc const&, glslang::TQualifier
   const&, bool) */void glslang::TParseContext::blockQualifierCheck(TSourceLoc *param_1, TQualifier *param_2, bool param_3) {
   byte bVar1;
   undefined7 in_register_00000011;
   long lVar2;
   lVar2 = CONCAT71(in_register_00000011, param_3);
   bVar1 = *(byte*)( lVar2 + 0xb );
   if (( ( ( (char)bVar1 < '\0' ) || ( ( bVar1 & 0x40 ) != 0 ) ) || ( ( *(byte*)( lVar2 + 0xc ) & 0x20 ) != 0 ) ) || ( ( *(byte*)( lVar2 + 0xc ) & 0x40 ) != 0 )) {
      ( **(code**)( *(long*)param_1 + 0x158 ) )(param_1, param_2, "cannot use interpolation qualifiers on an interface block", "flat/smooth/noperspective", &_LC1);
      bVar1 = *(byte*)( lVar2 + 0xb );
   }

   if (( bVar1 & 0x20 ) != 0) {
      ( **(code**)( *(long*)param_1 + 0x158 ) )(param_1, param_2, "cannot use centroid qualifier on an interface block", "centroid", &_LC1);
   }

   if (( *(byte*)( lVar2 + 0xd ) & 0x20 ) != 0) {
      ( **(code**)( *(long*)param_1 + 0x158 ) )(param_1, param_2, "cannot use sample qualifier on an interface block", "sample", &_LC1);
   }

   if (( *(byte*)( lVar2 + 0xb ) & 0x10 ) != 0) {
      ( **(code**)( *(long*)param_1 + 0x158 ) )(param_1, param_2, "cannot use invariant qualifier on an interface block", "invariant", &_LC1);
   }

   if (*(char*)( lVar2 + 0x2d ) != '\0') {
      *(int*)( *(long*)( param_1 + 0x38 ) + 0x268 ) = *(int*)( *(long*)( param_1 + 0x38 ) + 0x268 ) + 1;
   }

   if (*(char*)( lVar2 + 0x38 ) != '\0') {
      *(int*)( *(long*)( param_1 + 0x38 ) + 0x364 ) = *(int*)( *(long*)( param_1 + 0x38 ) + 0x364 ) + 1;
   }

   if (( *(byte*)( lVar2 + 0xd ) & 8 ) != 0) {
      *(int*)( *(long*)( param_1 + 0x38 ) + 0x370 ) = *(int*)( *(long*)( param_1 + 0x38 ) + 0x370 ) + 1;
   }

   return;
}
/* glslang::TParseContext::growGlobalUniformBlock(glslang::TSourceLoc const&, glslang::TType&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const&,
   glslang::TVector<glslang::TTypeLoc>*) */void glslang::TParseContext::growGlobalUniformBlock(TSourceLoc *param_1, TType *param_2, basic_string *param_3, TVector *param_4) {
   long lVar1;
   TIntermediate *this;
   code *pcVar2;
   int iVar3;
   char *pcVar4;
   long *plVar5;
   basic_string *pbVar6;
   lVar1 = *(long*)( param_1 + 0x470 );
   if (lVar1 == 0) {
      *(undefined4*)( param_1 + 0x478 ) = *(undefined4*)( *(long*)( param_1 + 0x38 ) + 0x2e4 );
      *(undefined4*)( param_1 + 0x47c ) = *(undefined4*)( *(long*)( param_1 + 0x38 ) + 0x2e0 );
   }

   glslang::TParseContextBase::growGlobalUniformBlock(param_1, param_2, param_3, param_4);
   if (( 0 < *(int*)( param_1 + 0x28 ) ) && ( param_1[0x30] != (TSourceLoc)0x0 )) {
      this * (TIntermediate**)( param_1 + 0x38 );
      pcVar4 = (char*)( **(code**)( *(long*)param_1 + 0x218 ) )(param_1);
      iVar3 = TIntermediate::getBlockStorageOverride(this, pcVar4);
      pcVar2 = *(code**)( **(long**)( param_1 + 0x470 ) + 0x68 );
      if (pcVar2 == TVariable::getWritableType) {
         plVar5 = *(long**)( param_1 + 0x470 ) + 5;
      }
 else {
         plVar5 = (long*)( *pcVar2 )();
      }

      if (*(code**)( *plVar5 + 0x50 ) == TType::getQualifier) {
         plVar5 = plVar5 + 2;
      }
 else {
         plVar5 = (long*)( **(code**)( *plVar5 + 0x50 ) )();
      }

      *(byte*)( (long)plVar5 + 0xc ) = *(byte*)( (long)plVar5 + 0xc ) | 8;
      if (iVar3 != 3) {
         if (lVar1 == 0) {
            *(bool*)( (long)plVar5 + 0x2d ) = iVar3 == 2;
            if (iVar3 == 1) {
               *(byte*)( plVar5 + 1 ) = *(byte*)( plVar5 + 1 ) & 0x80 | 6;
            }
 else if (iVar3 == 2) {
               *(byte*)( plVar5 + 1 ) = *(byte*)( plVar5 + 1 ) & 0x80 | 5;
               *(ulong*)( (long)plVar5 + 0x1d ) = *(ulong*)( (long)plVar5 + 0x1d ) & 0xffffff0000ffc07f | 0xffff001f80;
            }
 else if (iVar3 == 0) {
               if (( *(byte*)( plVar5 + 2 ) & 0xf ) == 3) {
                  *(byte*)( plVar5 + 2 ) = *(byte*)( plVar5 + 2 ) & 0xf0 | 2;
               }

               *(byte*)( plVar5 + 1 ) = *(byte*)( plVar5 + 1 ) & 0x80 | 5;
            }

            blockQualifierCheck(param_1, (TQualifier*)param_2, SUB81(plVar5, 0));
         }

         if (*(code**)( *(long*)param_3 + 0x50 ) == TType::getQualifier) {
            pbVar6 = param_3 + 0x10;
         }
 else {
            pbVar6 = (basic_string*)( **(code**)( *(long*)param_3 + 0x50 ) )(param_3);
         }

         pbVar6[0x2d] = ( basic_string )(iVar3 == 2);
         if (iVar3 == 1) {
            pbVar6[8] = ( basic_string )((byte)pbVar6[8] & 0x80 | 6);
         }
 else if (iVar3 == 2) {
            pbVar6[8] = ( basic_string )((byte)pbVar6[8] & 0x80 | 5);
            *(ulong*)( pbVar6 + 0x1d ) = *(ulong*)( pbVar6 + 0x1d ) & 0xffffff0000ffc07f | 0xffff001f80;
         }
 else if (iVar3 == 0) {
            if (( (byte)pbVar6[0x10] & 0xf ) == 3) {
               pbVar6[0x10] = ( basic_string )((byte)pbVar6[0x10] & 0xf0 | 2);
            }

            pbVar6[8] = ( basic_string )((byte)pbVar6[8] & 0x80 | 5);
         }

      }

   }

   return;
}
/* glslang::TParseContext::growAtomicCounterBlock(int, glslang::TSourceLoc const&, glslang::TType&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const&,
   glslang::TVector<glslang::TTypeLoc>*) */void glslang::TParseContext::growAtomicCounterBlock(int param_1, TSourceLoc *param_2, TType *param_3, basic_string *param_4, TVector *param_5) {
   TSourceLoc *pTVar1;
   code *pcVar2;
   TIntermediate *this;
   TSourceLoc *pTVar3;
   int iVar4;
   TSourceLoc *pTVar5;
   char *pcVar6;
   long *plVar7;
   TSourceLoc *pTVar8;
   basic_string *pbVar9;
   undefined4 in_register_0000003c;
   TSourceLoc *pTVar10;
   TSourceLoc *pTVar11;
   long in_FS_OFFSET;
   int local_4c;
   int *local_48;
   long local_40;
   pTVar10 = (TSourceLoc*)CONCAT44(in_register_0000003c, param_1);
   local_4c = (int)param_2;
   pTVar1 = pTVar10 + 0x498;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   pTVar3 = *(TSourceLoc**)( pTVar10 + 0x4a0 );
   pTVar5 = pTVar1;
   pTVar11 = pTVar1;
   if (*(TSourceLoc**)( pTVar10 + 0x4a0 ) == (TSourceLoc*)0x0) {
      LAB_00114aa3:*(undefined4*)( pTVar10 + 0x4c0 ) = *(undefined4*)( *(long*)( pTVar10 + 0x38 ) + 0x2e8 );
      pTVar11 = pTVar5;
   }
 else {
      do {
         while (true) {
            pTVar5 = pTVar3;
            if (*(int*)( pTVar5 + 0x20 ) < local_4c) break;
            pTVar3 = *(TSourceLoc**)( pTVar5 + 0x10 );
            pTVar11 = pTVar5;
            if (*(TSourceLoc**)( pTVar5 + 0x10 ) == (TSourceLoc*)0x0) goto LAB_00114990;
         }
;
         pTVar3 = *(TSourceLoc**)( pTVar5 + 0x18 );
      }
 while ( *(TSourceLoc**)( pTVar5 + 0x18 ) != (TSourceLoc*)0x0 );
      LAB_00114990:pTVar5 = pTVar11;
      if (( pTVar1 == pTVar11 ) || ( pTVar5 = pTVar1 ),local_4c < *(int*)( pTVar11 + 0x20 )) goto LAB_00114aa3;
   }

   glslang::TParseContextBase::growAtomicCounterBlock(param_1, (TSourceLoc*)( (ulong)param_2 & 0xffffffff ), param_3, param_4, param_5);
   pTVar3 = *(TSourceLoc**)( pTVar10 + 0x4a0 );
   pTVar5 = pTVar1;
   if (*(TSourceLoc**)( pTVar10 + 0x4a0 ) != (TSourceLoc*)0x0) {
      do {
         while (true) {
            pTVar8 = pTVar3;
            if (*(int*)( pTVar8 + 0x20 ) < local_4c) break;
            pTVar3 = *(TSourceLoc**)( pTVar8 + 0x10 );
            pTVar5 = pTVar8;
            if (*(TSourceLoc**)( pTVar8 + 0x10 ) == (TSourceLoc*)0x0) goto LAB_001149f0;
         }
;
         pTVar3 = *(TSourceLoc**)( pTVar8 + 0x18 );
      }
 while ( *(TSourceLoc**)( pTVar8 + 0x18 ) != (TSourceLoc*)0x0 );
      LAB_001149f0:if (( pTVar1 != pTVar5 ) && ( *(int*)( pTVar5 + 0x20 ) <= local_4c )) goto LAB_001149fe;
   }

   local_48 = &local_4c;
   pTVar5 = (TSourceLoc*)std::_Rb_tree<int,std::pair<int_const,glslang::TVariable*>,std::_Select1st<std::pair<int_const,glslang::TVariable*>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVariable*>>>::_M_emplace_hint_unique<std::piecewise_construct_t_const&,std::tuple<int_const&>,std::tuple<>>(pTVar10 + 0x488, pTVar5, &local_48);
   LAB_001149fe:pcVar2 = *(code**)( **(long**)( pTVar5 + 0x28 ) + 0x68 );
   if (pcVar2 == TVariable::getWritableType) {
      plVar7 = *(long**)( pTVar5 + 0x28 ) + 5;
   }
 else {
      plVar7 = (long*)( *pcVar2 )();
   }

   if (*(code**)( *plVar7 + 0x50 ) == TType::getQualifier) {
      plVar7 = plVar7 + 2;
   }
 else {
      plVar7 = (long*)( **(code**)( *plVar7 + 0x50 ) )();
   }

   *(byte*)( (long)plVar7 + 0xc ) = *(byte*)( (long)plVar7 + 0xc ) | 8;
   if (( 0 < *(int*)( pTVar10 + 0x28 ) ) && ( pTVar10[0x30] != (TSourceLoc)0x0 )) {
      this * (TIntermediate**)( pTVar10 + 0x38 );
      pcVar6 = (char*)( **(code**)( *(long*)pTVar10 + 0x230 ) )(pTVar10);
      iVar4 = TIntermediate::getBlockStorageOverride(this, pcVar6);
      if (iVar4 != 3) {
         if (pTVar1 == pTVar11) {
            *(bool*)( (long)plVar7 + 0x2d ) = iVar4 == 2;
            if (iVar4 == 1) {
               *(byte*)( plVar7 + 1 ) = *(byte*)( plVar7 + 1 ) & 0x80 | 6;
            }
 else if (iVar4 == 2) {
               *(byte*)( plVar7 + 1 ) = *(byte*)( plVar7 + 1 ) & 0x80 | 5;
               *(ulong*)( (long)plVar7 + 0x1d ) = *(ulong*)( (long)plVar7 + 0x1d ) & 0xffffff0000ffc07f | 0xffff001f80;
            }
 else if (iVar4 == 0) {
               if (( *(byte*)( plVar7 + 2 ) & 0xf ) == 3) {
                  *(byte*)( plVar7 + 2 ) = *(byte*)( plVar7 + 2 ) & 0xf0 | 2;
               }

               *(byte*)( plVar7 + 1 ) = *(byte*)( plVar7 + 1 ) & 0x80 | 5;
            }

            blockQualifierCheck(pTVar10, (TQualifier*)param_3, SUB81(plVar7, 0));
         }

         if (*(code**)( *(long*)param_4 + 0x50 ) == TType::getQualifier) {
            pbVar9 = param_4 + 0x10;
         }
 else {
            pbVar9 = (basic_string*)( **(code**)( *(long*)param_4 + 0x50 ) )(param_4);
         }

         pbVar9[0x2d] = ( basic_string )(iVar4 == 2);
         if (iVar4 == 1) {
            pbVar9[8] = ( basic_string )((byte)pbVar9[8] & 0x80 | 6);
         }
 else if (iVar4 == 2) {
            pbVar9[8] = ( basic_string )((byte)pbVar9[8] & 0x80 | 5);
            *(ulong*)( pbVar9 + 0x1d ) = *(ulong*)( pbVar9 + 0x1d ) & 0xffffff0000ffc07f | 0xffff001f80;
         }
 else if (iVar4 == 0) {
            if (( (byte)pbVar9[0x10] & 0xf ) == 3) {
               pbVar9[0x10] = ( basic_string )((byte)pbVar9[0x10] & 0xf0 | 2);
            }

            pbVar9[8] = ( basic_string )((byte)pbVar9[8] & 0x80 | 5);
         }

      }

   }

   if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   return;
}
/* glslang::TParseContext::fixBlockLocations(glslang::TSourceLoc const&, glslang::TQualifier&,
   glslang::TVector<glslang::TTypeLoc>&, bool, bool) */void glslang::TParseContext::fixBlockLocations(TParseContext *this, TSourceLoc *param_1, TQualifier *param_2, TVector *param_3, bool param_4, bool param_5) {
   code *pcVar1;
   ushort uVar2;
   ushort uVar3;
   int iVar4;
   long *plVar5;
   long lVar6;
   undefined8 *puVar7;
   uint uVar8;
   ulong uVar9;
   long lVar10;
   uVar3 = *(ushort*)( param_2 + 0x1c );
   if (( ~(uint)uVar3 & 0xfff ) == 0) {
      if (!param_4) {
         return;
      }

      if (param_5) {
         /* WARNING: Could not recover jumptable at 0x00114e59. Too many branches */
         /* WARNING: Treating indirect jump as call */
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "either the block needs a location, or all members need a location, or no members have a location", "location", &_LC1, *(code**)( *(long*)this + 0x158 ));
         return;
      }

      if (( (byte)param_2[0x1d] & 0x70 ) != 0x40) goto LAB_00114ca7;
      uVar8 = 0;
      if (param_2[0x22] == (TQualifier)0xff) goto LAB_00114d1b;
      uVar8 = 0xfff;
      *(ushort*)( param_2 + 0x1c ) = uVar3 | 0xfff;
      if (( ( byte )(( uVar3 | 0xfff ) >> 8) & 0x70 ) != 0x40) goto LAB_00114cc3;
   }
 else {
      if (!param_4) {
         return;
      }

      LAB_00114ca7:*(ushort*)( param_2 + 0x1c ) = uVar3 | 0xfff;
      uVar8 = uVar3 & 0xfff;
      if (( ( byte )(( uVar3 | 0xfff ) >> 8) & 0x70 ) != 0x40) {
         LAB_00114cc3:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot apply to a block", "component", &_LC1);
      }

      if (param_2[0x22] == (TQualifier)0xff) goto LAB_00114d1b;
   }

   ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot apply to a block", "index", &_LC1);
   LAB_00114d1b:lVar6 = *(long*)( param_3 + 8 );
   if (lVar6 != *(long*)( param_3 + 0x10 )) {
      uVar9 = 0;
      do {
         lVar10 = uVar9 * 0x20;
         pcVar1 = *(code**)( **(long**)( lVar6 + lVar10 ) + 0x50 );
         if (pcVar1 == TType::getQualifier) {
            plVar5 = *(long**)( lVar6 + lVar10 ) + 2;
         }
 else {
            plVar5 = (long*)( *pcVar1 )();
            lVar6 = *(long*)( param_3 + 8 );
         }

         puVar7 = (undefined8*)( lVar6 + lVar10 );
         uVar3 = *(ushort*)( (long)plVar5 + 0x1c ) & 0xfff;
         if (uVar3 == 0xfff) {
            if (0xffe < (int)uVar8) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, puVar7 + 1, "location is too large", "location", &_LC1);
               puVar7 = (undefined8*)( lVar10 + *(long*)( param_3 + 8 ) );
            }

            uVar3 = (ushort)uVar8 & 0xfff;
            uVar2 = *(ushort*)( (long)plVar5 + 0x1c ) & 0xf000 | uVar3;
            *(ushort*)( (long)plVar5 + 0x1c ) = uVar2;
            *(byte*)( (long)plVar5 + 0x1d ) = ( byte )(uVar2 >> 8) & 0x8f | 0x40;
         }

         iVar4 = glslang::TIntermediate::computeTypeLocationSize(*puVar7, *(undefined4*)( this + 0x1c ));
         uVar9 = ( ulong )((int)uVar9 + 1);
         uVar8 = (uint)uVar3 + iVar4;
         lVar6 = *(long*)( param_3 + 8 );
      }
 while ( uVar9 < ( ulong )(*(long*)( param_3 + 0x10 ) - lVar6 >> 5) );
   }

   return;
}
/* glslang::TParseContext::fixXfbOffsets(glslang::TQualifier&, glslang::TVector<glslang::TTypeLoc>&)
    */void glslang::TParseContext::fixXfbOffsets(TParseContext *this, TQualifier *param_1, TVector *param_2) {
   code *pcVar1;
   int iVar2;
   ulong uVar3;
   long *plVar4;
   long lVar5;
   uint uVar6;
   long in_FS_OFFSET;
   bool local_43;
   bool local_42;
   char local_41;
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (( ( ~(byte)param_1[0x24] & 0xf ) != 0 ) && ( ( ~*(ushort *)(param_1 + 0x26) & 0x7ffc ) != 0 )) {
      lVar5 = *(long*)( param_2 + 8 );
      uVar6 = *(ushort*)( param_1 + 0x26 ) >> 2 & 0x1fff;
      if (*(long*)( param_2 + 0x10 ) != lVar5) {
         uVar3 = 0;
         do {
            plVar4 = *(long**)( lVar5 + uVar3 * 0x20 );
            pcVar1 = *(code**)( *plVar4 + 0x50 );
            if (pcVar1 == TType::getQualifier) {
               plVar4 = plVar4 + 2;
            }
 else {
               plVar4 = (long*)( *pcVar1 )();
               lVar5 = *(long*)( param_2 + 8 );
            }

            local_43 = false;
            local_42 = false;
            local_41 = '\0';
            iVar2 = glslang::TIntermediate::computeTypeXfbSize(*(TType**)( this + 0x38 ), *(bool**)( lVar5 + uVar3 * 0x20 ), &local_43, &local_42);
            if (( ~*(ushort *)((long)plVar4 + 0x26) & 0x7ffc ) == 0) {
               if (local_43 == false) {
                  if (local_42 == false) {
                     if (local_41 != '\0') {
                        uVar6 = uVar6 + 1 & 0xfffffffe;
                     }

                  }
 else {
                     uVar6 = uVar6 + 3 & 0xfffffffc;
                  }

               }
 else {
                  uVar6 = uVar6 + 7 & 0xfffffff8;
               }

               *(ushort*)( (long)plVar4 + 0x26 ) = *(ushort*)( (long)plVar4 + 0x26 ) & 0x8003 | ( ushort )(( uVar6 & 0xffff1fff ) << 2);
            }
 else {
               uVar6 = *(ushort*)( (long)plVar4 + 0x26 ) >> 2 & 0x1fff;
            }

            lVar5 = *(long*)( param_2 + 8 );
            uVar6 = uVar6 + iVar2;
            uVar3 = ( ulong )((int)uVar3 + 1);
         }
 while ( uVar3 < ( ulong )(*(long*)( param_2 + 0x10 ) - lVar5 >> 5) );
      }

      *(ushort*)( param_1 + 0x26 ) = *(ushort*)( param_1 + 0x26 ) | 0x7ffc;
   }

   if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::fixBlockUniformOffsets(glslang::TQualifier&,
   glslang::TVector<glslang::TTypeLoc>&) */void glslang::TParseContext::fixBlockUniformOffsets(TParseContext *this, TQualifier *param_1, TVector *param_2) {
   if (( ( ( (byte)param_1[8] & 0x7f ) - 5 < 3 ) || ( ( (byte)param_1[0xd] & 8 ) != 0 ) ) && ( ( ( (byte)param_1[0x10] & 0xe ) == 2 || ( ( (byte)param_1[0x10] & 0xf ) == 5 ) ) )) {
      fixBlockUniformOffsets(this, param_1, param_2);
      return;
   }

   return;
}
/* glslang::TParseContext::invariantCheck(glslang::TSourceLoc const&, glslang::TQualifier const&) */void glslang::TParseContext::invariantCheck(TParseContext *this, TSourceLoc *param_1, TQualifier *param_2) {
   if (( (byte)param_2[0xb] & 0x10 ) != 0) {
      invariantCheck(this, param_1, param_2);
      return;
   }

   return;
}
/* glslang::TParseContext::wrapupSwitchSubsequence(glslang::TIntermAggregate*, TIntermNode*) */void glslang::TParseContext::wrapupSwitchSubsequence(TParseContext *this, TIntermAggregate *param_1, TIntermNode *param_2) {
   int iVar1;
   vector<TIntermNode*,glslang::pool_allocator<TIntermNode*>> *this_00;
   long *plVar2;
   long *plVar3;
   code *pcVar4;
   ulong uVar5;
   long lVar6;
   long lVar7;
   TIntermAggregate *pTVar8;
   TIntermNode *pTVar9;
   undefined8 *puVar10;
   undefined8 *puVar11;
   ulong uVar12;
   long lVar13;
   undefined8 *puVar14;
   long in_FS_OFFSET;
   TIntermAggregate *local_48;
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   this_00 = *(vector<TIntermNode*,glslang::pool_allocator<TIntermNode*>>**)( *(long*)( this + 0x148 ) + 0x10 );
   if (param_1 != (TIntermAggregate*)0x0) {
      if (*(long*)( this_00 + 8 ) == *(long*)( this_00 + 0x10 )) {
         pcVar4 = *(code**)( *(long*)this + 0x158 );
         if ((code*)**(undefined8**)param_1 == TIntermNode::getLoc) {
            pTVar8 = param_1 + 8;
         }
 else {
            pTVar8 = (TIntermAggregate*)( *(code*)**(undefined8**)param_1 )(param_1);
         }

         ( *pcVar4 )(this, pTVar8, "cannot have statements before first case/default label", "switch");
      }

      if (*(code**)( *(long*)param_1 + 0x188 ) == TIntermAggregate::setOperator) {
         *(undefined4*)( param_1 + 0xb8 ) = 1;
      }
 else {
         ( **(code**)( *(long*)param_1 + 0x188 ) )(param_1, 1);
      }

      local_48 = param_1;
      std::vector<TIntermNode*,glslang::pool_allocator<TIntermNode*>>::emplace_back<TIntermNode*>(this_00, (TIntermNode**)&local_48);
   }

   if (param_2 == (TIntermNode*)0x0) goto LAB_0011531d;
   puVar10 = *(undefined8**)( this_00 + 0x10 );
   puVar11 = *(undefined8**)( this_00 + 8 );
   if (puVar10 == puVar11) {
      uVar12 = 0;
      puVar14 = (undefined8*)0x0;
   }
 else {
      uVar5 = 0;
      do {
         lVar6 = ( **(code**)( *(long*)puVar11[uVar5] + 0x68 ) )();
         if (lVar6 != 0) {
            plVar2 = *(long**)( lVar6 + 0x28 );
            lVar6 = ( **(code**)( *(long*)param_2 + 0x68 ) )();
            plVar3 = *(long**)( lVar6 + 0x28 );
            if (plVar3 == (long*)0x0 && plVar2 == (long*)0x0) {
               pcVar4 = *(code**)( *(long*)this + 0x158 );
               pTVar9 = param_2 + 8;
               if ((code*)**(undefined8**)param_2 != TIntermNode::getLoc) {
                  pTVar9 = (TIntermNode*)( *(code*)**(undefined8**)param_2 )(param_2);
               }

               ( *pcVar4 )(this, pTVar9, "duplicate label", "default", &_LC1);
            }
 else if (( ( ( plVar2 != (long*)0x0 ) && ( plVar3 != (long*)0x0 ) ) && ( lVar6 = ( **(code**)( *plVar2 + 0x28 ) )() ),lVar6 != 0 )) {
               lVar6 = ( **(code**)( *plVar2 + 0x28 ) )(plVar2);
               iVar1 = **(int**)( *(long*)( lVar6 + 0xc0 ) + 8 );
               lVar6 = ( **(code**)( *plVar3 + 0x28 ) )();
               if (**(int**)( *(long*)( lVar6 + 0xc0 ) + 8 ) == iVar1) {
                  pcVar4 = *(code**)( *(long*)this + 0x158 );
                  if ((code*)**(undefined8**)param_2 == TIntermNode::getLoc) {
                     pTVar9 = param_2 + 8;
                  }
 else {
                     pTVar9 = (TIntermNode*)( *(code*)**(undefined8**)param_2 )(param_2);
                  }

                  ( *pcVar4 )(this, pTVar9, "duplicated value", &_LC600, &_LC1);
               }

            }

         }

         puVar10 = *(undefined8**)( this_00 + 0x10 );
         puVar11 = *(undefined8**)( this_00 + 8 );
         uVar5 = ( ulong )((int)uVar5 + 1);
         puVar14 = (undefined8*)( (long)puVar10 - (long)puVar11 );
         uVar12 = (long)puVar14 >> 3;
      }
 while ( uVar5 < uVar12 );
   }

   if (puVar10 != *(undefined8**)( this_00 + 0x18 )) {
      *puVar10 = param_2;
      *(undefined8**)( this_00 + 0x10 ) = puVar10 + 1;
      goto LAB_0011531d;
   }

   if (puVar10 == puVar11) {
      lVar6 = uVar12 + 1;
      LAB_001153fb:lVar7 = glslang::TPoolAllocator::allocate(*(ulong*)this_00);
      lVar6 = lVar7 + lVar6 * 8;
      *(TIntermNode**)( lVar7 + (long)puVar14 ) = param_2;
      if (puVar10 != puVar11) goto LAB_001153c1;
      lVar13 = lVar7 + 8;
   }
 else {
      lVar6 = uVar12 * 2;
      if (lVar6 != 0) goto LAB_001153fb;
      *puVar14 = param_2;
      lVar7 = 0;
      lVar6 = 0;
      LAB_001153c1:lVar13 = 0;
      do {
         *(undefined8*)( lVar7 + lVar13 ) = *(undefined8*)( (long)puVar11 + lVar13 );
         lVar13 = lVar13 + 8;
      }
 while ( lVar13 != (long)puVar10 - (long)puVar11 );
      lVar13 = lVar7 + 8 + lVar13;
   }

   *(long*)( this_00 + 8 ) = lVar7;
   *(long*)( this_00 + 0x10 ) = lVar13;
   *(long*)( this_00 + 0x18 ) = lVar6;
   LAB_0011531d:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   return;
}
/* glslang::TParseContext::recordStructCopy(std::map<glslang::TVector<glslang::TTypeLoc> const*,
   std::map<unsigned long, glslang::TVector<glslang::TTypeLoc> const*, std::less<unsigned long>,
   std::allocator<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc> const*> > >,
   std::less<glslang::TVector<glslang::TTypeLoc> const*>,
   std::allocator<std::pair<glslang::TVector<glslang::TTypeLoc> const* const, std::map<unsigned
   long, glslang::TVector<glslang::TTypeLoc> const*, std::less<unsigned long>,
   std::allocator<std::pair<unsigned long const, glslang::TVector<glslang::TTypeLoc> const*> > > > >
   >&, glslang::TType const*, glslang::TType const*) */ulong glslang::TParseContext::recordStructCopy(TParseContext *this, map *param_1, TType *param_2, TType *param_3) {
   byte bVar1;
   long lVar2;
   long lVar3;
   long lVar4;
   ulong uVar5;
   long lVar6;
   long *plVar7;
   map *pmVar8;
   map *pmVar9;
   map *pmVar10;
   map *pmVar11;
   map *pmVar12;
   map *pmVar13;
   map *pmVar14;
   long lVar15;
   uint uVar16;
   uint uVar17;
   ulong uVar18;
   ulong uVar19;
   long in_FS_OFFSET;
   bool bVar20;
   ulong local_90;
   ulong local_88;
   ulong *local_80;
   ulong *local_78;
   undefined4 local_70[2];
   long local_68;
   undefined4 *local_60;
   undefined4 *local_58;
   undefined8 local_50;
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   lVar2 = *(long*)( *(long*)( param_3 + 0x68 ) + 0x10 );
   lVar3 = *(long*)( *(long*)( param_3 + 0x68 ) + 8 );
   local_90 = 0;
   if (lVar3 == lVar2) {
      uVar18 = *(ulong*)( param_2 + 0x68 );
      goto LAB_001156f4;
   }

   uVar18 = 0;
   uVar19 = 0;
   do {
      lVar4 = *(long*)( *(long*)( param_2 + 0x68 ) + 8 );
      if (( ulong )(*(long*)( *(long*)( param_2 + 0x68 ) + 0x10 ) - lVar4 >> 5) <= uVar18) {
         LAB_00115a08:std::__throw_out_of_range_fmt("vector::_M_range_check: __n (which is %zu) >= this->size() (which is %zu)", uVar18);
         goto LAB_00115a19;
      }

      lVar15 = uVar18 * 0x20;
      plVar7 = *(long**)( lVar4 + lVar15 );
      if (*(code**)( *plVar7 + 0x50 ) == TType::getQualifier) {
         uVar16 = ( uint ) * (byte*)( plVar7 + 4 );
         LAB_001154e7:plVar7 = plVar7 + 2;
      }
 else {
         lVar6 = ( **(code**)( *plVar7 + 0x50 ) )();
         lVar4 = *(long*)( *(long*)( param_2 + 0x68 ) + 8 );
         uVar16 = ( uint ) * (byte*)( lVar6 + 0x10 );
         if (( ulong )(*(long*)( *(long*)( param_2 + 0x68 ) + 0x10 ) - lVar4 >> 5) <= uVar18) goto LAB_00115a08;
         plVar7 = *(long**)( lVar4 + lVar15 );
         if (*(code**)( *plVar7 + 0x50 ) == TType::getQualifier) goto LAB_001154e7;
         plVar7 = (long*)( **(code**)( *plVar7 + 0x50 ) )();
      }

      bVar1 = *(byte*)( (long)plVar7 + 0xf );
      lVar4 = *(long*)( *(long*)( param_3 + 0x68 ) + 8 );
      if (( ulong )(*(long*)( *(long*)( param_3 + 0x68 ) + 0x10 ) - lVar4 >> 5) <= uVar18) goto LAB_00115a08;
      plVar7 = *(long**)( lVar4 + lVar15 );
      if (*(code**)( *plVar7 + 0x50 ) == TType::getQualifier) {
         uVar17 = *(byte*)( plVar7 + 4 ) & 0xf;
         LAB_00115533:plVar7 = plVar7 + 2;
      }
 else {
         lVar6 = ( **(code**)( *plVar7 + 0x50 ) )();
         lVar4 = *(long*)( *(long*)( param_3 + 0x68 ) + 8 );
         uVar17 = *(byte*)( lVar6 + 0x10 ) & 0xf;
         if (( ulong )(*(long*)( *(long*)( param_3 + 0x68 ) + 0x10 ) - lVar4 >> 5) <= uVar18) goto LAB_00115a08;
         plVar7 = *(long**)( lVar4 + lVar15 );
         if (*(code**)( *plVar7 + 0x50 ) == TType::getQualifier) goto LAB_00115533;
         plVar7 = (long*)( **(code**)( *plVar7 + 0x50 ) )();
      }

      uVar18 = uVar18 + 1;
      uVar19 = ( (long)(int)( ( bVar1 >> 4 & 7 ) + ( uVar16 & 0xf ) ) ^ uVar19 ) * 2;
      local_90 = ( (long)(int)( ( *(byte*)( (long)plVar7 + 0xf ) >> 4 & 7 ) + uVar17 ) ^ local_90 ) * 2;
   }
 while ( uVar18 < ( ulong )(lVar2 - lVar3 >> 5) );
   local_88 = *(ulong*)( param_2 + 0x68 );
   uVar5 = *(ulong*)( param_3 + 0x68 );
   uVar18 = local_88;
   if (uVar19 == local_90) goto LAB_001156f4;
   pmVar9 = *(map**)( param_1 + 0x10 );
   pmVar10 = param_1 + 8;
   pmVar11 = pmVar9;
   pmVar14 = pmVar10;
   pmVar8 = pmVar10;
   pmVar12 = pmVar10;
   if (pmVar9 == (map*)0x0) {
      LAB_001157f5:local_60 = local_70;
      local_50 = 0;
      local_68 = 0;
      local_70[0] = 0;
      local_80 = &local_88;
      local_58 = local_60;
      pmVar8 = (map*)std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>const*,std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator < std::pair < unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>> > std::less<glslang::TVector<glslang::TTypeLoc>const*>,std::allocator<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less < unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>> >> ::_M_emplace_hint_unique<std::piecewise_construct_t_const&,std::tuple<glslang::TVector<glslang::TTypeLoc>const*const&>,std::tuple<>>(param_1, pmVar8, &local_80);
      LAB_00115814:std::_Rb_tree<unsigned_long,std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>,std::_Select1st<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>::_M_erase(*(_Rb_tree_node**)( pmVar8 + 0x38 ));
      pmVar9 = pmVar8 + 0x30;
      *(undefined8*)( pmVar8 + 0x38 ) = 0;
      *(map**)( pmVar8 + 0x40 ) = pmVar9;
      *(map**)( pmVar8 + 0x48 ) = pmVar9;
      *(undefined8*)( pmVar8 + 0x50 ) = 0;
      if (local_68 != 0) {
         *(undefined4*)( pmVar8 + 0x30 ) = local_70[0];
         *(long*)( pmVar8 + 0x38 ) = local_68;
         *(undefined4**)( pmVar8 + 0x40 ) = local_60;
         *(undefined4**)( pmVar8 + 0x48 ) = local_58;
         *(map**)( local_68 + 8 ) = pmVar9;
         *(undefined8*)( pmVar8 + 0x50 ) = local_50;
         local_68 = 0;
         local_50 = 0;
         local_60 = local_70;
         local_58 = local_70;
      }

      std::_Rb_tree<unsigned_long,std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>,std::_Select1st<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>::_M_erase((_Rb_tree_node*)0x0);
      pmVar9 = *(map**)( param_1 + 0x10 );
      if (pmVar9 == (map*)0x0) {
         LAB_001159d1:local_78 = &local_88;
         pmVar12 = (map*)std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>const*,std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator < std::pair < unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>> > std::less<glslang::TVector<glslang::TTypeLoc>const*>,std::allocator<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less < unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>> >> ::_M_emplace_hint_unique<std::piecewise_construct_t_const&,std::tuple<glslang::TVector<glslang::TTypeLoc>const*const&>,std::tuple<>>(param_1, pmVar10, &local_78);
      }
 else {
         do {
            pmVar11 = *(map**)( pmVar9 + 0x18 );
            if (local_88 <= *(ulong*)( pmVar9 + 0x20 )) {
               pmVar11 = *(map**)( pmVar9 + 0x10 );
               pmVar12 = pmVar9;
            }

            pmVar9 = pmVar11;
         }
 while ( pmVar11 != (map*)0x0 );
         bVar20 = pmVar10 == pmVar12;
         pmVar10 = pmVar12;
         if (( bVar20 ) || ( local_88 < *(ulong*)( pmVar12 + 0x20 ) )) goto LAB_001159d1;
      }

      pmVar9 = *(map**)( pmVar12 + 0x38 );
      pmVar10 = pmVar12 + 0x30;
      pmVar11 = pmVar10;
      if (pmVar9 != (map*)0x0) {
         do {
            pmVar14 = *(map**)( pmVar9 + 0x18 );
            if (local_90 <= *(ulong*)( pmVar9 + 0x20 )) {
               pmVar11 = pmVar9;
               pmVar14 = *(map**)( pmVar9 + 0x10 );
            }

            pmVar9 = pmVar14;
         }
 while ( pmVar14 != (map*)0x0 );
         bVar20 = pmVar11 != pmVar10;
         pmVar10 = pmVar11;
         if (bVar20) goto LAB_00115923;
      }

      goto LAB_00115929;
   }

   do {
      while (true) {
         pmVar13 = pmVar11;
         if (*(ulong*)( pmVar13 + 0x20 ) < local_88) break;
         pmVar11 = *(map**)( pmVar13 + 0x10 );
         pmVar14 = pmVar13;
         if (*(map**)( pmVar13 + 0x10 ) == (map*)0x0) goto LAB_001156b1;
      }
;
      pmVar11 = *(map**)( pmVar13 + 0x18 );
   }
 while ( *(map**)( pmVar13 + 0x18 ) != (map*)0x0 );
   LAB_001156b1:if (( pmVar14 == pmVar10 ) || ( local_88 < *(ulong*)( pmVar14 + 0x20 ) )) {
      local_60 = local_70;
      local_70[0] = 0;
      local_68 = 0;
      local_50 = 0;
      do {
         pmVar11 = *(map**)( pmVar9 + 0x18 );
         if (local_88 <= *(ulong*)( pmVar9 + 0x20 )) {
            pmVar11 = *(map**)( pmVar9 + 0x10 );
            pmVar8 = pmVar9;
         }

         pmVar9 = pmVar11;
      }
 while ( pmVar11 != (map*)0x0 );
      if (( pmVar10 == pmVar8 ) || ( local_58 = local_60 ),local_88 < *(ulong*)( pmVar8 + 0x20 )) goto LAB_001157f5;
      goto LAB_00115814;
   }

   pmVar11 = *(map**)( pmVar14 + 0x38 );
   pmVar8 = pmVar14 + 0x30;
   if (*(map**)( pmVar14 + 0x38 ) != (map*)0x0) {
      do {
         while (true) {
            pmVar13 = pmVar11;
            if (*(ulong*)( pmVar13 + 0x20 ) < local_90) break;
            pmVar11 = *(map**)( pmVar13 + 0x10 );
            pmVar8 = pmVar13;
            if (*(map**)( pmVar13 + 0x10 ) == (map*)0x0) goto LAB_00115781;
         }
;
         pmVar11 = *(map**)( pmVar13 + 0x18 );
      }
 while ( *(map**)( pmVar13 + 0x18 ) != (map*)0x0 );
      LAB_00115781:if (( pmVar14 + 0x30 != pmVar8 ) && ( *(ulong*)( pmVar8 + 0x20 ) <= local_90 )) {
         uVar18 = *(ulong*)( pmVar8 + 0x28 );
         goto LAB_001156f4;
      }

   }

   do {
      pmVar11 = *(map**)( pmVar9 + 0x18 );
      if (local_88 <= *(ulong*)( pmVar9 + 0x20 )) {
         pmVar12 = pmVar9;
         pmVar11 = *(map**)( pmVar9 + 0x10 );
      }

      pmVar9 = pmVar11;
   }
 while ( pmVar11 != (map*)0x0 );
   if (( pmVar10 == pmVar12 ) || ( local_88 < *(ulong*)( pmVar12 + 0x20 ) )) {
      local_78 = &local_88;
      pmVar12 = (map*)std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>const*,std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less<unsigned_long>,std::allocator < std::pair < unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>> > std::less<glslang::TVector<glslang::TTypeLoc>const*>,std::allocator<std::pair<glslang::TVector<glslang::TTypeLoc>const*const,std::map<unsigned_long,glslang::TVector<glslang::TTypeLoc>const*,std::less < unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>> >> ::_M_emplace_hint_unique<std::piecewise_construct_t_const&,std::tuple<glslang::TVector<glslang::TTypeLoc>const*const&>,std::tuple<>>(param_1, pmVar12, &local_78);
   }

   pmVar9 = *(map**)( pmVar12 + 0x38 );
   pmVar10 = pmVar12 + 0x30;
   pmVar11 = pmVar10;
   if (pmVar9 == (map*)0x0) {
      LAB_00115929:local_78 = &local_90;
      pmVar11 = (map*)std::_Rb_tree<unsigned_long,std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>,std::_Select1st<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>,std::less<unsigned_long>,std::allocator<std::pair<unsigned_long_const,glslang::TVector<glslang::TTypeLoc>const*>>>::_M_emplace_hint_unique<std::piecewise_construct_t_const&,std::tuple<unsigned_long_const&>,std::tuple<>>(pmVar12 + 0x28, pmVar10, &local_78);
   }
 else {
      do {
         pmVar14 = *(map**)( pmVar9 + 0x18 );
         if (local_90 <= *(ulong*)( pmVar9 + 0x20 )) {
            pmVar11 = pmVar9;
            pmVar14 = *(map**)( pmVar9 + 0x10 );
         }

         pmVar9 = pmVar14;
      }
 while ( pmVar14 != (map*)0x0 );
      bVar20 = pmVar10 == pmVar11;
      pmVar10 = pmVar11;
      if (bVar20) goto LAB_00115929;
      LAB_00115923:pmVar10 = pmVar11;
      if (local_90 < *(ulong*)( pmVar11 + 0x20 )) goto LAB_00115929;
   }

   *(ulong*)( pmVar11 + 0x28 ) = uVar5;
   uVar18 = uVar5;
   LAB_001156f4:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return uVar18;
   }

   LAB_00115a19:/* WARNING: Subroutine does not return */__stack_chk_fail();
}
/* glslang::TParseContext::mapLegacyLayoutFormat(glslang::TLayoutFormat, glslang::TBasicType) */undefined4 glslang::TParseContext::mapLegacyLayoutFormat(undefined8 param_1, int param_2, int param_3) {
   if (param_3 == 1) {
      if (param_2 - 0x31U < 4) {
         return *(undefined4*)( CSWTCH_3765 + ( ulong )(param_2 - 0x31U) * 4 );
      }

   }
 else if (param_3 == 9) {
      if (param_2 - 0x30U < 5) {
         return *(undefined4*)( CSWTCH_3766 + ( ulong )(param_2 - 0x30U) * 4 );
      }

   }
 else if (( param_3 == 8 ) && ( param_2 - 0x30U < 5 )) {
      return *(undefined4*)( CSWTCH_3767 + ( ulong )(param_2 - 0x30U) * 4 );
   }

   return 0;
}
/* glslang::TParseContext::globalQualifierFixCheck(glslang::TSourceLoc const&, glslang::TQualifier&,
   bool, glslang::TPublicType const*) */void glslang::TParseContext::globalQualifierFixCheck(TParseContext *this, TSourceLoc *param_1, TQualifier *param_2, bool param_3, TPublicType *param_4) {
   long lVar1;
   TQualifier TVar2;
   int iVar3;
   iVar3 = (int)param_1;
   switch ((byte)param_2[8] & 0x7f) {
      case 0:
      case 1:
    goto switchD_00115ac4_caseD_0;
      case 5:
    if ((*(long *)(this + 0x508) == 0) && (((byte)param_2[0x10] & 0xf) == 3)) {
      (**(code **)(*(long *)this + 0x28))
                (this,param_1,1,&E_GL_EXT_scalar_block_layout,"default std430 layout for uniform");
    }
    if ((((param_4 != (TPublicType *)0x0) && (*(int *)param_4 == 0xe)) &&
        (((byte)param_4[6] & 8) != 0)) &&
       ((1 < (byte)((char)param_4[5] - 7U) && ((byte)((char)param_2[0x2c] - 0x30U) < 5)))) {
      TVar2 = (TQualifier)mapLegacyLayoutFormat(this,param_2[0x2c],param_4[4]);
      param_2[0x2c] = TVar2;
    }
    break;
      case 0x10:
    glslang::TParseVersions::profileRequires((TSourceLoc *)this,iVar3,1,(char *)0x82,(char *)0x0);
    glslang::TParseVersions::profileRequires((TSourceLoc *)this,iVar3,8,(char *)0x12c,(char *)0x0);
    param_2[8] = (TQualifier)((byte)param_2[8] & 0x80 | 3);
    TVar2 = param_2[0xf];
    if (((byte)TVar2 & 4) == 0) goto LAB_00115b62;
    goto LAB_00115b36;
      case 0x11:
    glslang::TParseVersions::profileRequires((TSourceLoc *)this,iVar3,1,(char *)0x82,(char *)0x0);
    glslang::TParseVersions::profileRequires((TSourceLoc *)this,iVar3,8,(char *)0x12c,(char *)0x0);
    param_2[8] = (TQualifier)((byte)param_2[8] & 0x80 | 4);
    if (*(char *)(*(long *)(this + 0x38) + 0x272) != '\0') {
      param_2[0xb] = (TQualifier)((byte)param_2[0xb] | 0x10);
    }
    break;
      case 0x12:
    lVar1 = *(long *)this;
    param_2[8] = (TQualifier)((byte)param_2[8] & 0x80 | 3);
    (**(code **)(lVar1 + 0x158))(this,param_1,"cannot use \'inout\' at global scope",&_LC1);
   }

   if (( (byte)param_2[0xc] & 2 ) != 0) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "for non-parameter, can only apply to \'in\' or no storage qualifier", "nonuniformEXT", &_LC1);
   }

   switchD_00115ac4_caseD_0:TVar2 = param_2[0xf];
   if (( (byte)TVar2 & 4 ) != 0) {
      LAB_00115b36:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to parameter", "spirv_by_reference", &_LC1);
      TVar2 = param_2[0xf];
   }

   LAB_00115b62:if (( (byte)TVar2 & 8 ) != 0) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to parameter", "spirv_literal", &_LC1);
   }

   if (( ( !param_3 ) || ( 0 < *(int*)( this + 0x118 ) ) ) && ( ( (byte)param_2[0xb] & 0x10 ) != 0 )) {
      invariantCheck(this, param_1, param_2);
   }

   if (param_2[0x39] != (TQualifier)0x0) {
      if (( (byte)param_2[8] & 0x7f ) != 3) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to input layout", "full_quads ", &_LC1);
      }

      *(undefined1*)( *(long*)( this + 0x38 ) + 0x5c5 ) = 1;
   }

   if (param_2[0x3a] != (TQualifier)0x0) {
      if (( (byte)param_2[8] & 0x7f ) != 3) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to input layout", "quad_derivatives", &_LC1);
      }

      *(undefined1*)( *(long*)( this + 0x38 ) + 0x5c4 ) = 1;
   }

   return;
}
/* glslang::TParseContext::memberQualifierCheck(glslang::TPublicType&) */void glslang::TParseContext::memberQualifierCheck(TParseContext *this, TPublicType *param_1) {
   TSourceLoc *pTVar1;
   pTVar1 = (TSourceLoc*)( param_1 + 0xd0 );
   globalQualifierFixCheck(this, pTVar1, (TQualifier*)( param_1 + 8 ), true, (TPublicType*)0x0);
   checkNoShaderLayouts(this, pTVar1, (TShaderQualifiers*)( param_1 + 0x58 ));
   if (( (byte)param_1[0x14] & 2 ) != 0) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, pTVar1, "not allowed on block or structure members", "nonuniformEXT", &_LC1);
      param_1[0x14] = ( TPublicType )((byte)param_1[0x14] & 0xfd);
   }

   return;
}
/* glslang::TParseContext::globalQualifierTypeCheck(glslang::TSourceLoc const&, glslang::TQualifier
   const&, glslang::TPublicType const&) */void glslang::TParseContext::globalQualifierTypeCheck(TParseContext *this, TSourceLoc *param_1, TQualifier *param_2, TPublicType *param_3) {
   TQualifier TVar1;
   TQualifier TVar2;
   long *plVar3;
   byte bVar4;
   char cVar5;
   uint uVar6;
   int iVar7;
   undefined8 uVar8;
   long lVar9;
   long lVar10;
   char *pcVar11;
   char *pcVar12;
   int iVar13;
   TQualifier TVar14;
   code *UNRECOVERED_JUMPTABLE;
   TType *pTVar15;
   if (4 < (int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 )) {
      return;
   }

   plVar3 = *(long**)( param_3 + 200 );
   iVar13 = (int)param_1;
   if (plVar3 == (long*)0x0) {
      LAB_00115e85:if (this[0x1c1] != (TParseContext)0x0) goto LAB_00115ee0;
      TVar14 = param_2[0xe];
      if (-1 < (char)TVar14) {
         if (( ( ( ( ( (byte)TVar14 & 0x40 ) != 0 ) || ( ( (byte)TVar14 & 0x20 ) != 0 ) ) || ( ( (byte)TVar14 & 0x10 ) != 0 ) ) || ( ( ( (byte)TVar14 & 8 ) != 0 || ( ( (byte)TVar14 & 2 ) != 0 ) ) ) ) || ( ( ( ( (byte)TVar14 & 4 ) != 0 || ( ( ( (byte)param_2[0xd] & 0x40 ) != 0 || ( (char)param_2[0xd] < '\0' ) ) ) ) || ( ( (byte)TVar14 & 1 ) != 0 ) ) )) {
            if (*(int*)param_3 == 0xe) {
               if (( (byte)param_3[6] & 8 ) == 0) {
                  if (( (byte)param_3[0x10] & 0x7f ) != 6) goto LAB_00115eb9;
               }
 else if (( byte )((char)param_3[5] - 7U) < 2) goto LAB_00116872;
               LAB_0011688c:if (( (byte)TVar14 & 0x40 ) != 0) goto LAB_00116400;
            }
 else {
               if (( (byte)param_3[0x10] & 0x7f ) != 6) goto LAB_00115eb9;
               if (( (byte)TVar14 & 0x40 ) != 0) goto LAB_001161f8;
            }

            if (( (byte)TVar14 & 0x20 ) != 0) goto LAB_00116400;
         }

         if (( ( ( ( (byte)TVar14 & 0x10 ) != 0 ) || ( ( (byte)TVar14 & 8 ) != 0 ) ) || ( ( (byte)TVar14 & 2 ) != 0 ) ) || ( ( ( ( (byte)TVar14 & 4 ) != 0 || ( ( (byte)param_2[0xd] & 0x40 ) != 0 ) ) || ( ( (char)param_2[0xd] < '\0' || ( ( ( (byte)TVar14 & 1 ) != 0 || ( ( (byte)param_2[0xf] & 1 ) != 0 ) ) ) ) ) ) )) goto LAB_00116400;
         goto LAB_00115ee0;
      }

      if (*(int*)param_3 != 0xe) {
         if (( (byte)param_3[0x10] & 0x7f ) == 6) goto LAB_001161f8;
         LAB_00115eb9:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "memory qualifiers cannot be used on this type", &_LC1);
         goto LAB_00115ee0;
      }

      if (( (byte)param_3[6] & 8 ) == 0) {
         if (( (byte)param_3[0x10] & 0x7f ) != 6) goto LAB_00115eb9;
      }
 else if (( byte )((char)param_3[5] - 7U) < 2) {
         LAB_00116872:if (( (byte)param_3[0x10] & 0x7f ) != 6) goto LAB_00115eb9;
         if (-1 < (char)TVar14) goto LAB_0011688c;
      }

      LAB_00116400:if (*(int*)param_3 != 0xe) {
         LAB_001161f8:if (( (byte)param_3[0x10] & 0x7f ) - 5 < 2) goto LAB_00115ee0;
         goto LAB_00115eb9;
      }

      TVar14 = param_2[8];
      bVar4 = (byte)TVar14 & 0x7f;
      if (bVar4 == 6) goto LAB_001160fb;
      LAB_00115ef1:if (bVar4 != 3) goto LAB_00115ef5;
   }
 else {
      if (*(code**)( *plVar3 + 0x38 ) == TType::getBasicType) {
         uVar6 = ( uint ) * (byte*)( plVar3 + 1 );
      }
 else {
         uVar6 = ( **(code**)( *plVar3 + 0x38 ) )();
      }

      if (uVar6 != 0x12) goto LAB_00115e85;
      LAB_00115ee0:TVar14 = param_2[8];
      bVar4 = (byte)TVar14 & 0x7f;
      if (bVar4 != 6) goto LAB_00115ef1;
      if (*(int*)param_3 == 0x10) {
         return;
      }

      LAB_001160fb:if (param_2[0x2e] == (TQualifier)0x0) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "buffers can be declared only as blocks", "buffer");
         TVar14 = param_2[8];
         bVar4 = (byte)TVar14 & 0x7f;
         goto LAB_00115ef1;
      }

      LAB_00115ef5:if (*(int*)param_3 == 2) {
         cVar5 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_ARB_vertex_attrib_64bit");
         if (( ( cVar5 != '\0' ) && ( *(int*)( this + 0x1c ) == 0 ) ) && ( *(int*)( this + 0x18 ) < 400 )) {
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 6, (char*)0x19a, "GL_ARB_gpu_shader_fp64");
         }

         TVar14 = param_2[8];
      }

      if (1 < ( byte )(( (byte)TVar14 & 0x7f ) - 3)) {
         return;
      }

   }

   if (param_3[0xa0] == (TPublicType)0x0) {
      uVar6 = *(uint*)param_3;
      if (uVar6 == 0xc) goto LAB_00116174;
      LAB_00115f3c:if (uVar6 < 0xb) {
         if (( ( ( 0x550UL >> ( (ulong)uVar6 & 0x3f ) & 1 ) != 0 ) || ( ( 0xaa0UL >> ( (ulong)uVar6 & 0x3f ) & 1 ) != 0 ) ) || ( uVar6 == 2 )) {
            LAB_00115f54:glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 8, (char*)0x12c, (char*)0x0);
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, -9, (char*)0x82, (char*)0x0);
         }

      }
 else if (uVar6 < 0xc) goto LAB_00115f54;
   }
 else {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be applied to a standalone \'out\'", "blend equation");
      uVar6 = *(uint*)param_3;
      if (uVar6 != 0xc) goto LAB_00115f3c;
      LAB_00116174:if (this[0x1c1] == (TParseContext)0x0) {
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         uVar8 = GetStorageQualifierString((byte)param_2[8] & 0x7f);
         /* WARNING: Could not recover jumptable at 0x001161c1. Too many branches */
         /* WARNING: Treating indirect jump as call */
         ( *UNRECOVERED_JUMPTABLE )(this, param_1, "cannot be bool", uVar8, &_LC1);
         return;
      }

   }

   TVar14 = param_2[0xb];
   if ((char)TVar14 < '\0') {
      bVar4 = (byte)param_2[0xd] & 0x10;
      joined_r0x0011624c:if (bVar4 != 0) goto LAB_00116020;
      LAB_00116047:if (( (byte)param_2[8] & 0x7f ) != 0xf) {
         LAB_00116056:TVar14 = param_2[0xd];
         goto LAB_0011605a;
      }

      if (*(int*)param_3 == 0x10) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "taskPayloadSharedEXT variables should not be declared as interface blocks", "taskPayloadSharedEXT");
         goto LAB_00116056;
      }

      if (( (byte)param_2[0xd] & 8 ) != 0) goto LAB_00116066;
      uVar6 = *(uint*)( this + 0x1c );
   }
 else {
      if (( ( ( (byte)param_2[0xc] & 0x40 ) != 0 ) || ( (char)param_2[0xc] < '\0' ) ) || ( ( (byte)param_2[0xd] & 1 ) != 0 )) {
         LAB_00116218:if (( (byte)param_2[0xd] & 0x10 ) == 0) goto LAB_00116047;
         LAB_00116221:if (( ( (byte)TVar14 & 0x40 ) == 0 ) && ( ( (byte)param_2[0xc] & 0x20 ) == 0 )) {
            bVar4 = (byte)param_2[0xc] & 0x40;
            goto joined_r0x0011624c;
         }

         LAB_00116020:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot use interpolation qualifiers with patch", "patch");
         goto LAB_00116047;
      }

      uVar6 = *(uint*)param_3;
      if (10 < uVar6) {
         if (uVar6 < 0xc) goto LAB_00115fdd;
         LAB_001169fb:pTVar15 = *(TType**)( param_3 + 200 );
         if (pTVar15 == (TType*)0x0) goto LAB_00116218;
         lVar9 = *(long*)pTVar15;
         if (*(code**)( lVar9 + 400 ) == TType::containsBasicType) {
            if (pTVar15[8] == (TType)0x8) goto LAB_00115fdd;
            if (*(code**)( lVar9 + 0x128 ) != TType::isStruct) {
               cVar5 = ( **(code**)( lVar9 + 0x128 ) )(pTVar15);
               if (cVar5 == '\0') goto LAB_00116bfd;
               LAB_00116bdb:lVar9 = *(long*)( *(long*)( pTVar15 + 0x68 ) + 0x10 );
               lVar10 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( pTVar15 + 0x68 ) + 8 ),lVar9,8 ));
               if (lVar9 != lVar10) goto LAB_00115fdd;
               goto LAB_00116bfd;
            }

            if (( byte )((char)pTVar15[8] - 0xfU) < 2) goto LAB_00116bdb;
            LAB_00116a57:if (pTVar15[8] == (TType)0x9) goto LAB_00115fdd;
            if (*(code**)( lVar9 + 0x128 ) != TType::isStruct) {
               cVar5 = ( **(code**)( lVar9 + 0x128 ) )(pTVar15);
               if (cVar5 == '\0') goto LAB_00116c2a;
               LAB_00116c54:lVar9 = *(long*)( *(long*)( pTVar15 + 0x68 ) + 0x10 );
               lVar10 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( pTVar15 + 0x68 ) + 8 ),lVar9,9 ));
               if (lVar9 != lVar10) goto LAB_00115fdd;
               goto LAB_00116c2a;
            }

            if (( byte )((char)pTVar15[8] - 0xfU) < 2) goto LAB_00116c54;
         }
 else {
            cVar5 = ( **(code**)( lVar9 + 400 ) )(pTVar15, 8);
            if (cVar5 != '\0') goto LAB_00115fdd;
            LAB_00116bfd:pTVar15 = *(TType**)( param_3 + 200 );
            lVar9 = *(long*)pTVar15;
            if (*(code**)( lVar9 + 400 ) == TType::containsBasicType) goto LAB_00116a57;
            cVar5 = ( **(code**)( lVar9 + 400 ) )(pTVar15, 9);
            if (cVar5 != '\0') goto LAB_00115fdd;
            LAB_00116c2a:pTVar15 = *(TType**)( param_3 + 200 );
         }

         cVar5 = TType::contains16BitInt(pTVar15);
         if (( ( cVar5 != '\0' ) || ( cVar5 = TType::contains8BitInt(*(TType**)( param_3 + 200 )) ),cVar5 != '\0' )) goto LAB_00115fdd;
         LAB_001169a8:if (( (byte)param_2[0xd] & 0x10 ) == 0) goto LAB_00116047;
         LAB_0011600b:TVar14 = param_2[0xb];
         if (-1 < (char)TVar14) goto LAB_00116221;
         goto LAB_00116020;
      }

      if (( ( ( 0x550UL >> ( (ulong)uVar6 & 0x3f ) & 1 ) == 0 ) && ( ( 0xaa0UL >> ( (ulong)uVar6 & 0x3f ) & 1 ) == 0 ) ) && ( uVar6 != 2 )) goto LAB_001169fb;
      LAB_00115fdd:if (( (byte)param_2[8] & 0x7f ) == 3) {
         if (*(int*)( this + 0x1c ) == 4) {
            uVar8 = 3;
            UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
            LAB_0011697f:GetStorageQualifierString(uVar8);
            uVar8 = TType::getBasicString(*(undefined4*)param_3);
            ( *UNRECOVERED_JUMPTABLE )(this, param_1, "must be qualified as flat", uVar8);
            goto LAB_001169a8;
         }

      }
 else {
         if (( (byte)param_2[8] & 0x7f ) != 4) goto LAB_001169a8;
         if (*(long*)( this + 0x18 ) == 300) {
            uVar8 = 4;
            UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
            goto LAB_0011697f;
         }

      }

      TVar14 = param_2[0xd];
      if (( (byte)TVar14 & 0x10 ) != 0) goto LAB_0011600b;
      LAB_0011605a:if (( ( (byte)TVar14 & 8 ) != 0 ) && ( *(int*)param_3 != 0x10 )) {
         LAB_00116066:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "taskNV variables can be declared only as blocks", "taskNV");
      }

      uVar6 = *(uint*)( this + 0x1c );
      if (( (byte)param_2[8] & 0x7f ) == 3) {
         if (uVar6 != 4) {
            if (uVar6 < 5) {
               if (uVar6 != 0) {
                  if (uVar6 != 1) {
                     return;
                  }

                  if (( (byte)param_2[0xd] & 0x10 ) == 0) {
                     return;
                  }

                  pcVar11 = "patch";
                  pcVar12 = "can only use on output in tessellation-control shader";
                  UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                  goto LAB_00116368;
               }

               iVar7 = *(int*)param_3;
               if (iVar7 != 0xf) {
                  if (*(long*)( param_3 + 0xc0 ) != 0) {
                     glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar13, (char*)0xfffffff7);
                     glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 1, (char*)0x96, (char*)0x0);
                     iVar7 = *(int*)param_3;
                  }

                  if (iVar7 == 2) {
                     glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, -9, (char*)0x19a, "GL_ARB_vertex_attrib_64bit");
                  }

                  TVar14 = param_2[0xb];
                  if (( ( ( ( ( ( (byte)TVar14 & 0x20 ) == 0 ) && ( TVar2 = param_2[0xd]((byte)TVar2 & 0x10) == 0 ) ) && ( ( (byte)TVar2 & 0x20 ) == 0 ) ) && ( ( TVar1 = param_2[0xc] ),-1 < (char)TVar1 && ( ( (byte)TVar2 & 1 ) == 0 ) ) ) ) && ( -1 < (char)TVar14 )) &&( ( ( ( (byte)TVar14 & 0x40 ) == 0 && ( ( (byte)TVar1 & 0x20 ) == 0 ) ) && ( ( ( (byte)TVar1 & 0x40 ) == 0 && ( ( cVar5 = TQualifier::isMemory(param_2) ),cVar5 == '\0' && ( ( (byte)TVar14 & 0x10 ) == 0 ) ) ) ) ) );
               }

               pcVar11 = "";
               pcVar12 = "vertex input cannot be further qualified";
               UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
               goto LAB_00116368;
            }

            UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
            uVar8 = GetStorageQualifierString((byte)param_2[8] & 0x7f);
            pcVar11 = "cannot be a structure";
            goto LAB_001166d7;
         }

         if (uVar6 != 5) {
            return;
         }

         if ((int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 ) < 4) {
            return;
         }

         pcVar11 = "in";
         pcVar12 = "global storage input qualifier cannot be used in a compute shader";
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         goto LAB_00116368;
      }

      if (*(long*)( param_3 + 200 ) == 0) {
         return;
      }

      glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 8, (char*)0x12c, (char*)0x0);
      glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, -9, (char*)0x96, (char*)0x0);
      pTVar15 = *(TType**)( param_3 + 200 );
      if (*(code**)( *(long*)pTVar15 + 0x1a0 ) == TType::containsStructure) {
         cVar5 = TType::contains<glslang::TType::containsStructure()const::_lambda(glslang::TType_const*)_1_>(pTVar15, pTVar15);
      }
 else {
         cVar5 = ( **(code**)( *(long*)pTVar15 + 0x1a0 ) )();
      }

      if (cVar5 != '\0') {
         glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar13, (char*)0xfffffff7);
      }

      if (*(code**)( **(long**)( param_3 + 200 ) + 0x198 ) == TType::containsArray) {
         cVar5 = TType::contains<glslang::TType::containsArray()const::_lambda(glslang::TType_const*)_1_>();
      }
 else {
         cVar5 = ( **(code**)( **(long**)( param_3 + 200 ) + 0x198 ) )();
      }

      if (cVar5 == '\0') {
         return;
      }

      goto LAB_001165d1;
   }

}
if (uVar6 == 4) {
   glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 8, (char*)0x12c, (char*)0x0);
   if (*(int*)param_3 == 0xf) {
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
      uVar8 = GetStorageQualifierString((byte)param_2[8] & 0x7f);
      pcVar11 = "cannot be a structure";
   }
 else if (( (byte)param_3[0xb9] & 0xf ) == 0) {
      TVar14 = param_2[0xb];
      if (( ( ( ( (byte)TVar14 & 0x20 ) != 0 ) || ( TVar2 = param_2[0xd]((byte)TVar2 & 0x10) != 0 ) ) || ( ( (byte)TVar2 & 0x20 ) != 0 ) ) || ( ( (char)param_2[0xc] < '\0' || ( ( (byte)TVar2 & 1 ) != 0 ) ) )) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can\'t use auxiliary qualifier on a fragment output", "centroid/sample/patch", &_LC1);
         TVar14 = param_2[0xb];
      }

      if (( ( (char)TVar14 < '\0' ) || ( ( (byte)TVar14 & 0x40 ) != 0 ) ) || ( ( ( (byte)param_2[0xc] & 0x20 ) != 0 || ( ( (byte)param_2[0xc] & 0x40 ) != 0 ) ) )) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can\'t use interpolation qualifier on a fragment output", "flat/smooth/noperspective", &_LC1);
      }

      if (( 1 < *(int*)param_3 - 10U ) && ( *(int*)param_3 != 2 )) {
         return;
      }

      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
      uVar8 = GetStorageQualifierString((byte)param_2[8] & 0x7f);
      pcVar11 = "cannot contain a double, int64, or uint64";
   }
 else {
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
      uVar8 = GetStorageQualifierString((byte)param_2[8] & 0x7f);
      pcVar11 = "cannot be a matrix";
   }

   LAB_001166d7:/* WARNING: Could not recover jumptable at 0x001166e5. Too many branches *//* WARNING: Treating indirect jump as call */( *UNRECOVERED_JUMPTABLE )(this, param_1, pcVar11, uVar8, &_LC1);
   return;
}
if (4 < uVar6) {
   if (uVar6 != 5) {
      return;
   }

   pcVar11 = "out";
   pcVar12 = "global storage output qualifier cannot be used in a compute shader";
   UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
   LAB_00116368:/* WARNING: Could not recover jumptable at 0x0011637e. Too many branches *//* WARNING: Treating indirect jump as call */( *UNRECOVERED_JUMPTABLE )(this, param_1, pcVar12, pcVar11, &_LC1, UNRECOVERED_JUMPTABLE);
   return;
}
if (uVar6 != 0) {
   if (uVar6 != 2) {
      return;
   }

   if (( (byte)param_2[0xd] & 0x10 ) == 0) {
      return;
   }

   pcVar11 = "patch";
   pcVar12 = "can only use on input in tessellation-evaluation shader";
   UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
   goto LAB_00116368;
}
if (*(long*)( param_3 + 200 ) == 0) {
   return;
}
glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 8, (char*)0x12c, (char*)0x0);glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, -9, (char*)0x96, (char*)0x0);plVar3 = *(long**)( param_3 + 200 );lVar9 = *plVar3;if (*(code**)( lVar9 + 0x1a0 ) == TType::containsStructure) {
   if (*(code**)( lVar9 + 0x128 ) != TType::isStruct) {
      cVar5 = ( **(code**)( lVar9 + 0x128 ) )();
      if (cVar5 == '\0') goto LAB_00116956;
      LAB_00116b44:lVar9 = *(long*)( plVar3[0xd] + 0x10 );
      lVar10 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsStructure()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsStructure ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar3[0xd] + 8 ),lVar9,plVar3 ));
      if (lVar9 != lVar10) goto LAB_0011693f;
      goto LAB_00116956;
   }

   if (( byte )((char)plVar3[1] - 0xfU) < 2) goto LAB_00116b44;
}
 else {
   cVar5 = ( **(code**)( lVar9 + 0x1a0 ) )();
   if (cVar5 != '\0') {
      LAB_0011693f:glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar13, (char*)0xfffffff7);
   }

   LAB_00116956:lVar9 = **(long**)( param_3 + 200 );
}
if (*(code**)( lVar9 + 0x198 ) == TType::containsArray) {
   cVar5 = TType::contains<glslang::TType::containsArray()const::_lambda(glslang::TType_const*)_1_>();
}
 else {
   cVar5 = ( **(code**)( lVar9 + 0x198 ) )();
}
if (cVar5 == '\0') {
   return;
}
LAB_001165d1:glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar13, (char*)0xfffffff7);return;}/* __gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >
   std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSampler()
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsSampler()
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>
   >(__gnu_cxx::__normal_iterator<glslang::TTypeLoc*, std::vector<glslang::TTypeLoc,
   glslang::pool_allocator<glslang::TTypeLoc> > >, __gnu_cxx::__normal_iterator<glslang::TTypeLoc*,
   std::vector<glslang::TTypeLoc, glslang::pool_allocator<glslang::TTypeLoc> > >,
   __gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSampler()
   const::{lambda(glslang::TType const*)#1}>(glslang::TType::containsSampler()
   const::{lambda(glslang::TType const*)#1}) const::{lambda(glslang::TTypeLoc const&)#1}>,
   std::random_access_iterator_tag) [clone .isra.0] */long *std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSampler()const::_lambda(glslang::TType_const*)_1_>(glslang::TType::containsSampler()const::_lambda(glslang::TType_const*)_1_)const::_lambda(glslang::TTypeLoc_const&)_1_>(long *param_1, long *param_2) {
   long *plVar1;
   long *plVar2;
   char cVar3;
   byte bVar4;
   bool bVar5;
   code *pcVar6;
   long lVar7;
   long *plVar8;
   long lVar9;
   lVar9 = (long)param_2 - (long)param_1;
   if (0 < lVar9 >> 7) {
      plVar1 = param_1 + ( lVar9 >> 7 ) * 0x10;
      do {
         plVar2 = (long*)*param_1;
         lVar9 = *plVar2;
         if (*(code**)( lVar9 + 0x168 ) == glslang::TType::isTexture) {
            if ((char)plVar2[1] == '\x0e') {
               if (*(code**)( lVar9 + 0x40 ) == glslang::TType::getSampler) {
                  plVar8 = plVar2 + 0x10;
               }
 else {
                  plVar8 = (long*)( **(code**)( lVar9 + 0x40 ) )(plVar2);
               }

               if (( *(byte*)( (long)plVar8 + 2 ) & 0x20 ) == 0) {
                  bVar4 = *(byte*)( (long)plVar8 + 2 ) & 8;
                  goto joined_r0x00117117;
               }

               goto LAB_00117120;
            }

            pcVar6 = *(code**)( lVar9 + 0x158 );
            if (pcVar6 != glslang::TType::isImage) goto LAB_001171d0;
         }
 else {
            bVar4 = ( **(code**)( lVar9 + 0x168 ) )(plVar2);
            joined_r0x00117117:if (bVar4 != 0) {
               return param_1;
            }

            LAB_00117120:lVar9 = *plVar2;
            pcVar6 = *(code**)( lVar9 + 0x158 );
            if (pcVar6 == glslang::TType::isImage) {
               if ((char)plVar2[1] != '\x0e') goto LAB_00116d20;
               if (*(code**)( lVar9 + 0x40 ) == glslang::TType::getSampler) {
                  plVar8 = plVar2 + 0x10;
               }
 else {
                  plVar8 = (long*)( **(code**)( lVar9 + 0x40 ) )(plVar2);
               }

               if (( ( *plVar8 & 0x80000 ) != 0 ) && ( 1 < ( byte )(*(char*)( (long)plVar8 + 1 ) - 7U) )) {
                  return param_1;
               }

            }
 else {
               LAB_001171d0:cVar3 = ( *pcVar6 )(plVar2);
               if (cVar3 != '\0') {
                  return param_1;
               }

            }

            lVar9 = *plVar2;
         }

         LAB_00116d20:if (*(code**)( lVar9 + 0x128 ) == glslang::TType::isStruct) {
            if (( byte )((char)plVar2[1] - 0xfU) < 2) {
               LAB_001170e5:lVar9 = *(long*)( plVar2[0xd] + 0x10 );
               lVar7 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSampler()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsSampler ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar2[0xd] + 8 ),lVar9 ));
               if (lVar9 != lVar7) {
                  return param_1;
               }

            }

         }
 else {
            cVar3 = ( **(code**)( lVar9 + 0x128 ) )(plVar2);
            if (cVar3 != '\0') goto LAB_001170e5;
         }

         plVar2 = (long*)param_1[4];
         lVar9 = *plVar2;
         if (*(code**)( lVar9 + 0x168 ) == glslang::TType::isTexture) {
            if ((char)plVar2[1] == '\x0e') {
               if (*(code**)( lVar9 + 0x40 ) == glslang::TType::getSampler) {
                  plVar8 = plVar2 + 0x10;
               }
 else {
                  plVar8 = (long*)( **(code**)( lVar9 + 0x40 ) )(plVar2);
               }

               if (( ( *plVar8 & 0x200000 ) == 0 ) && ( ( *plVar8 & 0x80000 ) == 0 )) goto LAB_00116f5a;
               goto LAB_00116ed4;
            }

            pcVar6 = *(code**)( lVar9 + 0x158 );
            if (pcVar6 == glslang::TType::isImage) goto LAB_00116d73;
            LAB_001171e0:cVar3 = ( *pcVar6 )(plVar2);
            if (cVar3 != '\0') {
               return param_1 + 4;
            }

            LAB_00116f18:pcVar6 = *(code**)( *plVar2 + 0x128 );
            if (pcVar6 != glslang::TType::isStruct) goto LAB_00116f30;
            LAB_00116d83:if (( byte )((char)plVar2[1] - 0xfU) < 2) goto LAB_00116f3d;
         }
 else {
            cVar3 = ( **(code**)( lVar9 + 0x168 ) )(plVar2);
            if (cVar3 != '\0') {
               return param_1 + 4;
            }

            LAB_00116ed4:lVar9 = *plVar2;
            pcVar6 = *(code**)( lVar9 + 0x158 );
            if (pcVar6 != glslang::TType::isImage) goto LAB_001171e0;
            if ((char)plVar2[1] == '\x0e') {
               if (*(code**)( lVar9 + 0x40 ) == glslang::TType::getSampler) {
                  plVar8 = plVar2 + 0x10;
               }
 else {
                  plVar8 = (long*)( **(code**)( lVar9 + 0x40 ) )(plVar2);
               }

               if (( ( *plVar8 & 0x80000 ) != 0 ) && ( 1 < ( byte )(*(char*)( (long)plVar8 + 1 ) - 7U) )) goto LAB_00116f5a;
               goto LAB_00116f18;
            }

            LAB_00116d73:pcVar6 = *(code**)( lVar9 + 0x128 );
            if (pcVar6 == glslang::TType::isStruct) goto LAB_00116d83;
            LAB_00116f30:cVar3 = ( *pcVar6 )(plVar2);
            if (cVar3 != '\0') {
               LAB_00116f3d:lVar9 = *(long*)( plVar2[0xd] + 0x10 );
               lVar7 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSampler()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsSampler ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar2[0xd] + 8 ),lVar9 ));
               if (lVar9 != lVar7) {
                  LAB_00116f5a:return param_1 + 4;
               }

            }

         }

         plVar2 = (long*)param_1[8];
         lVar9 = *plVar2;
         if (*(code**)( lVar9 + 0x168 ) == glslang::TType::isTexture) {
            if ((char)plVar2[1] == '\x0e') {
               if (*(code**)( lVar9 + 0x40 ) == glslang::TType::getSampler) {
                  plVar8 = plVar2 + 0x10;
               }
 else {
                  plVar8 = (long*)( **(code**)( lVar9 + 0x40 ) )(plVar2);
               }

               if (( ( *plVar8 & 0x200000 ) == 0 ) && ( ( *plVar8 & 0x80000 ) == 0 )) goto LAB_00117012;
               goto LAB_00116f8c;
            }

            pcVar6 = *(code**)( lVar9 + 0x158 );
            if (pcVar6 == glslang::TType::isImage) goto LAB_00116dc6;
            LAB_00117200:cVar3 = ( *pcVar6 )(plVar2);
            if (cVar3 != '\0') {
               return param_1 + 8;
            }

            LAB_00116fd0:pcVar6 = *(code**)( *plVar2 + 0x128 );
            if (pcVar6 != glslang::TType::isStruct) goto LAB_00116fe8;
            LAB_00116dd6:if (( byte )((char)plVar2[1] - 0xfU) < 2) goto LAB_00116ff5;
         }
 else {
            cVar3 = ( **(code**)( lVar9 + 0x168 ) )(plVar2);
            if (cVar3 != '\0') {
               return param_1 + 8;
            }

            LAB_00116f8c:lVar9 = *plVar2;
            pcVar6 = *(code**)( lVar9 + 0x158 );
            if (pcVar6 != glslang::TType::isImage) goto LAB_00117200;
            if ((char)plVar2[1] == '\x0e') {
               if (*(code**)( lVar9 + 0x40 ) == glslang::TType::getSampler) {
                  plVar8 = plVar2 + 0x10;
               }
 else {
                  plVar8 = (long*)( **(code**)( lVar9 + 0x40 ) )(plVar2);
               }

               if (( ( *plVar8 & 0x80000 ) != 0 ) && ( 1 < ( byte )(*(char*)( (long)plVar8 + 1 ) - 7U) )) goto LAB_00117012;
               goto LAB_00116fd0;
            }

            LAB_00116dc6:pcVar6 = *(code**)( lVar9 + 0x128 );
            if (pcVar6 == glslang::TType::isStruct) goto LAB_00116dd6;
            LAB_00116fe8:cVar3 = ( *pcVar6 )(plVar2);
            if (cVar3 != '\0') {
               LAB_00116ff5:lVar9 = *(long*)( plVar2[0xd] + 0x10 );
               lVar7 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSampler()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsSampler ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar2[0xd] + 8 ),lVar9 ));
               if (lVar9 != lVar7) {
                  LAB_00117012:return param_1 + 8;
               }

            }

         }

         plVar2 = (long*)param_1[0xc];
         lVar9 = *plVar2;
         if (*(code**)( lVar9 + 0x168 ) == glslang::TType::isTexture) {
            if ((char)plVar2[1] == '\x0e') {
               if (*(code**)( lVar9 + 0x40 ) == glslang::TType::getSampler) {
                  plVar8 = plVar2 + 0x10;
               }
 else {
                  plVar8 = (long*)( **(code**)( lVar9 + 0x40 ) )(plVar2);
               }

               if (( ( *plVar8 & 0x200000 ) == 0 ) && ( ( *plVar8 & 0x80000 ) == 0 )) goto LAB_001170ca;
               goto LAB_00117044;
            }

            pcVar6 = *(code**)( lVar9 + 0x158 );
            if (pcVar6 == glslang::TType::isImage) goto LAB_00116e19;
            LAB_00117220:cVar3 = ( *pcVar6 )(plVar2);
            if (cVar3 != '\0') {
               return param_1 + 0xc;
            }

            LAB_00117088:pcVar6 = *(code**)( *plVar2 + 0x128 );
            if (pcVar6 != glslang::TType::isStruct) goto LAB_001170a0;
            LAB_00116e29:if (( byte )((char)plVar2[1] - 0xfU) < 2) goto LAB_001170ad;
         }
 else {
            cVar3 = ( **(code**)( lVar9 + 0x168 ) )(plVar2);
            if (cVar3 != '\0') {
               return param_1 + 0xc;
            }

            LAB_00117044:lVar9 = *plVar2;
            pcVar6 = *(code**)( lVar9 + 0x158 );
            if (pcVar6 != glslang::TType::isImage) goto LAB_00117220;
            if ((char)plVar2[1] == '\x0e') {
               if (*(code**)( lVar9 + 0x40 ) == glslang::TType::getSampler) {
                  plVar8 = plVar2 + 0x10;
               }
 else {
                  plVar8 = (long*)( **(code**)( lVar9 + 0x40 ) )(plVar2);
               }

               if (( ( *plVar8 & 0x80000 ) != 0 ) && ( 1 < ( byte )(*(char*)( (long)plVar8 + 1 ) - 7U) )) goto LAB_001170ca;
               goto LAB_00117088;
            }

            LAB_00116e19:pcVar6 = *(code**)( lVar9 + 0x128 );
            if (pcVar6 == glslang::TType::isStruct) goto LAB_00116e29;
            LAB_001170a0:cVar3 = ( *pcVar6 )(plVar2);
            if (cVar3 != '\0') {
               LAB_001170ad:lVar9 = *(long*)( plVar2[0xd] + 0x10 );
               lVar7 = __find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSampler()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsSampler ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar2[0xd] + 8 ),lVar9 ));
               if (lVar9 != lVar7) {
                  LAB_001170ca:return param_1 + 0xc;
               }

            }

         }

         param_1 = param_1 + 0x10;
      }
 while ( param_1 != plVar1 );
      lVar9 = (long)param_2 - (long)param_1;
   }

   lVar9 = lVar9 >> 5;
   if (lVar9 != 2) {
      if (lVar9 != 3) {
         if (lVar9 != 1) {
            return param_2;
         }

         goto LAB_00117310;
      }

      bVar5 = glslang::TType::contains<glslang::TType::containsSampler()const::_lambda(glslang::TType_const*)_1_>(*param_1);
      if (bVar5) {
         return param_1;
      }

      param_1 = param_1 + 4;
   }

   bVar5 = glslang::TType::contains<glslang::TType::containsSampler()const::_lambda(glslang::TType_const*)_1_>(*param_1);
   if (bVar5) {
      return param_1;
   }

   param_1 = param_1 + 4;
   LAB_00117310:bVar5 = glslang::TType::contains<glslang::TType::containsSampler()const::_lambda(glslang::TType_const*)_1_>(*param_1);
   if (!bVar5) {
      return param_2;
   }

   return param_1;
}
/* glslang::TParseContext::handleFunctionDeclarator(glslang::TSourceLoc const&, glslang::TFunction&,
   bool) */TFunction * __thiscall
glslang::TParseContext::handleFunctionDeclarator
          (TParseContext *this,TSourceLoc *param_1,TFunction *param_2,bool param_3){
   size_t __n;
   char cVar1;
   byte bVar2;
   int iVar3;
   int iVar4;
   long lVar5;
   long *plVar6;
   long lVar7;
   long *plVar8;
   code *pcVar9;
   TFunction *pTVar10;
   TType *this_00;
   char *pcVar11;
   TSymbolTable *pTVar12;
   ulong uVar13;
   long in_FS_OFFSET;
   long *local_68;
   bool local_41;
   long local_40;
   pTVar12 = *(TSymbolTable**)( this + 0xe8 );
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   iVar4 = (int)param_1;
   if (4 < (int)( *(long*)( pTVar12 + 8 ) - *(long*)pTVar12 >> 3 )) {
      glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar4, (char*)0xfffffff7);
      pTVar12 = *(TSymbolTable**)( this + 0xe8 );
   }

   if (*(code**)( *(long*)param_2 + 0x30 ) == TFunction::getMangledName_abi_cxx11_) {
      pTVar10 = param_2 + 0xe8;
   }
 else {
      pTVar10 = (TFunction*)( **(code**)( *(long*)param_2 + 0x30 ) )(param_2);
   }

   local_68 = (long*)TSymbolTable::find(pTVar12, (basic_string*)pTVar10, &local_41, (bool*)0x0, (int*)0x0);
   if (( ( local_68 != (long*)0x0 ) && ( lVar5 = ( **(code**)( *local_68 + 0x38 ) )(local_68) ),lVar5 != 0 )) {
      glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar4, (char*)0xfffffff7);
   }

   lVar5 = *(long*)param_2;
   uVar13 = 0;
   while (true) {
      if (*(code**)( lVar5 + 0x120 ) == TFunction::getParamCount) {
         iVar3 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
      }
 else {
         iVar3 = ( **(code**)( lVar5 + 0x120 ) )(param_2);
      }

      if (iVar3 <= (int)uVar13) break;
      if (*(code**)( *(long*)param_2 + 0x138 ) == TFunction::operator []) {
         lVar5 = *(long*)( param_2 + 0x30 ) + uVar13 * 0x18;
      }
 else {
         lVar5 = ( **(code**)( *(long*)param_2 + 0x138 ) )(param_2, uVar13 & 0xffffffff);
      }

      pcVar9 = *(code**)( **(long**)( lVar5 + 8 ) + 0x50 );
      if (pcVar9 == TType::getQualifier) {
         plVar6 = *(long**)( lVar5 + 8 ) + 2;
      }
 else {
         plVar6 = (long*)( *pcVar9 )();
      }

      lVar5 = *(long*)param_2;
      if (( *(byte*)( (long)plVar6 + 0xf ) & 8 ) != 0) {
         if (*(code**)( lVar5 + 0xd8 ) == TFunction::getBuiltInOp) {
            iVar3 = *(int*)( param_2 + 0x110 );
         }
 else {
            iVar3 = ( **(code**)( lVar5 + 0xd8 ) )(param_2);
            lVar5 = *(long*)param_2;
         }

         if (iVar3 != 7) {
            pcVar9 = *(code**)( *(long*)this + 0x158 );
            if (*(code**)( lVar5 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
               lVar5 = *(long*)( param_2 + 8 );
            }
 else {
               lVar5 = ( **(code**)( lVar5 + 0x18 ) )(param_2);
            }

            ( *pcVar9 )(this, param_1, "\'spirv_literal\' can only be used on functions defined with \'spirv_instruction\' for argument", *(undefined8*)( lVar5 + 8 ), &_LC524, (int)uVar13 + 1);
            lVar5 = *(long*)param_2;
         }

      }

      uVar13 = uVar13 + 1;
   }
;
   if (local_68 == (long*)0x0) {
      LAB_001177f8:plVar6 = (long*)0x0;
      local_68 = (long*)0x0;
   }
 else {
      if (local_41 != false) {
         if (*(code**)( *(long*)param_2 + 0xd8 ) == TFunction::getBuiltInOp) {
            iVar3 = *(int*)( param_2 + 0x110 );
         }
 else {
            iVar3 = ( **(code**)( *(long*)param_2 + 0xd8 ) )(param_2);
         }

         if (iVar3 == 7) goto LAB_001177f8;
      }

      plVar6 = (long*)( **(code**)( *local_68 + 0x38 ) )();
      if (plVar6 != (long*)0x0) {
         if (*(code**)( *plVar6 + 0xf8 ) == TFunction::isPrototyped) {
            cVar1 = *(char*)( (long)plVar6 + 0x115 );
         }
 else {
            cVar1 = ( **(code**)( *plVar6 + 0xf8 ) )(plVar6);
         }

         if (( cVar1 != '\0' ) && ( param_3 )) {
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar4, 8, (char*)0x12c, (char*)0x0);
         }

         if (*(code**)( *(long*)param_2 + 0x60 ) == TFunction::getType) {
            pTVar10 = param_2 + 0x48;
         }
 else {
            pTVar10 = (TFunction*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
         }

         if (*(code**)( *plVar6 + 0x60 ) == TFunction::getType) {
            this_00 = (TType*)( plVar6 + 9 );
         }
 else {
            this_00 = (TType*)( **(code**)( *plVar6 + 0x60 ) )(plVar6);
         }

         cVar1 = TType::operator ==(this_00, (TType*)pTVar10);
         if (cVar1 == '\0') {
            pcVar9 = *(code**)( *(long*)this + 0x158 );
            if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
               lVar5 = *(long*)( param_2 + 8 );
            }
 else {
               lVar5 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
            }

            ( *pcVar9 )(this, param_1, "overloaded functions must have the same return type", *(undefined8*)( lVar5 + 8 ), &_LC1);
         }

         if (*(code**)( *(long*)param_2 + 0x150 ) == TFunction::getSpirvInstruction) {
            pTVar10 = param_2 + 0x120;
         }
 else {
            pTVar10 = (TFunction*)( **(code**)( *(long*)param_2 + 0x150 ) )(param_2);
         }

         if (*(code**)( *plVar6 + 0x150 ) == TFunction::getSpirvInstruction) {
            plVar8 = plVar6 + 0x24;
         }
 else {
            plVar8 = (long*)( **(code**)( *plVar6 + 0x150 ) )(plVar6);
         }

         __n = plVar8[2];
         if (( ( __n != *(size_t*)( pTVar10 + 0x10 ) ) || ( ( __n != 0 && ( iVar4 = memcmp((void*)plVar8[1], *(void**)( pTVar10 + 8 ), __n) ),iVar4 != 0 ) ) )) {
            pcVar9 = *(code**)( *(long*)this + 0x158 );
            if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
               lVar5 = *(long*)( param_2 + 8 );
            }
 else {
               lVar5 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
            }

            ( *pcVar9 )(this, param_1, "overloaded functions must have the same qualifiers", *(undefined8*)( lVar5 + 8 ), "spirv_instruction");
         }

         lVar5 = 0;
         iVar4 = 0;
         while (true) {
            if (*(code**)( *plVar6 + 0x120 ) == TFunction::getParamCount) {
               iVar3 = (int)( plVar6[7] - plVar6[6] >> 3 ) * -0x55555555;
            }
 else {
               iVar3 = ( **(code**)( *plVar6 + 0x120 ) )(plVar6);
            }

            if (iVar3 <= iVar4) break;
            if (*(code**)( *plVar6 + 0x140 ) == TFunction::operator []) {
               plVar8 = *(long**)( plVar6[6] + lVar5 + 8 );
               pcVar9 = *(code**)( *plVar8 + 0x50 );
               if (pcVar9 == TType::getQualifier) goto LAB_001176fc;
               LAB_00117ac4:plVar8 = (long*)( *pcVar9 )();
            }
 else {
               lVar7 = ( **(code**)( *plVar6 + 0x140 ) )(plVar6, iVar4);
               plVar8 = *(long**)( lVar7 + 8 );
               pcVar9 = *(code**)( *plVar8 + 0x50 );
               if (pcVar9 != TType::getQualifier) goto LAB_00117ac4;
               LAB_001176fc:plVar8 = plVar8 + 2;
            }

            bVar2 = *(byte*)( plVar8 + 1 );
            if (*(code**)( *(long*)param_2 + 0x138 ) == TFunction::operator []) {
               lVar7 = *(long*)( param_2 + 0x30 ) + lVar5;
            }
 else {
               lVar7 = ( **(code**)( *(long*)param_2 + 0x138 ) )(param_2, iVar4);
            }

            pcVar9 = *(code**)( **(long**)( lVar7 + 8 ) + 0x50 );
            if (pcVar9 == TType::getQualifier) {
               plVar8 = *(long**)( lVar7 + 8 ) + 2;
            }
 else {
               plVar8 = (long*)( *pcVar9 )();
            }

            iVar3 = iVar4 + 1;
            if (( ( bVar2 ^ *(byte*)( plVar8 + 1 ) ) & 0x7f ) != 0) {
               pcVar9 = *(code**)( *(long*)this + 0x158 );
               if (*(code**)( *(long*)param_2 + 0x138 ) == TFunction::operator []) {
                  lVar7 = *(long*)( param_2 + 0x30 ) + lVar5;
               }
 else {
                  lVar7 = ( **(code**)( *(long*)param_2 + 0x138 ) )(param_2, iVar4);
               }

               switch (*(byte*)( *(long*)( lVar7 + 8 ) + 0x18 ) & 0x7f) {
                  case 0:
            pcVar11 = "temp";
            break;
                  case 1:
            pcVar11 = "global";
            break;
                  case 2:
            pcVar11 = "const";
            break;
                  case 3:
                  case 0x10:
            pcVar11 = "in";
            break;
                  case 4:
                  case 0x11:
            pcVar11 = "out";
            break;
                  case 5:
            pcVar11 = "uniform";
            break;
                  case 6:
            pcVar11 = "buffer";
            break;
                  case 7:
            pcVar11 = "shared";
            break;
                  case 8:
            pcVar11 = "spirv_storage_class";
            break;
                  case 9:
            pcVar11 = "rayPayloadNV";
            break;
                  case 10:
            pcVar11 = "rayPayloadInNV";
            break;
                  case 0xb:
            pcVar11 = "hitAttributeNV";
            break;
                  case 0xc:
            pcVar11 = "callableDataNV";
            break;
                  case 0xd:
            pcVar11 = "callableDataInNV";
            break;
                  case 0xe:
            pcVar11 = "hitObjectAttributeNV";
            break;
                  case 0xf:
            pcVar11 = "taskPayloadSharedEXT";
            break;
                  case 0x12:
            pcVar11 = "inout";
            break;
                  case 0x13:
            pcVar11 = "const (read only)";
            break;
                  case 0x14:
            pcVar11 = "gl_VertexId";
            break;
                  case 0x15:
            pcVar11 = "gl_InstanceId";
            break;
                  case 0x16:
            pcVar11 = "gl_Position";
            break;
                  case 0x17:
            pcVar11 = "gl_PointSize";
            break;
                  case 0x18:
            pcVar11 = "gl_ClipVertex";
            break;
                  case 0x19:
            pcVar11 = "gl_FrontFacing";
            break;
                  case 0x1a:
            pcVar11 = "gl_FragCoord";
            break;
                  case 0x1b:
            pcVar11 = "gl_PointCoord";
            break;
                  case 0x1c:
            pcVar11 = "fragColor";
            break;
                  case 0x1d:
            pcVar11 = "gl_FragDepth";
            break;
                  case 0x1e:
            pcVar11 = "gl_FragStencilRefARB";
            break;
                  default:
            pcVar11 = "unknown qualifier";
               }

               ( *pcVar9 )(this, param_1, "overloaded functions must have the same parameter storage qualifiers for argument", pcVar11, &_LC524, iVar3);
            }

            if (*(code**)( *plVar6 + 0x140 ) == TFunction::operator []) {
               lVar7 = plVar6[6] + lVar5;
            }
 else {
               lVar7 = ( **(code**)( *plVar6 + 0x140 ) )(plVar6, iVar4);
            }

            pcVar9 = *(code**)( **(long**)( lVar7 + 8 ) + 0x50 );
            if (pcVar9 == TType::getQualifier) {
               plVar8 = *(long**)( lVar7 + 8 ) + 2;
            }
 else {
               plVar8 = (long*)( *pcVar9 )();
            }

            bVar2 = *(byte*)( (long)plVar8 + 0xb );
            if (*(code**)( *(long*)param_2 + 0x138 ) == TFunction::operator []) {
               lVar7 = *(long*)( param_2 + 0x30 ) + lVar5;
            }
 else {
               lVar7 = ( **(code**)( *(long*)param_2 + 0x138 ) )(param_2, iVar4);
            }

            pcVar9 = *(code**)( **(long**)( lVar7 + 8 ) + 0x50 );
            if (pcVar9 == TType::getQualifier) {
               plVar8 = *(long**)( lVar7 + 8 ) + 2;
            }
 else {
               plVar8 = (long*)( *pcVar9 )();
            }

            if (( ( bVar2 ^ *(byte*)( (long)plVar8 + 0xb ) ) & 0xe ) != 0) {
               pcVar9 = *(code**)( *(long*)this + 0x158 );
               if (*(code**)( *(long*)param_2 + 0x138 ) == TFunction::operator []) {
                  lVar7 = *(long*)( param_2 + 0x30 ) + lVar5;
               }
 else {
                  lVar7 = ( **(code**)( *(long*)param_2 + 0x138 ) )(param_2, iVar4);
               }

               pcVar11 = "mediump";
               bVar2 = *(byte*)( *(long*)( lVar7 + 8 ) + 0x1b ) >> 1 & 7;
               if (bVar2 != 2) {
                  if (bVar2 < 3) {
                     pcVar11 = "";
                     if (bVar2 != 0) {
                        pcVar11 = "lowp";
                     }

                  }
 else {
                     pcVar11 = "highp";
                     if (bVar2 != 3) {
                        pcVar11 = "unknown precision qualifier";
                     }

                  }

               }

               ( *pcVar9 )(this, param_1, "overloaded functions must have the same parameter precision qualifiers for argument", pcVar11, &_LC524, iVar3);
            }

            lVar5 = lVar5 + 0x18;
            iVar4 = iVar3;
         }
;
      }

   }

   if (*(code**)( *(long*)param_2 + 0x60 ) == TFunction::getType) {
      pTVar10 = param_2 + 0x48;
   }
 else {
      pTVar10 = (TFunction*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
   }

   arrayObjectCheck((TSourceLoc*)this, (TType*)param_1, (char*)pTVar10);
   pTVar12 = *(TSymbolTable**)( this + 0xe8 );
   if (param_3) {
      if ((int)( *(long*)( pTVar12 + 8 ) - *(long*)pTVar12 >> 3 ) < 4) {
         pcVar9 = *(code**)( *(long*)param_2 + 0xe0 );
         if (pcVar9 == TFunction::setDefined) {
            param_2[0x114] = (TFunction)0x1;
            goto LAB_00117880;
         }

      }
 else {
         if (( plVar6 != (long*)0x0 ) && ( local_41 == false )) {
            plVar6 = (long*)( **(code**)( *local_68 + 0x38 ) )();
            if (*(code**)( *plVar6 + 0xf0 ) == TFunction::setPrototyped) {
               *(undefined1*)( (long)plVar6 + 0x115 ) = 1;
            }
 else {
               ( **(code**)( *plVar6 + 0xf0 ) )(plVar6);
            }

         }

         pcVar9 = *(code**)( *(long*)param_2 + 0xf0 );
         if (pcVar9 == TFunction::setPrototyped) {
            param_2[0x115] = (TFunction)0x1;
            pTVar12 = *(TSymbolTable**)( this + 0xe8 );
            goto LAB_00117880;
         }

      }

      ( *pcVar9 )(param_2);
      pTVar12 = *(TSymbolTable**)( this + 0xe8 );
   }

   LAB_00117880:cVar1 = TSymbolTable::insert(pTVar12, (TSymbol*)param_2);
   if (cVar1 == '\0') {
      pcVar9 = *(code**)( *(long*)this + 0x158 );
      if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
         lVar5 = *(long*)( param_2 + 8 );
      }
 else {
         lVar5 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
      }

      ( *pcVar9 )(this, param_1, "function name is redeclaration of existing name", *(undefined8*)( lVar5 + 8 ), &_LC1);
   }

   if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return param_2;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::declareNonArray(glslang::TSourceLoc const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const&,
   glslang::TType const&) */TSymbol * __thiscall
glslang::TParseContext::declareNonArray
          (TParseContext *this,TSourceLoc *param_1,basic_string *param_2,TType *param_3){
   TSymbol TVar1;
   TType TVar2;
   undefined4 uVar3;
   undefined8 uVar4;
   code *pcVar5;
   undefined8 uVar6;
   char cVar7;
   ulong uVar8;
   TSymbol *pTVar9;
   long lVar10;
   byte bVar11;
   byte bVar12;
   uVar8 = glslang::GetThreadPoolAllocator();
   pTVar9 = (TSymbol*)glslang::TPoolAllocator::allocate(uVar8);
   *(basic_string**)( pTVar9 + 8 ) = param_2;
   *(undefined8*)( pTVar9 + 0x10 ) = 0;
   *(undefined8*)( pTVar9 + 0x18 ) = 0;
   pTVar9[0x20] = (TSymbol)0x1;
   *(code**)pTVar9 = std::_Hash_bytes;
   *(undefined***)( pTVar9 + 0x28 ) = &PTR__TType_00167f00;
   *(uint*)( pTVar9 + 0xa8 ) = *(uint*)( pTVar9 + 0xa8 ) & 0x9fc00000;
   pTVar9[0x48] = ( TSymbol )((byte)pTVar9[0x48] & 0xf0);
   *(undefined1(*) [16])( pTVar9 + 0xb0 ) = (undefined1[16])0x0;
   *(uint*)( pTVar9 + 0x30 ) = CONCAT22((short)( ( uint ) * (undefined4*)( pTVar9 + 0x30 ) >> 0x10 ), 0x100) & 0xf800ffff;
   *(undefined1(*) [16])( pTVar9 + 0x88 ) = (undefined1[16])0x0;
   *(ulong*)( pTVar9 + 0x55 ) = *(ulong*)( pTVar9 + 0x55 ) & 0xffffff0000ffc07f | 0xffff001f80;
   *(undefined1(*) [16])( pTVar9 + 0x98 ) = (undefined1[16])0x0;
   *(ulong*)( pTVar9 + 0x60 ) = CONCAT71(( uint7 )(( ulong ) * (undefined8*)( pTVar9 + 0x60 ) >> 8) & 0xffffffff, 0xff);
   *(undefined8*)( pTVar9 + 0x6c ) = 0xfffff800;
   *(undefined2*)( pTVar9 + 0x80 ) = 0;
   *(undefined8*)( pTVar9 + 0x38 ) = 0;
   *(ulong*)( pTVar9 + 0x54 ) = *(ulong*)( pTVar9 + 0x54 ) & 0xffffffff8000 | 0xffff000000004fff;
   *(undefined8*)( pTVar9 + 0x4c ) = 0xffffffffffffffff;
   *(ulong*)( pTVar9 + 0x5c ) = *(ulong*)( pTVar9 + 0x5c ) | 0x1ffff007fffffff;
   pTVar9[0x68] = (TSymbol)0x0;
   pTVar9[100] = (TSymbol)0x0;
   *(undefined4*)( pTVar9 + 0x74 ) = 0xffffffff;
   *(undefined8*)( pTVar9 + 0x78 ) = 0;
   *(ulong*)( pTVar9 + 0x40 ) = *(ulong*)( pTVar9 + 0x40 ) & 0x8000000400000000;
   uVar4 = *(undefined8*)( param_3 + 0x10 );
   uVar6 = *(undefined8*)( param_3 + 0x18 );
   TVar1 = *(TSymbol*)( param_3 + 8 );
   *(undefined***)( pTVar9 + 200 ) = &PTR__TConstUnionArray_001680e8;
   uVar3 = *(undefined4*)( param_3 + 0x80 );
   *(undefined8*)( pTVar9 + 0x38 ) = uVar4;
   *(undefined8*)( pTVar9 + 0x40 ) = uVar6;
   uVar4 = *(undefined8*)( param_3 + 0x20 );
   uVar6 = *(undefined8*)( param_3 + 0x28 );
   pTVar9[0x30] = TVar1;
   *(undefined8*)( pTVar9 + 0x48 ) = uVar4;
   *(undefined8*)( pTVar9 + 0x50 ) = uVar6;
   uVar4 = *(undefined8*)( param_3 + 0x30 );
   uVar6 = *(undefined8*)( param_3 + 0x38 );
   *(undefined4*)( pTVar9 + 0xa8 ) = uVar3;
   *(undefined8*)( pTVar9 + 0x58 ) = uVar4;
   *(undefined8*)( pTVar9 + 0x60 ) = uVar6;
   uVar4 = *(undefined8*)( param_3 + 0x40 );
   uVar6 = *(undefined8*)( param_3 + 0x48 );
   pTVar9[0xc0] = (TSymbol)0x0;
   *(undefined8*)( pTVar9 + 0x68 ) = uVar4;
   *(undefined8*)( pTVar9 + 0x70 ) = uVar6;
   uVar4 = *(undefined8*)( param_3 + 0x50 );
   uVar6 = *(undefined8*)( param_3 + 0x58 );
   *(undefined8*)( pTVar9 + 0xd0 ) = 0;
   *(undefined8*)( pTVar9 + 0x78 ) = uVar4;
   *(undefined8*)( pTVar9 + 0x80 ) = uVar6;
   TVar2 = param_3[9];
   *(undefined8*)( pTVar9 + 0xd8 ) = 0;
   *(undefined8*)( pTVar9 + 0xe0 ) = 0;
   *(undefined4*)( pTVar9 + 0xe8 ) = 0xffffffff;
   pTVar9[0x31] = ( TSymbol )((byte)pTVar9[0x31] & 0xf0 | (byte)TVar2 & 0xf);
   pTVar9[0x31] = ( TSymbol )((byte)TVar2 & 0xf | (byte)param_3[9] & 0xf0);
   TVar1 = pTVar9[0x32];
   bVar11 = (byte)param_3[10] & 0xf;
   pTVar9[0x32] = ( TSymbol )((byte)TVar1 & 0xf0 | bVar11);
   bVar12 = (byte)param_3[10] & 0x10;
   pTVar9[0x32] = ( TSymbol )((byte)TVar1 & 0xe0 | bVar11 | bVar12);
   *(undefined8*)( pTVar9 + 0x88 ) = *(undefined8*)( param_3 + 0x60 );
   uVar6 = *(undefined8*)( param_3 + 0x78 );
   uVar4 = *(undefined8*)( param_3 + 0x68 );
   *(undefined8*)( pTVar9 + 0x98 ) = *(undefined8*)( param_3 + 0x70 );
   *(undefined8*)( pTVar9 + 0xa0 ) = uVar6;
   *(undefined8*)( pTVar9 + 0x90 ) = uVar4;
   uVar4 = *(undefined8*)( param_3 + 0x90 );
   *(undefined8*)( pTVar9 + 0xb0 ) = *(undefined8*)( param_3 + 0x88 );
   *(undefined8*)( pTVar9 + 0xb8 ) = uVar4;
   TVar2 = param_3[10];
   pTVar9[0x32] = ( TSymbol )((byte)TVar1 & 0xc0 | bVar11 | bVar12 | (byte)TVar2 & 0x20);
   pTVar9[0x32] = ( TSymbol )((byte)TVar1 & 0x80 | bVar11 | bVar12 | (byte)TVar2 & 0x20 | (byte)param_3[10] & 0x40);
   *(ushort*)( pTVar9 + 0x32 ) = *(ushort*)( pTVar9 + 0x32 ) & 0xfc7f | *(ushort*)( param_3 + 10 ) & 0x380;
   pTVar9[0x33] = ( TSymbol )((byte)pTVar9[0x33] & 0xfb | (byte)param_3[0xb] & 4);
   ioArrayCheck(this, param_1, param_3, param_2);
   cVar7 = TSymbolTable::insert(*(TSymbolTable**)( this + 0xe8 ), pTVar9);
   if (cVar7 != '\0') {
      if ((int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 ) < 5) {
         ( **(code**)( *(long*)this + 600 ) )(this, pTVar9);
      }

      return pTVar9;
   }

   pcVar5 = *(code**)( *(long*)this + 0x158 );
   if (*(code**)( *(long*)pTVar9 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
      lVar10 = *(long*)( pTVar9 + 8 );
   }
 else {
      lVar10 = ( **(code**)( *(long*)pTVar9 + 0x18 ) )(pTVar9);
   }

   ( *pcVar5 )(this, param_1, "redefinition", *(undefined8*)( lVar10 + 8 ), &_LC1);
   return (TSymbol*)0x0;
}
/* glslang::TParseContext::variableCheck(glslang::TIntermTyped*&) */void glslang::TParseContext::variableCheck(TParseContext *this, TIntermTyped **param_1) {
   long lVar1;
   TSymbolTableLevel *this_00;
   TVariable *pTVar2;
   char cVar3;
   uint uVar4;
   int iVar5;
   long *plVar6;
   ulong uVar7;
   TVariable *this_01;
   TIntermTyped *pTVar8;
   long *plVar9;
   long lVar10;
   basic_string *pbVar11;
   code *pcVar12;
   undefined8 *puVar13;
   char *pcVar14;
   code *pcVar15;
   long in_FS_OFFSET;
   undefined **local_108;
   uint local_100;
   undefined8 local_f8;
   ulong local_f0;
   byte local_e8;
   undefined8 local_e4;
   undefined1 uStack_dc;
   uint7 local_db;
   undefined4 uStack_d4;
   undefined4 local_d0;
   undefined4 uStack_cc;
   undefined1 local_c8;
   undefined8 local_c4;
   undefined4 local_bc;
   undefined8 local_b8;
   undefined2 local_b0;
   undefined1 local_a8[16];
   undefined1 local_98[16];
   uint local_88;
   undefined1 local_80[16];
   undefined8 local_68;
   undefined1 *local_60;
   undefined8 local_58;
   undefined1 local_50[16];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   plVar6 = (long*)( **(code**)( *(long*)*param_1 + 0x60 ) )();
   if (plVar6 != (long*)0x0) {
      if (*(code**)( *plVar6 + 0xf0 ) == TIntermTyped::getType) {
         plVar9 = plVar6 + 4;
      }
 else {
         plVar9 = (long*)( **(code**)( *plVar6 + 0xf0 ) )(plVar6);
      }

      if (*(code**)( *plVar9 + 0x38 ) == TType::getBasicType) {
         uVar4 = ( uint ) * (byte*)( plVar9 + 1 );
      }
 else {
         uVar4 = ( **(code**)( *plVar9 + 0x38 ) )();
      }

      puVar13 = (undefined8*)*plVar6;
      if (uVar4 == 0) {
         pcVar12 = (code*)puVar13[0x32];
         if (*(int*)( this + 0x28 ) == 0) {
            lVar10 = *(long*)this;
            pcVar14 = "";
            LAB_0011854a:pcVar15 = *(code**)( lVar10 + 0x158 );
            if (pcVar12 == TIntermSymbol::getName_abi_cxx11_) goto LAB_001182d8;
            plVar9 = (long*)( *pcVar12 )(plVar6);
            puVar13 = (undefined8*)*plVar6;
         }
 else {
            if (pcVar12 != TIntermSymbol::getName_abi_cxx11_) {
               lVar10 = ( *pcVar12 )(plVar6);
               puVar13 = (undefined8*)*plVar6;
               pcVar12 = (code*)puVar13[0x32];
               if (( ( *(long*)( lVar10 + 0x10 ) == 0xb ) && ( **(long**)( lVar10 + 8 ) == 0x65747265565f6c67 ) ) && ( *(int*)( (long)*(long**)( lVar10 + 8 ) + 7 ) == 0x44497865 )) {
                  lVar10 = *(long*)this;
                  pcVar14 = "(Did you mean gl_VertexIndex?)";
               }
 else {
                  LAB_0011871a:if (*(int*)( this + 0x28 ) != 0) {
                     if (pcVar12 == TIntermSymbol::getName_abi_cxx11_) goto LAB_001182b8;
                     lVar10 = ( *pcVar12 )(plVar6);
                     puVar13 = (undefined8*)*plVar6;
                     pcVar12 = (code*)puVar13[0x32];
                     if (( ( *(long*)( lVar10 + 0x10 ) == 0xd ) && ( **(long**)( lVar10 + 8 ) == 0x6174736e495f6c67 ) ) && ( *(long*)( (long)*(long**)( lVar10 + 8 ) + 5 ) == 0x444965636e617473 )) {
                        lVar10 = *(long*)this;
                        pcVar14 = "(Did you mean gl_InstanceIndex?)";
                        goto LAB_0011854a;
                     }

                  }

                  lVar10 = *(long*)this;
                  pcVar14 = "";
               }

               goto LAB_0011854a;
            }

            if (plVar6[0x1b] == 0xb) {
               if (( *(long*)plVar6[0x1a] != 0x65747265565f6c67 ) || ( *(int*)( plVar6[0x1a] + 7 ) != 0x44497865 )) goto LAB_0011871a;
               pcVar14 = "(Did you mean gl_VertexIndex?)";
               pcVar15 = *(code**)( *(long*)this + 0x158 );
            }
 else {
               LAB_001182b8:lVar10 = *(long*)this;
               pcVar14 = "";
               pcVar15 = *(code**)( lVar10 + 0x158 );
               if (( plVar6[0x1b] == 0xd ) && ( ( *(long*)plVar6[0x1a] != 0x6174736e495f6c67 || ( pcVar14 = "(Did you mean gl_InstanceIndex?)" * (long*)( plVar6[0x1a] + 5 ) != 0x444965636e617473 ) ) )) {
                  pcVar14 = "";
                  goto LAB_0011854a;
               }

            }

            LAB_001182d8:plVar9 = plVar6 + 0x19;
         }

         lVar10 = plVar9[1];
         if ((code*)*puVar13 == TIntermNode::getLoc) {
            plVar9 = plVar6 + 1;
         }
 else {
            plVar9 = (long*)( *(code*)*puVar13 )(plVar6);
         }

         ( *pcVar15 )(this, plVar9, "undeclared identifier", lVar10, pcVar14);
         if (*(code**)( *plVar6 + 400 ) == TIntermSymbol::getName_abi_cxx11_) {
            plVar9 = plVar6 + 0x19;
         }
 else {
            plVar9 = (long*)( **(code**)( *plVar6 + 400 ) )(plVar6);
         }

         if (plVar9[2] != 0) {
            uVar7 = glslang::GetThreadPoolAllocator();
            this_01 = (TVariable*)glslang::TPoolAllocator::allocate(uVar7);
            local_e8 = local_e8 & 0xf0;
            local_88 = local_88 & 0x9fc00000;
            local_108 = &PTR__TType_00167f00;
            local_f8 = 0;
            local_c8 = 0;
            local_100 = local_100 & 0xf8000000 | 0x101;
            local_e4 = 0xffffffffffffffff;
            local_c4 = 0xfffff800;
            local_b0 = 0;
            local_bc = 0xffffffff;
            local_b8 = 0;
            local_80 = (undefined1[16])0x0;
            local_a8 = (undefined1[16])0x0;
            uStack_cc = 0;
            local_db = local_db & 0xffc000 | 0xffffffff001fcf;
            local_98 = (undefined1[16])0x0;
            uStack_dc = 0xff;
            uVar7 = CONCAT44(local_d0, uStack_d4) & 0xfe07ff00ffffffff | 0x1ffffff7fffffff;
            uStack_d4 = (undefined4)uVar7;
            local_d0 = ( undefined4 )(uVar7 >> 0x20);
            local_f0 = local_f0 & 0x8000000400000000;
            if (*(code**)( *plVar6 + 400 ) == TIntermSymbol::getName_abi_cxx11_) {
               pbVar11 = (basic_string*)( plVar6 + 0x19 );
            }
 else {
               pbVar11 = (basic_string*)( **(code**)( *plVar6 + 400 ) )(plVar6);
            }

            TVariable::TVariable(this_01, pbVar11, (TType*)&local_108, false);
            plVar9 = *(long**)( this + 0xe8 );
            lVar10 = plVar9[3];
            puVar13 = (undefined8*)*plVar9;
            lVar1 = plVar9[1];
            cVar3 = *(char*)( (long)plVar9 + 0x21 );
            plVar9[3] = lVar10 + 1;
            *(long*)( this_01 + 0x10 ) = lVar10 + 1;
            if (cVar3 == '\0') {
               iVar5 = (int)( lVar1 - (long)puVar13 >> 3 );
               cVar3 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)puVar13[iVar5 + -1], *(basic_string**)( this_01 + 8 ));
               if (cVar3 == '\0') goto LAB_00118496;
            }
 else {
               iVar5 = (int)( lVar1 - (long)puVar13 >> 3 );
               LAB_00118496:if (( (char)plVar9[4] != '\0' ) && ( iVar5 - 2U < 3 )) {
                  pbVar11 = *(basic_string**)( this_01 + 8 );
                  cVar3 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)*puVar13, pbVar11);
                  if (( cVar3 != '\0' ) || ( ( iVar5 != 2 && ( cVar3 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)puVar13[1], pbVar11) ),cVar3 != '\0' ) )) goto LAB_00118506;
               }

               this_00 = (TSymbolTableLevel*)puVar13[iVar5 + -1];
               local_68 = glslang::GetThreadPoolAllocator();
               local_60 = local_50;
               local_58 = 0;
               local_50[0] = 0;
               TSymbolTableLevel::insert(this_00, (TSymbol*)this_01, *(bool*)( (long)plVar9 + 0x21 ), (basic_string*)&local_68);
            }

            LAB_00118506:pTVar2 = *(TVariable**)( this + 0x38 );
            if (*(code**)*plVar6 != TIntermNode::getLoc) {
               ( **(code**)*plVar6 )(plVar6);
            }

            pTVar8 = (TIntermTyped*)glslang::TIntermediate::addSymbol(pTVar2, (TSourceLoc*)this_01);
            *param_1 = pTVar8;
         }

      }
 else {
         if ((code*)puVar13[0x21] == TIntermTyped::getQualifier) {
            plVar9 = plVar6 + 6;
         }
 else {
            plVar9 = (long*)( *(code*)puVar13[0x21] )(plVar6);
         }

         if (( *(byte*)( plVar9 + 1 ) & 0x7f ) == 0x1b) {
            if (*(code**)*plVar6 == TIntermNode::getLoc) {
               iVar5 = (int)plVar6 + 8;
            }
 else {
               iVar5 = ( **(code**)*plVar6 )(plVar6);
            }

            if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
               glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar5, 1, (char*)0x78, (char*)0x0);
               return;
            }

            goto LAB_00118883;
         }

      }

   }

   if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return;
   }

   LAB_00118883:/* WARNING: Subroutine does not return */__stack_chk_fail();
}
/* glslang::TParseContext::redeclareBuiltinVariable(glslang::TSourceLoc const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const&,
   glslang::TQualifier const&, glslang::TShaderQualifiers const&) */long *__thiscallglslang::TParseContext::redeclareBuiltinVariable(TParseContext *this, TSourceLoc *param_1, basic_string *param_2, TQualifier *param_3, TShaderQualifiers *param_4) {
   byte bVar1;
   TQualifier TVar2;
   bool bVar3;
   char cVar4;
   char cVar5;
   char cVar6;
   TQualifier TVar7;
   int iVar8;
   uint uVar9;
   long *plVar10;
   long *plVar11;
   long lVar12;
   long lVar13;
   ulong uVar14;
   ulong uVar15;
   char *pcVar16;
   code *pcVar17;
   undefined8 uVar18;
   size_t __n;
   long in_FS_OFFSET;
   bool local_79;
   long *local_78;
   undefined8 local_70;
   basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> local_68[40];
   long local_40;
   uVar15 = *(ulong*)( param_2 + 0x10 );
   plVar10 = *(long**)( param_2 + 8 );
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (uVar15 != 0) {
      __n = 3;
      if (uVar15 < 4) {
         __n = uVar15;
      }

      iVar8 = memcmp(plVar10, &_LC61, __n);
      if (( iVar8 == 0 && (int)__n == 3 ) && ( (int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 ) == 4 )) {
         iVar8 = *(int*)( this + 0x18 );
         if (*(int*)( this + 0xc ) == 8) {
            if (iVar8 < 0x140) {
               cVar6 = ( **(code**)( *(long*)this + 0x48 ) )(this, 2, AEP_shader_io_blocks);
               if (cVar6 == '\0') goto LAB_001188c8;
               if (*(int*)( this + 0xc ) != 8) {
                  iVar8 = *(int*)( this + 0x18 );
                  cVar5 = '\0';
                  goto LAB_00118958;
               }

               uVar15 = *(ulong*)( param_2 + 0x10 );
               cVar5 = '\0';
            }
 else {
               cVar6 = '\x01';
               cVar5 = '\0';
            }

            goto LAB_00118968;
         }

         if (iVar8 < 0x82) {
            if (( uVar15 == 0xb ) && ( *plVar10 == 0x6f437865545f6c67 )) {
               cVar6 = '\0';
               cVar5 = '\x01';
               if (*(int*)( (long)plVar10 + 7 ) == 0x64726f6f) goto LAB_00118ec8;
            }

            goto LAB_001188c8;
         }

         cVar6 = '\0';
         cVar5 = '\x01';
         LAB_00118958:if (iVar8 < 0x8d) {
            LAB_00118ec8:cVar4 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_ARB_separate_shader_objects");
            uVar15 = *(ulong*)( param_2 + 0x10 );
            if (cVar4 == '\0') goto LAB_00118968;
            if (uVar15 == 0xb) {
               if (( **(long**)( param_2 + 8 ) != 0x7469736f505f6c67 ) || ( *(int*)( (long)*(long**)( param_2 + 8 ) + 7 ) != 0x6e6f6974 )) goto LAB_00118f20;
            }
 else if (( uVar15 != 0xc ) || ( ( **(long**)( param_2 + 8 ) != 0x746e696f505f6c67 || ( (int)( *(long**)( param_2 + 8 ) )[1] != 0x657a6953 ) ) )) {
               LAB_00118f20:cVar4 = std::operator ==(param_2, "gl_ClipVertex");
               if (( !(bool)cVar4 ) && ( cVar4 = std::operator ==(param_2, "gl_FogFragCoord") ),!(bool)cVar4) goto LAB_00118968;
            }

            goto LAB_00118b10;
         }

         uVar15 = *(ulong*)( param_2 + 0x10 );
         LAB_00118968:cVar4 = cVar5;
         if (uVar15 == 0xc) {
            plVar10 = *(long**)( param_2 + 8 );
            if (( *plVar10 == 0x44676172465f6c67 ) && ( (int)plVar10[1] == 0x68747065 )) {
               if (cVar4 == '\0') {
                  LAB_00118fdf:if (cVar6 == '\0') goto LAB_001189c0;
                  goto LAB_00118b10;
               }

               if (*(int*)( this + 0x18 ) < 0x1a4) {
                  LAB_00118ff5:if (cVar6 == '\0') goto LAB_001189c0;
               }

            }
 else {
               iVar8 = memcmp(plVar10, "gl_FragCoord", 0xc);
               if (iVar8 != 0) goto LAB_001189c0;
               if (cVar4 == '\0') goto LAB_00118fdf;
               if (*(int*)( this + 0x18 ) < 0x8c) goto LAB_00118ff5;
            }

            LAB_00118ffd:cVar4 = '\0';
         }
 else {
            if (uVar15 == 0xf) {
               plVar10 = *(long**)( param_2 + 8 );
               if (( ( *plVar10 != 0x4470696c435f6c67 ) || ( *(long*)( (long)plVar10 + 7 ) != 0x65636e6174736944 ) ) && ( ( *plVar10 != 0x446c6c75435f6c67 || ( *(long*)( (long)plVar10 + 7 ) != 0x65636e6174736944 ) ) )) goto LAB_001189c0;
               goto LAB_00118ffd;
            }

            if (uVar15 != 0x11) {
               if (( ( uVar15 != 0x1a ) || ( plVar10 = *(long**)( param_2 + 8 ) * plVar10 != 0x696d6972505f6c67 || plVar10[1] != 0x6461685365766974 ) ) || ( *(long*)( (long)plVar10 + 10 ) != 0x6e69646168536576 || *(long*)( (long)plVar10 + 0x12 ) != 0x5458456574615267 )) goto LAB_001189c0;
               goto LAB_00118ffd;
            }

            plVar10 = *(long**)( param_2 + 8 );
            if (( *plVar10 == 0x69646168535f6c67 && plVar10[1] == 0x584565746152676e ) && ( (char)plVar10[2] == 'T' )) goto LAB_00118ffd;
            LAB_001189c0:bVar3 = std::operator ==(param_2, "gl_FrontColor");
            if (( ( ( ( bVar3 ) || ( ( bVar3 = std::operator ==(param_2, "gl_BackColor") ),bVar3 || ( bVar3 = std::operator ==(param_2, "gl_FrontSecondaryColor") ),bVar3 ) ) ) ) || ( bVar3 = bVar3 )) ( ( ( bVar3 = std::operator ==(param_2, "gl_SecondaryColor") ),bVar3 || ( ( bVar3 = std::operator ==(param_2, "gl_Color") ),bVar3 && ( *(int*)( this + 0x1c ) == 4 ) ) ) ) || ( ( bVar3 = std::operator ==(param_2, "gl_FragStencilRefARB") ),bVar3 && ( ( ( cVar4 != '\0' && ( 0x8b < *(int*)( this + 0x18 ) ) ) && ( *(int*)( this + 0x1c ) == 4 ) ) ) ) || ( cVar4= std::operator==(param_2,"gl_SampleMask"),(bool)cVar4 );
            bVar3 = std::operator ==(param_2, "gl_Layer");
            if (!bVar3) {
               cVar4 = std::operator ==(param_2, "gl_PrimitiveIndicesNV");
               if ((bool)cVar4) goto LAB_00118ffd;
               bVar3 = std::operator ==(param_2, "gl_PrimitivePointIndicesEXT");
               if (( !bVar3 ) && ( bVar3 = !bVar3 )) {
                  cVar4 = std::operator ==(param_2, "gl_PrimitiveTriangleIndicesEXT");
                  if ((bool)cVar4) goto LAB_00118ffd;
                  bVar3 = std::operator ==(param_2, "gl_TexCoord");
                  if (!bVar3) goto LAB_001188c8;
               }

            }

         }

         LAB_00118b10:local_78 = (long*)TSymbolTable::find(*(TSymbolTable**)( this + 0xe8 ), param_2, &local_79, (bool*)0x0, (int*)0x0);
         plVar10 = local_78;
         if (local_78 == (long*)0x0) goto LAB_001188ca;
         if (local_79 != false) {
            ( **(code**)( *(long*)this + 0x260 ) )(this, &local_78);
            plVar10 = local_78;
            uVar9 = (int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 ) - 1;
            lVar13 = *local_78;
            uVar15 = 0x7f00000000000000;
            if (uVar9 < 0x80) {
               uVar15 = (ulong)uVar9 << 0x38;
            }

            if (*(code**)( lVar13 + 0x78 ) == TSymbol::getUniqueId) {
               uVar14 = local_78[2];
            }
 else {
               uVar14 = ( **(code**)( lVar13 + 0x78 ) )();
               lVar13 = *plVar10;
            }

            if (*(code**)( lVar13 + 0x70 ) == TSymbol::setUniqueId) {
               plVar10[2] = uVar14 & 0xffffffffffffff | uVar15;
            }
 else {
               ( **(code**)( lVar13 + 0x70 ) )();
            }

         }

         plVar11 = (long*)( **(code**)( *local_78 + 0x68 ) )(local_78);
         if (*(code**)( *plVar11 + 0x50 ) == TType::getQualifier) {
            plVar11 = plVar11 + 2;
         }
 else {
            plVar11 = (long*)( **(code**)( *plVar11 + 0x50 ) )();
         }

         if (cVar4 == '\0') {
            lVar13 = *(long*)( param_2 + 0x10 );
            if (lVar13 == 0xd) {
               if (( **(long**)( param_2 + 8 ) != 0x746e6f72465f6c67 ) || ( *(long*)( (long)*(long**)( param_2 + 8 ) + 5 ) != 0x726f6c6f43746e6f )) goto LAB_00118c38;
               LAB_00119330:TVar7 = param_3[0xb];
               bVar1 = *(byte*)( (long)plVar11 + 0xb );
               *(byte*)( (long)plVar11 + 0xb ) = bVar1 & 0x7f | (byte)TVar7 & 0x80;
               *(byte*)( (long)plVar11 + 0xb ) = bVar1 & 0x3f | (byte)TVar7 & 0x80 | (byte)param_3[0xb] & 0x40;
               *(byte*)( (long)plVar11 + 0xc ) = *(byte*)( (long)plVar11 + 0xc ) & 0xdf | (byte)param_3[0xc] & 0x20;
               if (( ( ( ( ( (byte)param_3[0xf] & 0x70 ) != 0 ) || ( ( (byte)param_3[0x10] & 0xf ) != 0 ) ) || ( *(int*)( param_3 + 0x14 ) != -1 ) ) || ( ( ( ( *(short*)( param_3 + 0x20 ) != -1 || ( ( *(uint*)( param_3 + 0x1c ) & 0x3f8000 ) != 0x1f8000 ) ) || ( ( *(int*)( param_3 + 0x18 ) != -1 || ( ( ( ~*(ushort *)(param_3 + 0x1c) & 0xfff ) != 0 || ( ( (byte)param_3[0x1d] & 0x70 ) != 0x40 ) ) ) ) ) ) || ( param_3[0x22] != (TQualifier)0xff ) ) ) ) || ( ( ( ( param_3[0x23] != (TQualifier)0xff || ( param_3[0x2c] != (TQualifier)0x0 ) ) || ( param_3[0x38] != (TQualifier)0x0 ) ) || ( ( ( param_3[0x2d] != (TQualifier)0x0 || ( param_3[0x2e] != (TQualifier)0x0 ) ) || ( ( ( ~(byte)param_3[0x24] & 0xf ) != 0 || ( ( ( ~*(uint *)(param_3 + 0x24) & 0x3fff0 ) != 0 || ( ( ~*(ushort *)(param_3 + 0x26) & 0x7ffc ) != 0 ) ) ) ) ) ) ) ) )) {
                  pcVar17 = *(code**)( *(long*)this + 0x158 );
                  if (*(code**)( *local_78 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                     lVar13 = local_78[1];
                  }
 else {
                     lVar13 = ( **(code**)( *local_78 + 0x18 ) )();
                  }

                  ( *pcVar17 )(this, param_1, "cannot apply layout qualifier to", "redeclaration", *(undefined8*)( lVar13 + 8 ));
               }

               TVar7 = param_3[0xe];
               if (( ( ( ( ( ( -1 < (char)TVar7 ) && ( ( (byte)TVar7 & 0x40 ) == 0 ) ) && ( ( (byte)TVar7 & 0x20 ) == 0 ) ) && ( ( ( (byte)TVar7 & 0x10 ) == 0 && ( ( (byte)TVar7 & 8 ) == 0 ) ) ) ) && ( ( ( (byte)TVar7 & 2 ) == 0 && ( ( ( (byte)TVar7 & 4 ) == 0 && ( TVar2 = param_3[0xd]((byte)TVar2 & 0x40) == 0 ) ) ) ) ) ) && ( -1 < (char)TVar2 ) ) && ( ( ( ( ( (byte)TVar7 & 1 ) == 0 && ( ( (byte)param_3[0xf] & 1 ) == 0 ) ) && ( ( (byte)param_3[0xb] & 0x20 ) == 0 ) ) && ( ( ( ( (byte)TVar2 & 0x10 ) == 0 && ( ( (byte)TVar2 & 0x20 ) == 0 ) ) && ( ( -1 < (char)param_3[0xc] && ( ( (byte)TVar2 & 1 ) == 0 ) ) ) ) ) ) )) {
                  plVar11 = (long*)( **(code**)( *local_78 + 0x60 ) )(local_78);
                  if (*(code**)( *plVar11 + 0x58 ) == TType::getQualifier) {
                     plVar11 = plVar11 + 2;
                  }
 else {
                     plVar11 = (long*)( **(code**)( *plVar11 + 0x58 ) )();
                  }

                  plVar10 = local_78;
                  if (( ( *(byte*)( plVar11 + 1 ) ^ (byte)param_3[8] ) & 0x7f ) == 0) goto LAB_001188ca;
               }

               pcVar17 = *(code**)( *(long*)this + 0x158 );
               if (*(code**)( *local_78 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                  lVar13 = local_78[1];
               }
 else {
                  lVar13 = ( **(code**)( *local_78 + 0x18 ) )(local_78);
               }

               uVar18 = *(undefined8*)( lVar13 + 8 );
               pcVar16 = "cannot change storage, memory, or auxiliary qualification of";
            }
 else {
               if (lVar13 == 0xc) {
                  if (( **(long**)( param_2 + 8 ) == 0x436b6361425f6c67 ) && ( (int)( *(long**)( param_2 + 8 ) )[1] == 0x726f6c6f )) goto LAB_00119330;
                  LAB_00118c38:bVar3 = std::operator ==(param_2, "gl_ClipDistance");
                  if (( !bVar3 ) && ( bVar3 = !bVar3 )) {
                     bVar3 = std::operator ==(param_2, "gl_FragCoord");
                     if (bVar3) {
                        lVar13 = *(long*)( this + 0x38 );
                        if (*(char*)( lVar13 + 0x31a ) == '\0') {
                           local_70 = glslang::GetThreadPoolAllocator();
                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::basic_string<glslang::std::allocator<char>>(local_68, "gl_FragCoord", (allocator*)&local_70);
                           lVar12 = std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>::find((_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>*)( lVar13 + 0x730 ), (basic_string*)local_68);
                           if (lVar13 + 0x738 != lVar12) {
                              ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot redeclare after use", "gl_FragCoord", &_LC1);
                           }

                        }

                        if (( ( ( ( ( (byte)param_3[0xc] ^ *(byte*)( (long)plVar11 + 0xc ) ) & 0x20 ) != 0 ) || ( (char)( (byte)param_3[0xb] ^ *(byte*)( (long)plVar11 + 0xb ) ) < '\0' ) ) || ( cVar5 = TQualifier::isMemory(param_3) ),cVar5 != '\0' )) {
                           pcVar17 = *(code**)( *(long*)this + 0x158 );
                           if (*(code**)( *local_78 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                              lVar13 = local_78[1];
                           }
 else {
                              lVar13 = ( **(code**)( *local_78 + 0x18 ) )();
                           }

                           ( *pcVar17 )(this, param_1, "can only change layout qualification of", "redeclaration", *(undefined8*)( lVar13 + 8 ));
                        }

                        if (( (byte)param_3[8] & 0x7f ) != 3) {
                           pcVar17 = *(code**)( *(long*)this + 0x158 );
                           if (*(code**)( *local_78 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                              lVar13 = local_78[1];
                           }
 else {
                              lVar13 = ( **(code**)( *local_78 + 0x18 ) )();
                           }

                           ( *pcVar17 )(this, param_1, "cannot change input storage qualification of", "redeclaration", *(undefined8*)( lVar13 + 8 ));
                        }

                        lVar13 = *(long*)( this + 0x38 );
                        if (( local_79 == false ) && ( ( param_4[4] != *(TShaderQualifiers*)( lVar13 + 0x318 ) || ( param_4[5] != *(TShaderQualifiers*)( lVar13 + 0x319 ) ) ) )) {
                           pcVar17 = *(code**)( *(long*)this + 0x158 );
                           lVar13 = ( **(code**)( *local_78 + 0x18 ) )();
                           ( *pcVar17 )(this, param_1, "cannot redeclare with different qualification:", "redeclaration", *(undefined8*)( lVar13 + 8 ));
                           lVar13 = *(long*)( this + 0x38 );
                        }

                        *(undefined1*)( lVar13 + 0x31a ) = 1;
                        if (param_4[4] != (TShaderQualifiers)0x0) {
                           *(undefined1*)( lVar13 + 0x318 ) = 1;
                        }

                        plVar10 = local_78;
                        if (param_4[5] != (TShaderQualifiers)0x0) {
                           *(undefined1*)( lVar13 + 0x319 ) = 1;
                        }

                        goto LAB_001188ca;
                     }

                     bVar3 = std::operator ==(param_2, "gl_FragDepth");
                     if (bVar3) {
                        if (( ( ( ( (byte)param_3[0xc] ^ *(byte*)( (long)plVar11 + 0xc ) ) & 0x20 ) != 0 ) || ( (char)( (byte)param_3[0xb] ^ *(byte*)( (long)plVar11 + 0xb ) ) < '\0' ) ) || ( ( cVar5 = TQualifier::isMemory(param_3) ),cVar5 != '\0' || ( cVar5 = TQualifier::isAuxiliary(param_3) ),cVar5 != '\0' )) {
                           pcVar17 = *(code**)( *(long*)this + 0x158 );
                           lVar13 = ( **(code**)( *local_78 + 0x18 ) )();
                           ( *pcVar17 )(this, param_1, "can only change layout qualification of", "redeclaration", *(undefined8*)( lVar13 + 8 ));
                        }

                        if (( (byte)param_3[8] & 0x7f ) != 4) {
                           pcVar17 = *(code**)( *(long*)this + 0x158 );
                           lVar13 = ( **(code**)( *local_78 + 0x18 ) )();
                           ( *pcVar17 )(this, param_1, "cannot change output storage qualification of", "redeclaration", *(undefined8*)( lVar13 + 8 ));
                        }

                        plVar10 = local_78;
                        if (*(int*)( param_4 + 0x40 ) == 0) goto LAB_001188ca;
                        lVar13 = *(long*)( this + 0x38 );
                        local_70 = glslang::GetThreadPoolAllocator();
                        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::basic_string<glslang::std::allocator<char>>(local_68, "gl_FragDepth", (allocator*)&local_70);
                        lVar12 = std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>::find((_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>*)( lVar13 + 0x730 ), (basic_string*)local_68);
                        if (lVar13 + 0x738 != lVar12) {
                           ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot redeclare after use", "gl_FragDepth", &_LC1);
                        }

                        iVar8 = *(int*)( *(long*)( this + 0x38 ) + 0x330 );
                        plVar10 = local_78;
                        if (iVar8 == 0) {
                           *(int*)( *(long*)( this + 0x38 ) + 0x330 ) = *(int*)( param_4 + 0x40 );
                           goto LAB_001188ca;
                        }

                        if (*(int*)( param_4 + 0x40 ) == iVar8) goto LAB_001188ca;
                        pcVar17 = *(code**)( *(long*)this + 0x158 );
                        lVar13 = ( **(code**)( *local_78 + 0x18 ) )(local_78);
                        pcVar16 = "all redeclarations must use the same depth layout on";
                        uVar18 = *(undefined8*)( lVar13 + 8 );
                     }
 else {
                        bVar3 = std::operator ==(param_2, "gl_FragStencilRefARB");
                        if (bVar3) {
                           if (( ( ( ( ( (uint)(byte)param_3[0xc] ^ *(uint*)( (long)plVar11 + 0xc ) ) & 0x20 ) != 0 ) || ( (char)( (byte)param_3[0xb] ^ *(byte*)( (long)plVar11 + 0xb ) ) < '\0' ) ) || ( cVar5 = TQualifier::isMemory(param_3) ),cVar5 != '\0' )) {
                              pcVar17 = *(code**)( *(long*)this + 0x158 );
                              lVar13 = ( **(code**)( *local_78 + 0x18 ) )();
                              ( *pcVar17 )(this, param_1, "can only change layout qualification of", "redeclaration", *(undefined8*)( lVar13 + 8 ));
                           }

                           if (( (byte)param_3[8] & 0x7f ) != 4) {
                              pcVar17 = *(code**)( *(long*)this + 0x158 );
                              lVar13 = ( **(code**)( *local_78 + 0x18 ) )();
                              ( *pcVar17 )(this, param_1, "cannot change output storage qualification of", "redeclaration", *(undefined8*)( lVar13 + 8 ));
                           }

                           plVar10 = local_78;
                           if (*(int*)( param_4 + 0x44 ) == 0) goto LAB_001188ca;
                           lVar13 = *(long*)( this + 0x38 );
                           local_70 = glslang::GetThreadPoolAllocator();
                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::basic_string<glslang::std::allocator<char>>(local_68, "gl_FragStencilRefARB", (allocator*)&local_70);
                           lVar12 = std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>::find((_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>*)( lVar13 + 0x730 ), (basic_string*)local_68);
                           if (lVar13 + 0x738 != lVar12) {
                              ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot redeclare after use", "gl_FragStencilRefARB", &_LC1);
                           }

                           iVar8 = *(int*)( *(long*)( this + 0x38 ) + 0x334 );
                           plVar10 = local_78;
                           if (iVar8 == 0) {
                              *(int*)( *(long*)( this + 0x38 ) + 0x334 ) = *(int*)( param_4 + 0x44 );
                              goto LAB_001188ca;
                           }

                           if (*(int*)( param_4 + 0x44 ) == iVar8) goto LAB_001188ca;
                           pcVar17 = *(code**)( *(long*)this + 0x158 );
                           lVar13 = ( **(code**)( *local_78 + 0x18 ) )(local_78);
                           pcVar16 = "all redeclarations must use the same stencil layout on";
                           uVar18 = *(undefined8*)( lVar13 + 8 );
                        }
 else {
                           bVar3 = std::operator ==(param_2, "gl_PrimitiveIndicesNV");
                           plVar10 = local_78;
                           if (!bVar3) {
                              bVar3 = std::operator ==(param_2, "gl_SampleMask");
                              if (bVar3) {
                                 if (param_4[0x54] == (TShaderQualifiers)0x0) {
                                    pcVar17 = *(code**)( *(long*)this + 0x158 );
                                    lVar13 = ( **(code**)( *plVar10 + 0x18 ) )(plVar10);
                                    ( *pcVar17 )(this, param_1, "redeclaration only allowed for override_coverage layout", "redeclaration", *(undefined8*)( lVar13 + 8 ));
                                    plVar10 = local_78;
                                 }

                                 *(undefined1*)( *(long*)( this + 0x38 ) + 0x361 ) = 1;
                              }
 else {
                                 bVar3 = std::operator ==(param_2, "gl_Layer");
                                 if (bVar3) {
                                    if (( param_3[0x30] == (TQualifier)0x0 ) && ( *(int*)( param_3 + 0x34 ) == -0x800 )) {
                                       pcVar17 = *(code**)( *(long*)this + 0x158 );
                                       lVar13 = ( **(code**)( *plVar10 + 0x18 ) )(plVar10);
                                       ( *pcVar17 )(this, param_1, "redeclaration only allowed for viewport_relative or secondary_view_offset layout", "redeclaration", *(undefined8*)( lVar13 + 8 ));
                                       plVar10 = local_78;
                                    }

                                    *(TQualifier*)( plVar11 + 6 ) = param_3[0x30];
                                    *(undefined4*)( (long)plVar11 + 0x34 ) = *(undefined4*)( param_3 + 0x34 );
                                 }

                              }

                              goto LAB_001188ca;
                           }

                           cVar5 = TQualifier::hasLayout(param_3);
                           if (cVar5 != '\0') {
                              pcVar17 = *(code**)( *(long*)this + 0x158 );
                              lVar13 = ( **(code**)( *plVar10 + 0x18 ) )(plVar10);
                              ( *pcVar17 )(this, param_1, "cannot apply layout qualifier to", "redeclaration", *(undefined8*)( lVar13 + 8 ));
                              plVar10 = local_78;
                           }

                           if (( (byte)param_3[8] & 0x7f ) == 4) goto LAB_001188ca;
                           pcVar17 = *(code**)( *(long*)this + 0x158 );
                           lVar13 = ( **(code**)( *plVar10 + 0x18 ) )(plVar10);
                           pcVar16 = "cannot change output storage qualification of";
                           uVar18 = *(undefined8*)( lVar13 + 8 );
                        }

                     }

                     goto LAB_00119228;
                  }

               }
 else {
                  if (lVar13 == 0x16) {
                     plVar10 = *(long**)( param_2 + 8 );
                     if (*plVar10 == 0x746e6f72465f6c67 && plVar10[1] == 0x7261646e6f636553) {
                        lVar13 = *(long*)( (long)plVar10 + 0xe );
                        joined_r0x00119281:if (lVar13 == 0x726f6c6f43797261) goto LAB_00119330;
                     }

                     goto LAB_00118c38;
                  }

                  if (lVar13 == 0x15) {
                     plVar10 = *(long**)( param_2 + 8 );
                     if (*plVar10 == 0x536b6361425f6c67 && plVar10[1] == 0x797261646e6f6365) {
                        lVar13 = *(long*)( (long)plVar10 + 0xd );
                        goto joined_r0x00119281;
                     }

                     goto LAB_00118c38;
                  }

                  if (lVar13 == 0x11) {
                     plVar10 = *(long**)( param_2 + 8 );
                     if (( *plVar10 == 0x6e6f6365535f6c67 && plVar10[1] == 0x6f6c6f4379726164 ) && ( (char)plVar10[2] == 'r' )) goto LAB_00119330;
                     goto LAB_00118c38;
                  }

                  if (lVar13 == 8) {
                     if (**(long**)( param_2 + 8 ) == 0x726f6c6f435f6c67) goto LAB_00119330;
                     goto LAB_00118c38;
                  }

                  if (( ( lVar13 != 0xb ) || ( **(long**)( param_2 + 8 ) != 0x6f437865545f6c67 ) ) || ( *(int*)( (long)*(long**)( param_2 + 8 ) + 7 ) != 0x64726f6f )) goto LAB_00118c38;
               }

               if (( ( ( ( ( (byte)param_3[0xf] & 0x70 ) == 0 ) && ( ( (byte)param_3[0x10] & 0xf ) == 0 ) ) && ( ( ( *(int*)( param_3 + 0x14 ) == -1 && ( ( ( *(short*)( param_3 + 0x20 ) == -1 && ( ( *(uint*)( param_3 + 0x1c ) & 0x3f8000 ) == 0x1f8000 ) ) && ( *(int*)( param_3 + 0x18 ) == -1 ) ) ) ) && ( ( ( ( ~*(ushort *)(param_3 + 0x1c) & 0xfff ) == 0 && ( ( (byte)param_3[0x1d] & 0x70 ) == 0x40 ) ) && ( param_3[0x22] == (TQualifier)0xff ) ) ) ) ) ) && ( ( param_3[0x23] == (TQualifier)0xff && ( param_3[0x2c] == (TQualifier)0x0 ) ) ) ) && ( ( ( param_3[0x38] == (TQualifier)0x0 && ( ( ( param_3[0x2d] == (TQualifier)0x0 && ( param_3[0x2e] == (TQualifier)0x0 ) ) && ( ( ~(byte)param_3[0x24] & 0xf ) == 0 ) ) ) ) && ( ( ( ( ~*(uint *)(param_3 + 0x24) & 0x3fff0 ) == 0 && ( ( ~*(ushort *)(param_3 + 0x26) & 0x7ffc ) == 0 ) ) && ( ( cVar5 = TQualifier::isMemory(param_3) ),cVar5 == '\0' && ( ( ( cVar5 = TQualifier::isAuxiliary(param_3) ),cVar5 == '\0' && ( ( ( (byte)param_3[0xc] ^ *(byte*)( (long)plVar11 + 0xc ) ) & 0x20 ) == 0 ) ) && ( ( -1 < (char)( (byte)param_3[0xb] ^ *(byte*)( (long)plVar11 + 0xb ) ) && ( plVar10 = local_78(( ( uint ) * (byte*)( plVar11 + 1 ) ^ *(uint*)( param_3 + 8 ) ) & 0x7f) == 0 ) ) ) ) ) ) ) ) )) goto LAB_001188ca;
               pcVar17 = *(code**)( *(long*)this + 0x158 );
               if (*(code**)( *local_78 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                  lVar13 = local_78[1];
               }
 else {
                  lVar13 = ( **(code**)( *local_78 + 0x18 ) )();
               }

               uVar18 = *(undefined8*)( lVar13 + 8 );
               pcVar16 = "cannot change qualification of";
            }

         }
 else {
            lVar13 = *(long*)( this + 0x38 );
            lVar12 = std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>::find((_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>*)( lVar13 + 0x730 ), param_2);
            if (lVar13 + 0x738 != lVar12) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot redeclare after use", *(undefined8*)( param_2 + 8 ), &_LC1);
            }

            if (( ( ( ( ( (byte)param_3[0xf] & 0x70 ) != 0 ) || ( ( (byte)param_3[0x10] & 0xf ) != 0 ) ) || ( ( *(int*)( param_3 + 0x14 ) != -1 || ( ( ( ( ( ( *(short*)( param_3 + 0x20 ) != -1 || ( ( *(uint*)( param_3 + 0x1c ) & 0x3f8000 ) != 0x1f8000 ) ) || ( *(int*)( param_3 + 0x18 ) != -1 ) ) || ( ( ( ~*(ushort *)(param_3 + 0x1c) & 0xfff ) != 0 || ( ( (byte)param_3[0x1d] & 0x70 ) != 0x40 ) ) ) ) || ( param_3[0x22] != (TQualifier)0xff ) ) || ( ( param_3[0x23] != (TQualifier)0xff || ( param_3[0x2c] != (TQualifier)0x0 ) ) ) ) ) ) ) ) || ( param_3[0x38] != (TQualifier)0x0 ) ) || ( ( ( ( param_3[0x2d] != (TQualifier)0x0 || ( param_3[0x2e] != (TQualifier)0x0 ) ) || ( ( ~(byte)param_3[0x24] & 0xf ) != 0 ) ) || ( ( ( ~*(uint *)(param_3 + 0x24) & 0x3fff0 ) != 0 || ( ( ~*(ushort *)(param_3 + 0x26) & 0x7ffc ) != 0 ) ) ) ) )) {
               pcVar17 = *(code**)( *(long*)this + 0x158 );
               if (*(code**)( *local_78 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                  lVar13 = local_78[1];
               }
 else {
                  lVar13 = ( **(code**)( *local_78 + 0x18 ) )();
               }

               ( *pcVar17 )(this, param_1, "cannot apply layout qualifier to", "redeclaration", *(undefined8*)( lVar13 + 8 ));
            }

            TVar7 = param_3[0xe];
            if (( ( ( (char)TVar7 < '\0' ) || ( ( (byte)TVar7 & 0x40 ) != 0 ) ) || ( ( ( (byte)TVar7 & 0x20 ) != 0 || ( ( ( ( (byte)TVar7 & 0x10 ) != 0 || ( ( (byte)TVar7 & 8 ) != 0 ) ) || ( ( (byte)TVar7 & 2 ) != 0 ) ) ) ) ) ) || ( ( ( ( (byte)TVar7 & 4 ) != 0 || ( TVar2 = param_3[0xd]((byte)TVar2 & 0x40) != 0 ) ) || ( ( (char)TVar2 < '\0' || ( ( ( ( (byte)TVar7 & 1 ) != 0 || ( ( (byte)param_3[0xf] & 1 ) != 0 ) ) || ( ( TVar7 = param_3[0xb]((byte)TVar7 & 0x20) != 0 || ( ( ( ( ( (byte)TVar2 & 0x10 ) != 0 || ( ( (byte)TVar2 & 0x20 ) != 0 ) ) || ( (char)param_3[0xc] < '\0' ) ) || ( ( (byte)TVar2 & 1 ) != 0 ) ) ) ) ) ) ) ) ) ) )) {
               LAB_00119198:pcVar17 = *(code**)( *(long*)this + 0x158 );
               if (*(code**)( *local_78 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                  lVar13 = local_78[1];
               }
 else {
                  lVar13 = ( **(code**)( *local_78 + 0x18 ) )();
               }

               ( *pcVar17 )(this, param_1, "cannot change storage, memory, or auxiliary qualification of", "redeclaration", *(undefined8*)( lVar13 + 8 ));
               TVar7 = param_3[0xb];
            }
 else if (*(int*)( this + 0x1c ) == 0) {
               if (( (byte)param_3[8] & 0x7f ) != 4) goto LAB_00119198;
            }
 else if (( *(int*)( this + 0x1c ) == 4 ) && ( ( (byte)param_3[8] & 0x7f ) != 3 )) goto LAB_00119198;
            plVar10 = local_78;
            if (( (byte)TVar7 & 0x40 ) != 0) goto LAB_001188ca;
            pcVar17 = *(code**)( *(long*)this + 0x158 );
            if (*(code**)( *local_78 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
               lVar13 = local_78[1];
            }
 else {
               lVar13 = ( **(code**)( *local_78 + 0x18 ) )(local_78);
            }

            uVar18 = *(undefined8*)( lVar13 + 8 );
            pcVar16 = "cannot change interpolation qualification of";
         }

         LAB_00119228:( *pcVar17 )(this, param_1, pcVar16, "redeclaration", uVar18);
         plVar10 = local_78;
         goto LAB_001188ca;
      }

   }

   LAB_001188c8:plVar10 = (long*)0x0;
   LAB_001188ca:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return plVar10;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::setInvariant(glslang::TSourceLoc const&, char const*) */void glslang::TParseContext::setInvariant(TParseContext *this, TSourceLoc *param_1, char *param_2) {
   TSymbolTable *this_00;
   long lVar1;
   size_t sVar2;
   TSymbol *pTVar3;
   long *plVar4;
   long lVar5;
   long in_FS_OFFSET;
   undefined8 local_68;
   undefined1 *local_60;
   undefined1 local_50[16];
   long local_40;
   this_00 = *(TSymbolTable**)( this + 0xe8 );
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   local_68 = glslang::GetThreadPoolAllocator();
   local_60 = local_50;
   if (param_2 == (char*)0x0) {
      /* WARNING: Subroutine does not return */
      std::__throw_logic_error("basic_string: construction from null is not valid");
   }

   sVar2 = strlen(param_2);
   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>((basic_string*)&local_68, param_2, param_2 + sVar2);
   pTVar3 = (TSymbol*)TSymbolTable::find(this_00, (basic_string*)&local_68, (bool*)0x0, (bool*)0x0, (int*)0x0);
   if (pTVar3 != (TSymbol*)0x0) {
      plVar4 = (long*)( **(code**)( *(long*)pTVar3 + 0x60 ) )(pTVar3);
      if (*(code**)( *plVar4 + 0x58 ) == TType::getQualifier) {
         plVar4 = plVar4 + 2;
      }
 else {
         plVar4 = (long*)( **(code**)( *plVar4 + 0x58 ) )();
      }

      if (( ( byte )(*(byte*)( plVar4 + 1 ) & 0x7f) < 0x1f ) && ( ( 0x71c00010UL >> ( ( ulong )(*(byte*)( plVar4 + 1 ) & 0x7f) & 0x3f ) & 1 ) != 0 )) {
         lVar1 = *(long*)( this + 0x38 );
         local_68 = glslang::GetThreadPoolAllocator();
         local_60 = local_50;
         sVar2 = strlen(param_2);
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>((basic_string*)&local_68, param_2, param_2 + sVar2);
         lVar5 = std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>::find((_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>*)( lVar1 + 0x730 ), (basic_string*)&local_68);
         if (lVar1 + 0x738 != lVar5) {
            ( **(code**)( *(long*)this + 0x160 ) )(this, param_1, "changing qualification after use", "invariant", param_2);
         }

         plVar4 = (long*)TSymbolTable::copyUp(*(TSymbolTable**)( this + 0xe8 ), pTVar3);
         plVar4 = (long*)( **(code**)( *plVar4 + 0x68 ) )(plVar4);
         if (*(code**)( *plVar4 + 0x50 ) == TType::getQualifier) {
            plVar4 = plVar4 + 2;
         }
 else {
            plVar4 = (long*)( **(code**)( *plVar4 + 0x50 ) )(plVar4);
         }

         *(byte*)( (long)plVar4 + 0xb ) = *(byte*)( (long)plVar4 + 0xb ) | 0x10;
      }

   }

   if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::makeEditable(glslang::TSymbol*&) */void glslang::TParseContext::makeEditable(TParseContext *this, TSymbol **param_1) {
   undefined8 *puVar1;
   char cVar2;
   TType *pTVar3;
   glslang::TParseContextBase::makeEditable((TSymbol**)this);
   pTVar3 = (TType*)( **(code**)( *(long*)*param_1 + 0x60 ) )();
   cVar2 = isIoResizeArray(this, pTVar3);
   if (cVar2 == '\0') {
      return;
   }

   puVar1 = *(undefined8**)( this + 0x7608 );
   if (puVar1 != *(undefined8**)( this + 0x7610 )) {
      *puVar1 = *param_1;
      *(undefined8**)( this + 0x7608 ) = puVar1 + 1;
      return;
   }

   std::vector<glslang::TSymbol*,glslang::pool_allocator<glslang::TSymbol*>>::_M_realloc_insert<glslang::TSymbol*const&>((vector<glslang::TSymbol*,glslang::pool_allocator<glslang::TSymbol*>>*)( this + 0x75f8 ), puVar1, param_1);
   return;
}
/* glslang::TParseContext::mergeQualifiers(glslang::TSourceLoc const&, glslang::TQualifier&,
   glslang::TQualifier const&, bool) */void glslang::TParseContext::mergeQualifiers(TParseContext *this, TSourceLoc *param_1, TQualifier *param_2, TQualifier *param_3, bool param_4) {
   long lVar1;
   _Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>> *this_00;
   byte bVar2;
   byte bVar3;
   byte bVar4;
   byte bVar5;
   byte bVar6;
   byte bVar7;
   byte bVar8;
   byte bVar9;
   byte bVar10;
   byte bVar11;
   byte bVar12;
   byte bVar13;
   _Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>> *p_Var14;
   TQualifier TVar15;
   TQualifier TVar16;
   byte bVar17;
   TQualifier TVar18;
   TQualifier TVar19;
   char cVar20;
   byte bVar21;
   _Rb_tree_node_base *p_Var22;
   _Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>> *p_Var23;
   char *pcVar24;
   byte bVar25;
   byte bVar26;
   TQualifier TVar27;
   uint uVar28;
   byte bVar29;
   byte bVar30;
   _Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>> *p_Var31;
   byte bVar32;
   TVar15 = param_3[0xb];
   if (( ( ( ( ( (byte)TVar15 & 0x20 ) != 0 ) || ( TVar16 = param_3[0xd]((byte)TVar16 & 0x10) != 0 ) ) || ( ( (byte)TVar16 & 0x20 ) != 0 ) ) || ( ( (char)param_3[0xc] < '\0' || ( ( (byte)TVar16 & 1 ) != 0 ) ) ) ) && ( ( ( ( (byte)param_2[0xb] & 0x20 ) != 0 || ( ( TVar16 = param_2[0xd]((byte)TVar16 & 0x10) != 0 || ( ( (byte)TVar16 & 0x20 ) != 0 ) ) ) ) || ( ( (char)param_2[0xc] < '\0' || ( ( (byte)TVar16 & 1 ) != 0 ) ) ) ) )) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only have one auxiliary qualifier (centroid, patch, and sample)");
      TVar15 = param_3[0xb];
   }

   if (( ( ( ( (char)TVar15 < '\0' ) || ( ( (byte)TVar15 & 0x40 ) != 0 ) ) || ( ( (byte)param_3[0xc] & 0x20 ) != 0 ) ) || ( ( (byte)param_3[0xc] & 0x40 ) != 0 ) ) && ( ( ( (char)param_2[0xb] < '\0' || ( ( (byte)param_2[0xb] & 0x40 ) != 0 ) ) || ( ( ( (byte)param_2[0xc] & 0x20 ) != 0 || ( ( (byte)param_2[0xc] & 0x40 ) != 0 ) ) ) ) )) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only have one interpolation qualifier (flat, smooth, noperspective, __explicitInterpAMD)");
   }

   if (param_4) {
      TVar15 = param_2[8];
      if (( (byte)TVar15 & 0x7e ) == 0) {
         param_2[8] = ( TQualifier )((byte)TVar15 & 0x80 | (byte)param_3[8] & 0x7f);
      }
 else {
         LAB_0011aa79:TVar16 = param_3[8];
         LAB_0011aa7e:bVar21 = (byte)TVar15 & 0x7f;
         if (bVar21 == 0x10) {
            if (( (byte)TVar16 & 0x7f ) != 0x11) {
               if (( (byte)TVar16 & 0x7f ) == 2) goto LAB_0011ae38;
               goto LAB_0011aaa3;
            }

            LAB_0011af54:param_2[8] = ( TQualifier )((byte)param_2[8] & 0x80 | 0x12);
         }
 else {
            if (bVar21 == 0x11) {
               if (( (byte)TVar16 & 0x7f ) == 0x10) goto LAB_0011af54;
            }
 else {
               LAB_0011aa91:if (( bVar21 == 2 ) && ( ( (byte)TVar16 & 0x7f ) == 0x10 )) {
                  LAB_0011ae38:param_2[8] = ( TQualifier )((byte)param_2[8] & 0x80 | 0x13);
                  goto LAB_0011aaac;
               }

            }

            LAB_0011aaa3:if (( (byte)TVar16 & 0x7e ) != 0) {
               LAB_0011ad24:switch ((byte)TVar16 & 0x7f) {
                  case 0:
            pcVar24 = "temp";
            break;
                  case 1:
            pcVar24 = "global";
            break;
                  case 2:
            pcVar24 = "const";
            break;
                  case 3:
                  case 0x10:
            pcVar24 = "in";
            break;
                  case 4:
                  case 0x11:
            pcVar24 = "out";
            break;
                  case 5:
            pcVar24 = "uniform";
            break;
                  case 6:
            pcVar24 = "buffer";
            break;
                  case 7:
            pcVar24 = "shared";
            break;
                  case 8:
            pcVar24 = "spirv_storage_class";
            break;
                  case 9:
            pcVar24 = "rayPayloadNV";
            break;
                  case 10:
            pcVar24 = "rayPayloadInNV";
            break;
                  case 0xb:
            pcVar24 = "hitAttributeNV";
            break;
                  case 0xc:
            pcVar24 = "callableDataNV";
            break;
                  case 0xd:
            pcVar24 = "callableDataInNV";
            break;
                  case 0xe:
            pcVar24 = "hitObjectAttributeNV";
            break;
                  case 0xf:
            pcVar24 = "taskPayloadSharedEXT";
            break;
                  case 0x12:
            pcVar24 = "inout";
            break;
                  case 0x13:
            pcVar24 = "const (read only)";
            break;
                  case 0x14:
            pcVar24 = "gl_VertexId";
            break;
                  case 0x15:
            pcVar24 = "gl_InstanceId";
            break;
                  case 0x16:
            pcVar24 = "gl_Position";
            break;
                  case 0x17:
            pcVar24 = "gl_PointSize";
            break;
                  case 0x18:
            pcVar24 = "gl_ClipVertex";
            break;
                  case 0x19:
            pcVar24 = "gl_FrontFacing";
            break;
                  case 0x1a:
            pcVar24 = "gl_FragCoord";
            break;
                  case 0x1b:
            pcVar24 = "gl_PointCoord";
            break;
                  case 0x1c:
            pcVar24 = "fragColor";
            break;
                  case 0x1d:
            pcVar24 = "gl_FragDepth";
            break;
                  case 0x1e:
            pcVar24 = "gl_FragStencilRefARB";
            break;
                  default:
            pcVar24 = "unknown qualifier";
               }

               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "too many storage qualifiers", pcVar24, &_LC1);
            }

         }

         LAB_0011aaac:if (!param_4) goto LAB_0011aab4;
      }

      if (( ( (byte)param_2[0xb] & 0xe ) == 0 ) || ( ( (byte)param_3[0xb] & 0xe ) != 0 )) {
         param_2[0xb] = ( TQualifier )((byte)param_3[0xb] & 0xe | (byte)param_2[0xb] & 0xf1);
      }

      goto LAB_0011a1d0;
   }

   if (*(int*)( this + 0xc ) != 8) {
      if (*(int*)( this + 0x18 ) < 0x1a4) goto LAB_0011a97a;
      LAB_0011aa6b:TVar15 = param_2[8];
      if (( (byte)TVar15 & 0x7e ) != 0) goto LAB_0011aa79;
      param_2[8] = ( TQualifier )((byte)param_2[8] & 0x80 | (byte)param_3[8] & 0x7f);
      goto LAB_0011aab4;
   }

   if (0x135 < *(int*)( this + 0x18 )) goto LAB_0011aa6b;
   LAB_0011a97a:cVar20 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_ARB_shading_language_420pack");
   if (cVar20 != '\0') {
      LAB_0011adfc:TVar15 = param_2[8];
      if (( (byte)TVar15 & 0x7e ) == 0) {
         param_2[8] = ( TQualifier )((byte)TVar15 & 0x80 | (byte)param_3[8] & 0x7f);
         goto LAB_0011aab4;
      }

      goto LAB_0011aa79;
   }

   if (( (byte)param_3[0xc] & 0x10 ) == 0) {
      LAB_0011ae72:TVar18 = param_3[0xb];
      if (( (byte)TVar18 & 0x10 ) == 0) {
         if ((char)TVar18 < '\0') {
            LAB_0011b052:if (( (byte)param_2[0xb] & 0x20 ) == 0) {
               TVar27 = param_2[0xd];
               goto LAB_0011aa2e;
            }

            goto LAB_0011aa37;
         }

         LAB_0011afc8:if (( (byte)TVar18 & 0x40 ) != 0) goto LAB_0011b052;
         LAB_0011afd0:if (( ( (byte)param_3[0xc] & 0x20 ) != 0 ) || ( ( (byte)param_3[0xc] & 0x40 ) != 0 )) goto LAB_0011b052;
         if (( ( (byte)TVar18 & 0x20 ) == 0 ) && ( TVar15 = param_3[0xd]((byte)TVar15 & 0x10) == 0 )) goto LAB_0011aff4;
         LAB_0011b280:if (( *(uint*)( param_2 + 8 ) & 0xe00007f ) == 0) goto LAB_0011b00f;
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "Auxiliary qualifiers (centroid, patch, and sample) must appear before storage and precision qualifiers", &_LC1);
      }
 else {
         TVar15 = param_2[0xb];
         if (( -1 < (char)TVar15 ) && ( ( (byte)TVar15 & 0x40 ) == 0 )) {
            TVar16 = param_2[0xc];
            goto LAB_0011b078;
         }

         LAB_0011ae8d:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "invariant qualifier must appear before interpolation, storage, and precision qualifiers ", &_LC1);
      }

      LAB_0011aeb1:TVar15 = param_2[8];
      if (( ( (byte)param_3[0xc] & 0x10 ) != 0 ) && ( ( ( byte )(( (byte)TVar15 & 0x7f ) - 0x10) < 2 || ( ( (byte)TVar15 & 0x7f ) == 2 ) ) )) {
         LAB_0011aed0:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "precise qualifier must appear first", &_LC1);
         TVar15 = param_2[8];
      }

      TVar16 = param_3[8];
      if (( (byte)TVar16 & 0x7f ) != 2) goto LAB_0011af0d;
      if (( (byte)TVar15 & 0x7e ) == 0x10) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "in/out must appear before const", &_LC1);
         goto LAB_0011adfc;
      }

      if (( (byte)TVar15 & 0x7e ) == 0) {
         param_2[8] = ( TQualifier )((byte)param_2[8] & 0x80 | 2);
         goto LAB_0011aab4;
      }

      bVar21 = (byte)TVar15 & 0x7f;
      if (bVar21 == 0x10) {
         param_2[8] = ( TQualifier )((byte)param_2[8] & 0x80 | 0x13);
         goto LAB_0011aab4;
      }

      if (bVar21 != 0x11) goto LAB_0011aa91;
      if (( (byte)TVar16 & 0x7e ) == 0) goto LAB_0011aab4;
      goto LAB_0011ad24;
   }

   TVar15 = param_2[0xb];
   if (( ( ( ( (byte)TVar15 & 0x10 ) != 0 ) || ( (char)TVar15 < '\0' ) ) || ( ( ( (byte)TVar15 & 0x40 ) != 0 || ( ( ( TVar16 = param_2[0xc]((byte)TVar16 & 0x20) != 0 || ( ( (byte)TVar16 & 0x40 ) != 0 ) ) || ( ( (byte)TVar15 & 0x20 ) != 0 ) ) ) ) ) ) || ( ( ( ( TVar27 = param_2[0xd]((byte)TVar27 & 0x10) != 0 || ( ( (byte)TVar27 & 0x20 ) != 0 ) ) || ( (char)TVar16 < '\0' ) ) || ( ( ( (byte)TVar27 & 1 ) != 0 || ( ( *(uint*)( param_2 + 8 ) & 0xe00007f ) != 0 ) ) ) ) )) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "precise qualifier must appear first", &_LC1);
      goto LAB_0011ae72;
   }

   TVar18 = param_3[0xb];
   if (( (byte)TVar18 & 0x10 ) == 0) {
      if (-1 < (char)TVar18) goto LAB_0011afc8;
      LAB_0011aa2e:if (( (byte)TVar27 & 0x10 ) != 0) goto LAB_0011aa37;
   }
 else {
      LAB_0011b078:if (( ( ( ( ( ( (byte)TVar16 & 0x20 ) != 0 ) || ( ( (byte)TVar16 & 0x40 ) != 0 ) ) || ( ( (byte)TVar15 & 0x20 ) != 0 ) ) || ( ( TVar27 = param_2[0xd]((byte)TVar27 & 0x10) != 0 || ( ( (byte)TVar27 & 0x20 ) != 0 ) ) ) ) || ( (char)TVar16 < '\0' ) ) || ( ( ( (byte)TVar27 & 1 ) != 0 || ( ( *(uint*)( param_2 + 8 ) & 0xe00007f ) != 0 ) ) )) goto LAB_0011ae8d;
      if (-1 < (char)TVar18) {
         if (( (byte)TVar18 & 0x40 ) == 0) goto LAB_0011afd0;
         goto LAB_0011aa2e;
      }

   }

   if (( ( ( ( (byte)TVar27 & 0x20 ) != 0 ) || ( (char)param_2[0xc] < '\0' ) ) || ( ( (byte)TVar27 & 1 ) != 0 ) ) || ( ( *(uint*)( param_2 + 8 ) & 0xe00007f ) != 0 )) {
      LAB_0011aa37:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "interpolation qualifiers must appear before storage and precision qualifiers", &_LC1);
      goto LAB_0011aeb1;
   }

   if (( ( (byte)TVar18 & 0x20 ) == 0 ) && ( TVar15 = param_3[0xd]((byte)TVar15 & 0x10) == 0 )) {
      LAB_0011aff4:if (( ( (byte)TVar15 & 0x20 ) != 0 ) || ( ( (char)param_3[0xc] < '\0' || ( ( (byte)TVar15 & 1 ) != 0 ) ) )) goto LAB_0011b280;
   }

   LAB_0011b00f:TVar16 = param_3[8];
   if (( (byte)TVar16 & 0x7f ) != 0) {
      if (( (byte)param_2[0xb] & 0xe ) != 0) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "precision qualifier must appear as last qualifier", &_LC1);
      }

      goto LAB_0011aeb1;
   }

   TVar15 = param_2[8];
   if (( ( (byte)param_3[0xc] & 0x10 ) != 0 ) && ( ( ( byte )(( (byte)TVar15 & 0x7f ) - 0x10) < 2 || ( ( (byte)TVar15 & 0x7f ) == 2 ) ) )) goto LAB_0011aed0;
   LAB_0011af0d:if (( (byte)TVar15 & 0x7e ) != 0) goto LAB_0011aa7e;
   param_2[8] = ( TQualifier )((byte)param_2[8] & 0x80 | (byte)TVar16 & 0x7f);
   LAB_0011aab4:TVar15 = param_2[0xb];
   TVar16 = param_3[0xb];
   if (( (byte)TVar16 & 0xe ) == 0) {
      if (( (byte)TVar15 & 0xe ) != 0) goto LAB_0011ab40;
      param_2[0xb] = ( TQualifier )((byte)TVar15 & 0xf1 | (byte)TVar16 & 0xe);
      TVar15 = param_3[0xe];
      if (( (byte)TVar15 & 2 ) != 0) goto LAB_0011ab4d;
      LAB_0011abd2:if (( (byte)TVar15 & 8 ) == 0) {
         if (( (byte)TVar15 & 0x10 ) == 0) {
            if (( (byte)TVar15 & 0x20 ) == 0) {
               LAB_0011ac36:if (( (byte)TVar15 & 0x40 ) == 0) {
                  LAB_0011b2b8:if (-1 < (char)TVar15) goto LAB_0011a1d0;
                  TVar16 = param_2[0xe];
                  if (( ( (byte)TVar16 & 2 ) == 0 ) && ( ( (byte)TVar16 & 8 ) == 0 )) goto LAB_0011ac78;
               }
 else {
                  TVar16 = param_2[0xe];
                  if (( ( (byte)TVar16 & 2 ) == 0 ) && ( ( (byte)TVar16 & 8 ) == 0 )) {
                     bVar21 = (byte)TVar16 & 0x10;
                     joined_r0x0011ac59:if (( ( bVar21 == 0 ) && ( ( (byte)TVar16 & 0x20 ) == 0 ) ) && ( -1 < (char)TVar16 )) {
                        if (-1 < (char)TVar15) goto LAB_0011a1d0;
                        LAB_0011ac78:if (( ( ( (byte)TVar16 & 0x10 ) == 0 ) && ( ( (byte)TVar16 & 0x20 ) == 0 ) ) && ( ( (byte)TVar16 & 0x40 ) == 0 )) goto LAB_0011a1d0;
                     }

                  }

               }

            }
 else {
               TVar16 = param_2[0xe];
               if (( (byte)TVar16 & 2 ) == 0) goto LAB_0011af81;
            }

         }
 else {
            TVar16 = param_2[0xe];
            if (( ( (byte)TVar16 & 2 ) == 0 ) && ( ( (byte)TVar16 & 8 ) == 0 )) {
               bVar21 = (byte)TVar16 & 0x20;
               goto joined_r0x0011accd;
            }

         }

      }
 else {
         TVar16 = param_2[0xe];
         if (( ( ( ( (byte)TVar16 & 2 ) == 0 ) && ( ( (byte)TVar16 & 0x10 ) == 0 ) ) && ( ( (byte)TVar16 & 0x20 ) == 0 ) ) && ( ( ( (byte)TVar16 & 0x40 ) == 0 && ( -1 < (char)TVar16 ) ) )) {
            if (( (byte)TVar15 & 0x10 ) == 0) {
               if (( (byte)TVar15 & 0x20 ) == 0) goto LAB_0011ac36;
               LAB_0011af81:if (( (byte)TVar16 & 8 ) == 0) goto LAB_0011af8a;
            }
 else {
               bVar21 = (byte)TVar16 & 8;
               joined_r0x0011accd:if (( ( bVar21 == 0 ) && ( ( (byte)TVar16 & 0x40 ) == 0 ) ) && ( -1 < (char)TVar16 )) {
                  if (( (byte)TVar15 & 0x20 ) == 0) goto LAB_0011ac36;
                  LAB_0011af8a:if (( ( ( (byte)TVar16 & 0x10 ) == 0 ) && ( ( (byte)TVar16 & 0x40 ) == 0 ) ) && ( -1 < (char)TVar16 )) {
                     if (( (byte)TVar15 & 0x40 ) != 0) {
                        bVar21 = (byte)TVar16 & 8;
                        goto joined_r0x0011ac59;
                     }

                     goto LAB_0011b2b8;
                  }

               }

            }

         }

      }

   }
 else {
      bVar21 = (byte)TVar16 >> 1 & 7;
      if (( (byte)TVar15 & 0xe ) == 0) {
         param_2[0xb] = ( TQualifier )((byte)TVar15 & 0xf1 | bVar21 * '\x02');
      }
 else {
         pcVar24 = "mediump";
         if (bVar21 != 2) {
            if (bVar21 < 3) {
               pcVar24 = "";
               if (bVar21 != 0) {
                  pcVar24 = "lowp";
               }

            }
 else {
               pcVar24 = "highp";
               if (bVar21 != 3) {
                  pcVar24 = "unknown precision qualifier";
               }

            }

         }

         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "only one precision qualifier allowed", pcVar24, &_LC1);
         if (( (byte)param_2[0xb] & 0xe ) == 0) {
            param_2[0xb] = ( TQualifier )((byte)param_2[0xb] & 0xf1 | (byte)param_3[0xb] & 0xe);
         }

      }

      LAB_0011ab40:TVar15 = param_3[0xe];
      if (( (byte)TVar15 & 2 ) == 0) goto LAB_0011abd2;
      LAB_0011ab4d:TVar16 = param_2[0xe];
      if (( ( ( ( (byte)TVar16 & 8 ) == 0 ) && ( ( (byte)TVar16 & 0x10 ) == 0 ) ) && ( ( (byte)TVar16 & 0x20 ) == 0 ) ) && ( ( ( (byte)TVar16 & 0x40 ) == 0 && ( -1 < (char)TVar16 ) ) )) goto LAB_0011abd2;
   }

   pcVar24 = "mediump";
   bVar21 = (byte)param_3[0xb] >> 1 & 7;
   if (bVar21 != 2) {
      if (bVar21 < 3) {
         pcVar24 = "";
         if (bVar21 != 0) {
            pcVar24 = "lowp";
         }

      }
 else {
         pcVar24 = "highp";
         if (bVar21 != 3) {
            pcVar24 = "unknown precision qualifier";
         }

      }

   }

   ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "only one coherent/devicecoherent/queuefamilycoherent/workgroupcoherent/subgroupcoherent/shadercallcoherent qualifier allowed", pcVar24, &_LC1);
   LAB_0011a1d0:mergeObjectLayoutQualifiers(this, param_2, param_3, false);
   if (( (byte)param_2[0xb] >> 4 & 1 ) == 0) {
      bVar21 = 0;
      uVar28 = (byte)param_3[0xb] >> 4 & 1;
   }
 else {
      uVar28 = (byte)param_3[0xb] >> 4 & 1;
      bVar21 = (byte)uVar28;
   }

   TVar15 = param_2[0xb];
   bVar17 = ( byte )(( uVar28 | (byte)param_2[0xb] >> 4 & 1 ) << 4);
   param_2[0xb] = ( TQualifier )((byte)TVar15 & 0xef | bVar17);
   uVar28 = (byte)param_3[0xb] >> 5 & 1;
   if (( (byte)TVar15 >> 5 & 1 ) != 0) {
      bVar21 = bVar21 | (byte)uVar28;
   }

   bVar4 = ( byte )(( (byte)TVar15 >> 5 & 1 | uVar28 ) << 5);
   param_2[0xb] = ( TQualifier )((byte)TVar15 & 0xcf | bVar17 | bVar4);
   uVar28 = (byte)param_3[0xb] >> 6 & 1;
   if (( (byte)TVar15 >> 6 & 1 ) != 0) {
      bVar21 = bVar21 | (byte)uVar28;
   }

   bVar2 = ( byte )(( (byte)TVar15 >> 6 & 1 | uVar28 ) << 6);
   TVar16 = ( TQualifier )((byte)TVar15 & 0x8f | bVar17 | bVar4 | bVar2);
   param_2[0xb] = TVar16;
   bVar25 = -((char)TVar16 >> 7);
   if (bVar25 != 0) {
      bVar21 = bVar21 | (byte)param_3[0xb] >> 7;
   }

   TVar16 = param_2[0xc];
   param_2[0xb] = ( TQualifier )((byte)TVar15 & 0xf | bVar17 | bVar4 | bVar2 | ( bVar25 | (byte)param_3[0xb] >> 7 ) << 7);
   if (( (byte)TVar16 & 1 ) != 0) {
      bVar21 = bVar21 | (byte)param_3[0xc] & 1;
   }

   bVar17 = (byte)param_3[0xc] & 1 | (byte)TVar16 & 1;
   param_2[0xc] = ( TQualifier )((byte)TVar16 & 0xfe | bVar17);
   uVar28 = (byte)param_3[0xc] >> 4 & 1;
   if (( (byte)TVar16 >> 4 & 1 ) != 0) {
      bVar21 = bVar21 | (byte)uVar28;
   }

   bVar4 = ( byte )(( (byte)TVar16 >> 4 & 1 | uVar28 ) << 4);
   param_2[0xc] = ( TQualifier )((byte)TVar16 & 0xee | bVar17 | bVar4);
   uVar28 = (byte)param_3[0xc] >> 5 & 1;
   if (( (byte)TVar16 & 0x20 ) != 0) {
      bVar21 = bVar21 | (byte)uVar28;
   }

   bVar2 = ( byte )(( (byte)TVar16 >> 5 & 1 | uVar28 ) << 5);
   param_2[0xc] = ( TQualifier )((byte)TVar16 & 0xce | bVar17 | bVar4 | bVar2);
   uVar28 = (byte)param_3[0xc] >> 6 & 1;
   if (( (byte)TVar16 & 0x40 ) != 0) {
      bVar21 = bVar21 | (byte)uVar28;
   }

   TVar15 = param_2[0xd];
   bVar25 = ( byte )(( (byte)TVar16 >> 6 & 1 | uVar28 ) << 6);
   param_2[0xc] = ( TQualifier )((byte)TVar16 & 0x8e | bVar17 | bVar4 | bVar2 | bVar25);
   bVar26 = (byte)param_3[0xd] >> 1 & 1;
   if (( (byte)TVar15 >> 1 & 1 ) != 0) {
      bVar21 = bVar21 | bVar26;
   }

   bVar26 = ( (byte)TVar15 >> 1 & 1 | bVar26 ) * '\x02';
   param_2[0xd] = ( TQualifier )((byte)TVar15 & 0xfd | bVar26);
   uVar28 = (byte)param_3[0xd] >> 2 & 1;
   if (( (byte)TVar15 >> 2 & 1 ) != 0) {
      bVar21 = bVar21 | (byte)uVar28;
   }

   bVar5 = ( byte )(( (byte)TVar15 >> 2 & 1 | uVar28 ) << 2);
   param_2[0xd] = ( TQualifier )((byte)TVar15 & 0xf9 | bVar26 | bVar5);
   uVar28 = (byte)param_3[0xd] >> 3 & 1;
   if (( (byte)TVar15 & 8 ) != 0) {
      bVar21 = bVar21 | (byte)uVar28;
   }

   bVar6 = ( byte )(( (byte)TVar15 >> 3 & 1 | uVar28 ) << 3);
   param_2[0xd] = ( TQualifier )((byte)TVar15 & 0xf1 | bVar26 | bVar5 | bVar6);
   uVar28 = (byte)param_3[0xd] >> 4 & 1;
   if (( (byte)TVar15 & 0x10 ) != 0) {
      bVar21 = bVar21 | (byte)uVar28;
   }

   bVar7 = ( byte )(( (byte)TVar15 >> 4 & 1 | uVar28 ) << 4);
   param_2[0xd] = ( TQualifier )((byte)TVar15 & 0xe1 | bVar26 | bVar5 | bVar6 | bVar7);
   uVar28 = (byte)param_3[0xd] >> 5 & 1;
   if (( (byte)TVar15 & 0x20 ) != 0) {
      bVar21 = bVar21 | (byte)uVar28;
   }

   bVar8 = ( byte )(( (byte)TVar15 >> 5 & 1 | uVar28 ) << 5);
   TVar27 = param_2[0xe];
   param_2[0xd] = ( TQualifier )((byte)TVar15 & 0xc1 | bVar26 | bVar5 | bVar6 | bVar7 | bVar8);
   bVar32 = (byte)param_3[0xe] >> 1 & 1;
   if (( (byte)TVar27 >> 1 & 1 ) != 0) {
      bVar21 = bVar21 | bVar32;
   }

   bVar32 = ( (byte)TVar27 >> 1 & 1 | bVar32 ) * '\x02';
   param_2[0xe] = ( TQualifier )((byte)TVar27 & 0xfd | bVar32);
   uVar28 = (byte)param_3[0xe] >> 3 & 1;
   if (( (byte)TVar27 >> 3 & 1 ) != 0) {
      bVar21 = bVar21 | (byte)uVar28;
   }

   bVar9 = ( byte )(( (byte)TVar27 >> 3 & 1 | uVar28 ) << 3);
   param_2[0xe] = ( TQualifier )((byte)TVar27 & 0xf5 | bVar32 | bVar9);
   uVar28 = (byte)param_3[0xe] >> 4 & 1;
   if (( (byte)TVar27 & 0x10 ) != 0) {
      bVar21 = bVar21 | (byte)uVar28;
   }

   bVar10 = ( byte )(( (byte)TVar27 >> 4 & 1 | uVar28 ) << 4);
   param_2[0xe] = ( TQualifier )((byte)TVar27 & 0xe5 | bVar32 | bVar9 | bVar10);
   uVar28 = (byte)param_3[0xe] >> 5 & 1;
   if (( (byte)TVar27 & 0x20 ) != 0) {
      bVar21 = bVar21 | (byte)uVar28;
   }

   bVar11 = ( byte )(( (byte)TVar27 >> 5 & 1 | uVar28 ) << 5);
   param_2[0xe] = ( TQualifier )((byte)TVar27 & 0xc5 | bVar32 | bVar9 | bVar10 | bVar11);
   uVar28 = (byte)param_3[0xe] >> 6 & 1;
   if (( (byte)TVar27 & 0x40 ) != 0) {
      bVar21 = bVar21 | (byte)uVar28;
   }

   bVar12 = ( byte )(( (byte)TVar27 >> 6 & 1 | uVar28 ) << 6);
   TVar18 = ( TQualifier )((byte)TVar27 & 0x85 | bVar32 | bVar9 | bVar10 | bVar11 | bVar12);
   param_2[0xe] = TVar18;
   bVar29 = -((char)TVar18 >> 7);
   if (bVar29 != 0) {
      bVar21 = bVar21 | (byte)param_3[0xe] >> 7;
   }

   bVar29 = ( bVar29 | (byte)param_3[0xe] >> 7 ) << 7;
   TVar19 = ( TQualifier )((byte)TVar27 & 5 | bVar32 | bVar9 | bVar10 | bVar11 | bVar12 | bVar29);
   TVar18 = param_2[0xf];
   param_2[0xe] = TVar19;
   if (( (byte)TVar18 & 1 ) != 0) {
      bVar21 = bVar21 | (byte)param_3[0xf] & 1;
   }

   param_2[0xf] = ( TQualifier )((byte)TVar18 & 0xfe | (byte)param_3[0xf] & 1 | (byte)TVar18 & 1);
   uVar28 = (byte)param_3[0xe] >> 2 & 1;
   if (( (byte)TVar27 & 4 ) != 0) {
      bVar21 = bVar21 | (byte)uVar28;
   }

   bVar13 = ( byte )(( (byte)TVar19 >> 2 & 1 | uVar28 ) << 2);
   param_2[0xe] = ( TQualifier )((byte)TVar27 & 1 | bVar32 | bVar9 | bVar10 | bVar11 | bVar12 | bVar29 | bVar13);
   uVar28 = (byte)param_3[0xd] >> 6 & 1;
   if (( (byte)TVar15 & 0x40 ) != 0) {
      bVar21 = bVar21 | (byte)uVar28;
   }

   bVar3 = ( byte )(( (byte)TVar15 >> 6 & 1 | uVar28 ) << 6);
   TVar18 = ( TQualifier )((byte)TVar15 & 0x81 | bVar26 | bVar5 | bVar6 | bVar7 | bVar8 | bVar3);
   param_2[0xd] = TVar18;
   bVar30 = -((char)TVar18 >> 7);
   if (bVar30 != 0) {
      bVar21 = bVar21 | (byte)param_3[0xd] >> 7;
   }

   param_2[0xd] = ( TQualifier )((byte)TVar15 & 1 | bVar26 | bVar5 | bVar6 | bVar7 | bVar8 | bVar3 | ( bVar30 | (byte)param_3[0xd] >> 7 ) << 7);
   if (( (byte)TVar27 & 1 ) != 0) {
      bVar21 = bVar21 | (byte)param_3[0xe] & 1;
   }

   param_2[0xe] = ( TQualifier )(bVar32 | bVar9 | bVar10 | bVar11 | bVar12 | bVar29 | bVar13 | (byte)param_3[0xe] & 1 | (byte)TVar27 & 1);
   bVar26 = (byte)param_3[0xc] >> 1 & 1;
   if (( (byte)TVar16 & 2 ) != 0) {
      bVar21 = bVar21 | bVar26;
   }

   param_2[0xc] = ( TQualifier )((byte)TVar16 & 0x8c | bVar17 | bVar4 | bVar2 | bVar25 | ( ( (byte)TVar16 & 2 ) >> 1 | bVar26 ) * '\x02');
   lVar1 = *(long*)( param_3 + 0x40 );
   *(undefined4*)( param_2 + 0x3c ) = *(undefined4*)( param_3 + 0x3c );
   if (lVar1 != 0) {
      this_00 = *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( param_2 + 0x40 );
      if (this_00 == (_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>*)0x0) {
         *(long*)( param_2 + 0x40 ) = lVar1;
      }
 else {
         for (p_Var22 = *(_Rb_tree_node_base**)( lVar1 + 0x20 ); p_Var22 != (_Rb_tree_node_base*)( lVar1 + 0x10 ); p_Var22 = (_Rb_tree_node_base*)std::_Rb_tree_increment(p_Var22)) {
            p_Var14 = *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( this_00 + 0x18 );
            p_Var31 = this_00 + 0x10;
            if (*(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( this_00 + 0x18 ) == (_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>*)0x0) {
               LAB_0011a6a0:std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>::_M_insert_unique<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>const&>(this_00, (pair_conflict*)( p_Var22 + 0x20 ));
            }
 else {
               do {
                  while (true) {
                     p_Var23 = p_Var14;
                     if (*(int*)( p_Var23 + 0x20 ) < *(int*)( p_Var22 + 0x20 )) break;
                     p_Var14 = *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( p_Var23 + 0x10 );
                     p_Var31 = p_Var23;
                     if (*(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( p_Var23 + 0x10 ) == (_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>*)0x0) goto LAB_0011a691;
                  }
;
                  p_Var14 = *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( p_Var23 + 0x18 );
               }
 while ( *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( p_Var23 + 0x18 ) != (_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>*)0x0 );
               LAB_0011a691:if (( this_00 + 0x10 == p_Var31 ) || ( *(int*)( p_Var22 + 0x20 ) < *(int*)( p_Var31 + 0x20 ) )) goto LAB_0011a6a0;
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "too many SPIR-V decorate qualifiers", "spirv_decorate", "(decoration=%u)");
            }

         }

         for (p_Var22 = *(_Rb_tree_node_base**)( lVar1 + 0x58 ); p_Var22 != (_Rb_tree_node_base*)( lVar1 + 0x48 ); p_Var22 = (_Rb_tree_node_base*)std::_Rb_tree_increment(p_Var22)) {
            p_Var14 = *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( this_00 + 0x50 );
            p_Var31 = this_00 + 0x48;
            if (*(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( this_00 + 0x50 ) == (_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>*)0x0) {
               LAB_0011a748:std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>>::_M_insert_unique<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>const&>((_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>>*)( this_00 + 0x38 ), (pair_conflict*)( p_Var22 + 0x20 ));
            }
 else {
               do {
                  while (true) {
                     p_Var23 = p_Var14;
                     if (*(int*)( p_Var23 + 0x20 ) < *(int*)( p_Var22 + 0x20 )) break;
                     p_Var14 = *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( p_Var23 + 0x10 );
                     p_Var31 = p_Var23;
                     if (*(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( p_Var23 + 0x10 ) == (_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>*)0x0) goto LAB_0011a739;
                  }
;
                  p_Var14 = *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( p_Var23 + 0x18 );
               }
 while ( *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( p_Var23 + 0x18 ) != (_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>*)0x0 );
               LAB_0011a739:if (( this_00 + 0x48 == p_Var31 ) || ( *(int*)( p_Var22 + 0x20 ) < *(int*)( p_Var31 + 0x20 ) )) goto LAB_0011a748;
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "too many SPIR-V decorate qualifiers", "spirv_decorate_id", "(decoration=%u)");
            }

         }

         for (p_Var22 = *(_Rb_tree_node_base**)( lVar1 + 0x90 ); (_Rb_tree_node_base*)( lVar1 + 0x80 ) != p_Var22; p_Var22 = (_Rb_tree_node_base*)std::_Rb_tree_increment(p_Var22)) {
            p_Var14 = *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( this_00 + 0x18 );
            p_Var31 = this_00 + 0x10;
            if (*(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( this_00 + 0x18 ) == (_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>*)0x0) {
               LAB_0011a7f8:std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>::_M_insert_unique<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>const&>(this_00 + 0x70, (pair_conflict*)( p_Var22 + 0x20 ));
            }
 else {
               do {
                  while (true) {
                     p_Var23 = p_Var14;
                     if (*(int*)( p_Var23 + 0x20 ) < *(int*)( p_Var22 + 0x20 )) break;
                     p_Var14 = *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( p_Var23 + 0x10 );
                     p_Var31 = p_Var23;
                     if (*(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( p_Var23 + 0x10 ) == (_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>*)0x0) goto LAB_0011a7e9;
                  }
;
                  p_Var14 = *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( p_Var23 + 0x18 );
               }
 while ( *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( p_Var23 + 0x18 ) != (_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>*)0x0 );
               LAB_0011a7e9:if (( p_Var31 == this_00 + 0x10 ) || ( *(int*)( p_Var22 + 0x20 ) < *(int*)( p_Var31 + 0x20 ) )) goto LAB_0011a7f8;
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "too many SPIR-V decorate qualifiers", "spirv_decorate_string", "(decoration=%u)");
            }

         }

      }

   }

   if (bVar21 != 0) {
      /* WARNING: Could not recover jumptable at 0x0011a85f. Too many branches */
      /* WARNING: Treating indirect jump as call */
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "replicated qualifiers", &_LC1, &_LC1, *(code**)( *(long*)this + 0x158 ));
      return;
   }

   return;
}
/* glslang::TParseContext::setLayoutQualifier(glslang::TSourceLoc const&, glslang::TPublicType&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >&,
   glslang::TIntermTyped const*) */void glslang::TParseContext::setLayoutQualifier(TParseContext *this, TSourceLoc *param_1, TPublicType *param_2, basic_string *param_3, TIntermTyped *param_4) {
   long *plVar1;
   bool bVar2;
   char cVar3;
   bool bVar4;
   int iVar5;
   int iVar6;
   long lVar7;
   uint uVar8;
   uint uVar9;
   char *pcVar10;
   size_t __n;
   char *pcVar11;
   code *UNRECOVERED_JUMPTABLE;
   ulong uVar12;
   char *pcVar13;
   TPublicType TVar14;
   uint uVar15;
   long in_FS_OFFSET;
   undefined8 local_70;
   char *local_68;
   char *pcStack_60;
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   integerCheck(this, param_4, "layout-id value");
   lVar7 = ( **(code**)( *(long*)param_4 + 0x88 ) )(param_4);
   iVar6 = (int)param_1;
   if (lVar7 == 0) {
      bVar4 = true;
      uVar15 = 0;
   }
 else {
      uVar15 = **(uint**)( *(long*)( lVar7 + 0xc0 ) + 8 );
      if (*(char*)( lVar7 + 200 ) == '\0') {
         glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar6, (char*)0x6);
         glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, 6, (char*)0x1b8, "GL_ARB_enhanced_layouts");
      }

      bVar4 = false;
      if ((int)uVar15 < 0) {
         if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) goto LAB_0011c623;
         pcVar11 = "layout-id value";
         pcVar10 = "cannot be negative";
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         goto LAB_0011b529;
      }

   }

   pcVar10 = *(char**)( param_3 + 8 );
   uVar12 = *(ulong*)( param_3 + 0x10 );
   pcVar11 = pcVar10 + uVar12;
   TVar14 = SUB41(uVar15, 0);
   if (pcVar10 == pcVar11) goto LAB_0011b9d6;
   do {
      pcVar13 = pcVar10 + 1;
      iVar5 = tolower((int)*pcVar10);
      *pcVar10 = (char)iVar5;
      pcVar10 = pcVar13;
   }
 while ( pcVar13 != pcVar11 );
   uVar12 = *(ulong*)( param_3 + 0x10 );
   plVar1 = *(long**)( param_3 + 8 );
   if (uVar12 == 6) {
      if (( (int)*plVar1 != 0x7366666f ) || ( *(short*)( (long)plVar1 + 4 ) != 0x7465 )) goto LAB_0011b494;
      if (*(int*)( this + 0x20 ) == 0) {
         glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar6, (char*)0xe);
         local_68 = "GL_ARB_enhanced_layouts";
         pcStack_60 = "GL_ARB_shader_atomic_counters";
         glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, 6, 0x1a4, (char**)0x2, (char*)&local_68);
         glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, 8, (char*)0x136, (char*)0x0);
      }

      param_2[0x14] = ( TPublicType )((byte)param_2[0x14] | 4);
      *(uint*)( param_2 + 0x1c ) = uVar15;
      if (bVar4) {
         if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
            pcVar11 = "offset";
            pcVar10 = "needs a literal integer";
            UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
            goto LAB_0011b529;
         }

         goto LAB_0011c623;
      }

      goto LAB_0011b618;
   }

   if (uVar12 == 5) {
      if (( (int)*plVar1 != 0x67696c61 ) || ( *(char*)( (long)plVar1 + 4 ) != 'n' )) goto LAB_0011b494;
      if (*(int*)( this + 0x20 ) == 0) {
         glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar6, (char*)0x6);
         glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, 6, (char*)0x1b8, "GL_ARB_enhanced_layouts");
      }

      if (( uVar15 == 0 ) || ( ( uVar15 - 1 & uVar15 ) != 0 )) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "must be a power of 2", "align", &_LC1);
      }
 else {
         *(uint*)( param_2 + 0x20 ) = uVar15;
      }

      if (bVar4) {
         if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) goto LAB_0011c623;
         pcVar11 = "align";
         pcVar10 = "needs a literal integer";
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         goto LAB_0011b529;
      }

      goto LAB_0011b618;
   }

   if (uVar12 == 8) {
      if (*plVar1 != 0x6e6f697461636f6c) goto LAB_0011b494;
      glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, 8, (char*)0x12c, (char*)0x0);
      local_68 = "GL_ARB_separate_shader_objects";
      pcStack_60 = "GL_ARB_explicit_attrib_location";
      glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, -9, 0x14a, (char**)0x2, (char*)&local_68);
      if ((int)uVar15 < 0xfff) {
         *(ushort*)( param_2 + 0x24 ) = (ushort)uVar15 & 0xfff | *(ushort*)( param_2 + 0x24 ) & 0xf000;
      }
 else {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "location is too large", *(undefined8*)( param_3 + 8 ), &_LC1);
      }

      if (!bVar4) goto LAB_0011b618;
      lVar7 = *(long*)this;
      pcVar11 = "location";
      LAB_0011b5fa:( **(code**)( lVar7 + 0x158 ) )(this, param_1, "needs a literal integer", pcVar11, &_LC1);
      goto LAB_0011b618;
   }

   if (uVar12 != 3) {
      if (uVar12 == 7) {
         if (( (int)*plVar1 == 0x646e6962 ) && ( *(int*)( (long)plVar1 + 3 ) == 0x676e6964 )) {
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, -9, (char*)0x1a4, "GL_ARB_shading_language_420pack");
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, 8, (char*)0x136, (char*)0x0);
            if ((int)uVar15 < 0xffff) {
               *(ushort*)( param_2 + 0x28 ) = (ushort)uVar15;
            }
 else {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "binding is too large", *(undefined8*)( param_3 + 8 ), &_LC1);
            }

            if (bVar4) {
               if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) goto LAB_0011c623;
               pcVar11 = "binding";
               pcVar10 = "needs a literal integer";
               UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
               goto LAB_0011b529;
            }

            goto LAB_0011b618;
         }

         goto LAB_0011b494;
      }

      if (uVar12 == 0xb) {
         if (( *plVar1 != 0x746e6174736e6f63 ) || ( *(int*)( (long)plVar1 + 7 ) != 0x64695f74 )) {
            LAB_0011b8f5:__n = 4;
            goto LAB_0011b8fa;
         }

         pcVar11 = "constant_id";
         ( **(code**)( *(long*)this + 0x148 ) )(this, param_1, "constant_id");
         if ((int)uVar15 < 0x7ff) {
            param_2[0x14] = ( TPublicType )((byte)param_2[0x14] | 1);
            *(uint*)( param_2 + 0x30 ) = *(uint*)( param_2 + 0x30 ) & 0xfff800ff | ( uVar15 & 0x7ff ) << 8;
            cVar3 = glslang::TIntermediate::addUsedConstantId((int)*(undefined8*)( this + 0x38 ));
            if (cVar3 == '\0') {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "specialization-constant id already used", *(undefined8*)( param_3 + 8 ), &_LC1);
            }

         }
 else {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "specialization-constant id is too large", *(undefined8*)( param_3 + 8 ), &_LC1);
         }

      }
 else {
         if (uVar12 != 9) {
            if (uVar12 == 0) goto LAB_0011b9d6;
            goto LAB_0011b494;
         }

         if (( *plVar1 != 0x6e656e6f706d6f63 ) || ( (char)plVar1[1] != 't' )) goto LAB_0011b8f5;
         pcVar11 = "component";
         glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar6, (char*)0x6);
         glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, 6, (char*)0x1b8, "GL_ARB_enhanced_layouts");
         if ((int)uVar15 < 4) {
            param_2[0x25] = ( TPublicType )((byte)param_2[0x25] & 0x8f | ( byte )(( uVar15 & 7 ) << 4));
         }
 else {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "component is too large", *(undefined8*)( param_3 + 8 ), &_LC1);
         }

      }

      goto LAB_0011bc67;
   }

   if (( (short)*plVar1 == 0x6573 ) && ( *(char*)( (long)plVar1 + 2 ) == 't' )) {
      if ((int)uVar15 < 0x3f) {
         *(uint*)( param_2 + 0x24 ) = *(uint*)( param_2 + 0x24 ) & 0xffc07fff | ( uVar15 & 0x7f ) << 0xf;
         if (uVar15 != 0) goto LAB_0011b793;
      }
 else {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "set is too large", plVar1, &_LC1);
         LAB_0011b793:( **(code**)( *(long*)this + 0x140 ) )(this, param_1, "descriptor set");
      }

      if (bVar4) {
         if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) goto LAB_0011c623;
         pcVar11 = "set";
         pcVar10 = "needs a literal integer";
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         goto LAB_0011b529;
      }

      goto LAB_0011b618;
   }

   LAB_0011b494:__n = 4;
   if (uVar12 < 5) {
      __n = uVar12;
   }

   LAB_0011b8fa:iVar5 = memcmp(plVar1, &_LC751, __n);
   if (iVar5 == 0 && (int)__n == 4) {
      *(undefined1*)( *(long*)( this + 0x38 ) + 0x340 ) = 1;
      glslang::TParseVersions::requireStage(this, param_1, 0xf, "transform feedback qualifier");
      glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar6, (char*)0x6);
      glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, 6, (char*)0x1b8, "GL_ARB_enhanced_layouts");
      uVar12 = *(ulong*)( param_3 + 0x10 );
      if (( ( uVar12 == 10 ) && ( plVar1 = *(long**)( param_3 + 8 ) * plVar1 == 0x666675625f626678 ) ) && ( (short)plVar1[1] == 0x7265 )) {
         if (*(int*)( this + 0x6f8 ) <= (int)uVar15) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "buffer is too large:", plVar1, "gl_MaxTransformFeedbackBuffers is %d");
         }

         if ((int)uVar15 < 0xf) {
            param_2[0x2c] = ( TPublicType )((byte)param_2[0x2c] & 0xf0 | (byte)TVar14 & 0xf);
         }
 else {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "buffer is too large:", *(undefined8*)( param_3 + 8 ), "internal max is %d", 0xe);
         }

         if (bVar4) {
            if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) goto LAB_0011c623;
            pcVar11 = "xfb_buffer";
            pcVar10 = "needs a literal integer";
            UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
            goto LAB_0011b529;
         }

         goto LAB_0011b618;
      }

      pcVar11 = "xfb_offset";
      bVar2 = std::operator ==(param_3, "xfb_offset");
      if (bVar2) {
         if ((int)uVar15 < 0x1fff) {
            *(ushort*)( param_2 + 0x2e ) = *(ushort*)( param_2 + 0x2e ) & 0x8003 | ( ushort )(( uVar15 & 0xffff1fff ) << 2);
         }
 else {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "offset is too large:", *(undefined8*)( param_3 + 8 ), "internal max is %d", 0x1ffe);
         }

      }
 else {
         pcVar11 = "xfb_stride";
         bVar2 = std::operator ==(param_3, "xfb_stride");
         if (!bVar2) goto LAB_0011b9d6;
         if (*(int*)( this + 0x6fc ) * 4 < (int)uVar15) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "1/4 stride is too large:", *(undefined8*)( param_3 + 8 ), "gl_MaxTransformFeedbackInterleavedComponents is %d");
         }

         if ((int)uVar15 < 0x3fff) {
            *(uint*)( param_2 + 0x2c ) = *(uint*)( param_2 + 0x2c ) & 0xfffc000f | ( uVar15 & 0x3fff ) << 4;
         }
 else {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "stride is too large:", *(undefined8*)( param_3 + 8 ), "internal max is %d", 0x3ffe);
         }

      }

      goto LAB_0011bc67;
   }

   LAB_0011b9d6:if (uVar12 == 0x16) {
      plVar1 = *(long**)( param_3 + 8 );
      if (( *plVar1 == 0x74615f7475706e69 && plVar1[1] == 0x746e656d68636174 ) && ( *(long*)( (long)plVar1 + 0xe ) == 0x7865646e695f746e )) {
         pcVar11 = "input_attachment_index";
         ( **(code**)( *(long*)this + 0x140 ) )(this, param_1, "input_attachment_index");
         if ((int)uVar15 < 0xff) {
            param_2[0x30] = TVar14;
         }
 else {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "attachment index is too large", *(undefined8*)( param_3 + 8 ), &_LC1);
         }

         goto LAB_0011bc67;
      }

      uVar8 = *(uint*)( this + 0x1c );
      if (( uVar8 < 4 ) && ( bVar2 = bVar2 )) goto LAB_0011ba2e;
      if (( *plVar1 != 0x725f726566667562 || plVar1[1] != 0x65636e6572656665 ) || ( *(long*)( (long)plVar1 + 0xe ) != 0x6e67696c615f6563 )) goto LAB_0011be1f;
      ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_EXT_buffer_reference, "buffer_reference_align");
      if (( uVar15 == 0 ) || ( ( uVar15 - 1 & uVar15 ) != 0 )) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "must be a power of 2", "buffer_reference_align", &_LC1);
      }
 else {
         uVar8 = 0;
         uVar9 = 0;
         if (uVar15 != 1) {
            do {
               uVar8 = uVar8 + 1;
               uVar9 = uVar8;
            }
 while ( uVar15 != 1 << ( (byte)uVar8 & 0x1f ) );
         }

         *(ushort*)( param_2 + 0x32 ) = ( ushort )(( uVar9 & 0x3f ) << 3) | *(ushort*)( param_2 + 0x32 ) & 0xfe07;
      }

      if (bVar4) {
         if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) goto LAB_0011c623;
         pcVar11 = "buffer_reference_align";
         pcVar10 = "needs a literal integer";
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         goto LAB_0011b529;
      }

      goto LAB_0011b618;
   }

   if (( ( uVar12 == 9 ) && ( **(long**)( param_3 + 8 ) == 0x776569765f6d756e ) ) && ( (char)( *(long**)( param_3 + 8 ) )[1] == 's' )) {
      ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 2, OVR_multiview_EXTs, "num_views");
      *(uint*)( param_2 + 0xa4 ) = uVar15;
      if (bVar4) {
         if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) goto LAB_0011c623;
         pcVar11 = "num_views";
         pcVar10 = "needs a literal integer";
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         goto LAB_0011b529;
      }

      goto LAB_0011b618;
   }

   uVar8 = *(uint*)( this + 0x1c );
   if (( uVar8 < 4 ) && ( bVar2 = bVar2 )) {
      LAB_0011ba2e:pcVar11 = "secondary_view_offset";
      ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_NV_stereo_view_rendering, "stereo view rendering");
      *(uint*)( param_2 + 0x3c ) = uVar15;
      if (bVar4) {
         if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) goto LAB_0011c623;
         pcVar10 = "needs a literal integer";
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         goto LAB_0011b529;
      }

      goto LAB_0011b618;
   }

   LAB_0011be1f:switch (uVar8) {
      case 1:
    pcVar11 = "vertices";
    bVar2 = std::operator==(param_3,"vertices");
    if (bVar2) {
      if (uVar15 == 0) {
        (**(code **)(*(long *)this + 0x158))(this,param_1,"must be greater than 0","vertices",&_LC1)
        ;
      }
      else {
        *(uint *)(param_2 + 100) = uVar15;
      }
      goto LAB_0011bc67;
    }
    break;
      case 3:
    pcVar11 = "invocations";
    bVar2 = std::operator==(param_3,"invocations");
    if (bVar2) {
      glslang::TParseVersions::profileRequires((TSourceLoc *)this,iVar6,6,(char *)0x190,(char *)0x0)
      ;
      if (uVar15 == 0) {
        (**(code **)(*(long *)this + 0x158))(this,param_1,"must be at least 1","invocations",&_LC1);
      }
      else {
        *(uint *)(param_2 + 0x60) = uVar15;
      }
    }
    else {
      pcVar11 = "max_vertices";
      bVar2 = std::operator==(param_3,"max_vertices");
      if (bVar2) {
        *(uint *)(param_2 + 100) = uVar15;
        if (*(int *)(this + 0x67c) < (int)uVar15) {
          (**(code **)(*(long *)this + 0x158))
                    (this,param_1,"too large, must be less than gl_MaxGeometryOutputVertices",
                     "max_vertices",&_LC1);
        }
      }
      else {
        pcVar11 = "stream";
        bVar2 = std::operator==(param_3,"stream");
        if (!bVar2) break;
        glslang::TParseVersions::requireProfile((TSourceLoc *)this,iVar6,(char *)0xfffffff7);
        param_2[0x2b] = TVar14;
        if (uVar15 != 0) {
          *(undefined1 *)(*(long *)(this + 0x38) + 0x360) = 1;
        }
      }
    }
    goto LAB_0011bc67;
      case 4:
    bVar2 = std::operator==(param_3,"index");
    if (bVar2) {
      glslang::TParseVersions::requireProfile((TSourceLoc *)this,iVar6,(char *)0xe);
      local_68 = "GL_ARB_separate_shader_objects";
      pcStack_60 = "GL_ARB_explicit_attrib_location";
      glslang::TParseVersions::profileRequires
                ((TSourceLoc *)this,iVar6,6,0x14a,(char **)0x2,(char *)&local_68);
      glslang::TParseVersions::profileRequires
                ((TSourceLoc *)this,iVar6,8,(char *)0x136,"GL_EXT_blend_func_extended");
      if (1 < (int)uVar15) {
        uVar15 = 0;
        (**(code **)(*(long *)this + 0x158))(this,param_1,"value must be 0 or 1","index",&_LC1);
      }
      param_2[0x2a] = SUB41(uVar15,0);
      if (bVar4) {
        lVar7 = *(long *)this;
        pcVar11 = "index";
        goto LAB_0011b5fa;
      }
      goto LAB_0011b618;
    }
    break;
      case 5:
      case 0xc:
    iVar5 = std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::
            compare(*(ulong *)(param_3 + 8),uVar12,(char *)0x0);
    if (iVar5 == 0) {
      if (uVar8 - 0xc < 2) {
LAB_0011c6b4:
        (**(code **)(*(long *)this + 0x28))(this,param_1,2,AEP_mesh_shader,"gl_WorkGroupSize");
      }
      else {
        glslang::TParseVersions::profileRequires
                  ((TSourceLoc *)this,iVar6,8,(char *)0x136,(char *)0x0);
        glslang::TParseVersions::profileRequires
                  ((TSourceLoc *)this,iVar6,-9,(char *)0x1ae,"GL_ARB_compute_shader");
      }
      if (bVar4) {
        (**(code **)(*(long *)this + 0x158))
                  (this,param_1,"needs a literal integer","local_size",&_LC1);
      }
      if ((*(long *)(param_3 + 0x10) == 0xc) && (uVar15 == 0)) {
        if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) goto LAB_0011c623;
        pcVar11 = *(char **)(param_3 + 8);
        pcVar10 = "must be at least 1";
        UNRECOVERED_JUMPTABLE = *(code **)(*(long *)this + 0x158);
        goto LAB_0011b529;
      }
      bVar4 = std::operator==(param_3,"local_size_x");
      if (bVar4) {
        *(uint *)(param_2 + 0x74) = uVar15;
        param_2[0x80] = (TPublicType)0x1;
      }
      else {
        bVar4 = std::operator==(param_3,"local_size_y");
        if (bVar4) {
          *(uint *)(param_2 + 0x78) = uVar15;
          param_2[0x81] = (TPublicType)0x1;
        }
        else {
          bVar4 = std::operator==(param_3,"local_size_z");
          if (bVar4) {
            *(uint *)(param_2 + 0x7c) = uVar15;
            param_2[0x82] = (TPublicType)0x1;
          }
          else {
            if (*(int *)(this + 0x20) == 0) break;
            bVar4 = std::operator==(param_3,"local_size_x_id");
            if (bVar4) {
              *(uint *)(param_2 + 0x84) = uVar15;
            }
            else {
              bVar4 = std::operator==(param_3,"local_size_y_id");
              if (bVar4) {
                *(uint *)(param_2 + 0x88) = uVar15;
              }
              else {
                bVar4 = std::operator==(param_3,"local_size_z_id");
                if (!bVar4) break;
                *(uint *)(param_2 + 0x8c) = uVar15;
              }
            }
          }
        }
      }
      goto LAB_0011b618;
    }
    break;
      case 0xd:
    pcVar11 = "max_vertices";
    bVar2 = std::operator==(param_3,"max_vertices");
    if (bVar2) {
      (**(code **)(*(long *)this + 0x28))(this,param_1,2,AEP_mesh_shader,"max_vertices");
      lVar7 = *(long *)this;
      *(uint *)(param_2 + 100) = uVar15;
      cVar3 = (**(code **)(lVar7 + 0x40))(this,"GL_EXT_mesh_shader");
      if (cVar3 == '\0') {
        iVar6 = *(int *)(this + 0x70c);
      }
      else {
        iVar6 = *(int *)(this + 0x730);
      }
      if (iVar6 < (int)uVar15) {
        local_70 = glslang::GetThreadPoolAllocator();
        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::
        basic_string<glslang::std::allocator<char>>
                  ((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *)
                   &local_68,"too large, must be less than ",(allocator *)&local_70);
        cVar3 = (**(code **)(*(long *)this + 0x40))(this,"GL_EXT_mesh_shader");
        pcVar10 = "gl_MaxMeshOutputVerticesNV";
        pcVar13 = "gl_MaxMeshOutputVerticesEXT";
LAB_0011c098:
        if (cVar3 != '\0') {
          pcVar10 = pcVar13;
        }
        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::
        append((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *)&local_68,
               pcVar10);
        (**(code **)(*(long *)this + 0x158))(this,param_1,pcStack_60,pcVar11,&_LC1);
      }
    }
    else {
      pcVar11 = "max_primitives";
      bVar2 = std::operator==(param_3,"max_primitives");
      if (!bVar2) {
        iVar6 = std::__cxx11::
                basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::compare
                          (*(ulong *)(param_3 + 8),uVar12,(char *)0x0);
        if (iVar6 == 0) goto LAB_0011c6b4;
        break;
      }
      (**(code **)(*(long *)this + 0x28))(this,param_1,2,AEP_mesh_shader,"max_primitives");
      lVar7 = *(long *)this;
      *(uint *)(param_2 + 0xb0) = uVar15;
      cVar3 = (**(code **)(lVar7 + 0x40))(this,"GL_EXT_mesh_shader");
      if (cVar3 == '\0') {
        iVar6 = *(int *)(this + 0x710);
      }
      else {
        iVar6 = *(int *)(this + 0x734);
      }
      if (iVar6 < (int)uVar15) {
        local_70 = glslang::GetThreadPoolAllocator();
        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::
        basic_string<glslang::std::allocator<char>>
                  ((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *)
                   &local_68,"too large, must be less than ",(allocator *)&local_70);
        cVar3 = (**(code **)(*(long *)this + 0x40))(this,"GL_EXT_mesh_shader");
        pcVar10 = "gl_MaxMeshOutputPrimitivesNV";
        pcVar13 = "gl_MaxMeshOutputPrimitivesEXT";
        goto LAB_0011c098;
      }
    }
LAB_0011bc67:
    if (!bVar4) {
LAB_0011b618:
      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {
        return;
      }
      goto LAB_0011c623;
    }
    if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) goto LAB_0011c623;
    pcVar10 = "needs a literal integer";
    UNRECOVERED_JUMPTABLE = *(code **)(*(long *)this + 0x158);
    goto LAB_0011b529;
   }

   if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
      LAB_0011c623:/* WARNING: Subroutine does not return */__stack_chk_fail();
   }

   pcVar11 = *(char**)( param_3 + 8 );
   pcVar10 = "there is no such layout identifier for this stage taking an assigned value";
   UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
   LAB_0011b529:/* WARNING: Could not recover jumptable at 0x0011b540. Too many branches *//* WARNING: Treating indirect jump as call */( *UNRECOVERED_JUMPTABLE )(this, param_1, pcVar10, pcVar11, &_LC1, UNRECOVERED_JUMPTABLE);
   return;
}
/* glslang::TParseContext::nonOpBuiltInCheck(glslang::TSourceLoc const&, glslang::TFunction const&,
   glslang::TIntermAggregate&) */void glslang::TParseContext::nonOpBuiltInCheck(TParseContext *this, TSourceLoc *param_1, TFunction *param_2, TIntermAggregate *param_3) {
   ulong uVar1;
   byte bVar2;
   byte bVar3;
   undefined1 *puVar4;
   char cVar5;
   int iVar6;
   uint uVar7;
   int iVar8;
   long lVar9;
   long *plVar10;
   long lVar11;
   undefined8 uVar12;
   size_t sVar13;
   char *pcVar14;
   ulong uVar15;
   TIntermAggregate *pTVar16;
   code *UNRECOVERED_JUMPTABLE_00;
   TFunction *pTVar17;
   void *pvVar18;
   ulong uVar19;
   long in_FS_OFFSET;
   undefined1 auVar20[16];
   undefined8 uStack_90;
   long local_78;
   undefined8 local_68;
   undefined1 *local_60;
   ulong local_58;
   undefined1 local_50;
   undefined7 uStack_4f;
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(code**)( *(long*)param_2 + 0x60 ) == TFunction::getType) {
      pTVar17 = param_2 + 0x48;
   }
 else {
      pTVar17 = (TFunction*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
   }

   if (*(code**)( *(long*)pTVar17 + 0x58 ) == TType::getQualifier) {
      pTVar17 = pTVar17 + 0x10;
   }
 else {
      pTVar17 = (TFunction*)( **(code**)( *(long*)pTVar17 + 0x58 ) )();
   }

   lVar11 = *(long*)param_2;
   if (( (byte)pTVar17[0xb] & 0xe ) == 0) {
      if (*(code**)( lVar11 + 0x120 ) == TFunction::getParamCount) {
         iVar6 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
      }
 else {
         iVar6 = ( **(code**)( lVar11 + 0x120 ) )(param_2);
         lVar11 = *(long*)param_2;
      }

      if (0 < iVar6) {
         if (*(code**)( lVar11 + 0x140 ) == TFunction::operator []) {
            lVar11 = *(long*)( param_2 + 0x30 );
         }
 else {
            lVar11 = ( **(code**)( lVar11 + 0x140 ) )(param_2, 0);
         }

         UNRECOVERED_JUMPTABLE_00 = *(code**)( **(long**)( lVar11 + 8 ) + 0x38 );
         if (UNRECOVERED_JUMPTABLE_00 == TType::getBasicType) {
            uVar7 = ( uint ) * (byte*)( *(long**)( lVar11 + 8 ) + 1 );
         }
 else {
            uVar7 = ( *UNRECOVERED_JUMPTABLE_00 )();
         }

         if (uVar7 == 0xe) {
            if (*(code**)( *(long*)param_3 + 400 ) == TIntermAggregate::getSequence) {
               pTVar16 = param_3 + 0xc0;
            }
 else {
               pTVar16 = (TIntermAggregate*)( **(code**)( *(long*)param_3 + 400 ) )(param_3);
            }

            plVar10 = (long*)( **(code**)( *(long*)**(undefined8**)( pTVar16 + 8 ) + 0x18 ) )();
            if (*(code**)( *plVar10 + 0x108 ) == TIntermTyped::getQualifier) {
               plVar10 = plVar10 + 6;
            }
 else {
               plVar10 = (long*)( **(code**)( *plVar10 + 0x108 ) )();
            }

            bVar2 = *(byte*)( (long)plVar10 + 0xb );
            if (*(code**)( *(long*)param_3 + 0x108 ) == TIntermTyped::getQualifier) {
               pTVar16 = param_3 + 0x30;
            }
 else {
               pTVar16 = (TIntermAggregate*)( **(code**)( *(long*)param_3 + 0x108 ) )(param_3);
            }

            pTVar16[0xb] = ( TIntermAggregate )((byte)pTVar16[0xb] & 0xf1 | ( bVar2 >> 1 & 7 ) * '\x02');
            lVar11 = *(long*)param_2;
         }
 else {
            lVar11 = *(long*)param_2;
         }

      }

   }

   if (*(code**)( lVar11 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
      lVar11 = *(long*)( param_2 + 8 );
      UNRECOVERED_JUMPTABLE_00 = TSymbol::getName_abi_cxx11_;
   }
 else {
      lVar11 = ( **(code**)( lVar11 + 0x18 ) )(param_2);
      UNRECOVERED_JUMPTABLE_00 = *(code**)( *(long*)param_2 + 0x18 );
   }

   uVar19 = *(ulong*)( lVar11 + 0x10 );
   iVar6 = (int)param_1;
   if (uVar19 == 0) {
      LAB_0011c949:if (UNRECOVERED_JUMPTABLE_00 == TSymbol::getName_abi_cxx11_) {
         LAB_0011c959:lVar11 = *(long*)( param_2 + 8 );
         LAB_0011c95d:pcVar14 = *(char**)( lVar11 + 8 );
         uVar19 = *(ulong*)( lVar11 + 0x10 );
         goto LAB_0011c967;
      }

      LAB_0011cc18:lVar11 = ( *UNRECOVERED_JUMPTABLE_00 )(param_2);
      uVar19 = *(ulong*)( lVar11 + 0x10 );
      pcVar14 = *(char**)( lVar11 + 8 );
      if (uVar19 != 0) goto LAB_0011cc2f;
      LAB_0011c970:if (*(code**)( *(long*)param_2 + 0x18 ) != TSymbol::getName_abi_cxx11_) {
         lVar11 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
         uVar19 = *(ulong*)( lVar11 + 0x10 );
         if (uVar19 != 0) goto LAB_0011cde2;
         goto LAB_0011cc7b;
      }

      lVar11 = *(long*)( param_2 + 8 );
      uVar19 = *(ulong*)( lVar11 + 0x10 );
      if (uVar19 != 0) {
         LAB_0011cde2:sVar13 = 0xc;
         if (uVar19 < 0xd) {
            sVar13 = uVar19;
         }

         iVar8 = memcmp(*(void**)( lVar11 + 8 ), "imageSamples", sVar13);
         if (iVar8 == 0 && (int)sVar13 == 0xc) goto LAB_0011cc57;
         goto LAB_0011cc7b;
      }

      LAB_0011c99c:uVar19 = *(ulong*)( lVar11 + 0x10 );
      pvVar18 = *(void**)( lVar11 + 8 );
   }
 else {
      sVar13 = 7;
      if (uVar19 < 8) {
         sVar13 = uVar19;
      }

      iVar8 = memcmp(*(void**)( lVar11 + 8 ), "texture", sVar13);
      if (iVar8 != 0 || (int)sVar13 != 7) goto LAB_0011c949;
      if (UNRECOVERED_JUMPTABLE_00 == TSymbol::getName_abi_cxx11_) {
         lVar11 = *(long*)( param_2 + 8 );
         uVar19 = *(ulong*)( lVar11 + 0x10 );
         pvVar18 = *(void**)( lVar11 + 8 );
         UNRECOVERED_JUMPTABLE_00 = TSymbol::getName_abi_cxx11_;
         if (uVar19 == 0) goto LAB_0011ca29;
         LAB_0011ce20:sVar13 = 0xd;
         if (uVar19 < 0xe) {
            sVar13 = uVar19;
         }

         iVar8 = memcmp(pvVar18, "textureGather", sVar13);
         if (iVar8 != 0 || (int)sVar13 != 0xd) goto LAB_0011d37e;
         if (UNRECOVERED_JUMPTABLE_00 == TSymbol::getName_abi_cxx11_) {
            lVar11 = *(long*)( param_2 + 8 );
         }
 else {
            lVar11 = ( *UNRECOVERED_JUMPTABLE_00 )(param_2);
         }

         uVar19 = *(ulong*)( lVar11 + 0x10 );
         pcVar14 = *(char**)( lVar11 + 8 );
         local_68 = glslang::GetThreadPoolAllocator();
         local_58 = 0;
         local_50 = 0;
         local_60 = &local_50;
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::reserve((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_68, uVar19 + 5);
         if (( 0x7fffffffffffffff - local_58 < uVar19 ) || ( std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_append((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_68, pcVar14, uVar19),uVar19 = local_58,0x7fffffffffffffff - local_58 < 5 )) {
            /* WARNING: Subroutine does not return */
            std::__throw_length_error("basic_string::append");
         }

         uVar1 = local_58 + 5;
         if (local_60 == &local_50) {
            uVar15 = 0xf;
         }
 else {
            uVar15 = CONCAT71(uStack_4f, local_50);
         }

         if (uVar15 < uVar1) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_68, local_58, 0, "(...)", 5);
         }
 else {
            *(undefined4*)( local_60 + local_58 ) = 0x2e2e2e28;
            *(undefined1*)( (long)( local_60 + local_58 ) + 4 ) = 0x29;
         }

         puVar4 = local_60;
         local_60[uVar19 + 5] = 0;
         local_58 = uVar1;
         glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, 8, (char*)0x136, (char*)0x0);
         lVar11 = *(long*)param_2;
         if (*(code**)( lVar11 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            lVar9 = *(long*)( param_2 + 8 );
         }
 else {
            lVar9 = ( **(code**)( lVar11 + 0x18 ) )(param_2);
            lVar11 = *(long*)param_2;
         }

         uVar19 = *(ulong*)( lVar9 + 0x10 );
         if (( ( ( uVar19 < 0x14 ) && ( uVar19 != 0 ) ) && ( iVar8 = memcmp(*(void**)( lVar9 + 8 ), "textureGatherOffset", uVar19) ),iVar8 == 0 )) {
            if (*(code**)( lVar11 + 0x140 ) == TFunction::operator []) {
               lVar11 = *(long*)( param_2 + 0x30 );
            }
 else {
               lVar11 = ( **(code**)( lVar11 + 0x140 ) )(param_2, 0);
            }

            UNRECOVERED_JUMPTABLE_00 = *(code**)( **(long**)( lVar11 + 8 ) + 0x48 );
            if (UNRECOVERED_JUMPTABLE_00 == TType::getSampler) {
               plVar10 = *(long**)( lVar11 + 8 ) + 0x10;
            }
 else {
               plVar10 = (long*)( *UNRECOVERED_JUMPTABLE_00 )();
            }

            if (*(char*)( (long)plVar10 + 1 ) == '\x02') {
               if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                  lVar11 = *(long*)( param_2 + 0x30 );
               }
 else {
                  lVar11 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
               }

               UNRECOVERED_JUMPTABLE_00 = *(code**)( **(long**)( lVar11 + 8 ) + 0x48 );
               if (UNRECOVERED_JUMPTABLE_00 == TType::getSampler) {
                  plVar10 = *(long**)( lVar11 + 8 ) + 0x10;
               }
 else {
                  plVar10 = (long*)( *UNRECOVERED_JUMPTABLE_00 )();
               }

               if (( *plVar10 & 0x20000 ) != 0) goto LAB_0011d018;
               if (*(code**)( *(long*)param_2 + 0x120 ) == TFunction::getParamCount) {
                  iVar8 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
               }
 else {
                  iVar8 = ( **(code**)( *(long*)param_2 + 0x120 ) )(param_2);
               }

               if (iVar8 != 3) goto LAB_0011d018;
               pcVar14 = "GL_ARB_texture_gather";
            }
 else {
               LAB_0011d018:pcVar14 = "GL_ARB_gpu_shader5";
            }

            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, -9, (char*)0x190, pcVar14);
            if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
               lVar11 = *(long*)( param_2 + 0x30 );
            }
 else {
               lVar11 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
            }

            UNRECOVERED_JUMPTABLE_00 = *(code**)( **(long**)( lVar11 + 8 ) + 0x48 );
            if (UNRECOVERED_JUMPTABLE_00 == TType::getSampler) {
               plVar10 = *(long**)( lVar11 + 8 ) + 0x10;
            }
 else {
               plVar10 = (long*)( *UNRECOVERED_JUMPTABLE_00 )();
            }

            bVar2 = *(byte*)( (long)plVar10 + 2 );
            if (*(code**)( *(long*)param_3 + 400 ) == TIntermAggregate::getSequence) {
               pTVar16 = param_3 + 0xc0;
            }
 else {
               pTVar16 = (TIntermAggregate*)( **(code**)( *(long*)param_3 + 400 ) )(param_3);
            }

            uStack_90 = 0x11d0ac;
            auVar20 = ( **(code**)( **(long**)( *(long*)( pTVar16 + 8 ) + (long)(int)( ( bVar2 >> 1 & 1 ) + 2 ) * 8 ) + 0x28 ) )();
            uVar12 = auVar20._8_8_;
            if (auVar20._0_8_ == 0) {
               glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, 8, 0x140, (char**)0x2, AEP_gpu_shader5);
               uVar12 = uStack_90;
            }

            if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
               lVar11 = *(long*)( param_2 + 0x30 );
            }
 else {
               lVar11 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0, uVar12);
            }

            UNRECOVERED_JUMPTABLE_00 = *(code**)( **(long**)( lVar11 + 8 ) + 0x48 );
            if (UNRECOVERED_JUMPTABLE_00 == TType::getSampler) {
               plVar10 = *(long**)( lVar11 + 8 ) + 0x10;
            }
 else {
               plVar10 = (long*)( *UNRECOVERED_JUMPTABLE_00 )();
            }

            lVar11 = *(long*)param_2;
            if (( *plVar10 & 0x20000 ) == 0) {
               LAB_0011d0f4:lVar9 = 3;
               goto LAB_0011d101;
            }

         }
 else {
            if (*(code**)( lVar11 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
               lVar11 = *(long*)( param_2 + 8 );
            }
 else {
               lVar11 = ( **(code**)( lVar11 + 0x18 ) )(param_2);
            }

            uVar19 = *(ulong*)( lVar11 + 0x10 );
            if (( ( uVar19 < 0x15 ) && ( uVar19 != 0 ) ) && ( ( iVar8 = memcmp(*(void**)( lVar11 + 8 ), "textureGatherOffsets", uVar19) ),iVar8 == 0 && ( (int)uVar19 == 0x14 ) )) {
               glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, -9, (char*)0x190, "GL_ARB_gpu_shader5");
               if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                  lVar11 = *(long*)( param_2 + 0x30 );
               }
 else {
                  lVar11 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
               }

               UNRECOVERED_JUMPTABLE_00 = *(code**)( **(long**)( lVar11 + 8 ) + 0x48 );
               if (UNRECOVERED_JUMPTABLE_00 == TType::getSampler) {
                  plVar10 = *(long**)( lVar11 + 8 ) + 0x10;
               }
 else {
                  plVar10 = (long*)( *UNRECOVERED_JUMPTABLE_00 )();
               }

               bVar2 = *(byte*)( (long)plVar10 + 2 );
               if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                  lVar11 = *(long*)( param_2 + 0x30 );
               }
 else {
                  lVar11 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
               }

               UNRECOVERED_JUMPTABLE_00 = *(code**)( **(long**)( lVar11 + 8 ) + 0x48 );
               if (UNRECOVERED_JUMPTABLE_00 == TType::getSampler) {
                  plVar10 = *(long**)( lVar11 + 8 ) + 0x10;
               }
 else {
                  plVar10 = (long*)( *UNRECOVERED_JUMPTABLE_00 )();
               }

               bVar3 = *(byte*)( (long)plVar10 + 2 );
               if (*(code**)( *(long*)param_3 + 400 ) == TIntermAggregate::getSequence) {
                  pTVar16 = param_3 + 0xc0;
               }
 else {
                  pTVar16 = (TIntermAggregate*)( **(code**)( *(long*)param_3 + 400 ) )(param_3);
               }

               lVar11 = ( **(code**)( **(long**)( *(long*)( pTVar16 + 8 ) + (long)(int)( ( bVar3 >> 1 & 1 ) + 2 ) * 8 ) + 0x28 ) )();
               if (lVar11 == 0) {
                  ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "must be a compile-time constant:", puVar4, "offsets argument");
               }

               lVar11 = *(long*)param_2;
               if ((int)( ( -(uint)((bVar2 >> 1 & 1) == 0) & 4 ) - 1 ) < 1) goto LAB_0011d1c7;
               goto LAB_0011d0f4;
            }

            lVar11 = *(long*)param_2;
            if (*(code**)( lVar11 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
               lVar9 = *(long*)( param_2 + 8 );
            }
 else {
               lVar9 = ( **(code**)( lVar11 + 0x18 ) )(param_2);
               lVar11 = *(long*)param_2;
            }

            uVar19 = *(ulong*)( lVar9 + 0x10 );
            if (( ( 0xd < uVar19 ) || ( uVar19 == 0 ) ) || ( ( iVar8 = memcmp(*(void**)( lVar9 + 8 ), "textureGather", uVar19) ),iVar8 != 0 || ( (int)uVar19 != 0xd ) )) goto LAB_0011d1c7;
            if (*(code**)( lVar11 + 0x120 ) == TFunction::getParamCount) {
               iVar8 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
            }
 else {
               iVar8 = ( **(code**)( lVar11 + 0x120 ) )(param_2);
            }

            if (iVar8 < 3) {
               if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                  lVar11 = *(long*)( param_2 + 0x30 );
               }
 else {
                  lVar11 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
               }

               UNRECOVERED_JUMPTABLE_00 = *(code**)( **(long**)( lVar11 + 8 ) + 0x48 );
               if (UNRECOVERED_JUMPTABLE_00 == TType::getSampler) {
                  plVar10 = *(long**)( lVar11 + 8 ) + 0x10;
               }
 else {
                  plVar10 = (long*)( *UNRECOVERED_JUMPTABLE_00 )();
               }

               if (*(char*)( (long)plVar10 + 1 ) != '\x05') {
                  if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                     lVar11 = *(long*)( param_2 + 0x30 );
                  }
 else {
                     lVar11 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
                  }

                  UNRECOVERED_JUMPTABLE_00 = *(code**)( **(long**)( lVar11 + 8 ) + 0x48 );
                  if (UNRECOVERED_JUMPTABLE_00 == TType::getSampler) {
                     plVar10 = *(long**)( lVar11 + 8 ) + 0x10;
                  }
 else {
                     plVar10 = (long*)( *UNRECOVERED_JUMPTABLE_00 )();
                  }

                  if (( *plVar10 & 0x20000 ) == 0) {
                     glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, -9, (char*)0x190, "GL_ARB_texture_gather");
                     lVar11 = *(long*)param_2;
                     goto LAB_0011d1c7;
                  }

               }

            }

            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, -9, (char*)0x190, "GL_ARB_gpu_shader5");
            if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
               lVar11 = *(long*)( param_2 + 0x30 );
            }
 else {
               lVar11 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
            }

            UNRECOVERED_JUMPTABLE_00 = *(code**)( **(long**)( lVar11 + 8 ) + 0x48 );
            if (UNRECOVERED_JUMPTABLE_00 == TType::getSampler) {
               plVar10 = *(long**)( lVar11 + 8 ) + 0x10;
            }
 else {
               plVar10 = (long*)( *UNRECOVERED_JUMPTABLE_00 )();
            }

            lVar11 = *(long*)param_2;
            if (( *plVar10 & 0x20000 ) != 0) goto LAB_0011d1c7;
            lVar9 = 2;
            LAB_0011d101:if (*(code**)( lVar11 + 0x120 ) == TFunction::getParamCount) {
               iVar8 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
            }
 else {
               iVar8 = ( **(code**)( lVar11 + 0x120 ) )(param_2);
            }

            if ((int)lVar9 < iVar8) {
               if (*(code**)( *(long*)param_3 + 400 ) == TIntermAggregate::getSequence) {
                  pTVar16 = param_3 + 0xc0;
               }
 else {
                  pTVar16 = (TIntermAggregate*)( **(code**)( *(long*)param_3 + 400 ) )(param_3);
               }

               lVar11 = ( **(code**)( **(long**)( *(long*)( pTVar16 + 8 ) + lVar9 * 8 ) + 0x28 ) )();
               if (lVar11 == 0) {
                  lVar11 = *(long*)this;
                  pcVar14 = "must be a compile-time constant:";
               }
 else {
                  if (*(code**)( *(long*)param_3 + 400 ) == TIntermAggregate::getSequence) {
                     pTVar16 = param_3 + 0xc0;
                  }
 else {
                     pTVar16 = (TIntermAggregate*)( **(code**)( *(long*)param_3 + 400 ) )(param_3);
                  }

                  lVar11 = ( **(code**)( **(long**)( *(long*)( pTVar16 + 8 ) + lVar9 * 8 ) + 0x28 ) )();
                  if (**(uint**)( *(long*)( lVar11 + 0xc0 ) + 8 ) < 4) goto LAB_0011d1c4;
                  lVar11 = *(long*)this;
                  pcVar14 = "must be 0, 1, 2, or 3:";
               }

               ( **(code**)( lVar11 + 0x158 ) )(this, param_1, pcVar14, puVar4, "component argument");
            }

            LAB_0011d1c4:lVar11 = *(long*)param_2;
         }

         LAB_0011d1c7:UNRECOVERED_JUMPTABLE_00 = *(code**)( lVar11 + 0x18 );
         goto LAB_0011c949;
      }

      lVar11 = ( *UNRECOVERED_JUMPTABLE_00 )(param_2);
      pvVar18 = *(void**)( lVar11 + 8 );
      uVar19 = *(ulong*)( lVar11 + 0x10 );
      UNRECOVERED_JUMPTABLE_00 = *(code**)( *(long*)param_2 + 0x18 );
      if (uVar19 != 0) goto LAB_0011ce20;
      LAB_0011d37e:if (UNRECOVERED_JUMPTABLE_00 != TSymbol::getName_abi_cxx11_) {
         lVar11 = ( *UNRECOVERED_JUMPTABLE_00 )(param_2);
         lVar9 = std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::find(*(char**)( lVar11 + 8 ), *(ulong*)( lVar11 + 0x10 ), 0x153774);
         lVar11 = *(long*)param_2;
         if (lVar9 != -1) {
            if (*(code**)( lVar11 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
               pcVar14 = *(char**)( *(long*)( param_2 + 8 ) + 8 );
               uVar19 = *(ulong*)( *(long*)( param_2 + 8 ) + 0x10 );
            }
 else {
               lVar11 = ( **(code**)( lVar11 + 0x18 ) )(param_2);
               pcVar14 = *(char**)( lVar11 + 8 );
               uVar19 = *(ulong*)( lVar11 + 0x10 );
            }

            goto LAB_0011ca57;
         }

         LAB_0011cbfe:UNRECOVERED_JUMPTABLE_00 = *(code**)( lVar11 + 0x18 );
         if (UNRECOVERED_JUMPTABLE_00 != TSymbol::getName_abi_cxx11_) goto LAB_0011cc18;
         goto LAB_0011c959;
      }

      lVar11 = *(long*)( param_2 + 8 );
      LAB_0011ca29:pcVar14 = *(char**)( lVar11 + 8 );
      uVar19 = *(ulong*)( lVar11 + 0x10 );
      lVar9 = std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::find(pcVar14, uVar19, 0x153774);
      if (lVar9 == -1) goto LAB_0011c95d;
      LAB_0011ca57:if (( ( ( uVar19 < 0xe ) && ( uVar19 != 0 ) ) && ( iVar8 = memcmp(pcVar14, "textureOffset", uVar19) ),iVar8 == 0 )) {
         LAB_0011ca8e:local_78 = 0x10;
         LAB_0011ca97:if (*(code**)( *(long*)param_3 + 400 ) == TIntermAggregate::getSequence) {
            pTVar16 = param_3 + 0xc0;
         }
 else {
            pTVar16 = (TIntermAggregate*)( **(code**)( *(long*)param_3 + 400 ) )(param_3);
         }

         lVar11 = ( **(code**)( **(long**)( *(long*)( pTVar16 + 8 ) + local_78 ) + 0x28 ) )();
         if (lVar11 == 0) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "argument must be compile-time constant", "texel offset", &_LC1);
            UNRECOVERED_JUMPTABLE_00 = *(code**)( *(long*)param_2 + 0x18 );
            goto LAB_0011c949;
         }

         if (*(code**)( *(long*)param_3 + 400 ) == TIntermAggregate::getSequence) {
            pTVar16 = param_3 + 0xc0;
         }
 else {
            pTVar16 = (TIntermAggregate*)( **(code**)( *(long*)param_3 + 400 ) )(param_3);
         }

         plVar10 = (long*)( **(code**)( **(long**)( *(long*)( pTVar16 + 8 ) + local_78 ) + 0x18 ) )();
         if (*(code**)( *plVar10 + 0xf0 ) == TIntermTyped::getType) {
            plVar10 = plVar10 + 4;
         }
 else {
            plVar10 = (long*)( **(code**)( *plVar10 + 0xf0 ) )();
         }

         lVar11 = 0;
         while (true) {
            if (*(code**)( *plVar10 + 0x60 ) == TType::getVectorSize) {
               uVar7 = *(byte*)( (long)plVar10 + 9 ) & 0xf;
            }
 else {
               uVar7 = ( **(code**)( *plVar10 + 0x60 ) )(plVar10);
            }

            if ((int)uVar7 <= (int)lVar11) break;
            pTVar16 = param_3 + 0xc0;
            if (*(code**)( *(long*)param_3 + 400 ) != TIntermAggregate::getSequence) {
               pTVar16 = (TIntermAggregate*)( **(code**)( *(long*)param_3 + 400 ) )(param_3);
            }

            lVar9 = ( **(code**)( **(long**)( *(long*)( pTVar16 + 8 ) + local_78 ) + 0x28 ) )();
            iVar8 = *(int*)( lVar11 * 0x10 + *(long*)( *(long*)( lVar9 + 0xc0 ) + 8 ) );
            if (( *(int*)( this + 0x608 ) < iVar8 ) || ( iVar8 < *(int*)( this + 0x604 ) )) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "value is out of range:", "texel offset", "[gl_MinProgramTexelOffset, gl_MaxProgramTexelOffset]");
            }

            lVar11 = lVar11 + 1;
         }
;
         LAB_0011cbfb:lVar11 = *(long*)param_2;
         goto LAB_0011cbfe;
      }

      if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
         lVar11 = *(long*)( param_2 + 8 );
      }
 else {
         lVar11 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
      }

      uVar19 = *(ulong*)( lVar11 + 0x10 );
      if (( ( uVar19 < 0x11 ) && ( uVar19 != 0 ) ) && ( ( iVar8 = memcmp(*(void**)( lVar11 + 8 ), "texelFetchOffset", uVar19) ),iVar8 == 0 && ( (int)uVar19 == 0x10 ) )) goto LAB_0011d46f;
      if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
         lVar11 = *(long*)( param_2 + 8 );
      }
 else {
         lVar11 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
      }

      uVar19 = *(ulong*)( lVar11 + 0x10 );
      if (( ( uVar19 < 0x12 ) && ( uVar19 != 0 ) ) && ( ( iVar8 = memcmp(*(void**)( lVar11 + 8 ), "textureProjOffset", uVar19) ),iVar8 == 0 && ( (int)uVar19 == 0x11 ) )) goto LAB_0011ca8e;
      if (*(code**)( *(long*)param_2 + 0x18 ) != TSymbol::getName_abi_cxx11_) {
         lVar11 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
         iVar8 = std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::compare(*(char**)( lVar11 + 8 ));
         if (iVar8 == 0) goto LAB_0011d46f;
         if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            pcVar14 = *(char**)( *(long*)( param_2 + 8 ) + 8 );
            uVar19 = *(ulong*)( *(long*)( param_2 + 8 ) + 0x10 );
            goto LAB_0011d9d4;
         }

         lVar11 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
         iVar8 = std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::compare(*(char**)( lVar11 + 8 ));
         if (iVar8 == 0) goto LAB_0011d46f;
         if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            pcVar14 = *(char**)( *(long*)( param_2 + 8 ) + 8 );
            uVar19 = *(ulong*)( *(long*)( param_2 + 8 ) + 0x10 );
            goto LAB_0011d9f5;
         }

         lVar11 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
         iVar8 = std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::compare(*(char**)( lVar11 + 8 ));
         if (iVar8 == 0) goto LAB_0011da33;
         if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            uVar19 = *(ulong*)( *(long*)( param_2 + 8 ) + 0x10 );
            pcVar14 = *(char**)( *(long*)( param_2 + 8 ) + 8 );
            goto LAB_0011da12;
         }

         lVar11 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
         iVar8 = std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::compare(*(char**)( lVar11 + 8 ));
         if (iVar8 == 0) goto LAB_0011da33;
         goto LAB_0011cbfb;
      }

      uVar19 = *(ulong*)( *(long*)( param_2 + 8 ) + 0x10 );
      pcVar14 = *(char**)( *(long*)( param_2 + 8 ) + 8 );
      iVar8 = std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::compare(pcVar14);
      if (iVar8 == 0) {
         LAB_0011d46f:local_78 = 0x18;
         goto LAB_0011ca97;
      }

      LAB_0011d9d4:iVar8 = std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::compare(pcVar14);
      if (iVar8 == 0) goto LAB_0011d46f;
      LAB_0011d9f5:iVar8 = std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::compare(pcVar14);
      if (iVar8 == 0) {
         LAB_0011da33:local_78 = 0x20;
         goto LAB_0011ca97;
      }

      LAB_0011da12:iVar8 = std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::compare(pcVar14);
      if (iVar8 == 0) goto LAB_0011da33;
      LAB_0011c967:if (uVar19 == 0) goto LAB_0011c970;
      LAB_0011cc2f:if (0xe < uVar19) {
         uVar19 = 0xe;
      }

      iVar8 = memcmp(pcVar14, "textureSamples", uVar19);
      if (iVar8 != 0 || (int)uVar19 != 0xe) goto LAB_0011c970;
      LAB_0011cc57:glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, -9, (char*)0x1c2, "GL_ARB_shader_texture_image_samples");
      LAB_0011cc7b:if (*(code**)( *(long*)param_2 + 0x18 ) != TSymbol::getName_abi_cxx11_) {
         lVar11 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
         goto LAB_0011c99c;
      }

      uVar19 = *(ulong*)( *(long*)( param_2 + 8 ) + 0x10 );
      pvVar18 = *(void**)( *(long*)( param_2 + 8 ) + 8 );
   }

   if (uVar19 != 0) {
      sVar13 = 0xb;
      if (uVar19 < 0xc) {
         sVar13 = uVar19;
      }

      iVar6 = memcmp(pvVar18, "imageAtomic", sVar13);
      if (iVar6 == 0 && (int)sVar13 == 0xb) {
         if (*(code**)( *(long*)param_3 + 400 ) == TIntermAggregate::getSequence) {
            pTVar16 = param_3 + 0xc0;
         }
 else {
            pTVar16 = (TIntermAggregate*)( **(code**)( *(long*)param_3 + 400 ) )(param_3);
         }

         plVar10 = (long*)( **(code**)( *(long*)**(undefined8**)( pTVar16 + 8 ) + 0x18 ) )();
         if (*(code**)( *plVar10 + 0xf0 ) == TIntermTyped::getType) {
            plVar10 = plVar10 + 4;
         }
 else {
            plVar10 = (long*)( **(code**)( *plVar10 + 0xf0 ) )();
         }

         lVar11 = *plVar10;
         if (*(code**)( lVar11 + 0x40 ) == TType::getSampler) {
            cVar5 = (char)plVar10[0x10];
            if (cVar5 != '\b') {
               LAB_0011cd4b:if (cVar5 != '\t') {
                  if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                     lVar11 = *(long*)( param_2 + 8 );
                     uVar19 = *(ulong*)( lVar11 + 0x10 );
                     pvVar18 = *(void**)( lVar11 + 8 );
                     if (uVar19 != 0) {
                        LAB_0011d480:sVar13 = 0x13;
                        if (uVar19 < 0x14) {
                           sVar13 = uVar19;
                        }

                        iVar6 = memcmp(pvVar18, "imageAtomicExchange", sVar13);
                        if (iVar6 == 0 && (int)sVar13 == 0x13) {
                           if (*(code**)( *plVar10 + 0x58 ) == TType::getQualifier) {
                              plVar10 = plVar10 + 2;
                           }
 else {
                              plVar10 = (long*)( **(code**)( *plVar10 + 0x58 ) )(plVar10);
                           }

                           if (( *(char*)( (long)plVar10 + 0x2c ) != '\x03' ) && ( *(int*)( this + 0xc ) == 8 )) {
                              UNRECOVERED_JUMPTABLE_00 = *(code**)( *(long*)this + 0x158 );
                              if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                                 lVar11 = *(long*)( param_2 + 8 );
                              }
 else {
                                 lVar11 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
                              }

                              if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                                 uVar12 = *(undefined8*)( lVar11 + 8 );
                                 pcVar14 = "only supported on image with format r32f";
                                 goto LAB_0011cdb3;
                              }

                              goto LAB_0011de3e;
                           }

                           goto LAB_0011c9af;
                        }

                        goto LAB_0011d7ae;
                     }

                     UNRECOVERED_JUMPTABLE_00 = *(code**)( *(long*)this + 0x158 );
                  }
 else {
                     lVar11 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
                     pvVar18 = *(void**)( lVar11 + 8 );
                     uVar19 = *(ulong*)( lVar11 + 0x10 );
                     if (uVar19 != 0) goto LAB_0011d480;
                     LAB_0011d7ae:UNRECOVERED_JUMPTABLE_00 = *(code**)( *(long*)this + 0x158 );
                     if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                        lVar11 = *(long*)( param_2 + 8 );
                     }
 else {
                        lVar11 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
                     }

                  }

                  if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                     uVar12 = *(undefined8*)( lVar11 + 8 );
                     pcVar14 = "only supported on integer images";
                     LAB_0011cdb3:/* WARNING: Could not recover jumptable at 0x0011cdcd. Too many branches *//* WARNING: Treating indirect jump as call */( *UNRECOVERED_JUMPTABLE_00 )(this, param_1, pcVar14, uVar12, &_LC1);
                     return;
                  }

                  goto LAB_0011de3e;
               }

               lVar11 = *plVar10;
            }

         }
 else {
            pcVar14 = (char*)( **(code**)( lVar11 + 0x40 ) )(plVar10);
            lVar11 = *plVar10;
            if (*pcVar14 != '\b') {
               if (*(code**)( lVar11 + 0x40 ) == TType::getSampler) {
                  cVar5 = (char)plVar10[0x10];
               }
 else {
                  pcVar14 = (char*)( **(code**)( lVar11 + 0x40 ) )(plVar10);
                  cVar5 = *pcVar14;
               }

               goto LAB_0011cd4b;
            }

         }

         if (*(code**)( lVar11 + 0x58 ) == TType::getQualifier) {
            cVar5 = *(char*)( (long)plVar10 + 0x3c );
            if (cVar5 != '\x1a') {
               LAB_0011d1f4:if (cVar5 != '&') {
                  UNRECOVERED_JUMPTABLE_00 = *(code**)( *(long*)this + 0x158 );
                  if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                     lVar11 = *(long*)( param_2 + 8 );
                  }
 else {
                     lVar11 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
                  }

                  if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                     /* WARNING: Could not recover jumptable at 0x0011d261. Too many branches */
                     /* WARNING: Treating indirect jump as call */
                     ( *UNRECOVERED_JUMPTABLE_00 )(this, param_1, "only supported on image with format r32i or r32ui", *(undefined8*)( lVar11 + 8 ), &_LC1);
                     return;
                  }

                  goto LAB_0011de3e;
               }

            }

         }
 else {
            lVar11 = ( **(code**)( lVar11 + 0x58 ) )(plVar10);
            if (*(char*)( lVar11 + 0x2c ) != '\x1a') {
               if (*(code**)( *plVar10 + 0x58 ) == TType::getQualifier) {
                  cVar5 = *(char*)( (long)plVar10 + 0x3c );
               }
 else {
                  lVar11 = ( **(code**)( *plVar10 + 0x58 ) )(plVar10);
                  cVar5 = *(char*)( lVar11 + 0x2c );
               }

               goto LAB_0011d1f4;
            }

         }

      }

   }

   LAB_0011c9af:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return;
   }

   LAB_0011de3e:/* WARNING: Subroutine does not return */__stack_chk_fail();
}
/* glslang::TParseContext::vkRelaxedRemapDotDereference(glslang::TSourceLoc const&,
   glslang::TIntermTyped&, glslang::TType const&, std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const&) */TIntermTyped * __thiscall
glslang::TParseContext::vkRelaxedRemapDotDereference
          (TParseContext *this,TSourceLoc *param_1,TIntermTyped *param_2,TType *param_3,
          basic_string *param_4){
   TIntermTyped TVar1;
   undefined4 uVar2;
   ulong uVar3;
   char *__src;
   TVariable *pTVar4;
   code *pcVar5;
   long lVar6;
   long lVar7;
   long lVar8;
   char cVar9;
   long *plVar10;
   long lVar11;
   byte bVar12;
   byte bVar13;
   byte bVar14;
   ulong uVar15;
   long in_FS_OFFSET;
   undefined **local_a8;
   undefined4 local_a0;
   undefined8 local_9c;
   undefined8 local_90;
   undefined8 local_88;
   undefined8 local_80;
   undefined8 local_78;
   undefined8 local_70;
   ulong *local_68;
   ulong local_60;
   ulong local_58[2];
   undefined4 local_48;
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(code**)( *(long*)param_3 + 0x140 ) == TType::isOpaque) {
      if (( 0x14 < (byte)param_3[8] ) || ( ( 0x1a6000UL >> ( (ulong)(byte)param_3[8] & 0x3f ) & 1 ) == 0 )) goto LAB_0011e16d;
   }
 else {
      cVar9 = ( **(code**)( *(long*)param_3 + 0x140 ) )(param_3);
      if (cVar9 == '\0') goto LAB_0011e16d;
   }

   local_a0 = 0x10000;
   local_a8 = &PTR__TIntermTraverser_00168108;
   local_9c = 0;
   local_90 = glslang::GetThreadPoolAllocator();
   local_88 = 0;
   local_80 = 0;
   local_78 = 0;
   local_a8 = &PTR__AccessChainTraverser_00168418;
   local_70 = glslang::GetThreadPoolAllocator();
   local_68 = local_58;
   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_70, &_LC1, &_LC1);
   local_48 = 0x20;
   ( **(code**)( *(long*)param_2 + 0x10 ) )(param_2, &local_a8);
   if (local_60 != 0) {
      if (local_60 == 0x7fffffffffffffff) goto LAB_0011e29f;
      uVar3 = local_60 + 1;
      uVar15 = local_58[0];
      if (local_68 == local_58) {
         uVar15 = 0xf;
      }

      if (uVar15 < uVar3) {
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_70, local_60, 0, ".", 1);
      }
 else {
         *(undefined1*)( (long)local_68 + local_60 ) = 0x2e;
      }

      *(undefined1*)( (long)local_68 + uVar3 ) = 0;
      local_60 = uVar3;
   }

   uVar3 = *(ulong*)( param_4 + 0x10 );
   __src = *(char**)( param_4 + 8 );
   if (uVar3 <= 0x7fffffffffffffff - local_60) {
      uVar15 = uVar3 + local_60;
      if (local_68 == local_58) {
         local_58[0] = 0xf;
      }

      if (local_58[0] < uVar15) {
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_70, local_60, 0, __src, uVar3);
      }
 else if (uVar3 != 0) {
         if (uVar3 == 1) {
            *(char*)( (long)local_68 + local_60 ) = *__src;
         }
 else {
            memcpy((char*)( (long)local_68 + local_60 ), __src, uVar3);
         }

      }

      *(undefined1*)( (long)local_68 + uVar15 ) = 0;
      local_60 = uVar15;
      plVar10 = (long*)TSymbolTable::find(*(TSymbolTable**)( this + 0xe8 ), (basic_string*)&local_70, (bool*)0x0, (bool*)0x0, (int*)0x0);
      if (plVar10 != (long*)0x0) {
         pTVar4 = *(TVariable**)( this + 0x38 );
         ( **(code**)( *plVar10 + 0x50 ) )(plVar10);
         param_2 = (TIntermTyped*)glslang::TIntermediate::addSymbol(pTVar4);
         pcVar5 = *(code**)( *(long*)param_2 + 0xe8 );
         lVar11 = ( **(code**)( *plVar10 + 0x60 ) )(plVar10);
         if (pcVar5 == TIntermTyped::setType) {
            lVar6 = *(long*)( lVar11 + 0x18 );
            TVar1 = *(TIntermTyped*)( lVar11 + 8 );
            uVar2 = *(undefined4*)( lVar11 + 0x80 );
            *(long*)( param_2 + 0x30 ) = *(long*)( lVar11 + 0x10 );
            *(long*)( param_2 + 0x38 ) = lVar6;
            lVar6 = *(long*)( lVar11 + 0x20 );
            lVar7 = *(long*)( lVar11 + 0x28 );
            *(undefined4*)( param_2 + 0xa0 ) = uVar2;
            *(long*)( param_2 + 0x40 ) = lVar6;
            *(long*)( param_2 + 0x48 ) = lVar7;
            lVar6 = *(long*)( lVar11 + 0x30 );
            lVar7 = *(long*)( lVar11 + 0x38 );
            param_2[0x28] = TVar1;
            *(long*)( param_2 + 0x50 ) = lVar6;
            *(long*)( param_2 + 0x58 ) = lVar7;
            lVar6 = *(long*)( lVar11 + 0x48 );
            *(long*)( param_2 + 0x60 ) = *(long*)( lVar11 + 0x40 );
            *(long*)( param_2 + 0x68 ) = lVar6;
            lVar6 = *(long*)( lVar11 + 0x58 );
            *(long*)( param_2 + 0x70 ) = *(long*)( lVar11 + 0x50 );
            *(long*)( param_2 + 0x78 ) = lVar6;
            bVar12 = *(byte*)( lVar11 + 9 ) & 0xf;
            param_2[0x29] = ( TIntermTyped )((byte)param_2[0x29] & 0xf0 | bVar12);
            param_2[0x29] = ( TIntermTyped )(bVar12 | *(byte*)( lVar11 + 9 ) & 0xf0);
            TVar1 = param_2[0x2a];
            bVar12 = *(byte*)( lVar11 + 10 ) & 0xf;
            param_2[0x2a] = ( TIntermTyped )((byte)TVar1 & 0xf0 | bVar12);
            bVar13 = *(byte*)( lVar11 + 10 ) & 0x10;
            param_2[0x2a] = ( TIntermTyped )((byte)TVar1 & 0xe0 | bVar12 | bVar13);
            lVar7 = *(long*)( lVar11 + 0x70 );
            lVar8 = *(long*)( lVar11 + 0x78 );
            *(long*)( param_2 + 0x80 ) = *(long*)( lVar11 + 0x60 );
            lVar6 = *(long*)( lVar11 + 0x68 );
            *(long*)( param_2 + 0x90 ) = lVar7;
            *(long*)( param_2 + 0x98 ) = lVar8;
            *(long*)( param_2 + 0x88 ) = lVar6;
            lVar6 = *(long*)( lVar11 + 0x90 );
            *(long*)( param_2 + 0xa8 ) = *(long*)( lVar11 + 0x88 );
            *(long*)( param_2 + 0xb0 ) = lVar6;
            bVar14 = *(byte*)( lVar11 + 10 ) & 0x20;
            param_2[0x2a] = ( TIntermTyped )((byte)TVar1 & 0xc0 | bVar12 | bVar13 | bVar14);
            param_2[0x2a] = ( TIntermTyped )((byte)TVar1 & 0x80 | bVar12 | bVar13 | bVar14 | *(byte*)( lVar11 + 10 ) & 0x40);
            *(ushort*)( param_2 + 0x2a ) = *(ushort*)( param_2 + 0x2a ) & 0xfc7f | *(ushort*)( lVar11 + 10 ) & 0x380;
            param_2[0x2b] = ( TIntermTyped )((byte)param_2[0x2b] & 0xfb | *(byte*)( lVar11 + 0xb ) & 4);
         }
 else {
            ( *pcVar5 )(param_2);
         }

      }

      LAB_0011e16d:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      return param_2;
   }

   LAB_0011e29f:/* WARNING: Subroutine does not return */std::__throw_length_error("basic_string::append");
}
/* glslang::TParseContext::layoutTypeCheck(glslang::TSourceLoc const&, glslang::TType const&) */void glslang::TParseContext::layoutTypeCheck(TParseContext *this, TSourceLoc *param_1, TType *param_2) {
   int *piVar1;
   ushort uVar2;
   long lVar3;
   TType TVar4;
   byte bVar5;
   char cVar6;
   int iVar7;
   uint uVar8;
   uint uVar9;
   long lVar10;
   code *UNRECOVERED_JUMPTABLE;
   int *piVar11;
   long lVar12;
   TType *pTVar13;
   undefined8 uVar14;
   TType *pTVar15;
   char *pcVar16;
   char *pcVar17;
   int iVar18;
   uint uVar19;
   long in_FS_OFFSET;
   char local_69;
   undefined8 local_60;
   lVar3 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(code**)( *(long*)param_2 + 0x58 ) == TType::getQualifier) {
      pTVar13 = param_2 + 0x10;
   }
 else {
      pTVar13 = (TType*)( **(code**)( *(long*)param_2 + 0x58 ) )(param_2);
   }

   layoutQualifierCheck(this, param_1, (TQualifier*)pTVar13);
   iVar18 = (int)param_1;
   if (( *(ushort*)( pTVar13 + 0x1c ) & 0xfff ) == 0xfff) {
      TVar4 = pTVar13[0x1d];
      if (( (byte)TVar4 & 0x70 ) != 0x40) goto LAB_0011e354;
      if (pTVar13[0x22] != (TType)0xff) goto LAB_0011e413;
   }
 else {
      if (( ( ( (byte)pTVar13[8] & 0x7f ) == 4 ) && ( *(int*)( this + 0x1c ) == 4 ) ) && ( *(uint*)( this + 0x5ec ) <= ( uint )(*(ushort*)( pTVar13 + 0x1c ) & 0xfff) )) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "too large for fragment output", "location", &_LC1);
      }

      TVar4 = pTVar13[0x1d];
      if (( (byte)TVar4 & 0x70 ) != 0x40) {
         LAB_0011e354:lVar12 = *(long*)param_2;
         if (*(code**)( lVar12 + 0x60 ) == TType::getVectorSize) {
            uVar19 = (byte)param_2[9] & 0xf;
         }
 else {
            uVar19 = ( **(code**)( lVar12 + 0x60 ) )(param_2);
            lVar12 = *(long*)param_2;
         }

         if (*(code**)( lVar12 + 0x38 ) == TType::getBasicType) {
            uVar9 = (uint)(byte)param_2[8];
         }
 else {
            uVar9 = ( **(code**)( lVar12 + 0x38 ) )(param_2);
         }

         if (uVar9 == 2) {
            uVar19 = uVar19 * 2;
         }

         if (4 < (int)( ( (byte)TVar4 >> 4 & 7 ) + uVar19 )) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "type overflows the available 4 components", "component", &_LC1);
         }

         lVar12 = *(long*)param_2;
         if (*(code**)( lVar12 + 0xe0 ) == TType::isMatrix) {
            if (0xf < (byte)param_2[9]) goto LAB_0011e3ce;
            LAB_0011f388:if (*(code**)( lVar12 + 0x38 ) != TType::getBasicType) {
               iVar7 = ( **(code**)( lVar12 + 0x38 ) )(param_2);
               if (iVar7 == 0x10) goto LAB_0011e3ce;
               if (*(code**)( *(long*)param_2 + 0x38 ) == TType::getBasicType) {
                  TVar4 = param_2[8];
                  goto LAB_0011f3a5;
               }

               iVar7 = ( **(code**)( *(long*)param_2 + 0x38 ) )(param_2);
               if (iVar7 == 0xf) goto LAB_0011e3ce;
               goto LAB_0011e3f6;
            }

            TVar4 = param_2[8];
            if (TVar4 == (TType)0x10) goto LAB_0011e3ce;
            LAB_0011f3a5:uVar19 = (uint)(byte)TVar4;
            if (TVar4 == (TType)0xf) goto LAB_0011e3ce;
         }
 else {
            cVar6 = ( **(code**)( lVar12 + 0xe0 ) )(param_2);
            if (cVar6 == '\0') {
               lVar12 = *(long*)param_2;
               goto LAB_0011f388;
            }

            LAB_0011e3ce:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot apply to a matrix, structure, or block", "component", &_LC1);
            LAB_0011e3f6:if (*(code**)( *(long*)param_2 + 0x38 ) == TType::getBasicType) {
               uVar19 = (uint)(byte)param_2[8];
            }
 else {
               uVar19 = ( **(code**)( *(long*)param_2 + 0x38 ) )(param_2);
            }

         }

         if (( uVar19 == 2 ) && ( ( (byte)pTVar13[0x1d] & 0x10 ) != 0 )) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "doubles cannot start on an odd-numbered component", "component", &_LC1);
         }

      }

      LAB_0011e413:switch ((char)pTVar13[8] + 0x7dU & 0x7f) {
         case 0:
         case 1:
      if (*(code **)(*(long *)param_2 + 0x38) == TType::getBasicType) {
        uVar19 = (uint)(byte)param_2[8];
      }
      else {
        uVar19 = (**(code **)(*(long *)param_2 + 0x38))(param_2);
      }
      if (uVar19 == 0x10) {
        glslang::TParseVersions::profileRequires
                  ((TSourceLoc *)this,iVar18,6,(char *)0x1b8,"GL_ARB_enhanced_layouts");
      }
      if (*(code **)(*(long *)param_2 + 0x58) == TType::getQualifier) {
        pTVar15 = param_2 + 0x10;
      }
      else {
        pTVar15 = (TType *)(**(code **)(*(long *)param_2 + 0x58))(param_2);
      }
      if (((byte)pTVar15[0xd] & 8) != 0) {
        (**(code **)(*(long *)this + 0x158))
                  (this,param_1,"cannot apply to taskNV in/out blocks","location",&_LC1);
      }
      break;
         case 2:
         case 3:
      if (*(code **)(*(long *)param_2 + 0x38) == TType::getBasicType) {
        uVar19 = (uint)(byte)param_2[8];
        if (param_2[8] == (TType)0x10) {
LAB_0011fde0:
          (**(code **)(*(long *)this + 0x158))
                    (this,param_1,"cannot apply to uniform or buffer block","location",&_LC1);
          break;
        }
      }
      else {
        iVar7 = (**(code **)(*(long *)param_2 + 0x38))(param_2);
        if (iVar7 == 0x10) goto LAB_0011fde0;
        if (*(code **)(*(long *)param_2 + 0x38) == TType::getBasicType) {
          uVar19 = (uint)(byte)param_2[8];
        }
        else {
          uVar19 = (**(code **)(*(long *)param_2 + 0x38))(param_2);
        }
      }
      if (uVar19 == 0xe) {
        if (*(code **)(*(long *)param_2 + 0x40) == TType::getSampler) {
          pTVar15 = param_2 + 0x80;
        }
        else {
          pTVar15 = (TType *)(**(code **)(*(long *)param_2 + 0x40))(param_2);
        }
        if (pTVar15[1] == (TType)0x8) {
          UNRECOVERED_JUMPTABLE = *(code **)(*(long *)this + 0x158);
          TType::getBasicTypeString_abi_cxx11_();
          (*UNRECOVERED_JUMPTABLE)
                    (this,param_1,"only applies to","location","%s with storage tileImageEXT",
                     local_60);
        }
      }
      break;
         default:
      (**(code **)(*(long *)this + 0x158))
                (this,param_1,"can only apply to uniform, buffer, in, or out storage qualifiers",
                 "location",&_LC1);
      break;
         case 5:
         case 6:
         case 7:
         case 8:
         case 9:
         case 10:
         case 0xb:
         case 0x1c:
      break;
         case 0xc:
      (**(code **)(*(long *)this + 0x158))
                (this,param_1,"cannot apply to taskPayloadSharedEXT","location",&_LC1);
      }

      iVar7 = glslang::TIntermediate::addUsedLocation(*(TQualifier**)( this + 0x38 ), pTVar13, (bool*)param_2);
      if (iVar7 < 0) {
         LAB_0011e4c1:if (local_69 == '\0') goto LAB_0011e4cc;
      }
 else if (local_69 == '\0') {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "overlapping use of location", "location", &_LC524, iVar7);
         goto LAB_0011e4c1;
      }

      uVar19 = (byte)pTVar13[8] & 0x7f;
      if ((byte)uVar19 < 0x1c) {
         if (( ( 0xe300008UL >> ( (ulong)uVar19 & 0x3f ) & 1 ) == 0 ) && ( ( 0x71c00010UL >> ( (ulong)uVar19 & 0x3f ) & 1 ) == 0 )) {
            LAB_0011f578:if (( (byte)pTVar13[8] & 0x7f ) != 0x1f) goto LAB_0011e4cc;
         }

      }
 else if (0x1e < (byte)uVar19) goto LAB_0011f578;
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "the aliases sharing the location", "location", "%d must be the same basic type and interpolation qualification", iVar7);
   }

   LAB_0011e4cc:if (( ~*(ushort *)(pTVar13 + 0x26) & 0x7ffc ) == 0) goto LAB_0011e818;
   if (( ~(byte)pTVar13[0x24] & 0xf ) != 0) {
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)param_2 + 0xf8 );
      if (UNRECOVERED_JUMPTABLE == TType::isUnsizedArray) {
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)param_2 + 0xe8 );
         if (UNRECOVERED_JUMPTABLE == TType::isArray) {
            lVar12 = *(long*)( param_2 + 0x60 );
            if (lVar12 != 0) {
               LAB_0011e52c:if (**(int**)( *(long*)( lVar12 + 8 ) + 8 ) == 0) goto LAB_0011e53e;
            }

         }
 else {
            cVar6 = ( *UNRECOVERED_JUMPTABLE )(param_2);
            if (cVar6 != '\0') {
               lVar12 = *(long*)( param_2 + 0x60 );
               goto LAB_0011e52c;
            }

         }

         LAB_0011ed48:iVar7 = glslang::TIntermediate::addXfbBufferOffset(*(TType**)( this + 0x38 ));
         if (-1 < iVar7) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "overlapping offsets at", "xfb_offset", "offset %d in buffer %d", iVar7, (byte)pTVar13[0x24] & 0xf);
         }

      }
 else {
         cVar6 = ( *UNRECOVERED_JUMPTABLE )(param_2);
         if (cVar6 == '\0') goto LAB_0011ed48;
         LAB_0011e53e:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "unsized array", "xfb_offset", "in buffer %d", (byte)pTVar13[0x24] & 0xf);
      }

      lVar12 = *(long*)param_2;
      if (*(code**)( lVar12 + 400 ) == TType::containsBasicType) {
         TVar4 = param_2[8];
         if (TVar4 != (TType)0x2) {
            if (*(code**)( lVar12 + 0x128 ) == TType::isStruct) {
               if (( byte )((char)TVar4 - 0xfU) < 2) goto LAB_0011f4e9;
               goto LAB_0011e5b9;
            }

            cVar6 = ( **(code**)( lVar12 + 0x128 ) )(param_2);
            if (cVar6 == '\0') goto LAB_0011f513;
            LAB_0011f4e9:lVar12 = *(long*)( *(long*)( param_2 + 0x68 ) + 0x10 );
            lVar10 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_2 + 0x68 ) + 8 ),lVar12,2 ));
            if (lVar12 == lVar10) goto LAB_0011f513;
            goto LAB_0011e638;
         }

         LAB_0011f748:if (( (byte)pTVar13[0x26] & 0x1c ) != 0) {
            LAB_0011f754:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "type contains double or 64-bit integer; xfb_offset must be a multiple of 8", "xfb_offset", &_LC1);
            goto LAB_0011e818;
         }

         LAB_0011e65b:if (TVar4 != (TType)0xc) {
            if (*(code**)( lVar12 + 0x128 ) == TType::isStruct) {
               if (( byte )((char)TVar4 - 0xfU) < 2) goto LAB_0011fba1;
               goto LAB_0011e685;
            }

            cVar6 = ( **(code**)( lVar12 + 0x128 ) )(param_2);
            if (cVar6 == '\0') goto LAB_0011fbcb;
            LAB_0011fba1:lVar12 = *(long*)( *(long*)( param_2 + 0x68 ) + 0x10 );
            lVar10 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_2 + 0x68 ) + 8 ),lVar12,0xc ));
            if (lVar12 == lVar10) goto LAB_0011fbcb;
            goto LAB_0011e740;
         }

         LAB_0011fa50:if (( (byte)pTVar13[0x26] & 0xc ) != 0) {
            LAB_0011fa5c:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "must be a multiple of size of first component", "xfb_offset", &_LC1);
            goto LAB_0011e818;
         }

         LAB_0011e763:if (TVar4 != (TType)0x3) {
            if (*(code**)( lVar12 + 0x128 ) == TType::isStruct) {
               if (( byte )((char)TVar4 - 0xfU) < 2) goto LAB_0011fc40;
               goto LAB_0011e78d;
            }

            cVar6 = ( **(code**)( lVar12 + 0x128 ) )(param_2);
            if (cVar6 == '\0') goto LAB_0011fc6a;
            LAB_0011fc40:lVar12 = *(long*)( *(long*)( param_2 + 0x68 ) + 0x10 );
            lVar10 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_2 + 0x68 ) + 8 ),lVar12,3 ));
            if (lVar12 == lVar10) goto LAB_0011fc6a;
         }

         LAB_0011faa2:if (( (byte)pTVar13[0x26] & 4 ) != 0) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "type contains half float or 16-bit integer; xfb_offset must be a multiple of 2", "xfb_offset", &_LC1);
         }

      }
 else {
         cVar6 = ( **(code**)( lVar12 + 400 ) )(param_2, 2);
         if (cVar6 == '\0') {
            LAB_0011f513:lVar12 = *(long*)param_2;
            if (*(code**)( lVar12 + 400 ) == TType::containsBasicType) {
               TVar4 = param_2[8];
               LAB_0011e5b9:if (TVar4 == (TType)0xa) goto LAB_0011f748;
               if (*(code**)( lVar12 + 0x128 ) != TType::isStruct) {
                  cVar6 = ( **(code**)( lVar12 + 0x128 ) )(param_2);
                  if (cVar6 == '\0') goto LAB_0011f540;
                  LAB_0011fdad:lVar12 = *(long*)( *(long*)( param_2 + 0x68 ) + 0x10 );
                  lVar10 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_2 + 0x68 ) + 8 ),lVar12,10 ));
                  if (lVar12 != lVar10) goto LAB_0011e638;
                  goto LAB_0011f540;
               }

               if (( byte )((char)TVar4 - 0xfU) < 2) goto LAB_0011fdad;
               LAB_0011e5e4:if (TVar4 == (TType)0xb) goto LAB_0011f748;
               if (*(code**)( lVar12 + 0x128 ) == TType::isStruct) {
                  if (1 < ( byte )((char)TVar4 - 0xfU)) goto LAB_0011e65b;
               }
 else {
                  cVar6 = ( **(code**)( lVar12 + 0x128 ) )(param_2);
                  if (cVar6 == '\0') goto LAB_0011e644;
               }

               lVar12 = *(long*)( *(long*)( param_2 + 0x68 ) + 0x10 );
               lVar10 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_2 + 0x68 ) + 8 ),lVar12,0xb ));
               if (lVar12 != lVar10) goto LAB_0011e638;
            }
 else {
               cVar6 = ( **(code**)( lVar12 + 400 ) )(param_2, 10);
               if (cVar6 != '\0') goto LAB_0011e638;
               LAB_0011f540:lVar12 = *(long*)param_2;
               if (*(code**)( lVar12 + 400 ) == TType::containsBasicType) {
                  TVar4 = param_2[8];
                  goto LAB_0011e5e4;
               }

               cVar6 = ( **(code**)( lVar12 + 400 ) )(param_2, 0xb);
               if (cVar6 != '\0') goto LAB_0011e638;
            }

         }
 else {
            LAB_0011e638:if (( (byte)pTVar13[0x26] & 0x1c ) != 0) goto LAB_0011f754;
         }

         LAB_0011e644:lVar12 = *(long*)param_2;
         if (*(code**)( lVar12 + 400 ) == TType::containsBasicType) {
            TVar4 = param_2[8];
            goto LAB_0011e65b;
         }

         cVar6 = ( **(code**)( lVar12 + 400 ) )(param_2, 0xc);
         if (cVar6 == '\0') {
            LAB_0011fbcb:lVar12 = *(long*)param_2;
            LAB_0011e685:if (*(code**)( lVar12 + 400 ) == TType::containsBasicType) {
               TVar4 = param_2[8];
               if (TVar4 == (TType)0x1) goto LAB_0011fa50;
               if (*(code**)( lVar12 + 0x128 ) != TType::isStruct) {
                  cVar6 = ( **(code**)( lVar12 + 0x128 ) )(param_2);
                  if (cVar6 == '\0') goto LAB_0011fcb2;
                  LAB_0011fc88:lVar12 = *(long*)( *(long*)( param_2 + 0x68 ) + 0x10 );
                  lVar10 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_2 + 0x68 ) + 8 ),lVar12,1 ));
                  if (lVar12 != lVar10) goto LAB_0011e740;
                  goto LAB_0011fcb2;
               }

               if (( byte )((char)TVar4 - 0xfU) < 2) goto LAB_0011fc88;
               LAB_0011e6c4:if (TVar4 == (TType)0x8) goto LAB_0011fa50;
               if (*(code**)( lVar12 + 0x128 ) != TType::isStruct) {
                  cVar6 = ( **(code**)( lVar12 + 0x128 ) )(param_2);
                  if (cVar6 == '\0') goto LAB_0011fce0;
                  LAB_0011ffe1:lVar12 = *(long*)( *(long*)( param_2 + 0x68 ) + 0x10 );
                  lVar10 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_2 + 0x68 ) + 8 ),lVar12,8 ));
                  if (lVar12 != lVar10) goto LAB_0011e740;
                  goto LAB_0011fce0;
               }

               if (( byte )((char)TVar4 - 0xfU) < 2) goto LAB_0011ffe1;
               LAB_0011e6ef:if (TVar4 == (TType)0x9) goto LAB_0011fa50;
               if (*(code**)( lVar12 + 0x128 ) == TType::isStruct) {
                  if (1 < ( byte )((char)TVar4 - 0xfU)) goto LAB_0011e763;
               }
 else {
                  cVar6 = ( **(code**)( lVar12 + 0x128 ) )(param_2);
                  if (cVar6 == '\0') goto LAB_0011e74c;
               }

               lVar12 = *(long*)( *(long*)( param_2 + 0x68 ) + 0x10 );
               lVar10 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_2 + 0x68 ) + 8 ),lVar12,9 ));
               if (lVar12 != lVar10) goto LAB_0011e740;
            }
 else {
               cVar6 = ( **(code**)( lVar12 + 400 ) )(param_2, 1);
               if (cVar6 != '\0') goto LAB_0011e740;
               LAB_0011fcb2:lVar12 = *(long*)param_2;
               if (*(code**)( lVar12 + 400 ) == TType::containsBasicType) {
                  TVar4 = param_2[8];
                  goto LAB_0011e6c4;
               }

               cVar6 = ( **(code**)( lVar12 + 400 ) )(param_2, 8);
               if (cVar6 != '\0') goto LAB_0011e740;
               LAB_0011fce0:lVar12 = *(long*)param_2;
               if (*(code**)( lVar12 + 400 ) == TType::containsBasicType) {
                  TVar4 = param_2[8];
                  goto LAB_0011e6ef;
               }

               cVar6 = ( **(code**)( lVar12 + 400 ) )(param_2, 9);
               if (cVar6 != '\0') goto LAB_0011e740;
            }

         }
 else {
            LAB_0011e740:if (( (byte)pTVar13[0x26] & 0xc ) != 0) goto LAB_0011fa5c;
         }

         LAB_0011e74c:lVar12 = *(long*)param_2;
         if (*(code**)( lVar12 + 400 ) == TType::containsBasicType) {
            TVar4 = param_2[8];
            goto LAB_0011e763;
         }

         cVar6 = ( **(code**)( lVar12 + 400 ) )(param_2, 3);
         if (cVar6 != '\0') goto LAB_0011faa2;
         LAB_0011fc6a:lVar12 = *(long*)param_2;
         LAB_0011e78d:if (*(code**)( lVar12 + 400 ) == TType::containsBasicType) {
            TVar4 = param_2[8];
            if (TVar4 == (TType)0x6) goto LAB_0011faa2;
            if (*(code**)( lVar12 + 0x128 ) != TType::isStruct) {
               cVar6 = ( **(code**)( lVar12 + 0x128 ) )(param_2);
               if (cVar6 == '\0') goto LAB_0011ff85;
               LAB_0011ff5b:lVar12 = *(long*)( *(long*)( param_2 + 0x68 ) + 0x10 );
               lVar10 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_2 + 0x68 ) + 8 ),lVar12,6 ));
               if (lVar12 != lVar10) goto LAB_0011faa2;
               goto LAB_0011ff85;
            }

            if (( byte )((char)TVar4 - 0xfU) < 2) goto LAB_0011ff5b;
         }
 else {
            cVar6 = ( **(code**)( lVar12 + 400 ) )(param_2, 6);
            if (cVar6 != '\0') goto LAB_0011faa2;
            LAB_0011ff85:lVar12 = *(long*)param_2;
            if (*(code**)( lVar12 + 400 ) != TType::containsBasicType) {
               cVar6 = ( **(code**)( lVar12 + 400 ) )(param_2, 7);
               if (cVar6 == '\0') goto LAB_0011e818;
               goto LAB_0011faa2;
            }

            TVar4 = param_2[8];
         }

         if (TVar4 == (TType)0x7) goto LAB_0011faa2;
         if (*(code**)( lVar12 + 0x128 ) == TType::isStruct) {
            if (( byte )((char)TVar4 - 0xfU) < 2) {
               LAB_0011e7f2:lVar12 = *(long*)( *(long*)( param_2 + 0x68 ) + 0x10 );
               lVar10 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_2 + 0x68 ) + 8 ),lVar12,7 ));
               if (lVar12 != lVar10) goto LAB_0011faa2;
            }

         }
 else {
            cVar6 = ( **(code**)( lVar12 + 0x128 ) )(param_2);
            if (cVar6 != '\0') goto LAB_0011e7f2;
         }

      }

      LAB_0011e818:if (( ( ~*(uint *)(pTVar13 + 0x24) & 0x3fff0 ) != 0 ) && ( uVar19 = (byte)pTVar13[0x24] & 0xf ),(char)uVar19 != '\x0f') {
         uVar8 = *(uint*)( pTVar13 + 0x24 ) >> 4 & 0x3fff;
         lVar12 = *(long*)( *(long*)( this + 0x38 ) + 0x348 ) + (ulong)uVar19 * 0x28;
         uVar9 = *(uint*)( lVar12 + 0x18 );
         if (uVar9 == 0x3fff) {
            *(uint*)( lVar12 + 0x18 ) = uVar8;
         }
 else if (uVar8 != uVar9) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "all stride settings must match for xfb buffer", "xfb_stride", &_LC524, uVar19);
         }

      }

   }

   if (*(short*)( pTVar13 + 0x20 ) == -1) {
      if (*(char*)( *(long*)( this + 0x38 ) + 0x4d0 ) != '\0') goto LAB_0011e8dd;
      if (param_2[8] == (TType)0xd) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "layout(binding=X) is required", "atomic_uint", &_LC1);
      }

      lVar12 = *(long*)param_2;
      if (( *(int*)( this + 0x20 ) != 0 ) && ( ( (byte)pTVar13[8] & 0x7f ) - 5 < 2 )) {
         if (*(code**)( lVar12 + 0x38 ) == TType::getBasicType) {
            uVar19 = (uint)(byte)param_2[8];
         }
 else {
            uVar19 = ( **(code**)( lVar12 + 0x38 ) )(param_2);
         }

         if (( ( ( uVar19 == 0x10 ) && ( pTVar13[0x2d] == (TType)0x0 ) ) && ( pTVar13[0x38] == (TType)0x0 ) ) && ( ( pTVar13[0x28] == (TType)0xff && ( pTVar13[0x2e] == (TType)0x0 ) ) )) {
            lVar12 = *(long*)this;
            pcVar16 = "uniform/buffer blocks require layout(binding=X)";
            LAB_0011ef99:( **(code**)( lVar12 + 0x158 ) )(this, param_1, pcVar16, "binding", &_LC1);
            goto LAB_0011e8dd;
         }

         lVar12 = *(long*)param_2;
         if (0 < *(int*)( this + 0x28 )) {
            if (*(code**)( lVar12 + 0x38 ) == TType::getBasicType) {
               uVar19 = (uint)(byte)param_2[8];
            }
 else {
               uVar19 = ( **(code**)( lVar12 + 0x38 ) )(param_2);
               lVar12 = *(long*)param_2;
            }

            if (uVar19 == 0xe) {
               if (*(code**)( lVar12 + 0x40 ) == TType::getSampler) {
                  pTVar15 = param_2 + 0x80;
               }
 else {
                  pTVar15 = (TType*)( **(code**)( lVar12 + 0x40 ) )(param_2);
               }

               if (pTVar15[1] == (TType)0x8) goto LAB_0011e8dd;
               lVar12 = *(long*)this;
               pcVar16 = "sampler/texture/image requires layout(binding=X)";
               goto LAB_0011ef99;
            }

         }

      }

   }
 else {
      lVar12 = *(long*)param_2;
      if (*(code**)( lVar12 + 0x140 ) == TType::isOpaque) {
         if (( (byte)param_2[8] < 0x15 ) && ( ( 0x1a6000UL >> ( (ulong)(byte)param_2[8] & 0x3f ) & 1 ) != 0 )) goto LAB_0011e8b9;
         LAB_0011efc7:if (*(code**)( lVar12 + 0x38 ) == TType::getBasicType) {
            if (param_2[8] == (TType)0x10) goto LAB_0011e8e0;
            LAB_0011efe5:if (param_2[8] == (TType)0x16) goto LAB_0011e8e0;
            LAB_0011efef:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "requires block, or sampler/image, or atomic-counter type", "binding", &_LC1);
         }
 else {
            iVar7 = ( **(code**)( lVar12 + 0x38 ) )(param_2);
            lVar12 = *(long*)param_2;
            if (iVar7 == 0x10) goto LAB_0011e8b9;
            if (*(code**)( lVar12 + 0x38 ) == TType::getBasicType) goto LAB_0011efe5;
            iVar7 = ( **(code**)( lVar12 + 0x38 ) )(param_2);
            if (iVar7 != 0x16) goto LAB_0011efef;
         }

         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)param_2 + 0x38 );
         if (UNRECOVERED_JUMPTABLE != TType::getBasicType) goto LAB_0011f027;
         LAB_0011e8c6:if (param_2[8] == (TType)0xe) {
            LAB_0011f035:uVar2 = *(ushort*)( pTVar13 + 0x20 );
            uVar19 = (uint)uVar2;
            if (*(code**)( *(long*)param_2 + 0xe8 ) == TType::isArray) {
               if (*(long*)( param_2 + 0x60 ) != 0) {
                  LAB_0011f060:uVar19 = (uint)uVar2;
                  if (*(int*)( this + 0x28 ) != 0) goto LAB_0011e8d3;
                  UNRECOVERED_JUMPTABLE = *(code**)( *(long*)param_2 + 0xf0 );
                  if (UNRECOVERED_JUMPTABLE == TType::isSizedArray) {
                     UNRECOVERED_JUMPTABLE = *(code**)( *(long*)param_2 + 0xe8 );
                     if (UNRECOVERED_JUMPTABLE == TType::isArray) {
                        lVar12 = *(long*)( param_2 + 0x60 );
                        if (lVar12 != 0) {
                           LAB_0011f0a4:if (**(int**)( *(long*)( lVar12 + 8 ) + 8 ) != 0) goto LAB_0011f0b8;
                        }

                     }
 else {
                        cVar6 = ( *UNRECOVERED_JUMPTABLE )(param_2);
                        if (cVar6 != '\0') {
                           lVar12 = *(long*)( param_2 + 0x60 );
                           goto LAB_0011f0a4;
                        }

                     }

                     LAB_0011fd50:( **(code**)( *(long*)this + 0x160 ) )(this, param_1, "assuming binding count of one for compile-time checking of binding numbers for unsized array", &_LC38, &_LC1);
                  }
 else {
                     cVar6 = ( *UNRECOVERED_JUMPTABLE )(param_2);
                     if (cVar6 == '\0') goto LAB_0011fd50;
                     LAB_0011f0b8:if (*(code**)( *(long*)param_2 + 0x88 ) == TType::getCumulativeArraySize) {
                        lVar12 = *(long*)( *(long*)( param_2 + 0x60 ) + 8 );
                        if (lVar12 != 0) {
                           piVar11 = *(int**)( lVar12 + 8 );
                           iVar7 = (int)( *(long*)( lVar12 + 0x10 ) - (long)piVar11 >> 4 );
                           if (iVar7 < 1) {
                              iVar7 = 1;
                           }
 else {
                              piVar1 = piVar11 + ( ulong )(iVar7 - 1) * 4 + 4;
                              iVar7 = 1;
                              do {
                                 iVar7 = iVar7 * *piVar11;
                                 piVar11 = piVar11 + 4;
                              }
 while ( piVar1 != piVar11 );
                           }

                           uVar19 = ( uVar19 - 1 ) + iVar7;
                        }

                     }
 else {
                        iVar7 = ( **(code**)( *(long*)param_2 + 0x88 ) )(param_2);
                        uVar19 = ( uVar19 - 1 ) + iVar7;
                     }

                  }

               }

            }
 else {
               uVar19 = (uint)uVar2;
               cVar6 = ( **(code**)( *(long*)param_2 + 0xe8 ) )(param_2);
               if (cVar6 != '\0') goto LAB_0011f060;
            }

            if (( *(int*)( this + 0x28 ) == 0 ) && ( *(int*)( this + 0x5e0 ) <= (int)uVar19 )) {
               UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
               if (*(code**)( *(long*)param_2 + 0xe8 ) == TType::isArray) {
                  cVar6 = *(long*)( param_2 + 0x60 ) != 0;
               }
 else {
                  cVar6 = ( **(code**)( *(long*)param_2 + 0xe8 ) )(param_2);
               }

               pcVar16 = "";
               if (cVar6 != '\0') {
                  pcVar16 = "(using array)";
               }

               ( *UNRECOVERED_JUMPTABLE )(this, param_1, "sampler binding not less than gl_MaxCombinedTextureImageUnits", "binding", pcVar16);
            }

         }

      }
 else {
         cVar6 = ( **(code**)( lVar12 + 0x140 ) )(param_2);
         lVar12 = *(long*)param_2;
         if (cVar6 == '\0') goto LAB_0011efc7;
         LAB_0011e8b9:UNRECOVERED_JUMPTABLE = *(code**)( lVar12 + 0x38 );
         if (UNRECOVERED_JUMPTABLE == TType::getBasicType) goto LAB_0011e8c6;
         LAB_0011f027:iVar7 = ( *UNRECOVERED_JUMPTABLE )(param_2);
         if (iVar7 == 0xe) goto LAB_0011f035;
      }

      LAB_0011e8d3:if (( ( param_2[8] == (TType)0xd ) && ( this[0x30] == (TParseContext)0x0 ) ) && ( *(uint*)( this + 0x6d8 ) <= ( uint ) * (ushort*)( pTVar13 + 0x20 ) )) {
         if (lVar3 == *(long*)( in_FS_OFFSET + 0x28 )) {
            pcVar16 = "binding";
            pcVar17 = "atomic_uint binding is too large; see gl_MaxAtomicCounterBindings";
            UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
            goto LAB_0011ecc5;
         }

         goto LAB_0012012b;
      }

      LAB_0011e8dd:lVar12 = *(long*)param_2;
   }

   LAB_0011e8e0:if (( ( *(long*)( param_2 + 0x60 ) != 0 ) && ( lVar10 = *(long*)( *(long*)( param_2 + 0x60 ) + 8 ) ),lVar10 != 0 )) {
      if (*(code**)( lVar12 + 0x140 ) == TType::isOpaque) {
         if (( (byte)param_2[8] < 0x15 ) && ( ( 0x1a6000UL >> ( (ulong)(byte)param_2[8] & 0x3f ) & 1 ) != 0 )) goto LAB_0011e940;
         LAB_0011f5a0:if (*(code**)( lVar12 + 0x58 ) == TType::getQualifier) {
            pTVar15 = param_2 + 0x10;
         }
 else {
            pTVar15 = (TType*)( **(code**)( lVar12 + 0x58 ) )(param_2);
            lVar12 = *(long*)param_2;
         }

         if (1 < ( (byte)pTVar15[8] & 0x7f ) - 5) goto LAB_0011e970;
         if (*(code**)( lVar12 + 0x38 ) == TType::getBasicType) {
            uVar19 = (uint)(byte)param_2[8];
         }
 else {
            uVar19 = ( **(code**)( lVar12 + 0x38 ) )(param_2);
         }

         if (uVar19 == 0x10) goto LAB_0011e940;
      }
 else {
         cVar6 = ( **(code**)( lVar12 + 0x140 ) )(param_2);
         if (cVar6 == '\0') {
            lVar12 = *(long*)param_2;
            goto LAB_0011f5a0;
         }

         LAB_0011e940:( **(code**)( *(long*)this + 0x160 ) )(this, param_1, "Generating SPIR-V array-of-arrays, but Vulkan only supports single array level for this resource", &_LC868, &_LC1);
      }

      lVar12 = *(long*)param_2;
   }

   LAB_0011e970:if (*(int*)( pTVar13 + 0x14 ) != -1) {
      if (*(code**)( lVar12 + 0x38 ) == TType::getBasicType) {
         uVar19 = (uint)(byte)param_2[8];
      }
 else {
         uVar19 = ( **(code**)( lVar12 + 0x38 ) )(param_2);
      }

      if (uVar19 == 0x10) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "only applies to block members, not blocks", "offset", &_LC1);
      }

      lVar12 = *(long*)param_2;
   }

   UNRECOVERED_JUMPTABLE = *(code**)( lVar12 + 0x158 );
   if (pTVar13[0x2c] == (TType)0x0) {
      if (UNRECOVERED_JUMPTABLE == TType::isImage) {
         if (param_2[8] != (TType)0xe) goto LAB_0011ea42;
         if (*(code**)( lVar12 + 0x40 ) == TType::getSampler) {
            pTVar15 = param_2 + 0x80;
         }
 else {
            pTVar15 = (TType*)( **(code**)( lVar12 + 0x40 ) )(param_2);
         }

         if (( ( (byte)pTVar15[2] & 8 ) != 0 ) && ( 1 < ( byte )((char)pTVar15[1] - 7U) )) goto LAB_0011ee4f;
      }
 else {
         cVar6 = ( *UNRECOVERED_JUMPTABLE )(param_2);
         if (cVar6 != '\0') {
            LAB_0011ee4f:if (( ( (byte)pTVar13[0xe] & 1 ) == 0 ) && ( *(long*)( *(long*)( this + 0x38 ) + 0x580 ) == 0 )) {
               glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar18, (char*)0x6);
               glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar18, 6, (char*)0x0, "GL_EXT_shader_image_load_formatted");
            }

         }

      }

      LAB_0011ea3f:lVar12 = *(long*)param_2;
   }
 else {
      if (UNRECOVERED_JUMPTABLE != TType::isImage) {
         cVar6 = ( *UNRECOVERED_JUMPTABLE )(param_2);
         if (cVar6 == '\0') goto LAB_0011e9ed;
         LAB_0011ea06:if (*(code**)( *(long*)param_2 + 0x40 ) == TType::getSampler) {
            TVar4 = param_2[0x80];
            if (TVar4 == (TType)0x1) {
               LAB_0011f47a:if (0x16 < (byte)pTVar13[0x2c]) {
                  UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                  uVar14 = TQualifier::getLayoutFormatString();
                  ( *UNRECOVERED_JUMPTABLE )(this, param_1, "does not apply to floating point images", uVar14, &_LC1);
               }

               goto LAB_0011f4ba;
            }

            LAB_0011ea25:if (TVar4 == (TType)0x8) {
               LAB_0011f40a:if (0xc < ( byte )((char)pTVar13[0x2c] - 0x16U)) {
                  UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                  uVar14 = TQualifier::getLayoutFormatString();
                  ( *UNRECOVERED_JUMPTABLE )(this, param_1, "does not apply to signed integer images", uVar14, &_LC1);
               }

               goto LAB_0011f44b;
            }

         }
 else {
            pcVar16 = (char*)( **(code**)( *(long*)param_2 + 0x40 ) )(param_2);
            if (*pcVar16 == '\x01') goto LAB_0011f47a;
            LAB_0011f4ba:if (*(code**)( *(long*)param_2 + 0x40 ) == TType::getSampler) {
               TVar4 = param_2[0x80];
               goto LAB_0011ea25;
            }

            pcVar16 = (char*)( **(code**)( *(long*)param_2 + 0x40 ) )(param_2);
            if (*pcVar16 == '\b') goto LAB_0011f40a;
            LAB_0011f44b:if (*(code**)( *(long*)param_2 + 0x40 ) == TType::getSampler) {
               TVar4 = param_2[0x80];
            }
 else {
               pTVar15 = (TType*)( **(code**)( *(long*)param_2 + 0x40 ) )(param_2);
               TVar4 = *pTVar15;
            }

         }

         if (( TVar4 == (TType)0x9 ) && ( (byte)pTVar13[0x2c] < 0x22 )) {
            UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
            uVar14 = TQualifier::getLayoutFormatString();
            ( *UNRECOVERED_JUMPTABLE )(this, param_1, "does not apply to unsigned integer images", uVar14, &_LC1);
         }

         if (*(int*)( this + 0xc ) == 8) {
            TVar4 = pTVar13[0x2c];
            if (( ( ( 0x26 < (byte)TVar4 ) || ( ( 0x4004000008U >> ( (ulong)(byte)TVar4 & 0x3f ) & 1 ) == 0 ) ) && ( -1 < (char)pTVar13[0xd] ) ) && ( ( (byte)pTVar13[0xe] & 1 ) == 0 )) {
               UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
               uVar14 = TQualifier::getLayoutFormatString(TVar4);
               pcVar16 = "format requires readonly or writeonly memory qualifier";
               goto LAB_0011f2f7;
            }

         }

         goto LAB_0011ea3f;
      }

      if (param_2[8] == (TType)0xe) {
         if (*(code**)( lVar12 + 0x40 ) == TType::getSampler) {
            pTVar15 = param_2 + 0x80;
         }
 else {
            pTVar15 = (TType*)( **(code**)( lVar12 + 0x40 ) )(param_2);
         }

         if (( ( (byte)pTVar15[2] & 8 ) != 0 ) && ( 1 < ( byte )((char)pTVar15[1] - 7U) )) goto LAB_0011ea06;
      }

      LAB_0011e9ed:if (*(long*)( *(long*)( this + 0x38 ) + 0x580 ) != 0) goto LAB_0011ea06;
      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
      uVar14 = TQualifier::getLayoutFormatString(pTVar13[0x2c]);
      pcVar16 = "only apply to images";
      LAB_0011f2f7:( *UNRECOVERED_JUMPTABLE )(this, param_1, pcVar16, uVar14, &_LC1);
      lVar12 = *(long*)param_2;
   }

   LAB_0011ea42:if (pTVar13[0x2d] != (TType)0x0) {
      if (*(code**)( lVar12 + 0x38 ) == TType::getBasicType) {
         uVar19 = (uint)(byte)param_2[8];
      }
 else {
         uVar19 = ( **(code**)( lVar12 + 0x38 ) )(param_2);
      }

      if (uVar19 != 0x10) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be used with a block", "push_constant", &_LC1);
      }

      lVar12 = *(long*)param_2;
      if (*(code**)( lVar12 + 0xe8 ) == TType::isArray) {
         if (*(long*)( param_2 + 0x60 ) == 0) goto LAB_0011eab8;
         LAB_0011eda9:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "Push constants blocks can\'t be an array", "push_constant", &_LC1);
      }
 else {
         cVar6 = ( **(code**)( lVar12 + 0xe8 ) )(param_2);
         if (cVar6 != '\0') goto LAB_0011eda9;
      }

      lVar12 = *(long*)param_2;
   }

   LAB_0011eab8:if (pTVar13[0x2e] != (TType)0x0) {
      if (*(code**)( lVar12 + 0x38 ) == TType::getBasicType) {
         uVar19 = (uint)(byte)param_2[8];
      }
 else {
         uVar19 = ( **(code**)( lVar12 + 0x38 ) )(param_2);
      }

      if (uVar19 != 0x10) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be used with a block", "buffer_reference", &_LC1);
      }

      lVar12 = *(long*)param_2;
   }

   if (pTVar13[0x38] != (TType)0x0) {
      if (*(code**)( lVar12 + 0x38 ) == TType::getBasicType) {
         uVar19 = (uint)(byte)param_2[8];
      }
 else {
         uVar19 = ( **(code**)( lVar12 + 0x38 ) )(param_2);
      }

      if (uVar19 != 0x10) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be used with a block", "shaderRecordNV", &_LC1);
      }

      lVar12 = *(long*)param_2;
   }

   if (*(code**)( lVar12 + 0x160 ) == TType::isSubpass) {
      if (param_2[8] == (TType)0xe) {
         if (*(code**)( lVar12 + 0x40 ) == TType::getSampler) {
            pTVar15 = param_2 + 0x80;
         }
 else {
            pTVar15 = (TType*)( **(code**)( lVar12 + 0x40 ) )(param_2);
         }

         if (pTVar15[1] == (TType)0x7) goto LAB_0011f1c5;
      }

      LAB_0011eb79:if (pTVar13[0x28] != (TType)0xff) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be used with a subpass", "input_attachment_index", &_LC1);
      }

   }
 else {
      cVar6 = ( **(code**)( lVar12 + 0x160 ) )(param_2);
      if (cVar6 == '\0') goto LAB_0011eb79;
      LAB_0011f1c5:cVar6 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_EXT_shader_tile_image");
      if (cVar6 != '\0') {
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         if (*(code**)( *(long*)param_2 + 0x40 ) != TType::getSampler) {
            ( **(code**)( *(long*)param_2 + 0x40 ) )(param_2);
         }

         TSampler::getString_abi_cxx11_();
         ( *UNRECOVERED_JUMPTABLE )(this, param_1, "can not be used with GL_EXT_shader_tile_image enabled", local_60, &_LC1);
      }

      if (pTVar13[0x28] == (TType)0xff) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "requires an input_attachment_index layout qualifier", "subpass", &_LC1);
      }

   }

   if (( ~*(uint *)(pTVar13 + 0x28) & 0x7ff00 ) != 0) {
      if (*(code**)( *(long*)param_2 + 0x58 ) == TType::getQualifier) {
         pTVar13 = param_2 + 0x10;
      }
 else {
         pTVar13 = (TType*)( **(code**)( *(long*)param_2 + 0x58 ) )(param_2);
      }

      if (( (byte)pTVar13[8] & 0x7f ) != 2) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be applied to \'const\'-qualified scalar", "constant_id", &_LC1);
      }

      UNRECOVERED_JUMPTABLE = *(code**)( *(long*)param_2 + 0xc0 );
      if (UNRECOVERED_JUMPTABLE == TType::isScalar) {
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)param_2 + 0xd8 );
         if (UNRECOVERED_JUMPTABLE == TType::isVector) {
            if (( (byte)param_2[9] & 0xf ) < 2) {
               bVar5 = (byte)param_2[10] >> 4 & 1;
               goto LAB_0011f792;
            }

            LAB_0011ec42:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be applied to a scalar", "constant_id", &_LC1);
            goto LAB_0011ec6a;
         }

         bVar5 = ( *UNRECOVERED_JUMPTABLE )(param_2);
         LAB_0011f792:if (bVar5 != 0) goto LAB_0011ec42;
         lVar12 = *(long*)param_2;
         if (*(code**)( lVar12 + 0xe0 ) != TType::isMatrix) {
            cVar6 = ( **(code**)( lVar12 + 0xe0 ) )(param_2);
            if (cVar6 == '\0') {
               lVar12 = *(long*)param_2;
               goto LAB_0011f7be;
            }

            goto LAB_0011ec42;
         }

         if (0xf < (byte)param_2[9]) goto LAB_0011ec42;
         LAB_0011f7be:if (*(code**)( lVar12 + 0x128 ) != TType::isStruct) {
            cVar6 = ( **(code**)( lVar12 + 0x128 ) )(param_2);
            if (cVar6 == '\0') {
               lVar12 = *(long*)param_2;
               goto LAB_0011f7e5;
            }

            goto LAB_0011ec42;
         }

         if (( byte )((char)param_2[8] - 0xfU) < 2) goto LAB_0011ec42;
         LAB_0011f7e5:if (*(code**)( lVar12 + 0xe8 ) != TType::isArray) {
            cVar6 = ( **(code**)( lVar12 + 0xe8 ) )(param_2);
            goto joined_r0x0011f867;
         }

         if (*(long*)( param_2 + 0x60 ) != 0) goto LAB_0011ec42;
      }
 else {
         cVar6 = ( *UNRECOVERED_JUMPTABLE )(param_2);
         joined_r0x0011f867:if (cVar6 == '\0') goto LAB_0011ec42;
         LAB_0011ec6a:lVar12 = *(long*)param_2;
      }

      if (*(code**)( lVar12 + 0x38 ) == TType::getBasicType) {
         uVar19 = (uint)(byte)param_2[8];
      }
 else {
         uVar19 = ( **(code**)( lVar12 + 0x38 ) )(param_2);
      }

      if (0xb < uVar19 - 1) {
         if (lVar3 == *(long*)( in_FS_OFFSET + 0x28 )) {
            pcVar16 = "constant_id";
            pcVar17 = "cannot be applied to this type";
            UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
            LAB_0011ecc5:/* WARNING: Could not recover jumptable at 0x0011ecdb. Too many branches *//* WARNING: Treating indirect jump as call */( *UNRECOVERED_JUMPTABLE )(this, param_1, pcVar17, pcVar16, &_LC1, UNRECOVERED_JUMPTABLE);
            return;
         }

         goto LAB_0012012b;
      }

   }

   if (lVar3 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return;
   }

   LAB_0012012b:/* WARNING: Subroutine does not return */__stack_chk_fail();
}
/* glslang::TParseContext::layoutObjectCheck(glslang::TSourceLoc const&, glslang::TSymbol const&) */void glslang::TParseContext::layoutObjectCheck(TParseContext *this, TSourceLoc *param_1, TSymbol *param_2) {
   uint uVar1;
   TType *pTVar2;
   TType *pTVar3;
   TType *pTVar4;
   long lVar5;
   pTVar2 = (TType*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
   if (*(code**)( *(long*)pTVar2 + 0x58 ) == TType::getQualifier) {
      pTVar3 = pTVar2 + 0x10;
   }
 else {
      pTVar3 = (TType*)( **(code**)( *(long*)pTVar2 + 0x58 ) )(pTVar2);
   }

   layoutTypeCheck(this, param_1, pTVar2);
   if (( ( ( ( ~*(ushort *)(pTVar3 + 0x1c) & 0xfff ) != 0 ) || ( ( (byte)pTVar3[0x1d] & 0x70 ) != 0x40 ) ) || ( pTVar3[0x22] != (TType)0xff ) ) && ( ( ( (byte)pTVar3[8] & 0x7f ) - 5 < 2 && ( lVar5 = ( **(code**)( *(long*)param_2 + 0x50 ) )(param_2) ),lVar5 == 0 ) )) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be used on variable declaration", "location", &_LC1);
   }

   if (( ( *(int*)( this + 0x20 ) == 0 ) || ( this[0x1c1] != (TParseContext)0x0 ) ) || ( ( 0x7f < *(ushort*)( pTVar3 + 8 ) || ( ( ( ( ~*(ushort *)(pTVar3 + 0x1c) & 0xfff ) != 0 || ( *(char*)( *(long*)( this + 0x38 ) + 0x4d1 ) != '\0' ) ) || ( 1 < ( (byte)pTVar3[8] & 0x7f ) - 3 ) ) ) ) )) goto LAB_001201d7;
   if (*(code**)( *(long*)pTVar2 + 0x58 ) == TType::getQualifier) {
      if (( (byte)pTVar2[0x1d] & 8 ) != 0) goto LAB_001201d7;
      LAB_0012027f:pTVar4 = pTVar2 + 0x10;
   }
 else {
      lVar5 = ( **(code**)( *(long*)pTVar2 + 0x58 ) )(pTVar2);
      if (( *(byte*)( lVar5 + 0xd ) & 8 ) != 0) goto LAB_001201d7;
      if (*(code**)( *(long*)pTVar2 + 0x58 ) == TType::getQualifier) goto LAB_0012027f;
      pTVar4 = (TType*)( **(code**)( *(long*)pTVar2 + 0x58 ) )(pTVar2);
   }

   if (*(long*)( pTVar4 + 0x40 ) == 0) {
      if (*(code**)( *(long*)pTVar2 + 0x38 ) == TType::getBasicType) {
         uVar1 = (uint)(byte)pTVar2[8];
      }
 else {
         uVar1 = ( **(code**)( *(long*)pTVar2 + 0x38 ) )(pTVar2);
      }

      if (( uVar1 != 0x10 ) || ( ( lVar5 = ( **(code**)( *(long*)**(undefined8**)( *(long*)( pTVar2 + 0x68 ) + 8 ) + 0x50 ) )()(~*(ushort *)(lVar5 + 0x1c) & 0xfff) == 0 && ( lVar5 = ( **(code**)( *(long*)**(undefined8**)( *(long*)( pTVar2 + 0x68 ) + 8 ) + 0x50 ) )() * (ushort*)( lVar5 + 8 ) < 0x80 ) ) )) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "SPIR-V requires location for user input/output", "location", &_LC1);
      }

   }

   LAB_001201d7:if (( ( ( ( (byte)pTVar3[0xf] & 0x70 ) != 0 ) || ( ( (byte)pTVar3[0x10] & 0xf ) != 0 ) ) || ( ( *(int*)( pTVar3 + 0x14 ) != -1 || ( ( ( *(short*)( pTVar3 + 0x20 ) != -1 || ( ( *(uint*)( pTVar3 + 0x1c ) & 0x3f8000 ) != 0x1f8000 ) ) || ( *(int*)( pTVar3 + 0x18 ) != -1 ) ) ) ) ) ) && ( ( (byte)pTVar3[8] & 0x7f ) - 5 < 2 )) {
      if (*(code**)( *(long*)pTVar2 + 0x38 ) == TType::getBasicType) {
         uVar1 = (uint)(byte)pTVar2[8];
      }
 else {
         uVar1 = ( **(code**)( *(long*)pTVar2 + 0x38 ) )(pTVar2);
      }

      if (uVar1 != 0x10) {
         if (( (byte)pTVar3[0xf] & 0x70 ) != 0) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot specify matrix layout on a variable declaration", "layout", &_LC1);
         }

         if (( (byte)pTVar3[0x10] & 0xf ) != 0) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot specify packing on a variable declaration", "layout", &_LC1);
         }

         if (( *(int*)( pTVar3 + 0x14 ) != -1 ) && ( pTVar2[8] != (TType)0xd )) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot specify on a variable declaration", "offset", &_LC1);
         }

         if (*(int*)( pTVar3 + 0x18 ) != -1) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot specify on a variable declaration", "align", &_LC1);
         }

         if (pTVar3[0x2d] != (TType)0x0) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only specify on a uniform block", "push_constant", &_LC1);
         }

         if (pTVar3[0x38] != (TType)0x0) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only specify on a buffer block", "shaderRecordNV", &_LC1);
         }

         if (( ( ~*(ushort *)(pTVar3 + 0x1c) & 0xfff ) != 0 ) && ( pTVar2[8] == (TType)0xd )) {
            /* WARNING: Could not recover jumptable at 0x001204cf. Too many branches */
            /* WARNING: Treating indirect jump as call */
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot specify on atomic counter", "location", &_LC1, *(code**)( *(long*)this + 0x158 ));
            return;
         }

      }

   }

   return;
}
/* glslang::TParseContext::accStructCheck(glslang::TSourceLoc const&, glslang::TType const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const&)
    */void glslang::TParseContext::accStructCheck(TParseContext *this, TSourceLoc *param_1, TType *param_2, basic_string *param_3) {
   undefined8 uVar1;
   code *pcVar2;
   char cVar3;
   int iVar4;
   uint uVar5;
   TType *pTVar6;
   long lVar7;
   char *pcVar8;
   long in_FS_OFFSET;
   undefined8 local_68;
   undefined1 *local_60;
   undefined1 local_50[16];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(code**)( *(long*)param_2 + 0x58 ) == TType::getQualifier) {
      pTVar6 = param_2 + 0x10;
   }
 else {
      pTVar6 = (TType*)( **(code**)( *(long*)param_2 + 0x58 ) )(param_2);
   }

   if (( (byte)pTVar6[8] & 0x7f ) == 5) goto LAB_001205ea;
   if (*(code**)( *(long*)param_2 + 0x38 ) == TType::getBasicType) {
      uVar5 = (uint)(byte)param_2[8];
      if (param_2[8] == (TType)0xf) {
         LAB_0012068a:cVar3 = containsFieldWithBasicType(this, param_2, 0x11);
         if (cVar3 != '\0') {
            uVar1 = *(undefined8*)( param_3 + 8 );
            pcVar2 = *(code**)( *(long*)this + 0x158 );
            if (param_2[8] == (TType)0xe) {
               TSampler::getString_abi_cxx11_();
            }
 else {
               local_68 = glslang::GetThreadPoolAllocator();
               switch (param_2[8]) {
                  case (TType)0x0:
            lVar7 = 4;
            pcVar8 = "void";
            break;
                  case (TType)0x1:
            lVar7 = 5;
            pcVar8 = "float";
            break;
                  case (TType)0x2:
            lVar7 = 6;
            pcVar8 = "double";
            break;
                  case (TType)0x3:
            lVar7 = 9;
            pcVar8 = "float16_t";
            break;
                  case (TType)0x4:
            lVar7 = 6;
            pcVar8 = "int8_t";
            break;
                  case (TType)0x5:
            lVar7 = 7;
            pcVar8 = "uint8_t";
            break;
                  case (TType)0x6:
            lVar7 = 7;
            pcVar8 = "int16_t";
            break;
                  case (TType)0x7:
            lVar7 = 8;
            pcVar8 = "uint16_t";
            break;
                  case (TType)0x8:
            lVar7 = 3;
            pcVar8 = "int";
            break;
                  case (TType)0x9:
            lVar7 = 4;
            pcVar8 = "uint";
            break;
                  case (TType)0xa:
            lVar7 = 7;
            pcVar8 = "int64_t";
            break;
                  case (TType)0xb:
            lVar7 = 8;
            pcVar8 = "uint64_t";
            break;
                  case (TType)0xc:
            lVar7 = 4;
            pcVar8 = "bool";
            break;
                  case (TType)0xd:
            lVar7 = 0xb;
            pcVar8 = "atomic_uint";
            break;
                  case (TType)0xe:
            lVar7 = 0xd;
            pcVar8 = "sampler/image";
            break;
                  case (TType)0xf:
            lVar7 = 9;
            pcVar8 = "structure";
            break;
                  case (TType)0x10:
            lVar7 = 5;
            pcVar8 = "block";
            break;
                  case (TType)0x11:
            lVar7 = 0x17;
            pcVar8 = "accelerationStructureNV";
            break;
                  case (TType)0x12:
            lVar7 = 9;
            pcVar8 = "reference";
            break;
                  case (TType)0x13:
            lVar7 = 0xb;
            pcVar8 = "rayQueryEXT";
            break;
                  default:
            lVar7 = 0xc;
            pcVar8 = "unknown type";
            break;
                  case (TType)0x15:
            lVar7 = 7;
            pcVar8 = "coopmat";
            break;
                  case (TType)0x16:
            lVar7 = 10;
            pcVar8 = "spirv_type";
            break;
                  case (TType)0x17:
            lVar7 = 6;
            pcVar8 = "string";
               }

               local_60 = local_50;
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, pcVar8, pcVar8 + lVar7);
            }

            ( *pcVar2 )(this, param_1, "non-uniform struct contains an accelerationStructureNV:", local_60, uVar1);
            goto LAB_001205ea;
         }

         goto LAB_0012069e;
      }

   }
 else {
      iVar4 = ( **(code**)( *(long*)param_2 + 0x38 ) )(param_2);
      if (iVar4 == 0xf) goto LAB_0012068a;
      LAB_0012069e:if (*(code**)( *(long*)param_2 + 0x38 ) == TType::getBasicType) {
         uVar5 = (uint)(byte)param_2[8];
      }
 else {
         uVar5 = ( **(code**)( *(long*)param_2 + 0x38 ) )(param_2);
      }

   }

   if (uVar5 == 0x11) {
      if (*(code**)( *(long*)param_2 + 0x58 ) == TType::getQualifier) {
         pTVar6 = param_2 + 0x10;
      }
 else {
         pTVar6 = (TType*)( **(code**)( *(long*)param_2 + 0x58 ) )(param_2);
      }

      if (( (byte)pTVar6[8] & 0x7f ) != 5) {
         uVar1 = *(undefined8*)( param_3 + 8 );
         pcVar2 = *(code**)( *(long*)this + 0x158 );
         if (param_2[8] == (TType)0xe) {
            TSampler::getString_abi_cxx11_();
         }
 else {
            local_68 = glslang::GetThreadPoolAllocator();
            switch (param_2[8]) {
               case (TType)0x0:
          lVar7 = 4;
          pcVar8 = "void";
          break;
               case (TType)0x1:
          lVar7 = 5;
          pcVar8 = "float";
          break;
               case (TType)0x2:
          lVar7 = 6;
          pcVar8 = "double";
          break;
               case (TType)0x3:
          lVar7 = 9;
          pcVar8 = "float16_t";
          break;
               case (TType)0x4:
          lVar7 = 6;
          pcVar8 = "int8_t";
          break;
               case (TType)0x5:
          lVar7 = 7;
          pcVar8 = "uint8_t";
          break;
               case (TType)0x6:
          lVar7 = 7;
          pcVar8 = "int16_t";
          break;
               case (TType)0x7:
          lVar7 = 8;
          pcVar8 = "uint16_t";
          break;
               case (TType)0x8:
          lVar7 = 3;
          pcVar8 = "int";
          break;
               case (TType)0x9:
          lVar7 = 4;
          pcVar8 = "uint";
          break;
               case (TType)0xa:
          lVar7 = 7;
          pcVar8 = "int64_t";
          break;
               case (TType)0xb:
          lVar7 = 8;
          pcVar8 = "uint64_t";
          break;
               case (TType)0xc:
          lVar7 = 4;
          pcVar8 = "bool";
          break;
               case (TType)0xd:
          lVar7 = 0xb;
          pcVar8 = "atomic_uint";
          break;
               case (TType)0xe:
          lVar7 = 0xd;
          pcVar8 = "sampler/image";
          break;
               case (TType)0xf:
          lVar7 = 9;
          pcVar8 = "structure";
          break;
               case (TType)0x10:
          lVar7 = 5;
          pcVar8 = "block";
          break;
               case (TType)0x11:
          lVar7 = 0x17;
          pcVar8 = "accelerationStructureNV";
          break;
               case (TType)0x12:
          lVar7 = 9;
          pcVar8 = "reference";
          break;
               case (TType)0x13:
          lVar7 = 0xb;
          pcVar8 = "rayQueryEXT";
          break;
               default:
          lVar7 = 0xc;
          pcVar8 = "unknown type";
          break;
               case (TType)0x15:
          lVar7 = 7;
          pcVar8 = "coopmat";
          break;
               case (TType)0x16:
          lVar7 = 10;
          pcVar8 = "spirv_type";
          break;
               case (TType)0x17:
          lVar7 = 6;
          pcVar8 = "string";
            }

            local_60 = local_50;
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, pcVar8, pcVar8 + lVar7);
         }

         ( *pcVar2 )(this, param_1, "accelerationStructureNV can only be used in uniform variables or function parameters:", local_60, uVar1);
      }

   }

   LAB_001205ea:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::atomicUintCheck(glslang::TSourceLoc const&, glslang::TType const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const&)
    */void glslang::TParseContext::atomicUintCheck(TParseContext *this, TSourceLoc *param_1, TType *param_2, basic_string *param_3) {
   undefined8 uVar1;
   code *pcVar2;
   char cVar3;
   int iVar4;
   uint uVar5;
   TType *pTVar6;
   long lVar7;
   char *pcVar8;
   long in_FS_OFFSET;
   undefined8 local_68;
   undefined1 *local_60;
   undefined1 local_50[16];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(code**)( *(long*)param_2 + 0x58 ) == TType::getQualifier) {
      pTVar6 = param_2 + 0x10;
   }
 else {
      pTVar6 = (TType*)( **(code**)( *(long*)param_2 + 0x58 ) )(param_2);
   }

   if (( (byte)pTVar6[8] & 0x7f ) == 5) goto LAB_00120dda;
   if (*(code**)( *(long*)param_2 + 0x38 ) == TType::getBasicType) {
      uVar5 = (uint)(byte)param_2[8];
      if (param_2[8] == (TType)0xf) {
         LAB_00120e7a:cVar3 = containsFieldWithBasicType(this, param_2, 0xd);
         if (cVar3 != '\0') {
            uVar1 = *(undefined8*)( param_3 + 8 );
            pcVar2 = *(code**)( *(long*)this + 0x158 );
            if (param_2[8] == (TType)0xe) {
               TSampler::getString_abi_cxx11_();
            }
 else {
               local_68 = glslang::GetThreadPoolAllocator();
               switch (param_2[8]) {
                  case (TType)0x0:
            lVar7 = 4;
            pcVar8 = "void";
            break;
                  case (TType)0x1:
            lVar7 = 5;
            pcVar8 = "float";
            break;
                  case (TType)0x2:
            lVar7 = 6;
            pcVar8 = "double";
            break;
                  case (TType)0x3:
            lVar7 = 9;
            pcVar8 = "float16_t";
            break;
                  case (TType)0x4:
            lVar7 = 6;
            pcVar8 = "int8_t";
            break;
                  case (TType)0x5:
            lVar7 = 7;
            pcVar8 = "uint8_t";
            break;
                  case (TType)0x6:
            lVar7 = 7;
            pcVar8 = "int16_t";
            break;
                  case (TType)0x7:
            lVar7 = 8;
            pcVar8 = "uint16_t";
            break;
                  case (TType)0x8:
            lVar7 = 3;
            pcVar8 = "int";
            break;
                  case (TType)0x9:
            lVar7 = 4;
            pcVar8 = "uint";
            break;
                  case (TType)0xa:
            lVar7 = 7;
            pcVar8 = "int64_t";
            break;
                  case (TType)0xb:
            lVar7 = 8;
            pcVar8 = "uint64_t";
            break;
                  case (TType)0xc:
            lVar7 = 4;
            pcVar8 = "bool";
            break;
                  case (TType)0xd:
            lVar7 = 0xb;
            pcVar8 = "atomic_uint";
            break;
                  case (TType)0xe:
            lVar7 = 0xd;
            pcVar8 = "sampler/image";
            break;
                  case (TType)0xf:
            lVar7 = 9;
            pcVar8 = "structure";
            break;
                  case (TType)0x10:
            lVar7 = 5;
            pcVar8 = "block";
            break;
                  case (TType)0x11:
            lVar7 = 0x17;
            pcVar8 = "accelerationStructureNV";
            break;
                  case (TType)0x12:
            lVar7 = 9;
            pcVar8 = "reference";
            break;
                  case (TType)0x13:
            lVar7 = 0xb;
            pcVar8 = "rayQueryEXT";
            break;
                  default:
            lVar7 = 0xc;
            pcVar8 = "unknown type";
            break;
                  case (TType)0x15:
            lVar7 = 7;
            pcVar8 = "coopmat";
            break;
                  case (TType)0x16:
            lVar7 = 10;
            pcVar8 = "spirv_type";
            break;
                  case (TType)0x17:
            lVar7 = 6;
            pcVar8 = "string";
               }

               local_60 = local_50;
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, pcVar8, pcVar8 + lVar7);
            }

            ( *pcVar2 )(this, param_1, "non-uniform struct contains an atomic_uint:", local_60, uVar1);
            goto LAB_00120dda;
         }

         goto LAB_00120e8e;
      }

   }
 else {
      iVar4 = ( **(code**)( *(long*)param_2 + 0x38 ) )(param_2);
      if (iVar4 == 0xf) goto LAB_00120e7a;
      LAB_00120e8e:if (*(code**)( *(long*)param_2 + 0x38 ) == TType::getBasicType) {
         uVar5 = (uint)(byte)param_2[8];
      }
 else {
         uVar5 = ( **(code**)( *(long*)param_2 + 0x38 ) )(param_2);
      }

   }

   if (uVar5 == 0xd) {
      if (*(code**)( *(long*)param_2 + 0x58 ) == TType::getQualifier) {
         pTVar6 = param_2 + 0x10;
      }
 else {
         pTVar6 = (TType*)( **(code**)( *(long*)param_2 + 0x58 ) )(param_2);
      }

      if (( (byte)pTVar6[8] & 0x7f ) != 5) {
         uVar1 = *(undefined8*)( param_3 + 8 );
         pcVar2 = *(code**)( *(long*)this + 0x158 );
         if (param_2[8] == (TType)0xe) {
            TSampler::getString_abi_cxx11_();
         }
 else {
            local_68 = glslang::GetThreadPoolAllocator();
            switch (param_2[8]) {
               case (TType)0x0:
          lVar7 = 4;
          pcVar8 = "void";
          break;
               case (TType)0x1:
          lVar7 = 5;
          pcVar8 = "float";
          break;
               case (TType)0x2:
          lVar7 = 6;
          pcVar8 = "double";
          break;
               case (TType)0x3:
          lVar7 = 9;
          pcVar8 = "float16_t";
          break;
               case (TType)0x4:
          lVar7 = 6;
          pcVar8 = "int8_t";
          break;
               case (TType)0x5:
          lVar7 = 7;
          pcVar8 = "uint8_t";
          break;
               case (TType)0x6:
          lVar7 = 7;
          pcVar8 = "int16_t";
          break;
               case (TType)0x7:
          lVar7 = 8;
          pcVar8 = "uint16_t";
          break;
               case (TType)0x8:
          lVar7 = 3;
          pcVar8 = "int";
          break;
               case (TType)0x9:
          lVar7 = 4;
          pcVar8 = "uint";
          break;
               case (TType)0xa:
          lVar7 = 7;
          pcVar8 = "int64_t";
          break;
               case (TType)0xb:
          lVar7 = 8;
          pcVar8 = "uint64_t";
          break;
               case (TType)0xc:
          lVar7 = 4;
          pcVar8 = "bool";
          break;
               case (TType)0xd:
          lVar7 = 0xb;
          pcVar8 = "atomic_uint";
          break;
               case (TType)0xe:
          lVar7 = 0xd;
          pcVar8 = "sampler/image";
          break;
               case (TType)0xf:
          lVar7 = 9;
          pcVar8 = "structure";
          break;
               case (TType)0x10:
          lVar7 = 5;
          pcVar8 = "block";
          break;
               case (TType)0x11:
          lVar7 = 0x17;
          pcVar8 = "accelerationStructureNV";
          break;
               case (TType)0x12:
          lVar7 = 9;
          pcVar8 = "reference";
          break;
               case (TType)0x13:
          lVar7 = 0xb;
          pcVar8 = "rayQueryEXT";
          break;
               default:
          lVar7 = 0xc;
          pcVar8 = "unknown type";
          break;
               case (TType)0x15:
          lVar7 = 7;
          pcVar8 = "coopmat";
          break;
               case (TType)0x16:
          lVar7 = 10;
          pcVar8 = "spirv_type";
          break;
               case (TType)0x17:
          lVar7 = 6;
          pcVar8 = "string";
            }

            local_60 = local_50;
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, pcVar8, pcVar8 + lVar7);
         }

         ( *pcVar2 )(this, param_1, "atomic_uints can only be used in uniform variables or function parameters:", local_60, uVar1);
      }

   }

   LAB_00120dda:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::paramCheckFix(glslang::TSourceLoc const&, glslang::TQualifier const&,
   glslang::TType&) */void glslang::TParseContext::paramCheckFix(TParseContext *this, TSourceLoc *param_1, TQualifier *param_2, TType *param_3) {
   TQualifier TVar1;
   TQualifier TVar2;
   TType TVar3;
   TQualifier TVar4;
   int iVar5;
   code *pcVar6;
   TType *pTVar7;
   long lVar8;
   char *pcVar9;
   byte bVar10;
   uint uVar11;
   long in_FS_OFFSET;
   uint local_6c;
   undefined8 local_68;
   undefined1 *local_60;
   undefined1 local_50[16];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   TVar4 = param_2[0xe];
   uVar11 = (byte)TVar4 >> 2 & 1;
   if (( ( ( ( ( ( (char)TVar4 < '\0' ) || ( ( (byte)TVar4 & 0x40 ) != 0 ) ) || ( ( (byte)TVar4 & 0x20 ) != 0 ) ) || ( ( ( (byte)TVar4 & 0x10 ) != 0 || ( ( (byte)TVar4 & 8 ) != 0 ) ) ) ) || ( ( ( (byte)TVar4 & 2 ) != 0 || ( ( (char)uVar11 != '\0' || ( ( (byte)param_2[0xd] & 0x40 ) != 0 ) ) ) ) ) ) || ( (char)param_2[0xd] < '\0' ) ) || ( ( ( (byte)TVar4 & 1 ) != 0 || ( ( (byte)param_2[0xf] & 1 ) != 0 ) ) )) {
      if (*(code**)( *(long*)param_3 + 0x50 ) == TType::getQualifier) {
         TVar3 = ( TType )((byte)param_3[0x1e] & 0xfb | ( byte )(uVar11 << 2));
         param_3[0x1e] = TVar3;
         bVar10 = (byte)param_2[0xe] >> 1 & 1;
         LAB_001215d2:TVar3 = ( TType )((byte)TVar3 & 0xfd | bVar10 * '\x02');
         param_3[0x1e] = TVar3;
         uVar11 = (byte)param_2[0xe] >> 3 & 1;
         LAB_001215ef:TVar3 = ( TType )((byte)TVar3 & 0xf7 | ( byte )(uVar11 << 3));
         param_3[0x1e] = TVar3;
         uVar11 = (byte)param_2[0xe] >> 4 & 1;
         LAB_0012160d:TVar3 = ( TType )((byte)TVar3 & 0xef | ( byte )(uVar11 << 4));
         param_3[0x1e] = TVar3;
         uVar11 = (byte)param_2[0xe] >> 5 & 1;
         LAB_0012162b:TVar3 = ( TType )((byte)TVar3 & 0xdf | ( byte )(uVar11 << 5));
         param_3[0x1e] = TVar3;
         uVar11 = (byte)param_2[0xe] >> 6 & 1;
         LAB_00121649:TVar3 = ( TType )((byte)TVar3 & 0xbf | ( byte )(uVar11 << 6));
         param_3[0x1e] = TVar3;
         bVar10 = (byte)param_2[0xe] >> 7;
         LAB_00121663:TVar3 = ( TType )((byte)TVar3 & 0x7f | bVar10 << 7);
         param_3[0x1e] = TVar3;
         bVar10 = (byte)param_2[0xf] & 1;
         LAB_00121679:param_3[0x1f] = ( TType )((byte)param_3[0x1f] & 0xfe | bVar10);
         bVar10 = (byte)param_2[0xd] >> 7;
         LAB_0012168f:param_3[0x1d] = ( TType )((byte)param_3[0x1d] & 0x7f | bVar10 << 7);
         bVar10 = (byte)param_2[0xe] & 1;
         LAB_001216a9:param_3[0x1e] = ( TType )((byte)TVar3 & 0xfe | bVar10);
         uVar11 = (byte)param_2[0xd] >> 6 & 1;
         LAB_001216bf:pTVar7 = param_3 + 0x10;
      }
 else {
         lVar8 = ( **(code**)( *(long*)param_3 + 0x50 ) )(param_3);
         pcVar6 = *(code**)( *(long*)param_3 + 0x50 );
         *(byte*)( lVar8 + 0xe ) = *(byte*)( lVar8 + 0xe ) & 0xfb | ( byte )(uVar11 << 2);
         bVar10 = (byte)param_2[0xe] >> 1 & 1;
         if (pcVar6 == TType::getQualifier) {
            TVar3 = param_3[0x1e];
            goto LAB_001215d2;
         }

         lVar8 = ( *pcVar6 )(param_3);
         pcVar6 = *(code**)( *(long*)param_3 + 0x50 );
         *(byte*)( lVar8 + 0xe ) = *(byte*)( lVar8 + 0xe ) & 0xfd | bVar10 * '\x02';
         uVar11 = (byte)param_2[0xe] >> 3 & 1;
         if (pcVar6 == TType::getQualifier) {
            TVar3 = param_3[0x1e];
            goto LAB_001215ef;
         }

         lVar8 = ( *pcVar6 )(param_3);
         pcVar6 = *(code**)( *(long*)param_3 + 0x50 );
         *(byte*)( lVar8 + 0xe ) = *(byte*)( lVar8 + 0xe ) & 0xf7 | ( byte )(uVar11 << 3);
         uVar11 = (byte)param_2[0xe] >> 4 & 1;
         if (pcVar6 == TType::getQualifier) {
            TVar3 = param_3[0x1e];
            goto LAB_0012160d;
         }

         lVar8 = ( *pcVar6 )(param_3);
         pcVar6 = *(code**)( *(long*)param_3 + 0x50 );
         *(byte*)( lVar8 + 0xe ) = *(byte*)( lVar8 + 0xe ) & 0xef | ( byte )(uVar11 << 4);
         uVar11 = (byte)param_2[0xe] >> 5 & 1;
         if (pcVar6 == TType::getQualifier) {
            TVar3 = param_3[0x1e];
            goto LAB_0012162b;
         }

         lVar8 = ( *pcVar6 )(param_3);
         pcVar6 = *(code**)( *(long*)param_3 + 0x50 );
         *(byte*)( lVar8 + 0xe ) = *(byte*)( lVar8 + 0xe ) & 0xdf | ( byte )(uVar11 << 5);
         uVar11 = (byte)param_2[0xe] >> 6 & 1;
         if (pcVar6 == TType::getQualifier) {
            TVar3 = param_3[0x1e];
            goto LAB_00121649;
         }

         lVar8 = ( *pcVar6 )(param_3);
         pcVar6 = *(code**)( *(long*)param_3 + 0x50 );
         *(byte*)( lVar8 + 0xe ) = *(byte*)( lVar8 + 0xe ) & 0xbf | ( byte )(uVar11 << 6);
         bVar10 = (byte)param_2[0xe] >> 7;
         if (pcVar6 == TType::getQualifier) {
            TVar3 = param_3[0x1e];
            goto LAB_00121663;
         }

         lVar8 = ( *pcVar6 )(param_3);
         pcVar6 = *(code**)( *(long*)param_3 + 0x50 );
         *(byte*)( lVar8 + 0xe ) = *(byte*)( lVar8 + 0xe ) & 0x7f | bVar10 << 7;
         bVar10 = (byte)param_2[0xf] & 1;
         if (pcVar6 == TType::getQualifier) {
            TVar3 = param_3[0x1e];
            goto LAB_00121679;
         }

         lVar8 = ( *pcVar6 )(param_3);
         pcVar6 = *(code**)( *(long*)param_3 + 0x50 );
         *(byte*)( lVar8 + 0xf ) = *(byte*)( lVar8 + 0xf ) & 0xfe | bVar10;
         bVar10 = (byte)param_2[0xd] >> 7;
         if (pcVar6 == TType::getQualifier) {
            TVar3 = param_3[0x1e];
            goto LAB_0012168f;
         }

         lVar8 = ( *pcVar6 )(param_3);
         pcVar6 = *(code**)( *(long*)param_3 + 0x50 );
         *(byte*)( lVar8 + 0xd ) = *(byte*)( lVar8 + 0xd ) & 0x7f | bVar10 << 7;
         bVar10 = (byte)param_2[0xe] & 1;
         if (pcVar6 == TType::getQualifier) {
            TVar3 = param_3[0x1e];
            goto LAB_001216a9;
         }

         lVar8 = ( *pcVar6 )(param_3);
         pcVar6 = *(code**)( *(long*)param_3 + 0x50 );
         *(byte*)( lVar8 + 0xe ) = *(byte*)( lVar8 + 0xe ) & 0xfe | bVar10;
         uVar11 = (byte)param_2[0xd] >> 6 & 1;
         if (pcVar6 == TType::getQualifier) goto LAB_001216bf;
         pTVar7 = (TType*)( *pcVar6 )(param_3);
      }

      pTVar7[0xd] = ( TType )((byte)pTVar7[0xd] & 0xbf | ( byte )(uVar11 << 6));
   }

   TVar4 = param_2[0xb];
   if (( ( ( ( ( (byte)TVar4 & 0x20 ) != 0 ) || ( TVar1 = param_2[0xd]((byte)TVar1 & 0x10) != 0 ) ) || ( ( (byte)TVar1 & 0x20 ) != 0 ) ) || ( ( ( TVar2 = param_2[0xc] ),(char)TVar2 < '\0' || ( ( (byte)TVar1 & 1 ) != 0 ) ) || ( ( (char)TVar4 < '\0' || ( ( ( (byte)TVar4 & 0x40 ) != 0 || ( ( (byte)TVar2 & 0x20 ) != 0 ) ) ) ) ) ) )) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot use auxiliary or interpolation qualifiers on a function parameter", &_LC1);
   }

   if (( ( ( ( ( (byte)param_2[0xf] & 0x70 ) != 0 ) || ( ( (byte)param_2[0x10] & 0xf ) != 0 ) ) || ( *(int*)( param_2 + 0x14 ) != -1 ) ) || ( ( ( *(short*)( param_2 + 0x20 ) != -1 || ( ( *(uint*)( param_2 + 0x1c ) & 0x3f8000 ) != 0x1f8000 ) ) || ( ( ( *(int*)( param_2 + 0x18 ) != -1 || ( ( ( ~*(ushort *)(param_2 + 0x1c) & 0xfff ) != 0 || ( ( (byte)param_2[0x1d] & 0x70 ) != 0x40 ) ) ) ) || ( param_2[0x22] != (TQualifier)0xff ) ) ) ) ) ) || ( ( ( ( ( param_2[0x23] != (TQualifier)0xff || ( param_2[0x2c] != (TQualifier)0x0 ) ) || ( param_2[0x38] != (TQualifier)0x0 ) ) || ( ( param_2[0x2d] != (TQualifier)0x0 || ( param_2[0x2e] != (TQualifier)0x0 ) ) ) ) || ( ( ( ~(byte)param_2[0x24] & 0xf ) != 0 || ( ( ( ~*(uint *)(param_2 + 0x24) & 0x3fff0 ) != 0 || ( ( ~*(ushort *)(param_2 + 0x26) & 0x7ffc ) != 0 ) ) ) ) ) ) )) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot use layout qualifiers on a function parameter", &_LC1);
   }

   if (( (byte)param_2[0xb] & 0x10 ) != 0) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot use invariant qualifier on a function parameter", &_LC1);
   }

   TVar4 = param_2[0xc];
   if (( (byte)TVar4 & 0x10 ) != 0) {
      if (( (byte)param_2[8] & 0x7f ) - 0x11 < 2) {
         if (*(code**)( *(long*)param_3 + 0x50 ) == TType::getQualifier) {
            pTVar7 = param_3 + 0x10;
         }
 else {
            pTVar7 = (TType*)( **(code**)( *(long*)param_3 + 0x50 ) )(param_3);
         }

         pTVar7[0xc] = ( TType )((byte)pTVar7[0xc] | 0x10);
         TVar4 = param_2[0xc];
      }
 else {
         ( **(code**)( *(long*)this + 0x160 ) )(this, param_1, "qualifier has no effect on non-output parameters", "precise", &_LC1);
         TVar4 = param_2[0xc];
      }

   }

   if (( (byte)TVar4 & 2 ) != 0) {
      if (*(code**)( *(long*)param_3 + 0x50 ) == TType::getQualifier) {
         pTVar7 = param_3 + 0x10;
      }
 else {
         pTVar7 = (TType*)( **(code**)( *(long*)param_3 + 0x50 ) )(param_3);
      }

      pTVar7[0xc] = ( TType )((byte)pTVar7[0xc] | 2);
   }

   TVar4 = param_2[0xf];
   if (( (byte)TVar4 & 4 ) != 0) {
      if (*(code**)( *(long*)param_3 + 0x50 ) == TType::getQualifier) {
         pTVar7 = param_3 + 0x10;
      }
 else {
         pTVar7 = (TType*)( **(code**)( *(long*)param_3 + 0x50 ) )(param_3);
      }

      pTVar7[0xf] = ( TType )((byte)pTVar7[0xf] | 4);
      TVar4 = param_2[0xf];
   }

   if (( (byte)TVar4 & 8 ) == 0) goto LAB_00121937;
   lVar8 = *(long*)param_3;
   if (*(code**)( lVar8 + 0x38 ) == TType::getBasicType) {
      TVar3 = param_3[8];
      if (TVar3 != (TType)0x1) {
         LAB_00121868:if (TVar3 != (TType)0x8) {
            LAB_00121871:uVar11 = (uint)(byte)TVar3;
            if (TVar3 != (TType)0x9) {
               LAB_0012187a:if (uVar11 != 0xc) {
                  pcVar6 = *(code**)( *(long*)this + 0x158 );
                  if (param_3[8] == (TType)0xe) {
                     TSampler::getString_abi_cxx11_();
                  }
 else {
                     local_68 = glslang::GetThreadPoolAllocator();
                     switch (param_3[8]) {
                        case (TType)0x0:
                lVar8 = 4;
                pcVar9 = "void";
                break;
                        case (TType)0x1:
                lVar8 = 5;
                pcVar9 = "float";
                break;
                        case (TType)0x2:
                lVar8 = 6;
                pcVar9 = "double";
                break;
                        case (TType)0x3:
                lVar8 = 9;
                pcVar9 = "float16_t";
                break;
                        case (TType)0x4:
                lVar8 = 6;
                pcVar9 = "int8_t";
                break;
                        case (TType)0x5:
                lVar8 = 7;
                pcVar9 = "uint8_t";
                break;
                        case (TType)0x6:
                lVar8 = 7;
                pcVar9 = "int16_t";
                break;
                        case (TType)0x7:
                lVar8 = 8;
                pcVar9 = "uint16_t";
                break;
                        case (TType)0x8:
                lVar8 = 3;
                pcVar9 = "int";
                break;
                        case (TType)0x9:
                lVar8 = 4;
                pcVar9 = "uint";
                break;
                        case (TType)0xa:
                lVar8 = 7;
                pcVar9 = "int64_t";
                break;
                        case (TType)0xb:
                lVar8 = 8;
                pcVar9 = "uint64_t";
                break;
                        case (TType)0xc:
                lVar8 = 4;
                pcVar9 = "bool";
                break;
                        case (TType)0xd:
                lVar8 = 0xb;
                pcVar9 = "atomic_uint";
                break;
                        case (TType)0xe:
                lVar8 = 0xd;
                pcVar9 = "sampler/image";
                break;
                        case (TType)0xf:
                lVar8 = 9;
                pcVar9 = "structure";
                break;
                        case (TType)0x10:
                lVar8 = 5;
                pcVar9 = "block";
                break;
                        case (TType)0x11:
                lVar8 = 0x17;
                pcVar9 = "accelerationStructureNV";
                break;
                        case (TType)0x12:
                lVar8 = 9;
                pcVar9 = "reference";
                break;
                        case (TType)0x13:
                lVar8 = 0xb;
                pcVar9 = "rayQueryEXT";
                break;
                        default:
                lVar8 = 0xc;
                pcVar9 = "unknown type";
                break;
                        case (TType)0x15:
                lVar8 = 7;
                pcVar9 = "coopmat";
                break;
                        case (TType)0x16:
                lVar8 = 10;
                pcVar9 = "spirv_type";
                break;
                        case (TType)0x17:
                lVar8 = 6;
                pcVar9 = "string";
                     }

                     local_60 = local_50;
                     std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, pcVar9, pcVar9 + lVar8);
                  }

                  ( *pcVar6 )(this, param_1, "cannot use spirv_literal qualifier", local_60, &_LC1);
                  goto LAB_00121937;
               }

               goto LAB_00121a70;
            }

         }

      }

      LAB_0012191b:pcVar6 = *(code**)( lVar8 + 0x50 );
      if (pcVar6 == TType::getQualifier) goto LAB_0012192f;
      LAB_00121a88:pTVar7 = (TType*)( *pcVar6 )(param_3);
   }
 else {
      iVar5 = ( **(code**)( lVar8 + 0x38 ) )(param_3);
      if (iVar5 != 1) {
         lVar8 = *(long*)param_3;
         if (*(code**)( lVar8 + 0x38 ) == TType::getBasicType) {
            TVar3 = param_3[8];
            goto LAB_00121868;
         }

         iVar5 = ( **(code**)( lVar8 + 0x38 ) )(param_3);
         if (iVar5 != 8) {
            lVar8 = *(long*)param_3;
            if (*(code**)( lVar8 + 0x38 ) == TType::getBasicType) {
               TVar3 = param_3[8];
               goto LAB_00121871;
            }

            iVar5 = ( **(code**)( lVar8 + 0x38 ) )(param_3);
            lVar8 = *(long*)param_3;
            if (iVar5 == 9) goto LAB_0012191b;
            if (*(code**)( lVar8 + 0x38 ) == TType::getBasicType) {
               uVar11 = (uint)(byte)param_3[8];
            }
 else {
               uVar11 = ( **(code**)( lVar8 + 0x38 ) )(param_3);
            }

            goto LAB_0012187a;
         }

      }

      LAB_00121a70:pcVar6 = *(code**)( *(long*)param_3 + 0x50 );
      if (pcVar6 != TType::getQualifier) goto LAB_00121a88;
      LAB_0012192f:pTVar7 = param_3 + 0x10;
   }

   pTVar7[0xf] = ( TType )((byte)pTVar7[0xf] | 8);
   LAB_00121937:local_6c = (byte)param_2[8] & 0x7f;
   paramCheckFixStorage(this, param_1, (TStorageQualifier*)&local_6c, param_3);
   if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::parameterTypeCheck(glslang::TSourceLoc const&,
   glslang::TStorageQualifier, glslang::TType const&) */void glslang::TParseContext::parameterTypeCheck(TParseContext *this, undefined8 param_1, int param_3, TType *param_4) {
   char cVar1;
   long lVar2;
   long lVar3;
   char *pcVar4;
   code *pcVar5;
   long in_FS_OFFSET;
   undefined8 local_58;
   undefined1 *local_50;
   undefined1 local_40[16];
   long local_30;
   local_30 = *(long*)( in_FS_OFFSET + 0x28 );
   if (param_3 - 0x11U < 2) {
      if (*(code**)( *(long*)param_4 + 0x140 ) == TType::isOpaque) {
         if (( (byte)param_4[8] < 0x15 ) && ( ( 0x1a6000UL >> ( (ulong)(byte)param_4[8] & 0x3f ) & 1 ) != 0 )) {
            LAB_00122205:if (( *(long*)( *(long*)( this + 0x38 ) + 0x550 ) == 0 ) && ( *(long*)( *(long*)( this + 0x38 ) + 0x580 ) == 0 )) {
               pcVar5 = *(code**)( *(long*)this + 0x158 );
               if (param_4[8] == (TType)0xe) {
                  TSampler::getString_abi_cxx11_();
               }
 else {
                  local_58 = glslang::GetThreadPoolAllocator();
                  switch (param_4[8]) {
                     case (TType)0x0:
              lVar3 = 4;
              pcVar4 = "void";
              break;
                     case (TType)0x1:
              lVar3 = 5;
              pcVar4 = "float";
              break;
                     case (TType)0x2:
              lVar3 = 6;
              pcVar4 = "double";
              break;
                     case (TType)0x3:
              lVar3 = 9;
              pcVar4 = "float16_t";
              break;
                     case (TType)0x4:
              lVar3 = 6;
              pcVar4 = "int8_t";
              break;
                     case (TType)0x5:
              lVar3 = 7;
              pcVar4 = "uint8_t";
              break;
                     case (TType)0x6:
              lVar3 = 7;
              pcVar4 = "int16_t";
              break;
                     case (TType)0x7:
              lVar3 = 8;
              pcVar4 = "uint16_t";
              break;
                     case (TType)0x8:
              lVar3 = 3;
              pcVar4 = "int";
              break;
                     case (TType)0x9:
              lVar3 = 4;
              pcVar4 = "uint";
              break;
                     case (TType)0xa:
              lVar3 = 7;
              pcVar4 = "int64_t";
              break;
                     case (TType)0xb:
              lVar3 = 8;
              pcVar4 = "uint64_t";
              break;
                     case (TType)0xc:
              lVar3 = 4;
              pcVar4 = "bool";
              break;
                     case (TType)0xd:
              lVar3 = 0xb;
              pcVar4 = "atomic_uint";
              break;
                     case (TType)0xe:
              lVar3 = 0xd;
              pcVar4 = "sampler/image";
              break;
                     case (TType)0xf:
              lVar3 = 9;
              pcVar4 = "structure";
              break;
                     case (TType)0x10:
              lVar3 = 5;
              pcVar4 = "block";
              break;
                     case (TType)0x11:
              lVar3 = 0x17;
              pcVar4 = "accelerationStructureNV";
              break;
                     case (TType)0x12:
              lVar3 = 9;
              pcVar4 = "reference";
              break;
                     case (TType)0x13:
              lVar3 = 0xb;
              pcVar4 = "rayQueryEXT";
              break;
                     default:
              lVar3 = 0xc;
              pcVar4 = "unknown type";
              break;
                     case (TType)0x15:
              lVar3 = 7;
              pcVar4 = "coopmat";
              break;
                     case (TType)0x16:
              lVar3 = 10;
              pcVar4 = "spirv_type";
              break;
                     case (TType)0x17:
              lVar3 = 6;
              pcVar4 = "string";
                  }

                  local_50 = local_40;
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_58, pcVar4, pcVar4 + lVar3);
               }

               ( *pcVar5 )(this, param_1, "samplers and atomic_uints cannot be output parameters", local_50, &_LC1);
            }

         }

      }
 else {
         cVar1 = ( **(code**)( *(long*)param_4 + 0x140 ) )(param_4);
         if (cVar1 != '\0') goto LAB_00122205;
      }

   }

   if (this[0x1c1] != (TParseContext)0x0) goto LAB_001221ad;
   pcVar5 = *(code**)( *(long*)param_4 + 400 );
   if (pcVar5 == TType::containsBasicType) {
      if (param_4[8] == (TType)0x3) {
         pcVar5 = *(code**)( *(long*)this + 0xa8 );
         LAB_0012236b:local_58 = glslang::GetThreadPoolAllocator();
         switch (param_4[8]) {
            case (TType)0x0:
        lVar3 = 4;
        pcVar4 = "void";
        break;
            case (TType)0x1:
        lVar3 = 5;
        pcVar4 = "float";
        break;
            case (TType)0x2:
        lVar3 = 6;
        pcVar4 = "double";
        break;
            case (TType)0x3:
        lVar3 = 9;
        pcVar4 = "float16_t";
        break;
            case (TType)0x4:
        lVar3 = 6;
        pcVar4 = "int8_t";
        break;
            case (TType)0x5:
        lVar3 = 7;
        pcVar4 = "uint8_t";
        break;
            case (TType)0x6:
        lVar3 = 7;
        pcVar4 = "int16_t";
        break;
            case (TType)0x7:
        lVar3 = 8;
        pcVar4 = "uint16_t";
        break;
            case (TType)0x8:
        lVar3 = 3;
        pcVar4 = "int";
        break;
            case (TType)0x9:
        lVar3 = 4;
        pcVar4 = "uint";
        break;
            case (TType)0xa:
        lVar3 = 7;
        pcVar4 = "int64_t";
        break;
            case (TType)0xb:
        lVar3 = 8;
        pcVar4 = "uint64_t";
        break;
            case (TType)0xc:
        lVar3 = 4;
        pcVar4 = "bool";
        break;
            case (TType)0xd:
        lVar3 = 0xb;
        pcVar4 = "atomic_uint";
        break;
            case (TType)0xe:
        lVar3 = 0xd;
        pcVar4 = "sampler/image";
        break;
            case (TType)0xf:
        lVar3 = 9;
        pcVar4 = "structure";
        break;
            case (TType)0x10:
        lVar3 = 5;
        pcVar4 = "block";
        break;
            case (TType)0x11:
        lVar3 = 0x17;
        pcVar4 = "accelerationStructureNV";
        break;
            case (TType)0x12:
        lVar3 = 9;
        pcVar4 = "reference";
        break;
            case (TType)0x13:
        lVar3 = 0xb;
        pcVar4 = "rayQueryEXT";
        break;
            default:
        lVar3 = 0xc;
        pcVar4 = "unknown type";
        break;
            case (TType)0x15:
        lVar3 = 7;
        pcVar4 = "coopmat";
        break;
            case (TType)0x16:
        lVar3 = 10;
        pcVar4 = "spirv_type";
        break;
            case (TType)0x17:
        lVar3 = 6;
        pcVar4 = "string";
         }

         local_50 = local_40;
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_58, pcVar4, pcVar4 + lVar3);
         LAB_001222eb:( *pcVar5 )(this, param_1, local_50, "float16 types can only be in uniform block or buffer storage");
         goto LAB_00122300;
      }

      pcVar5 = *(code**)( *(long*)param_4 + 0x128 );
      if (pcVar5 != TType::isStruct) {
         cVar1 = ( *pcVar5 )(param_4);
         if (cVar1 == '\0') goto LAB_00122300;
         LAB_001222a9:lVar3 = *(long*)( *(long*)( param_4 + 0x68 ) + 0x10 );
         lVar2 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_4 + 0x68 ) + 8 ),lVar3,3 ));
         if (lVar3 != lVar2) goto LAB_001222c7;
         goto LAB_00122300;
      }

      if (( byte )((char)param_4[8] - 0xfU) < 2) goto LAB_001222a9;
      cVar1 = TType::contains16BitInt(param_4);
   }
 else {
      cVar1 = ( *pcVar5 )(param_4, 3);
      if (cVar1 != '\0') {
         LAB_001222c7:pcVar5 = *(code**)( *(long*)this + 0xa8 );
         if (param_4[8] != (TType)0xe) goto LAB_0012236b;
         TSampler::getString_abi_cxx11_();
         goto LAB_001222eb;
      }

      LAB_00122300:if (this[0x1c1] != (TParseContext)0x0) goto LAB_001221ad;
      cVar1 = TType::contains16BitInt(param_4);
   }

   if (cVar1 != '\0') {
      pcVar5 = *(code**)( *(long*)this + 0xc0 );
      if (param_4[8] == (TType)0xe) {
         TSampler::getString_abi_cxx11_();
      }
 else {
         local_58 = glslang::GetThreadPoolAllocator();
         switch (param_4[8]) {
            case (TType)0x0:
        lVar3 = 4;
        pcVar4 = "void";
        break;
            case (TType)0x1:
        lVar3 = 5;
        pcVar4 = "float";
        break;
            case (TType)0x2:
        lVar3 = 6;
        pcVar4 = "double";
        break;
            case (TType)0x3:
        lVar3 = 9;
        pcVar4 = "float16_t";
        break;
            case (TType)0x4:
        lVar3 = 6;
        pcVar4 = "int8_t";
        break;
            case (TType)0x5:
        lVar3 = 7;
        pcVar4 = "uint8_t";
        break;
            case (TType)0x6:
        lVar3 = 7;
        pcVar4 = "int16_t";
        break;
            case (TType)0x7:
        lVar3 = 8;
        pcVar4 = "uint16_t";
        break;
            case (TType)0x8:
        lVar3 = 3;
        pcVar4 = "int";
        break;
            case (TType)0x9:
        lVar3 = 4;
        pcVar4 = "uint";
        break;
            case (TType)0xa:
        lVar3 = 7;
        pcVar4 = "int64_t";
        break;
            case (TType)0xb:
        lVar3 = 8;
        pcVar4 = "uint64_t";
        break;
            case (TType)0xc:
        lVar3 = 4;
        pcVar4 = "bool";
        break;
            case (TType)0xd:
        lVar3 = 0xb;
        pcVar4 = "atomic_uint";
        break;
            case (TType)0xe:
        lVar3 = 0xd;
        pcVar4 = "sampler/image";
        break;
            case (TType)0xf:
        lVar3 = 9;
        pcVar4 = "structure";
        break;
            case (TType)0x10:
        lVar3 = 5;
        pcVar4 = "block";
        break;
            case (TType)0x11:
        lVar3 = 0x17;
        pcVar4 = "accelerationStructureNV";
        break;
            case (TType)0x12:
        lVar3 = 9;
        pcVar4 = "reference";
        break;
            case (TType)0x13:
        lVar3 = 0xb;
        pcVar4 = "rayQueryEXT";
        break;
            default:
        lVar3 = 0xc;
        pcVar4 = "unknown type";
        break;
            case (TType)0x15:
        lVar3 = 7;
        pcVar4 = "coopmat";
        break;
            case (TType)0x16:
        lVar3 = 10;
        pcVar4 = "spirv_type";
        break;
            case (TType)0x17:
        lVar3 = 6;
        pcVar4 = "string";
         }

         local_50 = local_40;
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_58, pcVar4, pcVar4 + lVar3);
      }

      ( *pcVar5 )(this, param_1, local_50, "(u)int16 types can only be in uniform block or buffer storage");
   }

   if (( this[0x1c1] == (TParseContext)0x0 ) && ( cVar1 = TType::contains8BitInt(param_4) ),cVar1 != '\0') {
      pcVar5 = *(code**)( *(long*)this + 0xd8 );
      if (param_4[8] == (TType)0xe) {
         TSampler::getString_abi_cxx11_();
      }
 else {
         local_58 = glslang::GetThreadPoolAllocator();
         switch (param_4[8]) {
            case (TType)0x0:
        lVar3 = 4;
        pcVar4 = "void";
        break;
            case (TType)0x1:
        lVar3 = 5;
        pcVar4 = "float";
        break;
            case (TType)0x2:
        lVar3 = 6;
        pcVar4 = "double";
        break;
            case (TType)0x3:
        lVar3 = 9;
        pcVar4 = "float16_t";
        break;
            case (TType)0x4:
        lVar3 = 6;
        pcVar4 = "int8_t";
        break;
            case (TType)0x5:
        lVar3 = 7;
        pcVar4 = "uint8_t";
        break;
            case (TType)0x6:
        lVar3 = 7;
        pcVar4 = "int16_t";
        break;
            case (TType)0x7:
        lVar3 = 8;
        pcVar4 = "uint16_t";
        break;
            case (TType)0x8:
        lVar3 = 3;
        pcVar4 = "int";
        break;
            case (TType)0x9:
        lVar3 = 4;
        pcVar4 = "uint";
        break;
            case (TType)0xa:
        lVar3 = 7;
        pcVar4 = "int64_t";
        break;
            case (TType)0xb:
        lVar3 = 8;
        pcVar4 = "uint64_t";
        break;
            case (TType)0xc:
        lVar3 = 4;
        pcVar4 = "bool";
        break;
            case (TType)0xd:
        lVar3 = 0xb;
        pcVar4 = "atomic_uint";
        break;
            case (TType)0xe:
        lVar3 = 0xd;
        pcVar4 = "sampler/image";
        break;
            case (TType)0xf:
        lVar3 = 9;
        pcVar4 = "structure";
        break;
            case (TType)0x10:
        lVar3 = 5;
        pcVar4 = "block";
        break;
            case (TType)0x11:
        lVar3 = 0x17;
        pcVar4 = "accelerationStructureNV";
        break;
            case (TType)0x12:
        lVar3 = 9;
        pcVar4 = "reference";
        break;
            case (TType)0x13:
        lVar3 = 0xb;
        pcVar4 = "rayQueryEXT";
        break;
            default:
        lVar3 = 0xc;
        pcVar4 = "unknown type";
        break;
            case (TType)0x15:
        lVar3 = 7;
        pcVar4 = "coopmat";
        break;
            case (TType)0x16:
        lVar3 = 10;
        pcVar4 = "spirv_type";
        break;
            case (TType)0x17:
        lVar3 = 6;
        pcVar4 = "string";
         }

         local_50 = local_40;
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_58, pcVar4, pcVar4 + lVar3);
      }

      ( *pcVar5 )(this, param_1, local_50, "(u)int8 types can only be in uniform block or buffer storage");
   }

   LAB_001221ad:if (local_30 != *(long*)( in_FS_OFFSET + 0x28 )) {
      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   return;
}
/* glslang::TParseContext::constructAggregate(TIntermNode*, glslang::TType const&, int,
   glslang::TSourceLoc const&) */long *__thiscallglslang::TParseContext::constructAggregate(TParseContext *this, TIntermNode *param_1, TType *param_2, int param_3, TSourceLoc *param_4) {
   undefined1 uVar1;
   undefined8 uVar2;
   code *pcVar3;
   char cVar4;
   undefined8 uVar5;
   long *plVar6;
   TType *this_00;
   long in_FS_OFFSET;
   long *local_180;
   undefined8 local_158;
   undefined1 *local_150;
   undefined1 local_140[24];
   undefined8 local_128;
   undefined1 *local_120;
   undefined1 local_110[24];
   undefined1 local_f8[8];
   undefined8 local_f0;
   undefined8 local_c8;
   undefined1 *local_c0;
   undefined1 local_b0[24];
   undefined8 local_98;
   undefined1 *local_90;
   undefined1 local_80[24];
   undefined1 local_68[8];
   undefined8 local_60;
   long local_40;
   uVar2 = *(undefined8*)( this + 0x38 );
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   uVar5 = ( **(code**)( *(long*)param_1 + 0x18 ) )(param_1);
   plVar6 = (long*)glslang::TIntermediate::addConversion(uVar2, 0x241, param_2, uVar5);
   if (plVar6 != (long*)0x0) {
      if (*(code**)( *plVar6 + 0xf0 ) == TIntermTyped::getType) {
         this_00 = (TType*)( plVar6 + 4 );
      }
 else {
         this_00 = (TType*)( **(code**)( *plVar6 + 0xf0 ) )(plVar6);
      }

      cVar4 = TType::operator ==(this_00, param_2);
      if (cVar4 != '\0') goto LAB_001230aa;
   }

   uVar1 = *(undefined1*)( *(long*)( this + 0x38 ) + 0x26f );
   pcVar3 = *(code**)( *(long*)this + 0x158 );
   local_98 = glslang::GetThreadPoolAllocator();
   local_90 = local_80;
   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
   local_c8 = glslang::GetThreadPoolAllocator();
   local_c0 = local_b0;
   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_c8, &_LC1, &_LC1);
   TType::getCompleteString(local_68, param_2, uVar1, 1, 1, 1);
   plVar6 = (long*)( **(code**)( *(long*)param_1 + 0x18 ) )(param_1);
   local_180 = plVar6 + 4;
   if (*(code**)( *plVar6 + 0xf0 ) != TIntermTyped::getType) {
      local_180 = (long*)( **(code**)( *plVar6 + 0xf0 ) )();
   }

   local_128 = glslang::GetThreadPoolAllocator();
   local_120 = local_110;
   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_128, &_LC1, &_LC1);
   local_158 = glslang::GetThreadPoolAllocator();
   local_150 = local_140;
   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_158, &_LC1, &_LC1);
   TType::getCompleteString(local_f8, local_180, uVar1, 1, 1, 1, &local_158, &local_128);
   plVar6 = (long*)0x0;
   ( *pcVar3 )(this, param_4, &_LC1, "constructor", "cannot convert parameter %d from \'%s\' to \'%s\'", param_3, local_f0, local_60);
   LAB_001230aa:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   return plVar6;
}
/* glslang::TParseContext::addConstructor(glslang::TSourceLoc const&, TIntermNode*, glslang::TType
   const&) */long *__thiscallglslang::TParseContext::addConstructor(TParseContext *this, TSourceLoc *param_1, TIntermNode *param_2, TType *param_3) {
   code *pcVar1;
   uint uVar2;
   byte bVar3;
   char cVar4;
   int iVar5;
   long lVar6;
   long *plVar7;
   ulong uVar8;
   undefined8 uVar9;
   long lVar10;
   undefined8 *puVar11;
   TIntermNode *pTVar12;
   long *plVar13;
   TSourceLoc *pTVar14;
   TIntermNode *pTVar15;
   TType *pTVar16;
   long *plVar17;
   long in_FS_OFFSET;
   undefined8 *local_188;
   undefined **local_178;
   undefined4 local_170;
   undefined8 local_168;
   ulong uStack_160;
   uint local_158;
   undefined4 uStack_154;
   undefined4 uStack_150;
   undefined4 uStack_14c;
   undefined4 uStack_148;
   undefined4 uStack_144;
   undefined4 uStack_140;
   undefined4 uStack_13c;
   uint local_138;
   undefined4 uStack_134;
   undefined4 uStack_130;
   undefined4 uStack_12c;
   undefined8 local_128;
   ulong uStack_120;
   undefined1 local_118[16];
   undefined1 local_108[16];
   uint local_f8;
   undefined1 local_f0[16];
   TType local_d8[8];
   undefined4 local_d0;
   undefined8 local_c8;
   ulong uStack_c0;
   undefined8 local_b8;
   undefined8 uStack_b0;
   undefined8 local_a8;
   undefined8 uStack_a0;
   undefined8 local_98;
   undefined8 uStack_90;
   undefined8 local_88;
   ulong uStack_80;
   undefined8 local_78;
   undefined8 local_70;
   undefined8 local_68;
   undefined8 uStack_60;
   uint local_58;
   undefined8 local_50;
   undefined8 uStack_48;
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (( param_2 == (TIntermNode*)0x0 ) || ( lVar6 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2) ),lVar6 == 0) {
      LAB_001236a0:plVar7 = (long*)0x0;
   }
 else {
      pcVar1 = *(code**)( *(long*)this + 0x208 );
      ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
      ( *pcVar1 )(this, param_1, "constructor");
      plVar7 = (long*)( **(code**)( *(long*)param_2 + 0x30 ) )(param_2);
      iVar5 = glslang::TIntermediate::mapTypeToConstructorOp(*(TType**)( this + 0x38 ));
      if (iVar5 == 0x242) {
         if (plVar7 != (long*)0x0) {
            if (*(code**)( *plVar7 + 400 ) == TIntermAggregate::getSequence) {
               plVar13 = plVar7 + 0x18;
            }
 else {
               plVar13 = (long*)( **(code**)( *plVar7 + 400 ) )(plVar7);
            }

            plVar13 = (long*)( **(code**)( **(long**)( plVar13[1] + 8 ) + 0x18 ) )();
            if (*(code**)( *plVar13 + 0xf0 ) == TIntermTyped::getType) {
               plVar13 = plVar13 + 4;
            }
 else {
               plVar13 = (long*)( **(code**)( *plVar13 + 0xf0 ) )();
            }

            if (*(code**)( *plVar13 + 0x40 ) == TType::getSampler) {
               plVar13 = plVar13 + 0x10;
            }
 else {
               plVar13 = (long*)( **(code**)( *plVar13 + 0x40 ) )();
            }

            if (( *plVar13 & 0x20000 ) != 0) {
               if (*(code**)( *plVar7 + 400 ) == TIntermAggregate::getSequence) {
                  plVar13 = plVar7 + 0x18;
               }
 else {
                  plVar13 = (long*)( **(code**)( *plVar7 + 400 ) )(plVar7);
               }

               plVar13 = (long*)( **(code**)( **(long**)plVar13[1] + 0x18 ) )();
               if (*(code**)( *plVar13 + 0xf8 ) == TIntermTyped::getWritableType) {
                  plVar13 = plVar13 + 4;
               }
 else {
                  plVar13 = (long*)( **(code**)( *plVar13 + 0xf8 ) )();
               }

               if (*(code**)( *plVar13 + 0x48 ) == TType::getSampler) {
                  plVar13 = plVar13 + 0x10;
               }
 else {
                  plVar13 = (long*)( **(code**)( *plVar13 + 0x48 ) )();
               }

               *(byte*)( (long)plVar13 + 2 ) = *(byte*)( (long)plVar13 + 2 ) | 2;
            }

            if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
               plVar7 = (long*)glslang::TIntermediate::setAggregateOperator(*(undefined8*)( this + 0x38 ), plVar7, 0x242, param_3, param_1);
               return plVar7;
            }

            goto LAB_00123cf9;
         }

         local_188 = (undefined8*)0x0;
      }
 else {
         local_188 = (undefined8*)0x0;
         if (iVar5 == 0x241) {
            local_188 = *(undefined8**)( *(long*)( param_3 + 0x68 ) + 8 );
         }

      }

      local_158 = local_158 & 0xfffffff0;
      local_178 = &PTR__TType_00167f00;
      uStack_120 = uStack_120 & 0xffffffffffff0000;
      local_f8 = local_f8 & 0x9fc00000;
      local_170 = CONCAT22((short)( local_170 >> 0x10 ), 0x100) & 0xf800ffff;
      local_138 = local_138 & 0xffffff00;
      uStack_134 = 0xfffff800;
      uStack_130 = 0;
      local_168 = 0;
      uStack_154 = 0xffffffff;
      uStack_150 = 0xffffffff;
      local_f0 = (undefined1[16])0x0;
      local_118 = (undefined1[16])0x0;
      uStack_13c = 0;
      uVar8 = ( (ulong)CONCAT43(uStack_148, uStack_14c._1_3_) & 0xffc000 | 0xffff001f80 ) << 8 | 0xffff000000004fff;
      local_108 = (undefined1[16])0x0;
      uStack_14c = (undefined4)uVar8;
      uStack_148 = ( undefined4 )(uVar8 >> 0x20);
      uVar8 = CONCAT44(uStack_140, uStack_144) & 0xfe07ff00ffffffff | 0x1ffffff7fffffff;
      uStack_144 = (undefined4)uVar8;
      uStack_140 = ( undefined4 )(uVar8 >> 0x20);
      uStack_160 = uStack_160 & 0x8000000400000000;
      uStack_12c = 0xffffffff;
      local_128 = 0;
      if (*(code**)( *(long*)param_3 + 0xe8 ) == TType::isArray) {
         lVar6 = *(long*)( param_3 + 0x60 );
         if (lVar6 != 0) goto LAB_001236d0;
         LAB_001234bb:local_f8 = *(uint*)( param_3 + 0x80 );
         local_168 = *(undefined8*)( param_3 + 0x10 );
         uStack_160 = *(ulong*)( param_3 + 0x18 );
         local_128 = *(undefined8*)( param_3 + 0x50 );
         uStack_120 = *(ulong*)( param_3 + 0x58 );
         local_108 = *(undefined1(*) [16])( param_3 + 0x70 );
         local_158 = ( uint ) * (undefined8*)( param_3 + 0x20 );
         uStack_154 = ( undefined4 )(( ulong ) * (undefined8*)( param_3 + 0x20 ) >> 0x20);
         uStack_150 = ( undefined4 ) * (undefined8*)( param_3 + 0x28 );
         uStack_14c = ( undefined4 )(( ulong ) * (undefined8*)( param_3 + 0x28 ) >> 0x20);
         uVar2 = local_170 >> 0x10;
         local_118._8_8_ = *(undefined8*)( param_3 + 0x68 );
         local_118._0_8_ = lVar6;
         local_f0 = *(undefined1(*) [16])( param_3 + 0x88 );
         uStack_148 = ( undefined4 ) * (undefined8*)( param_3 + 0x30 );
         uStack_144 = ( undefined4 )(( ulong ) * (undefined8*)( param_3 + 0x30 ) >> 0x20);
         uStack_140 = ( undefined4 ) * (undefined8*)( param_3 + 0x38 );
         uStack_13c = ( undefined4 )(( ulong ) * (undefined8*)( param_3 + 0x38 ) >> 0x20);
         local_138 = ( uint ) * (undefined8*)( param_3 + 0x40 );
         uStack_134 = ( undefined4 )(( ulong ) * (undefined8*)( param_3 + 0x40 ) >> 0x20);
         uStack_130 = ( undefined4 ) * (undefined8*)( param_3 + 0x48 );
         uStack_12c = ( undefined4 )(( ulong ) * (undefined8*)( param_3 + 0x48 ) >> 0x20);
         local_170._0_2_ = ( undefined2 )(*(uint*)( param_3 + 8 ) & 0x1fffff);
         local_170 = CONCAT22((ushort)uVar2 & 0xf800 | ( ushort )(( *(uint*)( param_3 + 8 ) & 0x1fffff ) >> 0x10) | *(ushort*)( param_3 + 10 ) & 0x7e0, (undefined2)local_170);
         if (plVar7 != (long*)0x0) goto LAB_0012356b;
         LAB_001237d0:if (*(code**)( *(long*)param_3 + 0xe8 ) == TType::isArray) {
            if (*(long*)( param_3 + 0x60 ) != 0) goto LAB_00123a70;
            LAB_001237ee:puVar11 = *(undefined8**)param_2;
            pcVar1 = (code*)*puVar11;
            if (iVar5 == 0x241) {
               if (pcVar1 == TIntermNode::getLoc) {
                  pTVar15 = param_2 + 8;
               }
 else {
                  pTVar15 = (TIntermNode*)( *pcVar1 )(param_2);
               }

               pTVar16 = (TType*)*local_188;
               goto LAB_00123a8f;
            }

            if (pcVar1 == TIntermNode::getLoc) {
               pTVar15 = param_2 + 8;
            }
 else {
               pTVar15 = (TIntermNode*)( *pcVar1 )(param_2);
               puVar11 = *(undefined8**)param_2;
            }

            uVar9 = ( *(code*)puVar11[3] )(param_2);
            plVar7 = (long*)constructBuiltIn(this, param_3, iVar5, uVar9, pTVar15, 0);
         }
 else {
            cVar4 = ( **(code**)( *(long*)param_3 + 0xe8 ) )(param_3);
            if (cVar4 == '\0') goto LAB_001237ee;
            LAB_00123a70:pTVar15 = param_2 + 8;
            if ((code*)**(undefined8**)param_2 != TIntermNode::getLoc) {
               pTVar15 = (TIntermNode*)( *(code*)**(undefined8**)param_2 )(param_2);
            }

            pTVar16 = (TType*)&local_178;
            LAB_00123a8f:plVar7 = (long*)constructAggregate(this, param_2, pTVar16, 1, (TSourceLoc*)pTVar15);
         }

         if (plVar7 == (long*)0x0) goto LAB_001236a0;
         if (*(code**)( *(long*)param_3 + 0xe8 ) == TType::isArray) {
            cVar4 = *(long*)( param_3 + 0x60 ) != 0;
         }
 else {
            cVar4 = ( **(code**)( *(long*)param_3 + 0xe8 ) )(param_3);
         }

         if (( iVar5 == 0x241 ) || ( cVar4 != '\0' )) {
            plVar7 = (long*)glslang::TIntermediate::setAggregateOperator(*(undefined8*)( this + 0x38 ), plVar7, 0x241, param_3, param_1);
         }

      }
 else {
         cVar4 = ( **(code**)( *(long*)param_3 + 0xe8 ) )(param_3);
         if (cVar4 == '\0') {
            lVar6 = *(long*)( param_3 + 0x60 );
            goto LAB_001234bb;
         }

         LAB_001236d0:TType::TType(local_d8, param_3, 0, false);
         local_f8 = local_58;
         local_168 = local_c8;
         uStack_160 = uStack_c0;
         local_158 = (uint)local_b8;
         uStack_154 = ( undefined4 )((ulong)local_b8 >> 0x20);
         uStack_150 = (undefined4)uStack_b0;
         uStack_14c = ( undefined4 )((ulong)uStack_b0 >> 0x20);
         uVar2 = local_170 >> 0x10;
         uStack_148 = (undefined4)local_a8;
         uStack_144 = ( undefined4 )((ulong)local_a8 >> 0x20);
         uStack_140 = (undefined4)uStack_a0;
         uStack_13c = ( undefined4 )((ulong)uStack_a0 >> 0x20);
         local_138 = (uint)local_98;
         uStack_134 = ( undefined4 )((ulong)local_98 >> 0x20);
         uStack_130 = (undefined4)uStack_90;
         uStack_12c = ( undefined4 )((ulong)uStack_90 >> 0x20);
         local_128 = local_88;
         uStack_120 = uStack_80;
         local_108._8_8_ = uStack_60;
         local_108._0_8_ = local_68;
         local_118._8_8_ = local_70;
         local_118._0_8_ = local_78;
         local_f0._8_8_ = uStack_48;
         local_f0._0_8_ = local_50;
         local_170._0_2_ = ( undefined2 )(local_d0 & 0x1fffff);
         local_170 = CONCAT22((ushort)uVar2 & 0xf800 | ( ushort )(( local_d0 & 0x1fffff ) >> 0x10) | local_d0._2_2_ & 0x7e0, (undefined2)local_170);
         if (plVar7 == (long*)0x0) goto LAB_001237d0;
         LAB_0012356b:if ((int)plVar7[0x17] != 0) goto LAB_001237d0;
         if (*(code**)( *plVar7 + 400 ) == TIntermAggregate::getSequence) {
            plVar13 = plVar7 + 0x18;
         }
 else {
            plVar13 = (long*)( **(code**)( *plVar7 + 400 ) )(plVar7);
         }

         plVar17 = (long*)plVar13[1];
         lVar6 = 1;
         pTVar15 = param_2 + 8;
         if (plVar17 != (long*)plVar13[2]) {
            do {
               if (*(code**)( *(long*)param_3 + 0xe8 ) == TType::isArray) {
                  if (*(long*)( param_3 + 0x60 ) != 0) goto LAB_001235d0;
                  LAB_0012363a:pcVar1 = (code*)**(undefined8**)param_2;
                  if (iVar5 == 0x241) {
                     pTVar14 = (TSourceLoc*)pTVar15;
                     if (pcVar1 != TIntermNode::getLoc) {
                        pTVar14 = (TSourceLoc*)( *pcVar1 )(param_2);
                     }

                     lVar10 = constructAggregate(this, (TIntermNode*)*plVar17, (TType*)local_188[lVar6 * 4 + -4], (int)lVar6, pTVar14);
                  }
 else {
                     pTVar12 = pTVar15;
                     if (pcVar1 != TIntermNode::getLoc) {
                        pTVar12 = (TIntermNode*)( *pcVar1 )(param_2);
                     }

                     uVar9 = ( **(code**)( *(long*)*plVar17 + 0x18 ) )();
                     lVar10 = constructBuiltIn(this, param_3, iVar5, uVar9, pTVar12, 1);
                  }

               }
 else {
                  cVar4 = ( **(code**)( *(long*)param_3 + 0xe8 ) )(param_3);
                  if (cVar4 == '\0') goto LAB_0012363a;
                  LAB_001235d0:pTVar12 = pTVar15;
                  if ((code*)**(undefined8**)param_2 != TIntermNode::getLoc) {
                     pTVar12 = (TIntermNode*)( *(code*)**(undefined8**)param_2 )(param_2);
                  }

                  lVar10 = constructAggregate(this, (TIntermNode*)*plVar17, (TType*)&local_178, (int)lVar6, (TSourceLoc*)pTVar12);
               }

               if (lVar10 == 0) goto LAB_001236a0;
               *plVar17 = lVar10;
               lVar6 = lVar6 + 1;
               plVar17 = plVar17 + 1;
            }
 while ( (long*)plVar13[2] != plVar17 );
         }

         plVar7 = (long*)glslang::TIntermediate::setAggregateOperator(*(undefined8*)( this + 0x38 ), plVar7, iVar5, param_3, param_1);
         plVar13 = (long*)( **(code**)( *plVar7 + 0x30 ) )(plVar7);
         if (plVar13 == (long*)0x0) goto LAB_001236a2;
         lVar6 = *plVar13;
         if (*(code**)( lVar6 + 0x158 ) == TIntermTyped::isVector) {
            if (( *(byte*)( (long)plVar13 + 0x29 ) & 0xf ) < 2) {
               bVar3 = *(byte*)( (long)plVar13 + 0x2a ) >> 4 & 1;
               goto LAB_00123bea;
            }

            LAB_00123b14:( **(code**)( lVar6 + 0x180 ) )(plVar13);
         }
 else {
            bVar3 = ( **(code**)( lVar6 + 0x158 ) )(plVar13);
            lVar6 = *plVar13;
            LAB_00123bea:if (bVar3 != 0) goto LAB_00123b14;
            if (*(code**)( lVar6 + 0x150 ) != TIntermTyped::isArray) {
               cVar4 = ( **(code**)( lVar6 + 0x150 ) )(plVar13);
               lVar6 = *plVar13;
               if (cVar4 == '\0') goto LAB_00123c17;
               goto LAB_00123b14;
            }

            if (plVar13[0x10] != 0) goto LAB_00123b14;
            LAB_00123c17:if (*(code**)( lVar6 + 0x148 ) == TIntermTyped::isMatrix) {
               if (0xf < *(byte*)( (long)plVar13 + 0x29 )) goto LAB_00123b14;
            }
 else {
               cVar4 = ( **(code**)( lVar6 + 0x148 ) )(plVar13);
               if (cVar4 != '\0') {
                  lVar6 = *plVar13;
                  goto LAB_00123b14;
               }

            }

         }

      }

   }

   LAB_001236a2:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return plVar7;
   }

   LAB_00123cf9:/* WARNING: Subroutine does not return */__stack_chk_fail();
}
/* glslang::TParseContext::handleDotSwizzle(glslang::TSourceLoc const&, glslang::TIntermTyped*,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const&)
    */TIntermTyped * __thiscall
glslang::TParseContext::handleDotSwizzle
          (TParseContext *this,TSourceLoc *param_1,TIntermTyped *param_2,basic_string *param_3){
   TSwizzleSelectors *pTVar1;
   char cVar2;
   byte bVar3;
   TIntermTyped TVar4;
   TIntermTyped TVar5;
   uint uVar6;
   long lVar7;
   ulong uVar8;
   code *pcVar9;
   undefined8 uVar10;
   long lVar11;
   uint uVar12;
   uint uVar13;
   TIntermTyped *pTVar14;
   TIntermTyped *pTVar15;
   long in_FS_OFFSET;
   undefined **local_f8;
   uint local_f0;
   undefined8 local_e8;
   ulong uStack_e0;
   uint local_d8;
   undefined4 uStack_d4;
   undefined4 uStack_d0;
   undefined4 uStack_cc;
   undefined4 uStack_c8;
   undefined4 uStack_c4;
   uint uStack_c0;
   undefined4 uStack_bc;
   uint local_b8;
   undefined4 uStack_b4;
   undefined4 uStack_b0;
   undefined4 uStack_ac;
   undefined8 local_a8;
   undefined2 uStack_a0;
   uint6 uStack_9e;
   undefined1 local_98[16];
   undefined1 local_88[16];
   uint local_78;
   undefined1 local_70[16];
   uint local_58;
   uint local_54;
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   lVar7 = *(long*)param_2;
   if (*(code**)( lVar7 + 0x160 ) == TIntermTyped::isScalar) {
      if (( ( ( ( (byte)param_2[0x29] & 0xf ) < 2 ) && ( ( (byte)param_2[0x2a] & 0x10 ) == 0 ) ) && ( (byte)param_2[0x29] < 0x10 ) ) && ( ( 1 < ( byte )((char)param_2[0x28] - 0xfU) && ( *(long*)( param_2 + 0x80 ) == 0 ) ) )) {
         LAB_00123f02:glslang::TParseVersions::requireProfile((TSourceLoc*)this, (int)param_1, (char*)0xfffffff7);
         glslang::TParseVersions::profileRequires((TSourceLoc*)this, (int)param_1, -9, (char*)0x1a4, "GL_ARB_shading_language_420pack");
         goto LAB_00123f3b;
      }

   }
 else {
      cVar2 = ( **(code**)( lVar7 + 0x160 ) )(param_2);
      if (cVar2 != '\0') goto LAB_00123f02;
      LAB_00123f3b:lVar7 = *(long*)param_2;
   }

   local_58 = 0;
   pcVar9 = *(code**)( *(long*)this + 0x210 );
   if (*(code**)( lVar7 + 0x130 ) == TIntermTyped::getVectorSize) {
      uVar12 = (byte)param_2[0x29] & 0xf;
   }
 else {
      uVar12 = ( **(code**)( lVar7 + 0x130 ) )(param_2);
   }

   ( *pcVar9 )(this, param_1, param_3, uVar12, (TSourceLoc*)&local_58);
   lVar7 = *(long*)param_2;
   if (*(code**)( lVar7 + 0x158 ) == TIntermTyped::isVector) {
      TVar4 = param_2[0x29];
      if (( (byte)TVar4 & 0xf ) < 2) {
         TVar5 = param_2[0x2a];
         if (( (byte)TVar5 & 0x10 ) != 0) {
            if (local_58 != 1) goto LAB_00123de0;
            goto LAB_00123e5a;
         }

         LAB_00123f54:bVar3 = (byte)TVar5 >> 4 & 1;
         goto LAB_00123f5a;
      }

      if (local_58 != 1) goto LAB_00123de0;
      LAB_001242a8:if (local_58 == 1) goto LAB_00123f62;
      if (*(code**)( lVar7 + 0xf0 ) == TIntermTyped::getType) {
         pTVar14 = param_2 + 0x20;
      }
 else {
         pTVar14 = (TIntermTyped*)( **(code**)( lVar7 + 0xf0 ) )(param_2);
      }

      cVar2 = TType::contains8BitInt((TType*)pTVar14);
      if (cVar2 != '\0') {
         ( **(code**)( *(long*)this + 0xd8 ) )(this, param_1, &_LC820, "can\'t swizzle types containing (u)int8");
      }

      lVar7 = *(long*)param_2;
      pcVar9 = *(code**)( lVar7 + 0x160 );
      if (pcVar9 != TIntermTyped::isScalar) goto LAB_0012430b;
      LAB_00123f72:if (( ( ( ( (byte)param_2[0x29] & 0xf ) < 2 ) && ( ( (byte)param_2[0x2a] & 0x10 ) == 0 ) ) && ( (byte)param_2[0x29] < 0x10 ) ) && ( ( 1 < ( byte )((char)param_2[0x28] - 0xfU) && ( *(long*)( param_2 + 0x80 ) == 0 ) ) )) {
         LAB_00124318:uVar12 = local_58;
         if (local_58 != 1) {
            lVar7 = *(long*)param_2;
            if (*(code**)( lVar7 + 0x100 ) == TIntermTyped::getBasicType) {
               TVar4 = param_2[0x28];
            }
 else {
               TVar4 = ( TIntermTyped )(**(code**)( lVar7 + 0x100 ))(param_2);
               lVar7 = *(long*)param_2;
            }

            local_f0 = CONCAT31(local_f0._1_3_, TVar4);
            local_d8 = local_d8 & 0xfffffff0;
            local_70 = (undefined1[16])0x0;
            local_f0 = ( uVar12 & 0xf ) << 8 | local_f0 & 0xf80000ff;
            local_98 = (undefined1[16])0x0;
            uStack_b4 = 0xfffff800;
            uStack_b0 = 0;
            uStack_cc._1_3_ = ( uint3 )((uint)uStack_cc >> 8) & 0xffc070 | 0x1f8f;
            local_f8 = &PTR__TType_00167f00;
            local_88 = (undefined1[16])0x0;
            uStack_a0 = 0;
            uVar8 = (ulong)CONCAT43(0xffff, uStack_cc._1_3_) & 0xffffffff8f | 0xffffff0000000040;
            local_b8 = local_b8 & 0xffffff00;
            uStack_cc._1_3_ = (uint3)uVar8;
            uStack_cc = CONCAT31(uStack_cc._1_3_, 0xff);
            uStack_c8 = ( undefined4 )(uVar8 >> 0x18);
            uVar8 = ( ulong )(CONCAT43(uStack_c0, uStack_c4._1_3_) & 0xfe07ff00ffffff | 0x1f800ff000000) | 0x7ff007fffff;
            uStack_c4._1_3_ = (undefined3)uVar8;
            uStack_c4 = CONCAT31(uStack_c4._1_3_, 0xff);
            uStack_c0 = ( uint )(uVar8 >> 0x18);
            uStack_bc = 0;
            uStack_e0 = uStack_e0 & 0x8000000400000000;
            local_78 = local_78 & 0x9fc00000;
            local_e8 = 0;
            uStack_d4 = 0xffffffff;
            uStack_d0 = 0xffffffff;
            uStack_ac = 0xffffffff;
            local_a8 = 0;
            if (*(code**)( lVar7 + 0x108 ) == TIntermTyped::getQualifier) {
               pTVar14 = param_2 + 0x30;
            }
 else {
               pTVar14 = (TIntermTyped*)( **(code**)( lVar7 + 0x108 ) )(param_2);
            }

            if (( (byte)pTVar14[0xc] & 1 ) != 0) {
               uStack_e0 = uStack_e0 & 0xfffffffeffffff80 | 0x100000002;
            }

            param_2 = (TIntermTyped*)addConstructor(this, param_1, (TIntermNode*)param_2, (TType*)&local_f8);
         }

         goto LAB_00124279;
      }

   }
 else {
      cVar2 = ( **(code**)( lVar7 + 0x158 ) )(param_2);
      lVar7 = *(long*)param_2;
      if (( cVar2 != '\0' ) && ( local_58 != 1 )) {
         LAB_00123de0:if (*(code**)( lVar7 + 0xf0 ) == TIntermTyped::getType) {
            pTVar14 = param_2 + 0x20;
         }
 else {
            pTVar14 = (TIntermTyped*)( **(code**)( lVar7 + 0xf0 ) )(param_2);
         }

         pcVar9 = *(code**)( *(long*)pTVar14 + 400 );
         if (pcVar9 == TType::containsBasicType) {
            if (pTVar14[8] == (TIntermTyped)0x3) goto LAB_001245e7;
            pcVar9 = *(code**)( *(long*)pTVar14 + 0x128 );
            if (pcVar9 == TType::isStruct) {
               if (( byte )((char)pTVar14[8] - 0xfU) < 2) {
                  LAB_001248a4:lVar7 = *(long*)( *(long*)( pTVar14 + 0x68 ) + 0x10 );
                  lVar11 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( pTVar14 + 0x68 ) + 8 ),lVar7,3 ));
                  if (lVar7 != lVar11) goto LAB_001245e7;
               }

            }
 else {
               cVar2 = ( *pcVar9 )();
               if (cVar2 != '\0') goto LAB_001248a4;
            }

         }
 else {
            cVar2 = ( *pcVar9 )(pTVar14, 3);
            if (cVar2 == '\0') goto LAB_00123e43;
            LAB_001245e7:( **(code**)( *(long*)this + 0xa8 ) )(this, param_1, &_LC820, "can\'t swizzle types containing float16");
         }

         LAB_00123e43:lVar7 = *(long*)param_2;
      }

      if (*(code**)( lVar7 + 0x158 ) == TIntermTyped::isVector) {
         TVar4 = param_2[0x29];
         LAB_00123e5a:if (( (byte)TVar4 & 0xf ) < 2) {
            TVar5 = param_2[0x2a];
            if (( (byte)TVar5 & 0x10 ) == 0) goto LAB_00123f54;
            LAB_00124914:if (local_58 != 1) goto LAB_00123e74;
            LAB_00123e9f:pcVar9 = *(code**)( lVar7 + 0x158 );
            if (pcVar9 == TIntermTyped::isVector) {
               LAB_00123eaf:if (( (byte)param_2[0x29] & 0xf ) < 2) {
                  TVar5 = param_2[0x2a];
                  goto LAB_00123f54;
               }

               goto LAB_001242a8;
            }

            goto LAB_00124558;
         }

         if (local_58 != 1) {
            LAB_00123e74:if (*(code**)( lVar7 + 0xf0 ) == TIntermTyped::getType) {
               pTVar14 = param_2 + 0x20;
            }
 else {
               pTVar14 = (TIntermTyped*)( **(code**)( lVar7 + 0xf0 ) )(param_2);
            }

            cVar2 = TType::contains16BitInt((TType*)pTVar14);
            if (cVar2 != '\0') {
               ( **(code**)( *(long*)this + 0xc0 ) )(this, param_1, &_LC820, "can\'t swizzle types containing (u)int16");
            }

            lVar7 = *(long*)param_2;
            goto LAB_00123e9f;
         }

      }
 else {
         cVar2 = ( **(code**)( lVar7 + 0x158 ) )(param_2);
         lVar7 = *(long*)param_2;
         if (cVar2 != '\0') goto LAB_00124914;
         pcVar9 = *(code**)( lVar7 + 0x158 );
         if (pcVar9 == TIntermTyped::isVector) goto LAB_00123eaf;
         LAB_00124558:bVar3 = ( *pcVar9 )(param_2);
         lVar7 = *(long*)param_2;
         LAB_00123f5a:if (bVar3 != 0) goto LAB_001242a8;
      }

      LAB_00123f62:pcVar9 = *(code**)( lVar7 + 0x160 );
      if (pcVar9 == TIntermTyped::isScalar) goto LAB_00123f72;
      LAB_0012430b:cVar2 = ( *pcVar9 )(param_2);
      if (cVar2 != '\0') goto LAB_00124318;
      lVar7 = *(long*)param_2;
   }

   if (*(code**)( lVar7 + 0xf0 ) == TIntermTyped::getType) {
      pTVar14 = param_2 + 0x20;
   }
 else {
      pTVar14 = (TIntermTyped*)( **(code**)( lVar7 + 0xf0 ) )(param_2);
   }

   if (*(code**)( *(long*)pTVar14 + 0x58 ) == TType::getQualifier) {
      pTVar14 = pTVar14 + 0x10;
   }
 else {
      pTVar14 = (TIntermTyped*)( **(code**)( *(long*)pTVar14 + 0x58 ) )();
   }

   pTVar1 = *(TSwizzleSelectors**)( this + 0x38 );
   if (( ( (byte)pTVar14[8] & 0x7f ) == 2 ) && ( ( (byte)pTVar14[0xc] & 1 ) == 0 )) {
      param_2 = (TIntermTyped*)glslang::TIntermediate::foldSwizzle((TIntermTyped*)pTVar1, (TSwizzleSelectors*)param_2, (TSourceLoc*)&local_58);
      goto LAB_00124279;
   }

   if (local_58 == 1) {
      uVar10 = glslang::TIntermediate::addConstantUnion((int)pTVar1, (TSourceLoc*)(ulong)local_54, SUB81(param_1, 0));
      pTVar14 = (TIntermTyped*)glslang::TIntermediate::addIndex(*(undefined8*)( this + 0x38 ), 0xb6, param_2, uVar10, param_1);
      pcVar9 = *(code**)( *(long*)pTVar14 + 0xe8 );
      if (*(code**)( *(long*)param_2 + 0xf0 ) == TIntermTyped::getType) {
         pTVar15 = param_2 + 0x20;
      }
 else {
         pTVar15 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
      }

      if (*(code**)( *(long*)pTVar15 + 0x58 ) == TType::getQualifier) {
         pTVar15 = pTVar15 + 0x10;
      }
 else {
         pTVar15 = (TIntermTyped*)( **(code**)( *(long*)pTVar15 + 0x58 ) )();
      }

      TVar4 = pTVar15[0xb];
      if (*(code**)( *(long*)param_2 + 0x100 ) == TIntermTyped::getBasicType) {
         TVar5 = param_2[0x28];
      }
 else {
         TVar5 = ( TIntermTyped )(**(code**)( *(long*)param_2 + 0x100 ))(param_2);
      }

      uVar12 = local_d8;
      local_f0 = CONCAT31(local_f0._1_3_, TVar5);
      local_78 = local_78 & 0x9fc00000;
      local_d8 = local_d8 & 0xfffffff0;
      local_f0 = CONCAT22((short)( ( local_f0 & 0xf80000ff ) >> 0x10 ), CONCAT11(1, (char)( local_f0 & 0xf80000ff )));
      local_b8 = local_b8 & 0xffffff00;
      uVar8 = CONCAT44(uStack_c8, uStack_cc) & 0xffff0000ffc00000 | 0xffff001fcfff;
      uStack_cc = (undefined4)uVar8;
      uStack_c8 = ( undefined4 )(uVar8 >> 0x20);
      uVar8 = CONCAT44(uStack_c4, uStack_c8) | 0x7fffffffffff0000;
      uStack_c8 = (undefined4)uVar8;
      uStack_c4 = ( undefined4 )(uVar8 >> 0x20);
      uVar6 = uStack_c0 & 0xfe07ff00;
      uStack_c0 = uVar6 | 0x1ffffff;
      uStack_e0 = uStack_e0 & 0x8000000400000000 | ( ulong )(( (byte)TVar4 >> 1 & 7 ) << 0x19);
      if (pcVar9 == TIntermTyped::setType) {
         pTVar14[0x28] = TVar5;
         *(long*)( pTVar14 + 0x30 ) = 0;
         *(ulong*)( pTVar14 + 0x38 ) = uStack_e0;
         *(uint*)( pTVar14 + 0xa0 ) = local_78;
         *(ulong*)( pTVar14 + 0x40 ) = CONCAT44(0xffffffff, uVar12) & 0xfffffffffffffff0;
         *(long*)( pTVar14 + 0x48 ) = CONCAT44(uStack_cc, 0xffffffff);
         *(ulong*)( pTVar14 + 0x50 ) = uVar8;
         *(ulong*)( pTVar14 + 0x58 ) = (ulong)uVar6 | 0x1ffffff;
         *(long*)( pTVar14 + 0x60 ) = CONCAT44(0xfffff800, local_b8);
         *(long*)( pTVar14 + 0x68 ) = -0x100000000;
         *(uint*)( pTVar14 + 0x28 ) = CONCAT22((short)( ( *(uint*)( pTVar14 + 0x28 ) & 0xffe000ff ) >> 0x10 ), CONCAT11(1, (char)( *(uint*)( pTVar14 + 0x28 ) & 0xffe000ff )));
         *(long*)( pTVar14 + 0x80 ) = 0;
         *(long*)( pTVar14 + 0x88 ) = 0;
         *(long*)( pTVar14 + 0x70 ) = 0;
         *(ulong*)( pTVar14 + 0x78 ) = (ulong)uStack_9e << 0x10;
         *(undefined1(*) [16])( pTVar14 + 0x90 ) = (undefined1[16])0x0;
         goto LAB_001241de;
      }

      LAB_00124848:uStack_bc = 0;
      local_70 = (undefined1[16])0x0;
      local_88 = (undefined1[16])0x0;
      local_98 = (undefined1[16])0x0;
      uStack_a0 = 0;
      local_a8 = 0;
      uStack_ac = 0xffffffff;
      uStack_b0 = 0;
      uStack_b4 = 0xfffff800;
      uStack_d0 = 0xffffffff;
      uStack_d4 = 0xffffffff;
      local_e8 = 0;
      local_f8 = &PTR__TType_00167f00;
      ( *pcVar9 )(pTVar14, &local_f8);
   }
 else {
      pTVar14 = glslang::TIntermediate::addSwizzle<int>(pTVar1, (TSourceLoc*)&local_58);
      pTVar14 = (TIntermTyped*)glslang::TIntermediate::addIndex(*(undefined8*)( this + 0x38 ), 0xb9, param_2, pTVar14, param_1);
      uVar12 = local_58;
      pcVar9 = *(code**)( *(long*)pTVar14 + 0xe8 );
      if (*(code**)( *(long*)param_2 + 0xf0 ) == TIntermTyped::getType) {
         pTVar15 = param_2 + 0x20;
      }
 else {
         pTVar15 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
      }

      if (*(code**)( *(long*)pTVar15 + 0x58 ) == TType::getQualifier) {
         pTVar15 = pTVar15 + 0x10;
      }
 else {
         pTVar15 = (TIntermTyped*)( **(code**)( *(long*)pTVar15 + 0x58 ) )();
      }

      TVar4 = pTVar15[0xb];
      if (*(code**)( *(long*)param_2 + 0x100 ) == TIntermTyped::getBasicType) {
         TVar5 = param_2[0x28];
      }
 else {
         TVar5 = ( TIntermTyped )(**(code**)( *(long*)param_2 + 0x100 ))(param_2);
      }

      uVar6 = local_d8;
      local_f0 = CONCAT31(local_f0._1_3_, TVar5);
      uVar13 = ( uVar12 & 0xf ) << 8;
      local_78 = local_78 & 0x9fc00000;
      local_d8 = local_d8 & 0xfffffff0;
      local_f0 = local_f0 & 0xf80000ff | uVar13;
      local_b8 = local_b8 & 0xffffff00;
      uVar8 = CONCAT44(uStack_c8, uStack_cc) & 0xffff0000ffc00000 | 0xffff001fcfff;
      uStack_cc = (undefined4)uVar8;
      uStack_c8 = ( undefined4 )(uVar8 >> 0x20);
      uVar8 = CONCAT44(uStack_c4, uStack_c8) | 0x7fffffffffff0000;
      uStack_c8 = (undefined4)uVar8;
      uStack_c4 = ( undefined4 )(uVar8 >> 0x20);
      uVar12 = uStack_c0 & 0xfe07ff00;
      uStack_c0 = uVar12 | 0x1ffffff;
      uStack_e0 = uStack_e0 & 0x8000000400000000 | ( ulong )(( (byte)TVar4 >> 1 & 7 ) << 0x19);
      if (pcVar9 != TIntermTyped::setType) goto LAB_00124848;
      pTVar14[0x28] = TVar5;
      *(long*)( pTVar14 + 0x30 ) = 0;
      *(ulong*)( pTVar14 + 0x38 ) = uStack_e0;
      *(uint*)( pTVar14 + 0xa0 ) = local_78;
      *(ulong*)( pTVar14 + 0x40 ) = CONCAT44(0xffffffff, uVar6) & 0xfffffffffffffff0;
      *(long*)( pTVar14 + 0x48 ) = CONCAT44(uStack_cc, 0xffffffff);
      *(ulong*)( pTVar14 + 0x50 ) = uVar8;
      *(ulong*)( pTVar14 + 0x58 ) = (ulong)uVar12 | 0x1ffffff;
      *(long*)( pTVar14 + 0x60 ) = CONCAT44(0xfffff800, local_b8);
      *(long*)( pTVar14 + 0x68 ) = -0x100000000;
      *(uint*)( pTVar14 + 0x28 ) = uVar13 | *(uint*)( pTVar14 + 0x28 ) & 0xffe000ff;
      *(long*)( pTVar14 + 0x80 ) = 0;
      *(long*)( pTVar14 + 0x88 ) = 0;
      *(long*)( pTVar14 + 0x70 ) = 0;
      *(ulong*)( pTVar14 + 0x78 ) = (ulong)uStack_9e << 0x10;
      *(undefined1(*) [16])( pTVar14 + 0x90 ) = (undefined1[16])0x0;
      LAB_001241de:uStack_b0 = 0;
      uStack_b4 = 0xfffff800;
      uStack_bc = 0;
      uStack_d0 = 0xffffffff;
      uStack_d4 = 0xffffffff;
      local_70 = (undefined1[16])0x0;
      local_88 = (undefined1[16])0x0;
      local_98 = (undefined1[16])0x0;
      uStack_a0 = 0;
      local_a8 = 0;
      uStack_ac = 0xffffffff;
      local_e8 = 0;
      local_f8 = &PTR__TType_00167f00;
      *(ushort*)( pTVar14 + 0x2a ) = *(ushort*)( pTVar14 + 0x2a ) & 0xf81f;
      *(undefined1(*) [16])( pTVar14 + 0xa8 ) = (undefined1[16])0x0;
   }

   if (*(code**)( *(long*)param_2 + 0xf0 ) == TIntermTyped::getType) {
      pTVar15 = param_2 + 0x20;
   }
 else {
      pTVar15 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
   }

   if (*(code**)( *(long*)pTVar15 + 0x58 ) == TType::getQualifier) {
      pTVar15 = pTVar15 + 0x10;
   }
 else {
      pTVar15 = (TIntermTyped*)( **(code**)( *(long*)pTVar15 + 0x58 ) )();
   }

   param_2 = pTVar14;
   if (( (byte)pTVar15[0xc] & 1 ) != 0) {
      if (*(code**)( *(long*)pTVar14 + 0xf8 ) == TIntermTyped::getWritableType) {
         pTVar14 = pTVar14 + 0x20;
      }
 else {
         pTVar14 = (TIntermTyped*)( **(code**)( *(long*)pTVar14 + 0xf8 ) )(pTVar14);
      }

      if (*(code**)( *(long*)pTVar14 + 0x50 ) == TType::getQualifier) {
         pTVar14 = pTVar14 + 0x10;
      }
 else {
         pTVar14 = (TIntermTyped*)( **(code**)( *(long*)pTVar14 + 0x50 ) )();
      }

      *(ulong*)( pTVar14 + 8 ) = *(ulong*)( pTVar14 + 8 ) & 0xfffffffeffffff80 | 0x100000002;
   }

   LAB_00124279:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   return param_2;
}
/* glslang::TParseContext::convertInitializerList(glslang::TSourceLoc const&, glslang::TType const&,
   glslang::TIntermTyped*) */TIntermTyped * __thiscall
glslang::TParseContext::convertInitializerList
          (TParseContext *this,TSourceLoc *param_1,TType *param_2,TIntermTyped *param_3){
   undefined4 uVar1;
   char cVar2;
   byte bVar3;
   int iVar4;
   uint uVar5;
   uint uVar6;
   TIntermNode *pTVar7;
   TIntermTyped *pTVar8;
   undefined8 uVar9;
   undefined8 *puVar10;
   vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>> *this_00;
   TIntermNode *pTVar11;
   TIntermNode *pTVar12;
   long lVar13;
   long *plVar14;
   long lVar15;
   long *plVar16;
   char *pcVar17;
   int iVar18;
   long lVar19;
   ulong uVar20;
   code *pcVar21;
   long in_FS_OFFSET;
   undefined **local_208;
   undefined4 local_200;
   undefined8 local_1f8;
   undefined8 uStack_1f0;
   undefined8 local_1e8;
   undefined8 uStack_1e0;
   undefined8 local_1d8;
   undefined8 uStack_1d0;
   undefined8 local_1c8;
   undefined8 uStack_1c0;
   undefined8 local_1b8;
   undefined8 uStack_1b0;
   undefined8 *local_1a8;
   undefined8 local_1a0;
   undefined8 local_198;
   undefined8 uStack_190;
   undefined4 local_188;
   undefined8 local_180;
   undefined8 uStack_178;
   TType local_168[160];
   undefined8 local_c8;
   undefined1 *local_c0;
   undefined1 local_b0[24];
   undefined8 local_98;
   undefined1 *local_90;
   undefined1 local_80[24];
   undefined1 local_68[8];
   undefined8 local_60;
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   pTVar7 = (TIntermNode*)( **(code**)( *(long*)param_3 + 0x30 ) )(param_3);
   if (( pTVar7 != (TIntermNode*)0x0 ) && ( *(int*)( pTVar7 + 0xb8 ) == 0 )) {
      lVar13 = *(long*)param_2;
      if (*(code**)( lVar13 + 0xe8 ) == TType::isArray) {
         lVar19 = *(long*)( param_2 + 0x60 );
         if (lVar19 != 0) {
            LAB_00124dac:uVar1 = local_200;
            local_208 = &PTR__TType_00167f00;
            local_188 = *(undefined4*)( param_2 + 0x80 );
            local_1f8 = *(undefined8*)( param_2 + 0x10 );
            uStack_1f0 = *(undefined8*)( param_2 + 0x18 );
            local_1e8 = *(undefined8*)( param_2 + 0x20 );
            uStack_1e0 = *(undefined8*)( param_2 + 0x28 );
            local_1d8 = *(undefined8*)( param_2 + 0x30 );
            uStack_1d0 = *(undefined8*)( param_2 + 0x38 );
            local_1c8 = *(undefined8*)( param_2 + 0x40 );
            uStack_1c0 = *(undefined8*)( param_2 + 0x48 );
            local_1b8 = *(undefined8*)( param_2 + 0x50 );
            uStack_1b0 = *(undefined8*)( param_2 + 0x58 );
            local_198 = *(undefined8*)( param_2 + 0x70 );
            uStack_190 = *(undefined8*)( param_2 + 0x78 );
            local_200._2_2_ = (byte)param_2[10] & 0xf | ( ushort )(( ( (byte)param_2[10] >> 4 & 1 ) << 0x14 ) >> 0x10) | ( ushort )((uint)uVar1 >> 0x10) & 0xf800;
            local_1a0 = *(undefined8*)( param_2 + 0x68 );
            local_180 = *(undefined8*)( param_2 + 0x88 );
            uStack_178 = *(undefined8*)( param_2 + 0x90 );
            local_200 = CONCAT22(local_200._2_2_ | *(ushort*)( param_2 + 10 ) & 0x7e0, ( ushort )(( (byte)param_2[9] & 0xf ) << 8) | (ushort)(byte)param_2[8] | ( ushort )((byte)param_2[9] >> 4) << 0xc);
            local_1a8 = (undefined8*)lVar19;
            if (*(code**)( lVar13 + 0x98 ) != TType::getArraySizes) {
               lVar19 = ( **(code**)( lVar13 + 0x98 ) )(param_2);
            }

            uVar20 = glslang::GetThreadPoolAllocator();
            puVar10 = (undefined8*)glslang::TPoolAllocator::allocate(uVar20);
            *(undefined4*)( puVar10 + 2 ) = 0;
            *puVar10 = &PTR__TSmallArrayVector_00167ee0;
            uVar1 = *(undefined4*)( lVar19 + 0x10 );
            *(undefined2*)( (long)puVar10 + 0x14 ) = 1;
            puVar10[1] = 0;
            lVar13 = *(long*)( lVar19 + 8 );
            *(undefined4*)( puVar10 + 2 ) = uVar1;
            *(undefined1*)( (long)puVar10 + 0x15 ) = *(undefined1*)( lVar19 + 0x15 );
            local_1a8 = puVar10;
            if (lVar13 == 0) {
               puVar10[1] = 0;
            }
 else {
               uVar20 = glslang::GetThreadPoolAllocator();
               this_00 = (vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>*)glslang::TPoolAllocator::allocate(uVar20);
               uVar9 = glslang::GetThreadPoolAllocator();
               *(undefined8*)( this_00 + 8 ) = 0;
               *(undefined8*)this_00 = uVar9;
               *(undefined8*)( this_00 + 0x10 ) = 0;
               *(undefined8*)( this_00 + 0x18 ) = 0;
               puVar10[1] = this_00;
               std::vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>::operator =(this_00, *(vector**)( lVar19 + 8 ));
            }

            *(undefined1*)( (long)puVar10 + 0x14 ) = *(undefined1*)( lVar19 + 0x14 );
            if (*(code**)( *(long*)pTVar7 + 400 ) == TIntermAggregate::getSequence) {
               **(undefined4**)( local_1a8[1] + 8 ) = (int)( *(long*)( pTVar7 + 0xd0 ) - *(long*)( pTVar7 + 200 ) >> 3 );
               *(undefined1*)( (long)local_1a8 + 0x14 ) = 0;
               LAB_00124f9d:pTVar12 = pTVar7 + 0xc0;
            }
 else {
               lVar13 = ( **(code**)( *(long*)pTVar7 + 400 ) )(pTVar7);
               pcVar21 = *(code**)( *(long*)pTVar7 + 400 );
               **(undefined4**)( local_1a8[1] + 8 ) = (int)( *(long*)( lVar13 + 0x10 ) - *(long*)( lVar13 + 8 ) >> 3 );
               *(undefined1*)( (long)local_1a8 + 0x14 ) = 0;
               if (pcVar21 == TIntermAggregate::getSequence) goto LAB_00124f9d;
               pTVar12 = (TIntermNode*)( *pcVar21 )(pTVar7);
            }

            plVar14 = (long*)( **(code**)( *(long*)**(undefined8**)( pTVar12 + 8 ) + 0x18 ) )();
            if (( ( local_1a8 != (undefined8*)0x0 ) && ( lVar13 = local_1a8[1] ),lVar13 != 0 )) {
               if (*(code**)( *plVar14 + 0xf0 ) == TIntermTyped::getType) {
                  plVar16 = plVar14 + 4;
               }
 else {
                  plVar16 = (long*)( **(code**)( *plVar14 + 0xf0 ) )(plVar14);
               }

               if (*(code**)( *plVar16 + 0xe8 ) == TType::isArray) {
                  if (plVar16[0xc] != 0) {
                     LAB_00125024:lVar13 = local_1a8[1];
                     if (lVar13 == 0) {
                        iVar18 = 0;
                     }
 else {
                        iVar18 = (int)( *(long*)( lVar13 + 0x10 ) - *(long*)( lVar13 + 8 ) >> 4 );
                     }

                     if (*(code**)( *plVar14 + 0xf0 ) == TIntermTyped::getType) {
                        plVar16 = plVar14 + 4;
                     }
 else {
                        plVar16 = (long*)( **(code**)( *plVar14 + 0xf0 ) )(plVar14);
                     }

                     if (*(code**)( *plVar16 + 0x98 ) == TType::getArraySizes) {
                        lVar13 = plVar16[0xc];
                     }
 else {
                        lVar13 = ( **(code**)( *plVar16 + 0x98 ) )();
                     }

                     lVar13 = *(long*)( lVar13 + 8 );
                     if (lVar13 == 0) {
                        iVar4 = 1;
                     }
 else {
                        iVar4 = (int)( *(long*)( lVar13 + 0x10 ) - *(long*)( lVar13 + 8 ) >> 4 ) + 1;
                     }

                     if (( iVar18 == iVar4 ) && ( lVar13 = lVar13 != 0 )) {
                        lVar19 = 0;
                        puVar10 = local_1a8;
                        do {
                           if ((int)( *(long*)( lVar13 + 0x10 ) - *(long*)( lVar13 + 8 ) >> 4 ) <= (int)lVar19 + 1) break;
                           lVar15 = lVar19 * 0x10;
                           if (*(int*)( *(long*)( lVar13 + 8 ) + 0x10 + lVar15 ) == 0) {
                              plVar16 = plVar14 + 4;
                              if (*(code**)( *plVar14 + 0xf0 ) != TIntermTyped::getType) {
                                 plVar16 = (long*)( **(code**)( *plVar14 + 0xf0 ) )(plVar14);
                              }

                              if (*(code**)( *plVar16 + 0x98 ) == TType::getArraySizes) {
                                 lVar13 = plVar16[0xc];
                              }
 else {
                                 lVar13 = ( **(code**)( *plVar16 + 0x98 ) )();
                              }

                              *(undefined4*)( *(long*)( puVar10[1] + 8 ) + 0x10 + lVar15 ) = *(undefined4*)( *(long*)( *(long*)( lVar13 + 8 ) + 8 ) + lVar15 );
                              puVar10 = local_1a8;
                           }

                           lVar13 = puVar10[1];
                           lVar19 = lVar19 + 1;
                        }
 while ( lVar13 != 0 );
                     }

                  }

               }
 else {
                  cVar2 = ( **(code**)( *plVar16 + 0xe8 ) )();
                  if (cVar2 != '\0') goto LAB_00125024;
               }

            }

            uVar20 = 0;
            TType::TType(local_168, (TType*)&local_208, 0, false);
            pcVar21 = *(code**)( *(long*)pTVar7 + 400 );
            while (pcVar21 != TIntermAggregate::getSequence) {
               lVar13 = ( *pcVar21 )(pTVar7);
               if (( ulong )(*(long*)( lVar13 + 0x10 ) - *(long*)( lVar13 + 8 ) >> 3) <= uVar20) goto LAB_001252f0;
               if (*(code**)( *(long*)pTVar7 + 400 ) == TIntermAggregate::getSequence) {
                  lVar13 = *(long*)( pTVar7 + 200 );
               }
 else {
                  lVar13 = ( **(code**)( *(long*)pTVar7 + 400 ) )(pTVar7);
                  lVar13 = *(long*)( lVar13 + 8 );
               }

               LAB_001251b2:pTVar8 = (TIntermTyped*)( **(code**)( **(long**)( lVar13 + uVar20 * 8 ) + 0x18 ) )();
               uVar9 = convertInitializerList(this, param_1, local_168, pTVar8);
               pTVar12 = pTVar7 + 0xc0;
               if (*(code**)( *(long*)pTVar7 + 400 ) == TIntermAggregate::getSequence) {
                  *(undefined8*)( *(long*)( pTVar7 + 200 ) + uVar20 * 8 ) = uVar9;
               }
 else {
                  lVar13 = ( **(code**)( *(long*)pTVar7 + 400 ) )(pTVar7);
                  pcVar21 = *(code**)( *(long*)pTVar7 + 400 );
                  *(undefined8*)( *(long*)( lVar13 + 8 ) + uVar20 * 8 ) = uVar9;
                  if (pcVar21 != TIntermAggregate::getSequence) {
                     pTVar12 = (TIntermNode*)( *pcVar21 )(pTVar7);
                  }

               }

               param_3 = *(TIntermTyped**)( *(long*)( pTVar12 + 8 ) + uVar20 * 8 );
               if (param_3 == (TIntermTyped*)0x0) goto LAB_00124c0b;
               uVar20 = uVar20 + 1;
               pcVar21 = *(code**)( *(long*)pTVar7 + 400 );
            }
;
            lVar13 = *(long*)( pTVar7 + 200 );
            if (uVar20 < ( ulong )(*(long*)( pTVar7 + 0xd0 ) - lVar13 >> 3)) goto LAB_001251b2;
            LAB_001252f0:param_3 = (TIntermTyped*)addConstructor(this, param_1, pTVar7, (TType*)&local_208);
            goto LAB_00124c0b;
         }

      }
 else {
         cVar2 = ( **(code**)( lVar13 + 0xe8 ) )(param_2);
         lVar13 = *(long*)param_2;
         if (cVar2 != '\0') {
            lVar19 = *(long*)( param_2 + 0x60 );
            goto LAB_00124dac;
         }

      }

      if (*(code**)( lVar13 + 0x128 ) == TType::isStruct) {
         if (1 < ( byte )((char)param_2[8] - 0xfU)) {
            LAB_00124c48:if (*(code**)( lVar13 + 0xe0 ) == TType::isMatrix) {
               if ((byte)param_2[9] < 0x10) goto LAB_00125320;
               LAB_00124c6a:if (*(code**)( lVar13 + 0x68 ) == TType::getMatrixCols) {
                  uVar6 = ( uint )((byte)param_2[9] >> 4);
               }
 else {
                  uVar6 = ( **(code**)( lVar13 + 0x68 ) )(param_2);
               }

               if (*(code**)( *(long*)pTVar7 + 400 ) == TIntermAggregate::getSequence) {
                  pTVar12 = pTVar7 + 0xc0;
               }
 else {
                  pTVar12 = (TIntermNode*)( **(code**)( *(long*)pTVar7 + 400 ) )(pTVar7);
               }

               if (uVar6 == ( uint )(*(long*)( pTVar12 + 0x10 ) - *(long*)( pTVar12 + 8 ) >> 3)) {
                  lVar13 = 0;
                  TType::TType(local_168, param_2, 0, false);
                  pTVar12 = pTVar7 + 0xc0;
                  do {
                     if (*(code**)( *(long*)param_2 + 0x68 ) == TType::getMatrixCols) {
                        uVar6 = ( uint )((byte)param_2[9] >> 4);
                     }
 else {
                        uVar6 = ( **(code**)( *(long*)param_2 + 0x68 ) )(param_2);
                     }

                     lVar19 = *(long*)pTVar7;
                     if ((int)uVar6 <= (int)lVar13) goto LAB_00124b9a;
                     pTVar11 = pTVar12;
                     if (*(code**)( lVar19 + 400 ) != TIntermAggregate::getSequence) {
                        pTVar11 = (TIntermNode*)( **(code**)( lVar19 + 400 ) )(pTVar7);
                     }

                     lVar19 = lVar13 * 8;
                     pTVar8 = (TIntermTyped*)( **(code**)( **(long**)( *(long*)( pTVar11 + 8 ) + lVar13 * 8 ) + 0x18 ) )();
                     uVar9 = convertInitializerList(this, param_1, local_168, pTVar8);
                     pTVar11 = pTVar12;
                     if (*(code**)( *(long*)pTVar7 + 400 ) == TIntermAggregate::getSequence) {
                        *(undefined8*)( *(long*)( pTVar7 + 200 ) + lVar13 * 8 ) = uVar9;
                     }
 else {
                        lVar15 = ( **(code**)( *(long*)pTVar7 + 400 ) )(pTVar7);
                        pcVar21 = *(code**)( *(long*)pTVar7 + 400 );
                        *(undefined8*)( *(long*)( lVar15 + 8 ) + lVar13 * 8 ) = uVar9;
                        if (pcVar21 != TIntermAggregate::getSequence) {
                           pTVar11 = (TIntermNode*)( *pcVar21 )(pTVar7);
                        }

                     }

                     lVar13 = lVar13 + 1;
                  }
 while ( *(long*)( *(long*)( pTVar11 + 8 ) + lVar19 ) != 0 );
                  param_3 = (TIntermTyped*)0x0;
                  goto LAB_00124c0b;
               }

               pcVar21 = *(code**)( *(long*)this + 0x158 );
               local_98 = glslang::GetThreadPoolAllocator();
               local_90 = local_80;
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
               local_c8 = glslang::GetThreadPoolAllocator();
               local_c0 = local_b0;
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_c8, &_LC1, &_LC1);
               TType::getCompleteString(local_68, param_2, *(undefined1*)( *(long*)( this + 0x38 ) + 0x26f ), 1, 1, 1, &local_c8, &local_98);
               pcVar17 = "wrong number of matrix columns:";
            }
 else {
               cVar2 = ( **(code**)( lVar13 + 0xe0 ) )(param_2);
               lVar13 = *(long*)param_2;
               if (cVar2 != '\0') goto LAB_00124c6a;
               LAB_00125320:if (*(code**)( lVar13 + 0xd8 ) == TType::isVector) {
                  if (( (byte)param_2[9] & 0xf ) < 2) {
                     bVar3 = (byte)param_2[10] >> 4 & 1;
                     goto LAB_001254ab;
                  }

               }
 else {
                  bVar3 = ( **(code**)( lVar13 + 0xd8 ) )(param_2);
                  LAB_001254ab:if (bVar3 == 0) {
                     pcVar21 = *(code**)( *(long*)this + 0x158 );
                     local_98 = glslang::GetThreadPoolAllocator();
                     local_90 = local_80;
                     std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
                     local_c8 = glslang::GetThreadPoolAllocator();
                     local_c0 = local_b0;
                     std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_c8, &_LC1, &_LC1);
                     TType::getCompleteString(local_68, param_2, *(undefined1*)( *(long*)( this + 0x38 ) + 0x26f ), 1, 1, 1, &local_c8, &local_98);
                     pcVar17 = "unexpected initializer-list type:";
                     goto LAB_00124d7f;
                  }

                  lVar13 = *(long*)param_2;
               }

               if (*(code**)( lVar13 + 0x60 ) == TType::getVectorSize) {
                  uVar6 = (byte)param_2[9] & 0xf;
               }
 else {
                  uVar6 = ( **(code**)( lVar13 + 0x60 ) )(param_2);
               }

               if (*(code**)( *(long*)pTVar7 + 400 ) == TIntermAggregate::getSequence) {
                  pTVar12 = pTVar7 + 0xc0;
               }
 else {
                  pTVar12 = (TIntermNode*)( **(code**)( *(long*)pTVar7 + 400 ) )(pTVar7);
               }

               if (uVar6 == ( uint )(*(long*)( pTVar12 + 0x10 ) - *(long*)( pTVar12 + 8 ) >> 3)) {
                  lVar13 = *(long*)param_2;
                  if (*(code**)( lVar13 + 0x38 ) == TType::getBasicType) {
                     uVar6 = (uint)(byte)param_2[8];
                  }
 else {
                     uVar6 = ( **(code**)( lVar13 + 0x38 ) )(param_2);
                     lVar13 = *(long*)param_2;
                  }

                  lVar15 = 0;
                  while (true) {
                     if (*(code**)( lVar13 + 0x60 ) == TType::getVectorSize) {
                        uVar5 = (byte)param_2[9] & 0xf;
                     }
 else {
                        uVar5 = ( **(code**)( lVar13 + 0x60 ) )(param_2);
                     }

                     lVar19 = *(long*)pTVar7;
                     if ((int)uVar5 <= (int)lVar15) goto LAB_00124b9a;
                     if (*(code**)( lVar19 + 400 ) == TIntermAggregate::getSequence) {
                        pTVar12 = pTVar7 + 0xc0;
                     }
 else {
                        pTVar12 = (TIntermNode*)( **(code**)( lVar19 + 400 ) )(pTVar7);
                     }

                     plVar14 = (long*)( **(code**)( **(long**)( *(long*)( pTVar12 + 8 ) + lVar15 * 8 ) + 0x18 ) )();
                     if (*(code**)( *plVar14 + 0x100 ) == TIntermTyped::getBasicType) {
                        uVar5 = ( uint ) * (byte*)( plVar14 + 5 );
                     }
 else {
                        uVar5 = ( **(code**)( *plVar14 + 0x100 ) )();
                     }

                     if (( uVar6 != uVar5 ) && ( cVar2 = glslang::TIntermediate::canImplicitlyPromote(*(undefined8*)( this + 0x38 ), uVar5, uVar6, 0) ),cVar2 == '\0') break;
                     lVar13 = *(long*)param_2;
                     lVar15 = lVar15 + 1;
                  }
;
                  pcVar21 = *(code**)( *(long*)this + 0x158 );
                  local_98 = glslang::GetThreadPoolAllocator();
                  local_90 = local_80;
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
                  local_c8 = glslang::GetThreadPoolAllocator();
                  local_c0 = local_b0;
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_c8, &_LC1, &_LC1);
                  TType::getCompleteString(local_68, param_2, *(undefined1*)( *(long*)( this + 0x38 ) + 0x26f ), 1, 1, 1, &local_c8, &local_98);
                  pcVar17 = "type mismatch in initializer list";
               }
 else {
                  pcVar21 = *(code**)( *(long*)this + 0x158 );
                  local_98 = glslang::GetThreadPoolAllocator();
                  local_90 = local_80;
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
                  local_c8 = glslang::GetThreadPoolAllocator();
                  local_c0 = local_b0;
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_c8, &_LC1, &_LC1);
                  TType::getCompleteString(local_68, param_2, *(undefined1*)( *(long*)( this + 0x38 ) + 0x26f ), 1, 1, 1, &local_c8, &local_98);
                  pcVar17 = "wrong vector size (or rows in a matrix column):";
               }

            }

            LAB_00124d7f:( *pcVar21 )(this, param_1, pcVar17, "initializer list", local_60);
            LAB_00124d8e:param_3 = (TIntermTyped*)0x0;
            goto LAB_00124c0b;
         }

      }
 else {
         cVar2 = ( **(code**)( lVar13 + 0x128 ) )(param_2);
         if (cVar2 == '\0') {
            lVar13 = *(long*)param_2;
            goto LAB_00124c48;
         }

      }

      lVar13 = *(long*)( *(long*)( param_2 + 0x68 ) + 0x10 );
      lVar19 = *(long*)( *(long*)( param_2 + 0x68 ) + 8 );
      if (*(code**)( *(long*)pTVar7 + 400 ) == TIntermAggregate::getSequence) {
         pTVar12 = pTVar7 + 0xc0;
      }
 else {
         pTVar12 = (TIntermNode*)( **(code**)( *(long*)pTVar7 + 400 ) )(pTVar7);
      }

      if (*(long*)( pTVar12 + 0x10 ) - *(long*)( pTVar12 + 8 ) >> 3 == lVar13 - lVar19 >> 5) {
         pTVar12 = pTVar7 + 0xc0;
         uVar20 = 0;
         if (*(long*)( *(long*)( param_2 + 0x68 ) + 0x10 ) != *(long*)( *(long*)( param_2 + 0x68 ) + 8 )) {
            do {
               pTVar11 = pTVar12;
               if (*(code**)( *(long*)pTVar7 + 400 ) != TIntermAggregate::getSequence) {
                  pTVar11 = (TIntermNode*)( **(code**)( *(long*)pTVar7 + 400 ) )(pTVar7);
               }

               pTVar8 = (TIntermTyped*)( **(code**)( **(long**)( *(long*)( pTVar11 + 8 ) + uVar20 * 8 ) + 0x18 ) )();
               uVar9 = convertInitializerList(this, param_1, *(TType**)( uVar20 * 0x20 + *(long*)( *(long*)( param_2 + 0x68 ) + 8 ) ), pTVar8);
               pTVar11 = pTVar12;
               if (*(code**)( *(long*)pTVar7 + 400 ) == TIntermAggregate::getSequence) {
                  *(undefined8*)( *(long*)( pTVar7 + 200 ) + uVar20 * 8 ) = uVar9;
               }
 else {
                  lVar13 = ( **(code**)( *(long*)pTVar7 + 400 ) )(pTVar7);
                  pcVar21 = *(code**)( *(long*)pTVar7 + 400 );
                  *(undefined8*)( *(long*)( lVar13 + 8 ) + uVar20 * 8 ) = uVar9;
                  if (pcVar21 != TIntermAggregate::getSequence) {
                     pTVar11 = (TIntermNode*)( *pcVar21 )(pTVar7);
                  }

               }

               if (*(long*)( *(long*)( pTVar11 + 8 ) + uVar20 * 8 ) == 0) goto LAB_00124d8e;
               uVar20 = uVar20 + 1;
            }
 while ( uVar20 < ( ulong )(*(long*)( *(long*)( param_2 + 0x68 ) + 0x10 ) - *(long*)( *(long*)( param_2 + 0x68 ) + 8 ) >> 5) );
         }

         lVar19 = *(long*)pTVar7;
         LAB_00124b9a:if (*(code**)( lVar19 + 400 ) == TIntermAggregate::getSequence) {
            puVar10 = *(undefined8**)( pTVar7 + 200 );
            if (*(long*)( pTVar7 + 0xd0 ) - (long)puVar10 == 8) {
               LAB_001255cc:pTVar7 = (TIntermNode*)*puVar10;
            }

         }
 else {
            lVar13 = ( **(code**)( lVar19 + 400 ) )(pTVar7);
            if (*(long*)( lVar13 + 0x10 ) - *(long*)( lVar13 + 8 ) == 8) {
               if (*(code**)( *(long*)pTVar7 + 400 ) == TIntermAggregate::getSequence) {
                  puVar10 = *(undefined8**)( pTVar7 + 200 );
               }
 else {
                  lVar13 = ( **(code**)( *(long*)pTVar7 + 400 ) )(pTVar7);
                  puVar10 = *(undefined8**)( lVar13 + 8 );
               }

               goto LAB_001255cc;
            }

         }

         if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
            pTVar8 = (TIntermTyped*)addConstructor(this, param_1, pTVar7, param_2);
            return pTVar8;
         }

         goto LAB_00125a0e;
      }

      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "wrong number of structure members", "initializer list", &_LC1);
      param_3 = (TIntermTyped*)0x0;
   }

   LAB_00124c0b:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return param_3;
   }

   LAB_00125a0e:/* WARNING: Subroutine does not return */__stack_chk_fail();
}
/* glslang::TParseContext::handleDotDereference(glslang::TSourceLoc const&, glslang::TIntermTyped*,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const&)
    */TIntermTyped * __thiscall
glslang::TParseContext::handleDotDereference
          (TParseContext *this,TSourceLoc *param_1,TIntermTyped *param_2,basic_string *param_3){
   size_t __n;
   void *__s1;
   ulong uVar1;
   long lVar2;
   TIntermTyped TVar3;
   byte bVar4;
   char cVar5;
   int iVar6;
   uint uVar7;
   byte extraout_var;
   undefined8 uVar8;
   _Rb_tree_node_base *p_Var9;
   ulong uVar10;
   TIntermTyped *pTVar11;
   long lVar12;
   long lVar13;
   long *plVar14;
   basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *pbVar15;
   TIntermTyped *pTVar16;
   code *pcVar17;
   TIntermTyped *pTVar18;
   _Rb_tree_node_base *p_Var19;
   _Rb_tree_node_base *p_Var20;
   byte bVar21;
   byte bVar22;
   TIntermTyped *pTVar23;
   undefined *puVar24;
   bool bVar25;
   ulong uVar26;
   long in_FS_OFFSET;
   TIntermTyped *local_190;
   TIntermTyped *local_180;
   TIntermTyped *local_170;
   undefined **local_168;
   uint local_160;
   undefined8 local_158;
   ulong local_150;
   byte local_148;
   undefined8 local_144;
   undefined1 uStack_13c;
   uint7 local_13b;
   undefined4 uStack_134;
   undefined4 local_130;
   undefined4 uStack_12c;
   undefined1 local_128;
   undefined8 local_124;
   undefined4 local_11c;
   undefined8 local_118;
   undefined2 local_110;
   undefined1 local_108[16];
   undefined1 local_f8[16];
   uint local_e8;
   undefined1 local_e0[16];
   undefined8 local_c8;
   undefined1 *local_c0;
   undefined1 local_b0[24];
   undefined8 local_98;
   undefined1 *local_90;
   undefined1 local_80[24];
   undefined8 local_68;
   undefined *local_60;
   undefined8 local_58;
   undefined local_50[16];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   local_170 = param_2;
   variableCheck(this, &local_170);
   pTVar11 = local_170;
   if (*(long*)( param_3 + 0x10 ) == 6) {
      if (( **(int**)( param_3 + 8 ) != 0x676e656c ) || ( bVar25 = false(short)(*(int**)( param_3 + 8 ))[1] != 0x6874 )) {
         bVar25 = true;
      }

      lVar13 = *(long*)local_170;
      if (!bVar25) {
         iVar6 = (int)param_1;
         if (*(code**)( lVar13 + 0x150 ) == TIntermTyped::isArray) {
            if (*(long*)( local_170 + 0x80 ) == 0) goto LAB_00125fc5;
            LAB_001263f8:glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, 1, (char*)0x78, "GL_3DL_array_objects");
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, 8, (char*)0x12c, (char*)0x0);
            pTVar16 = *(TIntermTyped**)( this + 0x38 );
         }
 else {
            cVar5 = ( **(code**)( lVar13 + 0x150 ) )(local_170);
            if (cVar5 != '\0') goto LAB_001263f8;
            lVar13 = *(long*)pTVar11;
            LAB_00125fc5:if (*(code**)( lVar13 + 0x158 ) == TIntermTyped::isVector) {
               if (( (byte)pTVar11[0x29] & 0xf ) < 2) {
                  bVar4 = (byte)pTVar11[0x2a] >> 4 & 1;
                  goto LAB_00126153;
               }

            }
 else {
               bVar4 = ( **(code**)( lVar13 + 0x158 ) )(pTVar11);
               LAB_00126153:if (bVar4 == 0) {
                  lVar13 = *(long*)pTVar11;
                  if (*(code**)( lVar13 + 0x148 ) == TIntermTyped::isMatrix) {
                     if ((byte)pTVar11[0x29] < 0x10) {
                        LAB_00126180:if (*(code**)( lVar13 + 0xf0 ) == TIntermTyped::getType) {
                           pTVar23 = pTVar11 + 0x20;
                        }
 else {
                           pTVar23 = (TIntermTyped*)( **(code**)( lVar13 + 0xf0 ) )(pTVar11);
                        }

                        pTVar16 = *(TIntermTyped**)( this + 0x38 );
                        if (( ( (byte)pTVar23[10] & 0x20 ) == 0 ) && ( ( (byte)pTVar23[10] & 0x40 ) == 0 )) {
                           TVar3 = pTVar16[0x26f];
                           pcVar17 = *(code**)( *(long*)this + 0x158 );
                           if (*(code**)( *(long*)pTVar11 + 0xf0 ) == TIntermTyped::getType) {
                              local_180 = pTVar11 + 0x20;
                           }
 else {
                              local_180 = (TIntermTyped*)( **(code**)( *(long*)pTVar11 + 0xf0 ) )(pTVar11);
                           }

                           local_98 = glslang::GetThreadPoolAllocator();
                           local_90 = local_80;
                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
                           local_c8 = glslang::GetThreadPoolAllocator();
                           local_c0 = local_b0;
                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_c8, &_LC1, &_LC1);
                           TType::getCompleteString(&local_68, local_180, TVar3, 1, 1, 1, &local_c8, &local_98);
                           ( *pcVar17 )(this, param_1, "does not operate on this type:", *(undefined8*)( param_3 + 8 ), local_60);
                           goto LAB_00125f45;
                        }

                        goto LAB_0012602a;
                     }

                  }
 else {
                     cVar5 = ( **(code**)( lVar13 + 0x148 ) )(pTVar11);
                     if (cVar5 == '\0') {
                        lVar13 = *(long*)pTVar11;
                        goto LAB_00126180;
                     }

                  }

               }

            }

            glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar6, (char*)0xfffffff7);
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar6, -9, (char*)0x1a4, "GL_ARB_shading_language_420pack");
            pTVar16 = *(TIntermTyped**)( this + 0x38 );
         }

         LAB_0012602a:local_168 = &PTR__TType_00167f00;
         local_110 = 0;
         local_148 = local_148 & 0xf0;
         local_160 = local_160 & 0xf8000000 | 0x108;
         local_128 = 0;
         local_124 = 0xfffff800;
         local_e8 = local_e8 & 0x9fc00000;
         local_158 = 0;
         local_144 = 0xffffffffffffffff;
         local_11c = 0xffffffff;
         uStack_12c = 0;
         local_13b = local_13b & 0xffc000 | 0xffffffff001fcf;
         local_118 = 0;
         uStack_13c = 0xff;
         local_e0 = (undefined1[16])0x0;
         uVar26 = CONCAT44(local_130, uStack_134) & 0xfe07ff00ffffffff | 0x1ffffff7fffffff;
         uStack_134 = (undefined4)uVar26;
         local_130 = ( undefined4 )(uVar26 >> 0x20);
         local_108 = (undefined1[16])0x0;
         local_150 = local_150 & 0x8000000400000000;
         local_f8 = (undefined1[16])0x0;
         pTVar11 = (TIntermTyped*)glslang::TIntermediate::addMethod(pTVar16, (TType*)pTVar11, (basic_string*)&local_168, (TSourceLoc*)param_3);
         goto LAB_00125f45;
      }

   }

   lVar13 = *(long*)local_170;
   if (*(code**)( lVar13 + 0x150 ) == TIntermTyped::isArray) {
      if (*(long*)( local_170 + 0x80 ) != 0) {
         LAB_001263c8:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot apply to an array:", &_LC820, *(undefined8*)( param_3 + 8 ));
         goto LAB_00125f45;
      }

   }
 else {
      cVar5 = ( **(code**)( lVar13 + 0x150 ) )(local_170);
      if (cVar5 != '\0') goto LAB_001263c8;
      lVar13 = *(long*)pTVar11;
   }

   if (*(code**)( lVar13 + 0xf0 ) == TIntermTyped::getType) {
      pTVar16 = pTVar11 + 0x20;
   }
 else {
      pTVar16 = (TIntermTyped*)( **(code**)( lVar13 + 0xf0 ) )(pTVar11);
   }

   if (( ( (byte)pTVar16[10] & 0x20 ) != 0 ) || ( ( (byte)pTVar16[10] & 0x40 ) != 0 )) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot apply to a cooperative matrix type:", &_LC820, *(undefined8*)( param_3 + 8 ));
      goto LAB_00125f45;
   }

   lVar13 = *(long*)pTVar11;
   if (*(code**)( lVar13 + 0x158 ) != TIntermTyped::isVector) {
      bVar4 = ( **(code**)( lVar13 + 0x158 ) )(pTVar11);
      lVar13 = *(long*)pTVar11;
      LAB_00126523:if (bVar4 != 0) goto LAB_00125b04;
      if (*(code**)( lVar13 + 0x160 ) == TIntermTyped::isScalar) {
         if (( ( ( ( (byte)pTVar11[0x29] & 0xf ) < 2 ) && ( ( (byte)pTVar11[0x2a] & 0x10 ) == 0 ) ) && ( (byte)pTVar11[0x29] < 0x10 ) ) && ( ( 1 < ( byte )((char)pTVar11[0x28] - 0xfU) && ( *(long*)( pTVar11 + 0x80 ) == 0 ) ) )) goto LAB_00125b04;
      }
 else {
         cVar5 = ( **(code**)( lVar13 + 0x160 ) )(pTVar11);
         lVar13 = *(long*)pTVar11;
         if (cVar5 != '\0') goto LAB_00125b04;
      }

      LAB_00125b7f:pTVar16 = pTVar11;
      if (*(code**)( lVar13 + 0x168 ) == TIntermTyped::isStruct) {
         TVar3 = pTVar11[0x28];
         if (1 < ( byte )((char)TVar3 - 0xfU)) {
            LAB_00126590:if (TVar3 != (TIntermTyped)0x12) {
               pcVar17 = *(code**)( *(long*)this + 0x158 );
               if (*(code**)( lVar13 + 0xf0 ) == TIntermTyped::getType) {
                  local_190 = pTVar11 + 0x20;
               }
 else {
                  local_190 = (TIntermTyped*)( **(code**)( lVar13 + 0xf0 ) )(pTVar11);
               }

               local_98 = glslang::GetThreadPoolAllocator();
               local_90 = local_80;
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
               local_c8 = glslang::GetThreadPoolAllocator();
               local_c0 = local_b0;
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_c8, &_LC1, &_LC1);
               TType::getCompleteString(&local_68, local_190, *(undefined1*)( *(long*)( this + 0x38 ) + 0x26f ), 1, 1, 1, &local_c8, &local_98);
               ( *pcVar17 )(this, param_1, "does not apply to this type:", *(undefined8*)( param_3 + 8 ), local_60);
               goto LAB_001262eb;
            }

            goto LAB_00126921;
         }

         pcVar17 = *(code**)( lVar13 + 0xf0 );
         LAB_00125bae:pTVar23 = pTVar11;
         if (pcVar17 == TIntermTyped::getType) {
            pTVar23 = pTVar11 + 0x20;
            goto LAB_00125bbb;
         }

      }
 else {
         cVar5 = ( **(code**)( lVar13 + 0x168 ) )(pTVar11);
         lVar13 = *(long*)pTVar11;
         if (cVar5 == '\0') {
            TVar3 = pTVar11[0x28];
            goto LAB_00126590;
         }

         pcVar17 = *(code**)( lVar13 + 0xf0 );
         if (pTVar11[0x28] != (TIntermTyped)0x12) goto LAB_00125bae;
         LAB_00126921:if (*(code**)( lVar13 + 0xf0 ) == TIntermTyped::getType) {
            pTVar23 = pTVar11 + 0x20;
         }
 else {
            pTVar23 = (TIntermTyped*)( **(code**)( lVar13 + 0xf0 ) )(pTVar11);
         }

         pcVar17 = *(code**)( *(long*)pTVar23 + 0xa8 );
         if (pcVar17 == TType::getReferentType) {
            pTVar23 = *(TIntermTyped**)( pTVar23 + 0x68 );
            goto LAB_00125bbb;
         }

      }

      pTVar23 = (TIntermTyped*)( *pcVar17 )(pTVar23);
      LAB_00125bbb:lVar13 = *(long*)( pTVar23 + 0x68 );
      uVar26 = 0;
      lVar12 = *(long*)( lVar13 + 8 );
      pTVar23 = pTVar11;
      if (0 < (int)( *(long*)( lVar13 + 0x10 ) - lVar12 >> 5 )) {
         do {
            plVar14 = *(long**)( lVar12 + uVar26 * 0x20 );
            pcVar17 = *(code**)( *plVar14 + 0x30 );
            if (pcVar17 == TType::getFieldName_abi_cxx11_) {
               lVar12 = plVar14[0xe];
            }
 else {
               lVar12 = ( *pcVar17 )();
            }

            __n = *(size_t*)( lVar12 + 0x10 );
            if (( __n == *(size_t*)( param_3 + 0x10 ) ) && ( ( __n == 0 || ( iVar6 = memcmp(*(void**)( lVar12 + 8 ), *(void**)( param_3 + 8 ), __n) ),iVar6 == 0 ) )) {
               iVar6 = (int)uVar26;
               if (( *(int*)( this + 0x28 ) != 0 ) && ( ( this[0x30] != (TParseContext)0x0 && ( pTVar16 = (TIntermTyped*)vkRelaxedRemapDotDereference(this, param_1, pTVar11, *(TType**)( (long)iVar6 * 0x20 + *(long*)( lVar13 + 8 ) ), param_3) ),pTVar11 != pTVar16 ) )) goto LAB_00126848;
               pTVar16 = pTVar11 + 0x20;
               if (*(code**)( *(long*)pTVar11 + 0xf0 ) != TIntermTyped::getType) {
                  pTVar16 = (TIntermTyped*)( **(code**)( *(long*)pTVar11 + 0xf0 ) )(pTVar11);
               }

               if (*(code**)( *(long*)pTVar16 + 0x58 ) == TType::getQualifier) {
                  pTVar16 = pTVar16 + 0x10;
               }
 else {
                  pTVar16 = (TIntermTyped*)( **(code**)( *(long*)pTVar16 + 0x58 ) )();
               }

               if (( ( (byte)pTVar16[8] & 0x7f ) == 2 ) && ( ( (byte)pTVar16[0xc] & 1 ) == 0 )) {
                  pTVar16 = (TIntermTyped*)glslang::TIntermediate::foldDereference(*(TIntermTyped**)( this + 0x38 ), (int)pTVar11, (TSourceLoc*)( uVar26 & 0xffffffff ));
                  goto LAB_00126848;
               }

               blockMemberExtensionCheck(this, param_1, pTVar11, iVar6, param_3);
               uVar8 = glslang::TIntermediate::addConstantUnion((int)*(undefined8*)( this + 0x38 ), (TSourceLoc*)( uVar26 & 0xffffffff ), SUB81(param_1, 0));
               pTVar16 = (TIntermTyped*)glslang::TIntermediate::addIndex(*(undefined8*)( this + 0x38 ), 0xb8, pTVar11, uVar8, param_1);
               plVar14 = *(long**)( *(long*)( lVar13 + 8 ) + (long)iVar6 * 0x20 );
               if (*(code**)( *(long*)pTVar16 + 0xe8 ) == TIntermTyped::setType) {
                  lVar13 = plVar14[3];
                  TVar3 = *(TIntermTyped*)( plVar14 + 1 );
                  lVar2 = plVar14[0x10];
                  *(long*)( pTVar16 + 0x30 ) = plVar14[2];
                  *(long*)( pTVar16 + 0x38 ) = lVar13;
                  lVar13 = plVar14[4];
                  lVar12 = plVar14[5];
                  *(int*)( pTVar16 + 0xa0 ) = (int)lVar2;
                  *(long*)( pTVar16 + 0x40 ) = lVar13;
                  *(long*)( pTVar16 + 0x48 ) = lVar12;
                  lVar13 = plVar14[6];
                  lVar12 = plVar14[7];
                  pTVar16[0x28] = TVar3;
                  *(long*)( pTVar16 + 0x50 ) = lVar13;
                  *(long*)( pTVar16 + 0x58 ) = lVar12;
                  lVar13 = plVar14[9];
                  *(long*)( pTVar16 + 0x60 ) = plVar14[8];
                  *(long*)( pTVar16 + 0x68 ) = lVar13;
                  lVar13 = plVar14[0xb];
                  *(long*)( pTVar16 + 0x70 ) = plVar14[10];
                  *(long*)( pTVar16 + 0x78 ) = lVar13;
                  bVar4 = *(byte*)( (long)plVar14 + 9 ) & 0xf;
                  pTVar16[0x29] = ( TIntermTyped )((byte)pTVar16[0x29] & 0xf0 | bVar4);
                  pTVar16[0x29] = ( TIntermTyped )(bVar4 | *(byte*)( (long)plVar14 + 9 ) & 0xf0);
                  TVar3 = pTVar16[0x2a];
                  bVar4 = *(byte*)( (long)plVar14 + 10 ) & 0xf;
                  pTVar16[0x2a] = ( TIntermTyped )((byte)TVar3 & 0xf0 | bVar4);
                  bVar21 = *(byte*)( (long)plVar14 + 10 ) & 0x10;
                  pTVar16[0x2a] = ( TIntermTyped )((byte)TVar3 & 0xe0 | bVar4 | bVar21);
                  lVar12 = plVar14[0xe];
                  lVar2 = plVar14[0xf];
                  *(long*)( pTVar16 + 0x80 ) = plVar14[0xc];
                  lVar13 = plVar14[0xd];
                  *(long*)( pTVar16 + 0x90 ) = lVar12;
                  *(long*)( pTVar16 + 0x98 ) = lVar2;
                  *(long*)( pTVar16 + 0x88 ) = lVar13;
                  lVar13 = plVar14[0x12];
                  *(long*)( pTVar16 + 0xa8 ) = plVar14[0x11];
                  *(long*)( pTVar16 + 0xb0 ) = lVar13;
                  bVar22 = *(byte*)( (long)plVar14 + 10 ) & 0x20;
                  pTVar16[0x2a] = ( TIntermTyped )((byte)TVar3 & 0xc0 | bVar4 | bVar21 | bVar22);
                  pTVar16[0x2a] = ( TIntermTyped )((byte)TVar3 & 0x80 | bVar4 | bVar21 | bVar22 | *(byte*)( (long)plVar14 + 10 ) & 0x40);
                  *(ushort*)( pTVar16 + 0x2a ) = *(ushort*)( pTVar16 + 0x2a ) & 0xfc7f | *(ushort*)( (long)plVar14 + 10 ) & 0x380;
                  pTVar16[0x2b] = ( TIntermTyped )((byte)pTVar16[0x2b] & 0xfb | *(byte*)( (long)plVar14 + 0xb ) & 4);
               }
 else {
                  ( **(code**)( *(long*)pTVar16 + 0xe8 ) )(pTVar16);
                  plVar14 = *(long**)( *(long*)( lVar13 + 8 ) + (long)iVar6 * 0x20 );
               }

               if (*(code**)( *plVar14 + 0x50 ) == TType::getQualifier) {
                  plVar14 = plVar14 + 2;
               }
 else {
                  plVar14 = (long*)( **(code**)( *plVar14 + 0x50 ) )(plVar14);
               }

               bVar4 = *(byte*)( plVar14 + 1 ) & 0x7f;
               if (bVar4 < 7) {
                  if (bVar4 < 3) goto LAB_00126848;
               }
 else if (10 < ( bVar4 + 0x6c & 0x7f )) goto LAB_00126848;
               lVar13 = *(long*)( this + 0x38 );
               p_Var9 = (_Rb_tree_node_base*)( lVar13 + 0x738 );
               p_Var19 = p_Var9;
               if (*(_Rb_tree_node_base**)( lVar13 + 0x740 ) == (_Rb_tree_node_base*)0x0) goto LAB_00126adc;
               __s1 = *(void**)( param_3 + 8 );
               uVar26 = *(ulong*)( param_3 + 0x10 );
               p_Var20 = *(_Rb_tree_node_base**)( lVar13 + 0x740 );
               goto LAB_00125eba;
            }

            lVar12 = *(long*)( lVar13 + 8 );
            uVar26 = uVar26 + 1;
         }
 while ( (int)uVar26 < (int)( *(long*)( lVar13 + 0x10 ) - lVar12 >> 5 ) );
      }

      do {
         lVar13 = ( **(code**)( *(long*)pTVar23 + 0x60 ) )(pTVar23);
         while (true) {
            if (( lVar13 != 0 ) || ( plVar14 = (long*)( **(code**)( *(long*)pTVar23 + 0x40 ) )(pTVar23) ),plVar14 == (long*)0x0) {
               lVar13 = ( **(code**)( *(long*)pTVar23 + 0x60 ) )(pTVar23);
               if (lVar13 == 0) {
                  uVar8 = *(undefined8*)( param_3 + 8 );
                  lVar13 = *(long*)this;
                  puVar24 = &_LC1;
               }
 else {
                  local_68 = glslang::GetThreadPoolAllocator();
                  local_58 = 0;
                  local_60 = local_50;
                  local_50[0] = 0;
                  pbVar15 = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_68, "\'");
                  plVar14 = (long*)( **(code**)( *(long*)pTVar23 + 0x60 ) )(pTVar23);
                  if (*(code**)( *plVar14 + 400 ) == TIntermSymbol::getName_abi_cxx11_) {
                     plVar14 = plVar14 + 0x19;
                  }
 else {
                     plVar14 = (long*)( **(code**)( *plVar14 + 400 ) )(plVar14);
                  }

                  pbVar15 = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(pbVar15, (char*)plVar14[1]);
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(pbVar15, "\'");
                  uVar8 = *(undefined8*)( param_3 + 8 );
                  lVar13 = *(long*)this;
                  puVar24 = local_60;
               }

               ( **(code**)( lVar13 + 0x158 ) )(this, param_1, "no such field in structure", uVar8, puVar24);
               goto LAB_001262eb;
            }

            if (*(code**)( *plVar14 + 400 ) != TIntermBinary::getLeft) break;
            pTVar23 = (TIntermTyped*)plVar14[0x18];
            lVar13 = ( **(code**)( *(long*)pTVar23 + 0x60 ) )(pTVar23);
         }
;
         pTVar23 = (TIntermTyped*)( **(code**)( *plVar14 + 400 ) )();
      }
 while ( true );
   }

   if (( (byte)pTVar11[0x29] & 0xf ) < 2) {
      bVar4 = (byte)pTVar11[0x2a] >> 4 & 1;
      goto LAB_00126523;
   }

   LAB_00125b04:if (*(code**)( lVar13 + 0x170 ) == TIntermTyped::isFloatingDomain) {
      if (2 < ( byte )((char)pTVar11[0x28] - 1U)) {
         LAB_00125b2b:if (*(code**)( lVar13 + 0x178 ) == TIntermTyped::isIntegerDomain) {
            TVar3 = pTVar11[0x28];
            if ((byte)TVar3 < 0xc) {
               if ((byte)TVar3 < 4) {
                  LAB_00125b57:if (*(code**)( lVar13 + 0x100 ) == TIntermTyped::getBasicType) {
                     uVar7 = (uint)(byte)pTVar11[0x28];
                  }
 else {
                     uVar7 = ( **(code**)( lVar13 + 0x100 ) )(pTVar11);
                  }

                  if (uVar7 != 0xc) {
                     lVar13 = *(long*)pTVar11;
                     goto LAB_00125b7f;
                  }

               }

            }
 else if (TVar3 != (TIntermTyped)0xd) goto LAB_00125b57;
         }
 else {
            cVar5 = ( **(code**)( lVar13 + 0x178 ) )(pTVar11);
            if (cVar5 == '\0') {
               lVar13 = *(long*)pTVar11;
               goto LAB_00125b57;
            }

         }

      }

   }
 else {
      cVar5 = ( **(code**)( lVar13 + 0x170 ) )(pTVar11);
      if (cVar5 == '\0') {
         lVar13 = *(long*)pTVar11;
         goto LAB_00125b2b;
      }

   }

   pTVar16 = (TIntermTyped*)handleDotSwizzle(this, param_1, pTVar11, param_3);
   goto LAB_001262eb;
   LAB_00125eba:do {
      p_Var19 = p_Var20;
      uVar1 = *(ulong*)( p_Var19 + 0x30 );
      uVar10 = uVar1;
      if (uVar26 <= uVar1) {
         uVar10 = uVar26;
      }

      if (uVar10 == 0) {
         LAB_00125eeb:uVar10 = uVar26 - uVar1;
         if ((long)uVar10 < 0x80000000) {
            if (-0x80000001 < (long)uVar10) goto LAB_00125f0a;
            goto LAB_00125ea4;
         }

         LAB_00125f0e:p_Var20 = *(_Rb_tree_node_base**)( p_Var19 + 0x18 );
         bVar25 = false;
      }
 else {
         uVar7 = memcmp(__s1, *(void**)( p_Var19 + 0x28 ), uVar10);
         uVar10 = (ulong)uVar7;
         if (uVar7 == 0) goto LAB_00125eeb;
         LAB_00125f0a:if (-1 < (int)uVar10) goto LAB_00125f0e;
         LAB_00125ea4:p_Var20 = *(_Rb_tree_node_base**)( p_Var19 + 0x10 );
         bVar25 = true;
      }

   }
 while ( p_Var20 != (_Rb_tree_node_base*)0x0 );
   p_Var20 = p_Var19;
   if (bVar25) {
      LAB_00126adc:p_Var20 = *(_Rb_tree_node_base**)( lVar13 + 0x748 );
      if (p_Var19 != p_Var20) {
         p_Var20 = (_Rb_tree_node_base*)std::_Rb_tree_decrement(p_Var19);
         goto LAB_001269e6;
      }

      LAB_00126a0f:bVar25 = true;
      if (p_Var20 != p_Var9) {
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::compare(*(basic_string**)( param_3 + 8 ));
         bVar25 = (bool)( extraout_var >> 7 );
      }

      p_Var19 = (_Rb_tree_node_base*)operator_new(0x48);
      std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::basic_string((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( p_Var19 + 0x20 ), param_3);
      std::_Rb_tree_insert_and_rebalance(bVar25, p_Var19, p_Var20, p_Var9);
      *(long*)( lVar13 + 0x758 ) = *(long*)( lVar13 + 0x758 ) + 1;
   }
 else {
      LAB_001269e6:iVar6 = std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::compare(*(basic_string**)( p_Var20 + 0x28 ));
      p_Var20 = p_Var19;
      if (iVar6 < 0) goto LAB_00126a0f;
   }

   LAB_00126848:if (*(code**)( *(long*)pTVar16 + 0xf8 ) == TIntermTyped::getWritableType) {
      pTVar23 = pTVar16 + 0x20;
   }
 else {
      pTVar23 = (TIntermTyped*)( **(code**)( *(long*)pTVar16 + 0xf8 ) )(pTVar16);
   }

   if (*(code**)( *(long*)pTVar23 + 0x50 ) == TType::getQualifier) {
      pTVar23 = pTVar23 + 0x10;
   }
 else {
      pTVar23 = (TIntermTyped*)( **(code**)( *(long*)pTVar23 + 0x50 ) )();
   }

   if (*(code**)( *(long*)pTVar11 + 0x108 ) == TIntermTyped::getQualifier) {
      pTVar18 = pTVar11 + 0x30;
   }
 else {
      pTVar18 = (TIntermTyped*)( **(code**)( *(long*)pTVar11 + 0x108 ) )(pTVar11);
   }

   if ((char)pTVar18[0xd] < '\0') {
      pTVar23[0xd] = ( TIntermTyped )((byte)pTVar23[0xd] | 0x80);
   }

   TVar3 = pTVar18[0xe];
   if (( (byte)TVar3 & 1 ) != 0) {
      pTVar23[0xe] = ( TIntermTyped )((byte)pTVar23[0xe] | 1);
      TVar3 = pTVar18[0xe];
   }

   if (( (byte)TVar3 & 2 ) != 0) {
      pTVar23[0xe] = ( TIntermTyped )((byte)pTVar23[0xe] | 2);
      TVar3 = pTVar18[0xe];
   }

   if (( (byte)TVar3 & 4 ) != 0) {
      pTVar23[0xe] = ( TIntermTyped )((byte)pTVar23[0xe] | 4);
   }

   if (( (byte)pTVar18[0xd] & 0x40 ) != 0) {
      pTVar23[0xd] = ( TIntermTyped )((byte)pTVar23[0xd] | 0x40);
   }

   LAB_001262eb:if (*(code**)( *(long*)pTVar11 + 0x108 ) == TIntermTyped::getQualifier) {
      if (( (byte)pTVar11[0x3c] & 0x10 ) != 0) {
         LAB_00126363:pTVar23 = pTVar16 + 0x20;
         if (*(code**)( *(long*)pTVar16 + 0xf8 ) != TIntermTyped::getWritableType) {
            pTVar23 = (TIntermTyped*)( **(code**)( *(long*)pTVar16 + 0xf8 ) )(pTVar16);
         }

         if (*(code**)( *(long*)pTVar23 + 0x50 ) == TType::getQualifier) {
            pTVar23 = pTVar23 + 0x10;
         }
 else {
            pTVar23 = (TIntermTyped*)( **(code**)( *(long*)pTVar23 + 0x50 ) )();
         }

         pTVar23[0xc] = ( TIntermTyped )((byte)pTVar23[0xc] | 0x10);
         goto LAB_001263a1;
      }

      LAB_00126301:pTVar23 = pTVar11 + 0x30;
   }
 else {
      lVar13 = ( **(code**)( *(long*)pTVar11 + 0x108 ) )(pTVar11);
      if (( *(byte*)( lVar13 + 0xc ) & 0x10 ) != 0) goto LAB_00126363;
      LAB_001263a1:if (*(code**)( *(long*)pTVar11 + 0x108 ) == TIntermTyped::getQualifier) goto LAB_00126301;
      pTVar23 = (TIntermTyped*)( **(code**)( *(long*)pTVar11 + 0x108 ) )(pTVar11);
   }

   pTVar11 = pTVar16;
   if (( (byte)pTVar23[0xc] & 2 ) != 0) {
      if (*(code**)( *(long*)pTVar16 + 0xf8 ) == TIntermTyped::getWritableType) {
         pTVar16 = pTVar16 + 0x20;
      }
 else {
         pTVar16 = (TIntermTyped*)( **(code**)( *(long*)pTVar16 + 0xf8 ) )(pTVar16);
      }

      if (*(code**)( *(long*)pTVar16 + 0x50 ) == TType::getQualifier) {
         pTVar16 = pTVar16 + 0x10;
      }
 else {
         pTVar16 = (TIntermTyped*)( **(code**)( *(long*)pTVar16 + 0x50 ) )();
      }

      pTVar16[0xc] = ( TIntermTyped )((byte)pTVar16[0xc] | 2);
   }

   LAB_00125f45:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return pTVar11;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::handleUnaryMath(glslang::TSourceLoc const&, char const*,
   glslang::TOperator, glslang::TIntermTyped*) */long *__thiscallglslang::TParseContext::handleUnaryMath(TParseContext *this, undefined8 param_1, undefined8 param_2, undefined4 param_4, long *param_5) {
   undefined1 uVar1;
   code *pcVar2;
   long lVar3;
   char cVar4;
   long *plVar5;
   long lVar6;
   TType *pTVar7;
   long in_FS_OFFSET;
   undefined1 local_c8[8];
   undefined8 local_c0;
   undefined8 local_98;
   undefined1 *local_90;
   undefined1 local_80[24];
   undefined8 local_68;
   undefined1 *local_60;
   undefined1 local_50[16];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   ( **(code**)( *(long*)this + 0x208 ) )();
   if (*(code**)( *param_5 + 0xf0 ) == TIntermTyped::getType) {
      plVar5 = param_5 + 4;
   }
 else {
      plVar5 = (long*)( **(code**)( *param_5 + 0xf0 ) )(param_5);
   }

   pcVar2 = *(code**)( *plVar5 + 400 );
   if (pcVar2 == TType::containsBasicType) {
      if ((char)plVar5[1] == '\x03') goto LAB_00126dd4;
      pcVar2 = *(code**)( *plVar5 + 0x128 );
      if (pcVar2 == TType::isStruct) {
         if (( byte )((char)plVar5[1] - 0xfU) < 2) {
            LAB_00126daa:lVar3 = *(long*)( plVar5[0xd] + 0x10 );
            lVar6 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar5[0xd] + 8 ),lVar3,3 ));
            if (lVar3 != lVar6) goto LAB_00126dd4;
         }

      }
 else {
         cVar4 = ( *pcVar2 )();
         if (cVar4 != '\0') goto LAB_00126daa;
      }

      LAB_00126c17:pTVar7 = (TType*)( param_5 + 4 );
      if (*(code**)( *param_5 + 0xf0 ) != TIntermTyped::getType) {
         pTVar7 = (TType*)( **(code**)( *param_5 + 0xf0 ) )(param_5);
      }

      cVar4 = TType::contains16BitInt(pTVar7);
      if (( cVar4 == '\0' ) || ( cVar4 = ( **(code**)( *(long*)this + 0xb8 ) )(this) ),cVar4 != '\0') {
         if (*(code**)( *param_5 + 0xf0 ) == TIntermTyped::getType) {
            cVar4 = TType::contains8BitInt((TType*)( param_5 + 4 ));
         }
 else {
            pTVar7 = (TType*)( **(code**)( *param_5 + 0xf0 ) )(param_5);
            cVar4 = TType::contains8BitInt(pTVar7);
         }

         if (( ( cVar4 == '\0' ) || ( cVar4 = ( **(code**)( *(long*)this + 0xd0 ) )(this) ),cVar4 != '\0' )) &&( plVar5 = (long*)glslang::TIntermediate::addUnaryMath(*(undefined8*)( this + 0x38 ), param_4, param_5, param_1) ),plVar5 != (long*)0x0;
      }

   }
 else {
      cVar4 = ( *pcVar2 )(plVar5, 3);
      if (cVar4 == '\0') goto LAB_00126c17;
      LAB_00126dd4:cVar4 = ( **(code**)( *(long*)this + 0xa0 ) )(this);
      if (cVar4 != '\0') goto LAB_00126c17;
   }

   uVar1 = *(undefined1*)( *(long*)( this + 0x38 ) + 0x26f );
   local_68 = glslang::GetThreadPoolAllocator();
   local_60 = local_50;
   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, &_LC1, &_LC1);
   local_98 = glslang::GetThreadPoolAllocator();
   local_90 = local_80;
   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
   TType::getCompleteString(local_c8, param_5 + 4, uVar1, 1, 1, 1, &local_98, &local_68);
   ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, " wrong operand type", param_2, "no operation \'%s\' exists that takes an operand of type %s (or there is no acceptable conversion)", param_2, local_c0);
   plVar5 = param_5;
   LAB_00126d17:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return plVar5;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::handleBinaryMath(glslang::TSourceLoc const&, char const*,
   glslang::TOperator, glslang::TIntermTyped*, glslang::TIntermTyped*) */long glslang::TParseContext::handleBinaryMath(TParseContext *this, undefined8 param_1, undefined8 param_2, int param_4, long *param_5, long *param_6) {
   undefined1 uVar1;
   char cVar2;
   long lVar3;
   long *plVar4;
   code *pcVar5;
   long lVar6;
   TType *pTVar7;
   byte bVar8;
   long in_FS_OFFSET;
   byte bVar9;
   undefined1 local_f8[8];
   undefined8 local_f0;
   undefined1 local_c8[8];
   undefined8 local_c0;
   undefined8 local_98;
   undefined1 *local_90;
   undefined1 local_80[24];
   undefined8 local_68;
   undefined1 *local_60;
   undefined1 local_50[16];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   pcVar5 = *(code**)( *(long*)this + 0x208 );
   plVar4 = param_5;
   if (*(code**)( *param_5 + 0x18 ) != TIntermTyped::getAsTyped) {
      plVar4 = (long*)( **(code**)( *param_5 + 0x18 ) )(param_5, param_1, param_2, param_5);
   }

   ( *pcVar5 )(this, param_1, param_2, plVar4);
   pcVar5 = *(code**)( *(long*)this + 0x208 );
   plVar4 = param_6;
   if (*(code**)( *param_6 + 0x18 ) != TIntermTyped::getAsTyped) {
      plVar4 = (long*)( **(code**)( *param_6 + 0x18 ) )(param_6);
   }

   ( *pcVar5 )(this, param_1, param_2, plVar4);
   bVar9 = 1;
   lVar3 = *param_5;
   if (param_4 - 0xaaU < 4) {
      if (*(code**)( lVar3 + 0x160 ) == TIntermTyped::isScalar) {
         bVar9 = 0;
         if (( *(byte*)( (long)param_5 + 0x29 ) & 0xf ) < 2) {
            bVar8 = *(byte*)( (long)param_5 + 0x2a ) >> 4;
            bVar9 = bVar8 & 1;
            if (( bVar8 & 1 ) == 0) {
               if (( ( *(byte*)( (long)param_5 + 0x29 ) < 0x10 ) && ( 1 < ( byte )((char)param_5[5] - 0xfU) ) ) && ( param_5[0x10] == 0 )) goto LAB_001273c0;
            }
 else {
               LAB_001274f0:bVar9 = 0;
            }

         }

      }
 else {
         bVar9 = ( **(code**)( lVar3 + 0x160 ) )(param_5);
         if (bVar9 != 0) {
            LAB_001273c0:if (*(code**)( *param_6 + 0x160 ) == TIntermTyped::isScalar) {
               lVar3 = *param_5;
               bVar9 = 0;
               if (( *(byte*)( (long)param_6 + 0x29 ) & 0xf ) < 2) {
                  bVar8 = *(byte*)( (long)param_6 + 0x2a ) >> 4;
                  bVar9 = bVar8 & 1;
                  if (( bVar8 & 1 ) != 0) goto LAB_001274f0;
                  if (( *(byte*)( (long)param_6 + 0x29 ) < 0x10 ) && ( 1 < ( byte )((char)param_6[5] - 0xfU) )) {
                     bVar9 = param_6[0x10] == 0;
                  }

               }

               goto LAB_00126f30;
            }

            bVar9 = ( **(code**)( *param_6 + 0x160 ) )(param_6);
         }

         lVar3 = *param_5;
      }

   }

   LAB_00126f30:if (*(code**)( lVar3 + 0xf0 ) == TIntermTyped::getType) {
      plVar4 = param_5 + 4;
   }
 else {
      plVar4 = (long*)( **(code**)( lVar3 + 0xf0 ) )(param_5);
   }

   pcVar5 = *(code**)( *plVar4 + 400 );
   if (pcVar5 == TType::containsBasicType) {
      if ((char)plVar4[1] == '\x03') goto LAB_00127226;
      pcVar5 = *(code**)( *plVar4 + 0x128 );
      if (pcVar5 == TType::isStruct) {
         if (( byte )((char)plVar4[1] - 0xfU) < 2) {
            LAB_0012728b:lVar3 = *(long*)( plVar4[0xd] + 0x10 );
            lVar6 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar4[0xd] + 8 ),lVar3,3 ));
            if (lVar3 != lVar6) goto LAB_00127226;
         }

      }
 else {
         cVar2 = ( *pcVar5 )();
         if (cVar2 != '\0') goto LAB_0012728b;
      }

      LAB_00126f93:plVar4 = param_6 + 4;
      if (*(code**)( *param_6 + 0xf0 ) != TIntermTyped::getType) {
         plVar4 = (long*)( **(code**)( *param_6 + 0xf0 ) )(param_6);
         lVar3 = *plVar4;
         pcVar5 = *(code**)( lVar3 + 400 );
         if (pcVar5 == TType::containsBasicType) goto LAB_00126fbf;
         LAB_0012739a:cVar2 = ( *pcVar5 )(plVar4, 3);
         if (cVar2 != '\0') goto LAB_00127226;
         goto LAB_00126fed;
      }

      lVar3 = *plVar4;
      pcVar5 = *(code**)( lVar3 + 400 );
      if (pcVar5 != TType::containsBasicType) goto LAB_0012739a;
      LAB_00126fbf:if ((char)plVar4[1] == '\x03') goto LAB_00127226;
      if (*(code**)( lVar3 + 0x128 ) == TType::isStruct) {
         if (( byte )((char)plVar4[1] - 0xfU) < 2) {
            LAB_00127448:lVar3 = *(long*)( plVar4[0xd] + 0x10 );
            lVar6 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar4[0xd] + 8 ),lVar3,3 ));
            if (lVar3 != lVar6) goto LAB_00127226;
         }

      }
 else {
         cVar2 = ( **(code**)( lVar3 + 0x128 ) )();
         if (cVar2 != '\0') goto LAB_00127448;
      }

      LAB_00126fed:pTVar7 = (TType*)( param_5 + 4 );
      if (*(code**)( *param_5 + 0xf0 ) != TIntermTyped::getType) {
         pTVar7 = (TType*)( **(code**)( *param_5 + 0xf0 ) )(param_5);
      }

      cVar2 = TType::contains16BitInt(pTVar7);
      if (cVar2 == '\0') {
         if (*(code**)( *param_6 + 0xf0 ) == TIntermTyped::getType) {
            pTVar7 = (TType*)( param_6 + 4 );
         }
 else {
            pTVar7 = (TType*)( **(code**)( *param_6 + 0xf0 ) )(param_6);
         }

         cVar2 = TType::contains16BitInt(pTVar7);
         if (cVar2 != '\0') goto LAB_00127011;
      }
 else {
         LAB_00127011:cVar2 = ( **(code**)( *(long*)this + 0xb8 ) )(this);
         if (cVar2 == '\0') goto LAB_00127080;
      }

      if (*(code**)( *param_5 + 0xf0 ) == TIntermTyped::getType) {
         pTVar7 = (TType*)( param_5 + 4 );
      }
 else {
         pTVar7 = (TType*)( **(code**)( *param_5 + 0xf0 ) )(param_5);
      }

      cVar2 = TType::contains8BitInt(pTVar7);
      if (cVar2 == '\0') {
         if (*(code**)( *param_6 + 0xf0 ) == TIntermTyped::getType) {
            pTVar7 = (TType*)( param_6 + 4 );
         }
 else {
            pTVar7 = (TType*)( **(code**)( *param_6 + 0xf0 ) )(param_6);
         }

         cVar2 = TType::contains8BitInt(pTVar7);
         if (cVar2 != '\0') goto LAB_00127068;
      }
 else {
         LAB_00127068:cVar2 = ( **(code**)( *(long*)this + 0xd0 ) )(this);
         if (cVar2 == '\0') goto LAB_00127080;
      }

      if (bVar9 != 0) {
         if (( (char)param_5[5] == '\x12' ) || ( (char)param_6[5] == '\x12' )) {
            ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_EXT_buffer_reference2, "buffer reference math");
         }

         lVar3 = glslang::TIntermediate::addBinaryMath(*(undefined8*)( this + 0x38 ), param_4, param_5, param_6, param_1);
         if (lVar3 != 0) goto LAB_001271e5;
      }

   }
 else {
      cVar2 = ( *pcVar5 )(plVar4, 3);
      if (cVar2 == '\0') goto LAB_00126f93;
      LAB_00127226:cVar2 = ( **(code**)( *(long*)this + 0xa0 ) )(this);
      if (cVar2 != '\0') goto LAB_00126fed;
   }

   LAB_00127080:uVar1 = *(undefined1*)( *(long*)( this + 0x38 ) + 0x26f );
   local_68 = glslang::GetThreadPoolAllocator();
   local_60 = local_50;
   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, &_LC1, &_LC1);
   local_98 = glslang::GetThreadPoolAllocator();
   local_90 = local_80;
   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
   TType::getCompleteString(local_c8, param_6 + 4, uVar1, 1, 1, 1, &local_98, &local_68);
   local_68 = glslang::GetThreadPoolAllocator();
   local_60 = local_50;
   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, &_LC1, &_LC1);
   local_98 = glslang::GetThreadPoolAllocator();
   local_90 = local_80;
   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
   TType::getCompleteString(local_f8, param_5 + 4, uVar1, 1, 1, 1, &local_98, &local_68);
   ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, " wrong operand types:", param_2, "no operation \'%s\' exists that takes a left-hand operand of type \'%s\' and a right operand of type \'%s\' (or there is no acceptable conversion)", param_2, local_f0, local_c0);
   lVar3 = 0;
   LAB_001271e5:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   return lVar3;
}
/* glslang::TParseContext::executeInitializer(glslang::TSourceLoc const&, glslang::TIntermTyped*,
   glslang::TVariable*) */long glslang::TParseContext::executeInitializer(TParseContext *this, TSourceLoc *param_1, TIntermTyped *param_2, TVariable *param_3) {
   TVariable TVar1;
   undefined1 uVar2;
   uint uVar3;
   char cVar4;
   ushort uVar5;
   int iVar6;
   undefined4 uVar7;
   long lVar8;
   ulong uVar9;
   long *plVar10;
   long lVar11;
   code *pcVar12;
   undefined8 uVar13;
   TVariable *pTVar14;
   long lVar15;
   long *plVar16;
   TType *pTVar17;
   char *pcVar18;
   byte bVar19;
   int iVar20;
   TVariable *pTVar21;
   int iVar22;
   long in_FS_OFFSET;
   bool bVar23;
   TVariable *local_1c0;
   undefined **local_198;
   undefined4 local_190;
   undefined8 local_188;
   ulong uStack_180;
   uint local_178;
   undefined4 uStack_174;
   undefined4 uStack_170;
   uint uStack_16c;
   undefined4 uStack_168;
   undefined4 uStack_164;
   uint uStack_160;
   undefined4 uStack_15c;
   uint local_158;
   undefined4 uStack_154;
   undefined4 uStack_150;
   undefined4 uStack_14c;
   undefined8 local_148;
   ulong uStack_140;
   undefined1 local_138[16];
   undefined1 local_128[16];
   uint local_118;
   undefined1 local_110[16];
   undefined1 local_f8[8];
   undefined8 local_f0;
   undefined8 local_c8;
   undefined1 *local_c0;
   undefined1 local_b0[24];
   undefined8 local_98;
   undefined1 *local_90;
   undefined1 local_80[24];
   undefined8 local_68;
   undefined1 *local_60;
   undefined1 local_50[16];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   lVar8 = ( **(code**)( *(long*)param_2 + 0x30 ) )(param_2);
   if (( lVar8 == 0 ) || ( lVar8 = ( **(code**)( *(long*)param_2 + 0x30 ) )(param_2) * (int*)( lVar8 + 0xb8 ) != 0 )) {
      bVar23 = false;
   }
 else {
      plVar10 = (long*)( **(code**)( *(long*)param_2 + 0x30 ) )(param_2);
      if (*(code**)( *plVar10 + 400 ) == TIntermAggregate::getSequence) {
         plVar10 = plVar10 + 0x18;
      }
 else {
         plVar10 = (long*)( **(code**)( *plVar10 + 400 ) )(plVar10);
      }

      bVar23 = plVar10[2] == plVar10[1];
   }

   if (*(code**)( *(long*)param_3 + 0x60 ) == TVariable::getType) {
      pTVar21 = param_3 + 0x28;
   }
 else {
      pTVar21 = (TVariable*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
   }

   if (*(code**)( *(long*)pTVar21 + 0x58 ) == TType::getQualifier) {
      pTVar21 = pTVar21 + 0x10;
   }
 else {
      pTVar21 = (TVariable*)( **(code**)( *(long*)pTVar21 + 0x58 ) )();
   }

   TVar1 = pTVar21[8];
   bVar19 = (byte)TVar1 & 0x7f;
   iVar20 = (int)param_1;
   if (bVar19 < 3) {
      LAB_00127c70:if (bVar23) {
         LAB_00127c79:if (*(code**)( *(long*)param_3 + 0x60 ) == TVariable::getType) {
            pTVar21 = param_3 + 0x28;
         }
 else {
            pTVar21 = (TVariable*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
         }

         lVar8 = *(long*)pTVar21;
         if (*(code**)( lVar8 + 0x1a8 ) != TType::containsUnsizedArray) {
            cVar4 = ( **(code**)( lVar8 + 0x1a8 ) )(pTVar21);
            if (cVar4 == '\0') goto LAB_00127d19;
            LAB_0012805a:lVar8 = 0;
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "null initializers can\'t size unsized arrays", &_LC1021, &_LC1);
            goto LAB_00128000;
         }

         if (*(code**)( lVar8 + 0xf8 ) == TType::isUnsizedArray) {
            if (*(code**)( lVar8 + 0xe8 ) != TType::isArray) {
               cVar4 = ( **(code**)( lVar8 + 0xe8 ) )(pTVar21);
               if (cVar4 == '\0') goto LAB_00127cf0;
               lVar11 = *(long*)( pTVar21 + 0x60 );
               LAB_00127cde:if (**(int**)( *(long*)( lVar11 + 8 ) + 8 ) == 0) goto LAB_0012805a;
               goto LAB_00127cf0;
            }

            lVar11 = *(long*)( pTVar21 + 0x60 );
            if (lVar11 != 0) goto LAB_00127cde;
         }
 else {
            cVar4 = ( **(code**)( lVar8 + 0xf8 ) )(pTVar21);
            if (cVar4 != '\0') goto LAB_0012805a;
            LAB_00127cf0:lVar8 = *(long*)pTVar21;
         }

         if (*(code**)( lVar8 + 0x128 ) == TType::isStruct) {
            if (( byte )((char)pTVar21[8] - 0xfU) < 2) {
               LAB_0012803d:lVar8 = *(long*)( *(long*)( pTVar21 + 0x68 ) + 0x10 );
               lVar11 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsUnsizedArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsUnsizedArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( pTVar21 + 0x68 ) + 8 ),lVar8 ));
               if (lVar8 != lVar11) goto LAB_0012805a;
            }

         }
 else {
            cVar4 = ( **(code**)( lVar8 + 0x128 ) )(pTVar21);
            if (cVar4 != '\0') goto LAB_0012803d;
         }

         LAB_00127d19:if (*(code**)( *(long*)param_3 + 0x60 ) == TVariable::getType) {
            pTVar21 = param_3 + 0x28;
         }
 else {
            pTVar21 = (TVariable*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
         }

         lVar8 = *(long*)pTVar21;
         if (*(code**)( lVar8 + 0x1b0 ) != TType::containsOpaque) {
            cVar4 = ( **(code**)( lVar8 + 0x1b0 ) )(pTVar21);
            if (cVar4 != '\0') goto LAB_00127d7a;
            goto LAB_001285f6;
         }

         if (*(code**)( lVar8 + 0x140 ) == TType::isOpaque) {
            if (( 0x14 < (byte)pTVar21[8] ) || ( ( 0x1a6000UL >> ( (ulong)(byte)pTVar21[8] & 0x3f ) & 1 ) == 0 )) {
               LAB_001285d0:if (*(code**)( lVar8 + 0x128 ) == TType::isStruct) {
                  if (( byte )((char)pTVar21[8] - 0xfU) < 2) {
                     LAB_00128895:lVar8 = *(long*)( *(long*)( pTVar21 + 0x68 ) + 0x10 );
                     lVar11 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( pTVar21 + 0x68 ) + 8 ),lVar8 ));
                     if (lVar8 != lVar11) goto LAB_00127d7a;
                  }

               }
 else {
                  cVar4 = ( **(code**)( lVar8 + 0x128 ) )(pTVar21);
                  if (cVar4 != '\0') goto LAB_00128895;
               }

               LAB_001285f6:if (*(code**)( *(long*)param_3 + 0x68 ) == TVariable::getWritableType) {
                  pTVar21 = param_3 + 0x28;
               }
 else {
                  pTVar21 = (TVariable*)( **(code**)( *(long*)param_3 + 0x68 ) )(param_3);
               }

               if (*(code**)( *(long*)pTVar21 + 0x50 ) == TType::getQualifier) {
                  pTVar21 = pTVar21 + 0x10;
               }
 else {
                  pTVar21 = (TVariable*)( **(code**)( *(long*)pTVar21 + 0x50 ) )();
               }

               pTVar21[0xf] = ( TVariable )((byte)pTVar21[0xf] | 2);
               lVar8 = 0;
               goto LAB_00128000;
            }

         }
 else {
            cVar4 = ( **(code**)( lVar8 + 0x140 ) )(pTVar21);
            if (cVar4 == '\0') {
               lVar8 = *(long*)pTVar21;
               goto LAB_001285d0;
            }

         }

         LAB_00127d7a:lVar8 = 0;
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "null initializers can\'t be used on opaque values", &_LC1021, &_LC1);
         goto LAB_00128000;
      }

   }
 else {
      if (bVar19 == 5) {
         if (( *(int*)( this + 0xc ) == 8 ) || ( *(int*)( this + 0x18 ) < 0x78 )) goto LAB_00127f42;
         goto LAB_00127c70;
      }

      if (bVar19 != 7) {
         LAB_00127f42:pcVar12 = *(code**)( *(long*)this + 0x158 );
         if (*(code**)( *(long*)param_3 + 0x60 ) == TVariable::getType) {
            pTVar21 = param_3 + 0x28;
         }
 else {
            pTVar21 = (TVariable*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
         }

         switch ((byte)pTVar21[0x18] & 0x7f) {
            case 0:
        pcVar18 = "temp";
        break;
            case 1:
        pcVar18 = "global";
        break;
            case 2:
        pcVar18 = "const";
        break;
            case 3:
            case 0x10:
        pcVar18 = "in";
        break;
            case 4:
            case 0x11:
        pcVar18 = "out";
        break;
            case 5:
        pcVar18 = "uniform";
        break;
            case 6:
        pcVar18 = "buffer";
        break;
            case 7:
        pcVar18 = "shared";
        break;
            case 8:
        pcVar18 = "spirv_storage_class";
        break;
            case 9:
        pcVar18 = "rayPayloadNV";
        break;
            case 10:
        pcVar18 = "rayPayloadInNV";
        break;
            case 0xb:
        pcVar18 = "hitAttributeNV";
        break;
            case 0xc:
        pcVar18 = "callableDataNV";
        break;
            case 0xd:
        pcVar18 = "callableDataInNV";
        break;
            case 0xe:
        pcVar18 = "hitObjectAttributeNV";
        break;
            case 0xf:
        pcVar18 = "taskPayloadSharedEXT";
        break;
            case 0x12:
        pcVar18 = "inout";
        break;
            case 0x13:
        pcVar18 = "const (read only)";
        break;
            case 0x14:
        pcVar18 = "gl_VertexId";
        break;
            case 0x15:
        pcVar18 = "gl_InstanceId";
        break;
            case 0x16:
        pcVar18 = "gl_Position";
        break;
            case 0x17:
        pcVar18 = "gl_PointSize";
        break;
            case 0x18:
        pcVar18 = "gl_ClipVertex";
        break;
            case 0x19:
        pcVar18 = "gl_FrontFacing";
        break;
            case 0x1a:
        pcVar18 = "gl_FragCoord";
        break;
            case 0x1b:
        pcVar18 = "gl_PointCoord";
        break;
            case 0x1c:
        pcVar18 = "fragColor";
        break;
            case 0x1d:
        pcVar18 = "gl_FragDepth";
        break;
            case 0x1e:
        pcVar18 = "gl_FragStencilRefARB";
        break;
            default:
        pcVar18 = "unknown qualifier";
         }

         ( *pcVar12 )(this, param_1, " cannot initialize this type of qualifier ", pcVar18, &_LC1);
         lVar8 = 0;
         goto LAB_00128000;
      }

      if (bVar23) {
         glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar20, 8, (char*)0x0, "GL_EXT_null_initializer");
         glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar20, -9, (char*)0x0, "GL_EXT_null_initializer");
         goto LAB_00127c79;
      }

      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "initializer can only be a null initializer (\'{}\')", "shared", &_LC1);
   }

   if (*(code**)( *(long*)param_3 + 0x60 ) == TVariable::getType) {
      pTVar21 = param_3 + 0x28;
   }
 else {
      pTVar21 = (TVariable*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
   }

   arrayObjectCheck((TSourceLoc*)this, (TType*)param_1, (char*)pTVar21);
   local_178 = local_178 & 0xfffffff0;
   local_198 = &PTR__TType_00167f00;
   local_110 = (undefined1[16])0x0;
   local_158 = local_158 & 0xffffff00;
   local_190 = CONCAT22(local_190._2_2_, 0x100) & 0xf800ffff;
   local_138 = (undefined1[16])0x0;
   uStack_154 = 0xfffff800;
   uStack_150 = 0;
   uStack_140 = uStack_140 & 0xffffffffffff0000;
   local_128 = (undefined1[16])0x0;
   uStack_174 = (undefined4)_LC291;
   uStack_170 = ( undefined4 )((ulong)_LC291 >> 0x20);
   uStack_14c = 0xffffffff;
   local_118 = local_118 & 0x9fc00000;
   local_188 = 0;
   local_148 = 0;
   uStack_15c = 0;
   uVar9 = ( (ulong)uStack_16c._1_3_ & 0xffc000 | 0xffff001f80 ) << 8 | 0xffff000000004fff;
   uStack_16c = (uint)uVar9;
   uStack_168 = ( undefined4 )(uVar9 >> 0x20);
   uVar9 = CONCAT44(uStack_160, uStack_164) & 0xfe07ff00ffffffff | 0x1ffffff7fffffff;
   uStack_164 = (undefined4)uVar9;
   uStack_160 = ( uint )(uVar9 >> 0x20);
   uStack_180 = uStack_180 & 0x8000000400000000;
   if (*(code**)( *(long*)param_3 + 0x60 ) == TVariable::getType) {
      pTVar21 = param_3 + 0x28;
   }
 else {
      pTVar21 = (TVariable*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
   }

   uVar3 = local_190;
   local_118 = *(uint*)( pTVar21 + 0x80 );
   uStack_16c = ( uint )(( ulong ) * (undefined8*)( pTVar21 + 0x28 ) >> 0x20);
   local_190._0_2_ = CONCAT11((byte)pTVar21[9] & 0xf | (byte)pTVar21[9] & 0xf0, pTVar21[8]);
   local_190._3_1_ = SUB41(uVar3, 3);
   local_128 = *(undefined1(*) [16])( pTVar21 + 0x70 );
   local_138 = *(undefined1(*) [16])( pTVar21 + 0x60 );
   local_110 = *(undefined1(*) [16])( pTVar21 + 0x88 );
   local_190._0_3_ = CONCAT12((byte)pTVar21[10] & 0xf | (byte)pTVar21[10] & 0x10 | (byte)pTVar21[10] & 0x20 | (byte)pTVar21[10] & 0x40, (undefined2)local_190);
   uVar5 = local_190._2_2_ & 0xfc7f | *(ushort*)( pTVar21 + 10 ) & 0x380;
   local_190 = CONCAT22(uVar5, (undefined2)local_190);
   uVar7 = local_190;
   local_190._3_1_ = ( byte )(uVar5 >> 8);
   local_178 = ( uint ) * (undefined8*)( pTVar21 + 0x20 ) & 0xfffffff0;
   local_158._1_3_ = ( uint3 )(( ulong ) * (undefined8*)( pTVar21 + 0x40 ) >> 8);
   local_158 = (uint)local_158._1_3_ << 8;
   uStack_154 = 0xfffff800;
   local_148 = 0;
   local_190._0_3_ = (undefined3)uVar7;
   local_190 = CONCAT13(local_190._3_1_ & 0xfb | (byte)pTVar21[0xb] & 4, (undefined3)local_190);
   local_188 = 0;
   uStack_174 = (undefined4)_LC291;
   uStack_170 = ( undefined4 )((ulong)_LC291 >> 0x20);
   uStack_16c = uStack_16c & 0xffc00000 | 0x1fcfff;
   uStack_168 = ( undefined4 )(*(ulong*)( pTVar21 + 0x30 ) | 0x7fffffffffffffff);
   uStack_164 = ( undefined4 )(( *(ulong*)( pTVar21 + 0x30 ) | 0x7fffffffffffffff ) >> 0x20);
   uStack_160 = ( uint ) * (undefined8*)( pTVar21 + 0x38 ) & 0xfe000000 | 0x1ffffff;
   uStack_15c = 0;
   uStack_150 = 0;
   uStack_14c = 0xffffffff;
   uStack_140 = *(ulong*)( pTVar21 + 0x58 ) & 0xffffffffffff0000;
   uStack_180 = *(ulong*)( pTVar21 + 0x18 ) & 0x800000141fff0000;
   plVar10 = (long*)convertInitializerList(this, param_1, (TType*)&local_198, param_2);
   if (plVar10 == (long*)0x0) {
      if (bVar19 != 2) {
         LAB_00127c64:lVar8 = 0;
         goto LAB_00128000;
      }

      LAB_001284d9:pcVar12 = *(code**)( *(long*)param_3 + 0x68 );
      if (pcVar12 == TVariable::getWritableType) {
         LAB_001284f0:pTVar21 = param_3 + 0x28;
      }
 else {
         LAB_001283e0:pTVar21 = (TVariable*)( *pcVar12 )(param_3);
      }

   }
 else {
      if (*(code**)( *plVar10 + 0xf0 ) == TIntermTyped::getType) {
         plVar16 = plVar10 + 4;
      }
 else {
         plVar16 = (long*)( **(code**)( *plVar10 + 0xf0 ) )(plVar10);
      }

      pcVar12 = *(code**)( *plVar16 + 0xf0 );
      if (pcVar12 == TType::isSizedArray) {
         pcVar12 = *(code**)( *plVar16 + 0xe8 );
         if (pcVar12 == TType::isArray) {
            lVar8 = plVar16[0xc];
            if (lVar8 != 0) {
               LAB_00127e08:if (**(int**)( *(long*)( lVar8 + 8 ) + 8 ) != 0) goto LAB_00127e1a;
            }

         }
 else {
            cVar4 = ( *pcVar12 )();
            if (cVar4 != '\0') {
               lVar8 = plVar16[0xc];
               goto LAB_00127e08;
            }

         }

         LAB_00127964:pcVar12 = *(code**)( *plVar10 + 0xf0 );
         if (pcVar12 != TIntermTyped::getType) goto LAB_00127efc;
         LAB_00127977:plVar16 = plVar10 + 4;
      }
 else {
         cVar4 = ( *pcVar12 )();
         if (cVar4 == '\0') goto LAB_00127964;
         LAB_00127e1a:pTVar21 = param_3 + 0x28;
         if (*(code**)( *(long*)param_3 + 0x60 ) != TVariable::getType) {
            pTVar21 = (TVariable*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
         }

         pcVar12 = *(code**)( *(long*)pTVar21 + 0xf8 );
         if (pcVar12 == TType::isUnsizedArray) {
            pcVar12 = *(code**)( *(long*)pTVar21 + 0xe8 );
            if (pcVar12 == TType::isArray) {
               lVar8 = *(long*)( pTVar21 + 0x60 );
               if (lVar8 != 0) {
                  LAB_00127e6c:if (**(int**)( *(long*)( lVar8 + 8 ) + 8 ) == 0) goto LAB_00127e80;
               }

            }
 else {
               cVar4 = ( *pcVar12 )();
               if (cVar4 != '\0') {
                  lVar8 = *(long*)( pTVar21 + 0x60 );
                  goto LAB_00127e6c;
               }

            }

            goto LAB_00127964;
         }

         cVar4 = ( *pcVar12 )();
         if (cVar4 == '\0') goto LAB_00127964;
         LAB_00127e80:pTVar21 = param_3 + 0x28;
         if (*(code**)( *(long*)param_3 + 0x68 ) != TVariable::getWritableType) {
            pTVar21 = (TVariable*)( **(code**)( *(long*)param_3 + 0x68 ) )(param_3);
         }

         if (*(code**)( *plVar10 + 0xf0 ) == TIntermTyped::getType) {
            plVar16 = plVar10 + 4;
         }
 else {
            plVar16 = (long*)( **(code**)( *plVar10 + 0xf0 ) )(plVar10);
         }

         if (*(code**)( *plVar16 + 0x78 ) == TType::getOuterArraySize) {
            uVar7 = **(undefined4**)( *(long*)( plVar16[0xc] + 8 ) + 8 );
         }
 else {
            uVar7 = ( **(code**)( *plVar16 + 0x78 ) )();
         }

         lVar8 = *(long*)( pTVar21 + 0x60 );
         **(undefined4**)( *(long*)( lVar8 + 8 ) + 8 ) = uVar7;
         lVar11 = *plVar10;
         *(undefined1*)( lVar8 + 0x14 ) = 0;
         pcVar12 = *(code**)( lVar11 + 0xf0 );
         if (pcVar12 == TIntermTyped::getType) goto LAB_00127977;
         LAB_00127efc:plVar16 = (long*)( *pcVar12 )(plVar10);
      }

      if (( ( plVar16[0xc] != 0 ) && ( lVar8 = *(long*)( plVar16[0xc] + 8 ) ),lVar8 != 0 )) {
         if (*(code**)( *(long*)param_3 + 0x60 ) == TVariable::getType) {
            pTVar21 = param_3 + 0x28;
         }
 else {
            pTVar21 = (TVariable*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
         }

         if (( ( *(long*)( pTVar21 + 0x60 ) != 0 ) && ( lVar8 = *(long*)( *(long*)( pTVar21 + 0x60 ) + 8 ) ),lVar8 != 0 )) {
            if (*(code**)( *plVar10 + 0xf0 ) == TIntermTyped::getType) {
               plVar16 = plVar10 + 4;
            }
 else {
               plVar16 = (long*)( **(code**)( *plVar10 + 0xf0 ) )(plVar10);
            }

            if (*(code**)( *plVar16 + 0x98 ) == TType::getArraySizes) {
               lVar8 = plVar16[0xc];
            }
 else {
               lVar8 = ( **(code**)( *plVar16 + 0x98 ) )();
            }

            lVar8 = *(long*)( lVar8 + 8 );
            if (lVar8 == 0) {
               iVar22 = 0;
            }
 else {
               iVar22 = (int)( *(long*)( lVar8 + 0x10 ) - *(long*)( lVar8 + 8 ) >> 4 );
            }

            if (*(code**)( *(long*)param_3 + 0x60 ) == TVariable::getType) {
               pTVar21 = param_3 + 0x28;
            }
 else {
               pTVar21 = (TVariable*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
            }

            if (*(code**)( *(long*)pTVar21 + 0x98 ) == TType::getArraySizes) {
               lVar8 = *(long*)( pTVar21 + 0x60 );
            }
 else {
               lVar8 = ( **(code**)( *(long*)pTVar21 + 0x98 ) )();
            }

            lVar8 = *(long*)( lVar8 + 8 );
            if (lVar8 == 0) {
               iVar6 = 0;
            }
 else {
               iVar6 = (int)( *(long*)( lVar8 + 0x10 ) - *(long*)( lVar8 + 8 ) >> 4 );
            }

            if (iVar6 == iVar22) {
               pTVar21 = param_3 + 0x28;
               lVar8 = 0x10;
               iVar22 = 1;
               while (true) {
                  pTVar14 = pTVar21;
                  if (*(code**)( *(long*)param_3 + 0x60 ) != TVariable::getType) {
                     pTVar14 = (TVariable*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
                  }

                  if (*(code**)( *(long*)pTVar14 + 0x98 ) == TType::getArraySizes) {
                     lVar11 = *(long*)( pTVar14 + 0x60 );
                  }
 else {
                     lVar11 = ( **(code**)( *(long*)pTVar14 + 0x98 ) )();
                  }

                  lVar11 = *(long*)( lVar11 + 8 );
                  if (( lVar11 == 0 ) || ( (int)( *(long*)( lVar11 + 0x10 ) - *(long*)( lVar11 + 8 ) >> 4 ) <= iVar22 )) break;
                  pTVar14 = pTVar21;
                  if (*(code**)( *(long*)param_3 + 0x60 ) != TVariable::getType) {
                     pTVar14 = (TVariable*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
                  }

                  if (*(code**)( *(long*)pTVar14 + 0x98 ) == TType::getArraySizes) {
                     lVar11 = *(long*)( pTVar14 + 0x60 );
                  }
 else {
                     lVar11 = ( **(code**)( *(long*)pTVar14 + 0x98 ) )();
                  }

                  if (*(int*)( *(long*)( *(long*)( lVar11 + 8 ) + 8 ) + lVar8 ) == 0) {
                     pTVar14 = pTVar21;
                     if (*(code**)( *(long*)param_3 + 0x68 ) != TVariable::getWritableType) {
                        pTVar14 = (TVariable*)( **(code**)( *(long*)param_3 + 0x68 ) )(param_3);
                     }

                     if (*(code**)( *(long*)pTVar14 + 0xa0 ) == TType::getArraySizes) {
                        lVar11 = *(long*)( pTVar14 + 0x60 );
                     }
 else {
                        lVar11 = ( **(code**)( *(long*)pTVar14 + 0xa0 ) )();
                     }

                     plVar16 = plVar10 + 4;
                     if (*(code**)( *plVar10 + 0xf0 ) != TIntermTyped::getType) {
                        plVar16 = (long*)( **(code**)( *plVar10 + 0xf0 ) )(plVar10);
                     }

                     if (*(code**)( *plVar16 + 0x98 ) == TType::getArraySizes) {
                        lVar15 = plVar16[0xc];
                     }
 else {
                        lVar15 = ( **(code**)( *plVar16 + 0x98 ) )();
                     }

                     *(undefined4*)( *(long*)( *(long*)( lVar11 + 8 ) + 8 ) + lVar8 ) = *(undefined4*)( *(long*)( *(long*)( lVar15 + 8 ) + 8 ) + lVar8 );
                  }

                  iVar22 = iVar22 + 1;
                  lVar8 = lVar8 + 0x10;
               }
;
            }

         }

      }

      bVar19 = (byte)TVar1 & 0x7f;
      lVar8 = *plVar10;
      pcVar12 = *(code**)( lVar8 + 0xf0 );
      if (bVar19 != 5) {
         iVar22 = (int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 );
         if (bVar19 == 2) {
            if (iVar22 < 5) {
               if (pcVar12 == TIntermTyped::getType) {
                  plVar16 = plVar10 + 4;
               }
 else {
                  plVar16 = (long*)( *pcVar12 )(plVar10);
               }

               if (*(code**)( *plVar16 + 0x58 ) == TType::getQualifier) {
                  plVar16 = plVar16 + 2;
               }
 else {
                  plVar16 = (long*)( **(code**)( *plVar16 + 0x58 ) )();
               }

               if (( ( *(byte*)( plVar16 + 1 ) & 0x7f ) == 2 ) || ( ( *(byte*)( (long)plVar16 + 0xc ) & 1 ) != 0 )) {
                  lVar8 = *plVar10;
                  goto LAB_001283f3;
               }

               pcVar12 = *(code**)( *(long*)this + 0x158 );
               if (*(code**)( *(long*)param_3 + 0x60 ) == TVariable::getType) {
                  local_1c0 = param_3 + 0x28;
               }
 else {
                  local_1c0 = (TVariable*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
               }

               local_98 = glslang::GetThreadPoolAllocator();
               local_90 = local_80;
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
               local_c8 = glslang::GetThreadPoolAllocator();
               local_c0 = local_b0;
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_c8, &_LC1, &_LC1);
               TType::getCompleteString(&local_68, local_1c0, *(undefined1*)( *(long*)( this + 0x38 ) + 0x26f ), 1, 1, 1, &local_c8, &local_98);
               ( *pcVar12 )(this, param_1, "global const initializers must be constant", &_LC1026, &_LC1025, local_60);
               pcVar12 = *(code**)( *(long*)param_3 + 0x68 );
               if (pcVar12 != TVariable::getWritableType) goto LAB_001283e0;
               goto LAB_001284f0;
            }

            LAB_001283f3:if (*(code**)( lVar8 + 0xf0 ) == TIntermTyped::getType) {
               plVar16 = plVar10 + 4;
            }
 else {
               plVar16 = (long*)( **(code**)( lVar8 + 0xf0 ) )(plVar10);
            }

            if (*(code**)( *plVar16 + 0x58 ) == TType::getQualifier) {
               plVar16 = plVar16 + 2;
            }
 else {
               plVar16 = (long*)( **(code**)( *plVar16 + 0x58 ) )();
            }

            if (( ( *(byte*)( plVar16 + 1 ) & 0x7f ) == 2 ) || ( ( *(byte*)( (long)plVar16 + 0xc ) & 1 ) != 0 )) goto LAB_00127b69;
            glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar20, (char*)0xfffffff7);
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar20, -9, (char*)0x1a4, "GL_ARB_shading_language_420pack");
            if (*(code**)( *(long*)param_3 + 0x68 ) == TVariable::getWritableType) {
               pTVar21 = param_3 + 0x28;
            }
 else {
               pTVar21 = (TVariable*)( **(code**)( *(long*)param_3 + 0x68 ) )(param_3);
            }

            if (*(code**)( *(long*)pTVar21 + 0x50 ) == TType::getQualifier) {
               pTVar21 = pTVar21 + 0x10;
            }
 else {
               pTVar21 = (TVariable*)( **(code**)( *(long*)pTVar21 + 0x50 ) )();
            }

            pTVar21[8] = ( TVariable )((byte)pTVar21[8] & 0x80 | 0x13);
            lVar8 = *plVar10;
         }
 else if (iVar22 < 5) goto LAB_00127ac7;
         LAB_00127f9b:if (*(code**)( lVar8 + 0xf0 ) == TIntermTyped::getType) {
            pTVar17 = (TType*)( plVar10 + 4 );
         }
 else {
            pTVar17 = (TType*)( **(code**)( lVar8 + 0xf0 ) )(plVar10);
         }

         specializationCheck(this, param_1, pTVar17, "initializer");
         lVar11 = glslang::TIntermediate::addSymbol(*(TVariable**)( this + 0x38 ), (TSourceLoc*)param_3);
         lVar8 = glslang::TIntermediate::addAssign(*(undefined8*)( this + 0x38 ), 0x249, lVar11, plVar10, param_1);
         if (lVar8 == 0) {
            uVar2 = *(undefined1*)( *(long*)( this + 0x38 ) + 0x26f );
            local_68 = glslang::GetThreadPoolAllocator();
            local_60 = local_50;
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, &_LC1, &_LC1);
            local_98 = glslang::GetThreadPoolAllocator();
            local_90 = local_80;
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
            TType::getCompleteString(&local_c8, plVar10 + 4, uVar2, 1, 1, 1, &local_98);
            uVar2 = *(undefined1*)( *(long*)( this + 0x38 ) + 0x26f );
            local_68 = glslang::GetThreadPoolAllocator();
            local_60 = local_50;
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, &_LC1, &_LC1);
            local_98 = glslang::GetThreadPoolAllocator();
            local_90 = local_80;
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
            TType::getCompleteString(local_f8, lVar11 + 0x20, uVar2, 1, 1, 1, &local_98, &local_68);
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, &_LC1, &_LC1026, "cannot convert from \'%s\' to \'%s\'", local_c0, local_f0);
         }

         goto LAB_00128000;
      }

      if (pcVar12 == TIntermTyped::getType) {
         plVar16 = plVar10 + 4;
      }
 else {
         plVar16 = (long*)( *pcVar12 )(plVar10);
      }

      if (*(code**)( *plVar16 + 0x58 ) == TType::getQualifier) {
         plVar16 = plVar16 + 2;
      }
 else {
         plVar16 = (long*)( **(code**)( *plVar16 + 0x58 ) )();
      }

      if (( ( *(byte*)( plVar16 + 1 ) & 0x7f ) == 2 ) && ( ( *(byte*)( (long)plVar16 + 0xc ) & 1 ) == 0 )) {
         if ((int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 ) < 5) {
            lVar8 = *plVar10;
            LAB_00127ac7:if (*(code**)( lVar8 + 0xf0 ) == TIntermTyped::getType) {
               plVar16 = plVar10 + 4;
            }
 else {
               plVar16 = (long*)( **(code**)( lVar8 + 0xf0 ) )(plVar10);
            }

            if (*(code**)( *plVar16 + 0x58 ) == TType::getQualifier) {
               plVar16 = plVar16 + 2;
            }
 else {
               plVar16 = (long*)( **(code**)( *plVar16 + 0x58 ) )();
            }

            if (( ( ( *(byte*)( plVar16 + 1 ) & 0x7f ) != 2 ) && ( ( *(byte*)( (long)plVar16 + 0xc ) & 1 ) == 0 ) ) && ( *(int*)( this + 0xc ) == 8 )) {
               if (( ( (byte)this[0xd0] & 1 ) == 0 ) || ( cVar4 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_EXT_shader_non_constant_global_initializers") ),cVar4 != '\0') {
                  glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar20, 8, (char*)0x0, "GL_EXT_shader_non_constant_global_initializers");
               }
 else {
                  ( **(code**)( *(long*)this + 0x160 ) )(this, param_1, "not allowed in this version", "non-constant global initializer (needs GL_EXT_shader_non_constant_global_initializers)", &_LC1);
               }

            }

            if (bVar19 != 5) {
               lVar8 = *plVar10;
               goto LAB_00127f9b;
            }

         }

         LAB_00127b69:uVar13 = *(undefined8*)( this + 0x38 );
         pTVar21 = param_3 + 0x28;
         if (*(code**)( *(long*)param_3 + 0x60 ) != TVariable::getType) {
            pTVar21 = (TVariable*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
         }

         plVar10 = (long*)glslang::TIntermediate::addConversion(uVar13, 0x249, pTVar21, plVar10);
         if (plVar10 != (long*)0x0) {
            if (*(code**)( *plVar10 + 0xf0 ) == TIntermTyped::getType) {
               plVar16 = plVar10 + 4;
            }
 else {
               plVar16 = (long*)( **(code**)( *plVar10 + 0xf0 ) )(plVar10);
            }

            if (*(code**)( *plVar16 + 0x58 ) == TType::getQualifier) {
               plVar16 = plVar16 + 2;
            }
 else {
               plVar16 = (long*)( **(code**)( *plVar16 + 0x58 ) )();
            }

            if (( ( *(byte*)( plVar16 + 1 ) & 0x7f ) == 2 ) || ( ( *(byte*)( (long)plVar16 + 0xc ) & 1 ) != 0 )) {
               if (*(code**)( *plVar10 + 0xf0 ) == TIntermTyped::getType) {
                  pTVar17 = (TType*)( plVar10 + 4 );
               }
 else {
                  pTVar17 = (TType*)( **(code**)( *plVar10 + 0xf0 ) )(plVar10);
               }

               if (*(code**)( *(long*)param_3 + 0x60 ) == TVariable::getType) {
                  pTVar21 = param_3 + 0x28;
               }
 else {
                  pTVar21 = (TVariable*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
               }

               cVar4 = TType::operator ==((TType*)pTVar21, pTVar17);
               if (cVar4 != '\0') {
                  lVar8 = ( **(code**)( *plVar10 + 0x28 ) )(plVar10);
                  if (lVar8 == 0) {
                     if (*(code**)( *(long*)param_3 + 0x68 ) == TVariable::getWritableType) {
                        pTVar21 = param_3 + 0x28;
                     }
 else {
                        pTVar21 = (TVariable*)( **(code**)( *(long*)param_3 + 0x68 ) )(param_3);
                     }

                     if (*(code**)( *(long*)pTVar21 + 0x50 ) == TType::getQualifier) {
                        pTVar21 = pTVar21 + 0x10;
                     }
 else {
                        pTVar21 = (TVariable*)( **(code**)( *(long*)pTVar21 + 0x50 ) )();
                     }

                     *(ulong*)( pTVar21 + 8 ) = *(ulong*)( pTVar21 + 8 ) & 0xfffffffeffffff80 | 0x100000002;
                     if (*(code**)( *(long*)param_3 + 0xd0 ) == TVariable::setConstSubtree) {
                        *(long**)( param_3 + 0xd8 ) = plVar10;
                        lVar8 = 0;
                     }
 else {
                        lVar8 = 0;
                        ( **(code**)( *(long*)param_3 + 0xd0 ) )(param_3, plVar10);
                     }

                     goto LAB_00128000;
                  }

                  pcVar12 = *(code**)( *(long*)param_3 + 200 );
                  lVar11 = ( **(code**)( *plVar10 + 0x28 ) )(plVar10);
                  if (pcVar12 != TVariable::setConstArray) {
                     lVar8 = 0;
                     ( *pcVar12 )(param_3, lVar11 + 0xb8);
                     goto LAB_00128000;
                  }

                  *(undefined8*)( param_3 + 0xd0 ) = *(undefined8*)( lVar11 + 0xc0 );
                  goto LAB_00127c64;
               }

            }

         }

         pcVar12 = *(code**)( *(long*)this + 0x158 );
         if (*(code**)( *(long*)param_3 + 0x60 ) == TVariable::getType) {
            pTVar21 = param_3 + 0x28;
         }
 else {
            pTVar21 = (TVariable*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
         }

         uVar13 = GetStorageQualifierString((byte)pTVar21[0x18] & 0x7f);
         ( *pcVar12 )(this, param_1, "non-matching or non-convertible constant type for const initializer", uVar13, &_LC1);
         goto LAB_001284d9;
      }

      pcVar12 = *(code**)( *(long*)this + 0x158 );
      if (*(code**)( *(long*)param_3 + 0x60 ) == TVariable::getType) {
         local_1c0 = param_3 + 0x28;
      }
 else {
         local_1c0 = (TVariable*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
      }

      local_98 = glslang::GetThreadPoolAllocator();
      local_90 = local_80;
      std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
      local_c8 = glslang::GetThreadPoolAllocator();
      local_c0 = local_b0;
      std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_c8, &_LC1, &_LC1);
      TType::getCompleteString(&local_68, local_1c0, *(undefined1*)( *(long*)( this + 0x38 ) + 0x26f ), 1, 1, 1, &local_c8, &local_98);
      ( *pcVar12 )(this, param_1, "uniform initializers must be constant", &_LC1026, &_LC1025, local_60);
      pTVar21 = param_3 + 0x28;
      pcVar12 = *(code**)( *(long*)param_3 + 0x68 );
      if (pcVar12 != TVariable::getWritableType) goto LAB_001283e0;
   }

   if (*(code**)( *(long*)pTVar21 + 0x50 ) == TType::getQualifier) {
      pTVar21 = pTVar21 + 0x10;
   }
 else {
      pTVar21 = (TVariable*)( **(code**)( *(long*)pTVar21 + 0x50 ) )();
   }

   uVar13 = _LC291;
   pTVar21[0x30] = (TVariable)0x0;
   pTVar21[0x10] = ( TVariable )((byte)pTVar21[0x10] & 0xf0);
   *(undefined8*)( pTVar21 + 0x14 ) = uVar13;
   *(long*)( pTVar21 + 0x38 ) = -0x100000000;
   lVar8 = 0;
   *(uint*)( pTVar21 + 0x1c ) = *(uint*)( pTVar21 + 0x1c ) & 0xffc00000 | 0x1fcfff;
   *(ulong*)( pTVar21 + 0x20 ) = *(ulong*)( pTVar21 + 0x20 ) | 0x7fffffffffffffff;
   *(undefined4*)( pTVar21 + 0x34 ) = 0xfffff800;
   *(long*)( pTVar21 + 0x40 ) = 0;
   *(undefined2*)( pTVar21 + 0x48 ) = 0;
   *(ulong*)( pTVar21 + 0x28 ) = ( ulong )(( uint ) * (long*)( pTVar21 + 0x28 ) & 0xfe000000) | 0x1ffffff;
   *(long*)pTVar21 = 0;
   *(ulong*)( pTVar21 + 8 ) = *(ulong*)( pTVar21 + 8 ) & 0x800000141fff0000;
   LAB_00128000:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   return lVar8;
}
/* glslang::TParseContext::TParseContext(glslang::TSymbolTable&, glslang::TIntermediate&, bool, int,
   EProfile, glslang::SpvVersion const&, EShLanguage, TInfoSink&, bool, EShMessages,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const*)
    */void glslang::TParseContext::TParseContext(TParseContext *this, undefined8 param_1, undefined8 param_2, TParseContext param_3, undefined4 param_4, undefined4 param_6, uint *param_7, uint param_8, char *param_9, TParseContext param_10, undefined4 param_11, basic_string *param_12) {
   uint uVar1;
   undefined8 uVar2;
   undefined8 uVar3;
   *(code**)this = glslang::TIntermediate::traverseLValueBase;
   *(undefined4*)( this + 0xc ) = param_6;
   *(undefined4*)( this + 0x18 ) = param_4;
   uVar3 = *(undefined8*)param_7;
   uVar2 = *(undefined8*)( param_7 + 2 );
   this[8] = param_10;
   uVar1 = param_7[4];
   *(undefined8*)( this + 0x20 ) = uVar3;
   *(undefined8*)( this + 0x28 ) = uVar2;
   *(uint*)( this + 0x30 ) = uVar1;
   *(char**)( this + 0x10 ) = param_9;
   *(uint*)( this + 0x1c ) = param_8;
   *(undefined8*)( this + 0x38 ) = param_2;
   uVar3 = glslang::GetThreadPoolAllocator();
   *(undefined4*)( this + 0x50 ) = 0;
   *(undefined8*)( this + 0x40 ) = uVar3;
   *(undefined8*)( this + 0x58 ) = 0;
   *(TParseContext**)( this + 0x60 ) = this + 0x50;
   *(TParseContext**)( this + 0x68 ) = this + 0x50;
   *(undefined8*)( this + 0x70 ) = 0;
   uVar3 = glslang::GetThreadPoolAllocator();
   *(undefined4*)( this + 0x88 ) = 0;
   *(undefined8*)( this + 0x78 ) = uVar3;
   *(undefined8*)( this + 0x90 ) = 0;
   *(TParseContext**)( this + 0x98 ) = this + 0x88;
   *(TParseContext**)( this + 0xa0 ) = this + 0x88;
   *(undefined8*)( this + 0xa8 ) = 0;
   uVar3 = glslang::GetThreadPoolAllocator();
   *(undefined8*)( this + 0xb8 ) = 0;
   *(undefined8*)( this + 0xb0 ) = uVar3;
   *(code**)this = glslang::TIntermediate::addConversion;
   *(undefined4*)( this + 0xd0 ) = param_11;
   *(undefined8*)( this + 0xe8 ) = param_1;
   *(undefined8*)( this + 0xc0 ) = 0;
   *(undefined8*)( this + 200 ) = 0;
   *(undefined4*)( this + 0xd4 ) = 0;
   *(undefined8*)( this + 0xd8 ) = 0;
   *(undefined**)( this + 0xe0 ) = &_LC1034;
   uVar3 = glslang::GetThreadPoolAllocator();
   this[0x131] = (TParseContext)0x0;
   *(undefined8*)( this + 0xf0 ) = uVar3;
   for (int i = 0; i < 3; i++) {
      *(undefined8*)( this + ( 8*i + 248 ) ) = 0;
   }

   *(undefined4*)( this + 0x120 ) = 0;
   *(undefined8*)( this + 0x128 ) = 0;
   *(undefined1(*) [16])( this + 0x110 ) = (undefined1[16])0x0;
   uVar3 = glslang::GetThreadPoolAllocator();
   *(undefined8*)( this + 0x150 ) = 0;
   *(undefined8*)( this + 0x138 ) = uVar3;
   *(TParseContext**)( this + 0x148 ) = this + 0x140;
   *(TParseContext**)( this + 0x140 ) = this + 0x140;
   uVar3 = glslang::GetThreadPoolAllocator();
   *(undefined8*)( this + 0x170 ) = 0;
   *(undefined8*)( this + 0x158 ) = uVar3;
   *(TParseContext**)( this + 0x168 ) = this + 0x160;
   *(TParseContext**)( this + 0x160 ) = this + 0x160;
   *(undefined2*)( this + 0x178 ) = 1;
   uVar3 = glslang::GetThreadPoolAllocator();
   this[0x1c0] = (TParseContext)0x0;
   *(undefined8*)( this + 0x180 ) = uVar3;
   *(undefined4*)( this + 400 ) = 0;
   *(undefined8*)( this + 0x198 ) = 0;
   *(TParseContext**)( this + 0x1a0 ) = this + 400;
   *(TParseContext**)( this + 0x1a8 ) = this + 400;
   *(undefined8*)( this + 0x1b0 ) = 0;
   *(undefined8*)( this + 0x1b8 ) = 0;
   this[0x1c1] = param_3;
   uVar3 = glslang::GetThreadPoolAllocator();
   *(undefined8*)( this + 0x1d0 ) = 0;
   *(undefined8*)( this + 0x1c8 ) = uVar3;
   for (int i = 0; i < 4; i++) {
      *(undefined8*)( this + ( 8*i + 472 ) ) = 0;
   }

   *(TParseContext**)( this + 0x3a0 ) = this + 0x390;
   uVar3 = glslang::GetThreadPoolAllocator();
   this[0x3c0] = (TParseContext)0x0;
   *(undefined8*)( this + 0x3a8 ) = uVar3;
   *(TParseContext**)( this + 0x3b0 ) = this + 0x3c0;
   uVar3 = _LC1035;
   *(undefined8*)( this + 0x3b8 ) = 0;
   for (int i = 0; i < 5; i++) {
      *(undefined8*)( this + ( 32*i + 992 ) ) = 0;
      *(undefined8*)( this + ( 32*i + 1000 ) ) = 0;
   }

   *(undefined8*)( this + 0x470 ) = 0;
   *(undefined8*)( this + 0x478 ) = uVar3;
   for (int i = 0; i < 5; i++) {
      *(undefined1(*) [16])( this + ( 32*i + 976 ) ) = (undefined1[16])0;
   }

   uVar3 = glslang::GetThreadPoolAllocator();
   *(undefined4*)( this + 0x498 ) = 0;
   *(undefined8*)( this + 0x488 ) = uVar3;
   *(undefined8*)( this + 0x4a0 ) = 0;
   *(TParseContext**)( this + 0x4a8 ) = this + 0x498;
   *(TParseContext**)( this + 0x4b0 ) = this + 0x498;
   *(undefined8*)( this + 0x4b8 ) = 0;
   *(undefined4*)( this + 0x4c0 ) = 0x3f;
   uVar3 = glslang::GetThreadPoolAllocator();
   uVar1 = *param_7;
   *(undefined4*)( this + 0x4d8 ) = 0;
   *(undefined8*)( this + 0x4c8 ) = uVar3;
   *(undefined8*)( this + 0x4e0 ) = 0;
   *(TParseContext**)( this + 0x4e8 ) = this + 0x4d8;
   *(TParseContext**)( this + 0x4f0 ) = this + 0x4d8;
   *(undefined8*)( this + 0x4f8 ) = 0;
   if (0x102ff < uVar1) {
      *(undefined1*)( *(long*)( this + 0x38 ) + 0x271 ) = 1;
   }

   if (param_12 != (basic_string*)0x0) {
      std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( this + 0x3a8 ), param_12);
   }

   this[0x500] = (TParseContext)0x0;
   *(undefined***)this = &PTR__TParseContext_00168190;
   *(TParseContext**)( this + 0x768 ) = this + 0x758;
   *(undefined8*)( this + 0x508 ) = 0;
   *(undefined***)( this + 0x7370 ) = &PTR__TPrecisionManager_00168170;
   *(undefined4*)( this + 0x7378 ) = 0;
   uVar3 = glslang::GetThreadPoolAllocator();
   this[0x7528] = (TParseContext)0x0;
   *(undefined8*)( this + 0x7510 ) = uVar3;
   *(TParseContext**)( this + 0x7518 ) = this + 0x7528;
   *(undefined8*)( this + 0x7520 ) = 0;
   *(undefined8*)( this + 0x7538 ) = 0;
   this[0x7540] = (TParseContext)0x0;
   *(undefined4*)( this + 0x7550 ) = 0;
   *(undefined8*)( this + 0x7558 ) = 0;
   *(TParseContext**)( this + 0x7560 ) = this + 0x7550;
   *(TParseContext**)( this + 0x7568 ) = this + 0x7550;
   *(undefined8*)( this + 0x7570 ) = 0;
   uVar3 = glslang::GetThreadPoolAllocator();
   *(undefined8*)( this + 0x7580 ) = 0;
   *(undefined8*)( this + 0x7578 ) = uVar3;
   *(TParseContext**)( this + 0x75b0 ) = this + 0x75a0;
   *(TParseContext**)( this + 0x75b8 ) = this + 0x75a0;
   *(undefined8*)( this + 0x7588 ) = 0;
   *(undefined8*)( this + 0x7590 ) = 0;
   *(undefined4*)( this + 0x75a0 ) = 0;
   *(undefined8*)( this + 0x75a8 ) = 0;
   *(undefined8*)( this + 0x75c0 ) = 0;
   *(undefined4*)( this + 0x75d0 ) = 0;
   *(undefined8*)( this + 0x75d8 ) = 0;
   *(TParseContext**)( this + 0x75e0 ) = this + 0x75d0;
   *(TParseContext**)( this + 0x75e8 ) = this + 0x75d0;
   *(undefined8*)( this + 0x75f0 ) = 0;
   uVar3 = glslang::GetThreadPoolAllocator();
   *(undefined8*)( this + 0x7600 ) = 0;
   *(undefined8*)( this + 0x75f8 ) = uVar3;
   *(undefined8*)( this + 0x7608 ) = 0;
   *(undefined8*)( this + 0x7610 ) = 0;
   if (*(int*)( this + 0xc ) == 8) {
      this[0x7378] = (TParseContext)0x1;
   }
 else if (( ( 0 < (int)param_7[2] ) && ( this[0x7378] = (TParseContext)0x1 ),param_3 != (TParseContext)0x1 )) {
      this[0x7379] = (TParseContext)0x1;
   }

   setPrecisionDefaults(this);
   uVar3 = _LC291;
   uVar1 = *param_7;
   this[0x7400] = (TParseContext)0x0;
   *(undefined4*)( this + 0x7404 ) = 0xfffff800;
   *(uint*)( this + 0x73ec ) = *(uint*)( this + 0x73ec ) & 0xffc00000 | 0x1fcfff;
   *(undefined8*)( this + 0x73e4 ) = uVar3;
   *(undefined8*)( this + 0x7408 ) = 0xffffffff00000000;
   *(ulong*)( this + 0x73f0 ) = *(ulong*)( this + 0x73f0 ) & 0x8000000000000000 | 0x7fffffffffffffff;
   *(undefined8*)( this + 0x7410 ) = 0;
   *(undefined8*)( this + 0x7394 ) = uVar3;
   *(undefined8*)( this + 0x73d0 ) = 0;
   *(ulong*)( this + 0x73f8 ) = ( ulong )(( uint ) * (undefined8*)( this + 0x73f8 ) & 0xfe000000) | 0x1ffffff;
   *(undefined2*)( this + 0x7418 ) = 0;
   this[0x73b0] = (TParseContext)0x0;
   *(undefined4*)( this + 0x73b4 ) = 0xfffff800;
   *(undefined8*)( this + 0x73b8 ) = 0xffffffff00000000;
   *(ulong*)( this + 0x73d8 ) = *(ulong*)( this + 0x73d8 ) & 0x8000000400000000 | 0x2000000000000000;
   *(undefined8*)( this + 0x73c0 ) = 0;
   *(undefined8*)( this + 0x7380 ) = 0;
   this[0x73e0] = ( TParseContext )((byte)this[0x73e0] & 0xf0 | 2U - ( uVar1 == 0 ));
   *(undefined2*)( this + 0x73c8 ) = 0;
   *(uint*)( this + 0x739c ) = *(uint*)( this + 0x739c ) & 0xffc00000 | 0x1fcfff;
   *(ulong*)( this + 0x73a0 ) = *(ulong*)( this + 0x73a0 ) & 0x8000000000000000 | 0x7fffffffffffffff;
   *(ulong*)( this + 0x73a8 ) = ( ulong )(( uint ) * (undefined8*)( this + 0x73a8 ) & 0xfe000000) | 0x1ffffff;
   *(undefined8*)( this + 0x7434 ) = uVar3;
   this[0x7450] = (TParseContext)0x0;
   *(undefined4*)( this + 0x7454 ) = 0xfffff800;
   *(ulong*)( this + 0x7388 ) = *(ulong*)( this + 0x7388 ) & 0x8000000400000000 | 0x2000000000000000;
   *(ulong*)( this + 0x7428 ) = *(ulong*)( this + 0x7428 ) & 0x8000000400000000;
   this[0x7430] = ( TParseContext )((byte)this[0x7430] & 0xf0);
   *(uint*)( this + 0x7478 ) = *(uint*)( this + 0x7478 ) & 0xc1ff0000;
   *(undefined8*)( this + 0x7458 ) = 0xffffffff00000000;
   this[0x7390] = ( TParseContext )(( -(uVar1 == 0) & 0xfeU ) + 3 & 0xf | (byte)this[0x7390] & 0xf0);
   *(undefined8*)( this + 0x7460 ) = 0;
   *(undefined2*)( this + 0x7468 ) = 0;
   *(undefined8*)( this + 0x7484 ) = uVar3;
   *(uint*)( this + 0x743c ) = *(uint*)( this + 0x743c ) & 0xffc00000 | 0x1fcfff;
   *(undefined8*)( this + 0x7420 ) = 0;
   this[0x74a0] = (TParseContext)0x0;
   *(undefined8*)( this + 0x7470 ) = 0;
   *(ulong*)( this + 0x7440 ) = *(ulong*)( this + 0x7440 ) & 0x8000000000000000 | 0x7fffffffffffffff;
   *(ulong*)( this + 0x7448 ) = ( ulong )(( uint ) * (undefined8*)( this + 0x7448 ) & 0xfe000000) | 0x1ffffff;
   *(uint*)( this + 0x748c ) = *(uint*)( this + 0x748c ) & 0xffc00000 | 0x1fcfff;
   *(ulong*)( this + 0x7490 ) = *(ulong*)( this + 0x7490 ) & 0x8000000000000000 | 0x7fffffffffffffff;
   *(ulong*)( this + 0x7498 ) = ( ulong )(( uint ) * (undefined8*)( this + 0x7498 ) & 0xfe000000) | 0x1ffffff;
   *(undefined4*)( this + 0x74a4 ) = 0xfffff800;
   *(ulong*)( this + 0x7478 ) = *(ulong*)( this + 0x7478 ) & 0x800000043e00ffff;
   *(ulong*)( this + 0x74e0 ) = *(ulong*)( this + 0x74e0 ) & 0x8000000000000000 | 0x7fffffffffffffff;
   this[0x7480] = ( TParseContext )((byte)this[0x7480] & 0xf0);
   *(undefined8*)( this + 0x74a8 ) = 0xffffffff00000000;
   *(undefined8*)( this + 0x74b0 ) = 0;
   *(ulong*)( this + 0x74e8 ) = ( ulong )(( uint ) * (undefined8*)( this + 0x74e8 ) & 0xfe000000) | 0x1ffffff;
   *(undefined2*)( this + 0x7508 ) = 0;
   *(undefined2*)( this + 0x74b8 ) = 0;
   *(undefined8*)( this + 0x74d4 ) = uVar3;
   *(uint*)( this + 0x74dc ) = *(uint*)( this + 0x74dc ) & 0xffc00000 | 0x1fcfff;
   *(ulong*)( this + 0x74c8 ) = *(ulong*)( this + 0x74c8 ) & 0x8000000400000000 | 0x2000000000000000;
   *(undefined8*)( this + 0x74c0 ) = 0;
   this[0x74f0] = (TParseContext)0x0;
   *(undefined4*)( this + 0x74f4 ) = 0xfffff800;
   *(undefined8*)( this + 0x74f8 ) = 0xffffffff00000000;
   *(undefined8*)( this + 0x7500 ) = 0;
   this[0x74d0] = ( TParseContext )((byte)this[0x74d0] & 0xf0 | 3);
   if (( param_8 < 4 ) && ( this[0x7494] = param_8 == 3 )) {
      this[0x7493] = (TParseContext)0x0;
   }

   if (( ( param_12 != (basic_string*)0x0 ) && ( *(long*)( param_12 + 0x10 ) != 0 ) ) && ( ( *(long*)( param_12 + 0x10 ) != 4 || ( **(int**)( param_12 + 8 ) != 0x6e69616d ) ) )) {
      for (int i = 0; i < 3; i++) {
         glslang::TInfoSinkBase::append(param_9);
      }

      return;
   }

   return;
}
/* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::TEMPNAMEPLACEHOLDERVALUE(std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> >&&) [clone .isra.0] */void std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::operator =(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *this, basic_string *param_1) {
   basic_string *pbVar1;
   undefined8 uVar2;
   uint uVar3;
   basic_string *pbVar4;
   ulong uVar5;
   basic_string *pbVar6;
   long lVar7;
   uint uVar8;
   ulong uVar9;
   pbVar6 = *(basic_string**)( this + 8 );
   pbVar4 = *(basic_string**)( param_1 + 8 );
   pbVar1 = param_1 + 0x18;
   if (pbVar6 == (basic_string*)( this + 0x18 )) {
      if (pbVar1 == pbVar4) goto LAB_00129a70;
      if (*(long*)this == *(long*)param_1) {
         uVar2 = *(undefined8*)( param_1 + 0x10 );
         *(basic_string**)( this + 8 ) = pbVar4;
         *(undefined8*)( this + 0x10 ) = uVar2;
         *(undefined8*)( this + 0x18 ) = *(undefined8*)( param_1 + 0x18 );
         goto LAB_00129b05;
      }

   }
 else {
      if (pbVar1 == pbVar4) {
         LAB_00129a70:uVar9 = *(ulong*)( param_1 + 0x10 );
         if (this != (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)param_1) {
            if (uVar9 != 0) {
               if (uVar9 == 1) {
                  *pbVar6 = *pbVar4;
                  uVar9 = *(ulong*)( param_1 + 0x10 );
                  pbVar6 = *(basic_string**)( this + 8 );
               }
 else {
                  uVar3 = (uint)uVar9;
                  uVar5 = uVar9 & 0xffffffff;
                  if (uVar3 < 8) {
                     if (( uVar9 & 4 ) != 0) {
                        *(undefined4*)pbVar6 = *(undefined4*)pbVar4;
                        *(undefined4*)( pbVar6 + ( uVar5 - 4 ) ) = *(undefined4*)( pbVar4 + ( uVar5 - 4 ) );
                        pbVar6 = *(basic_string**)( this + 8 );
                        uVar9 = *(ulong*)( param_1 + 0x10 );
                        goto LAB_00129ac3;
                     }

                     if (uVar3 == 0) goto LAB_00129ac3;
                     *pbVar6 = *pbVar4;
                     if (( uVar9 & 2 ) != 0) {
                        *(undefined2*)( pbVar6 + ( uVar5 - 2 ) ) = *(undefined2*)( pbVar4 + ( uVar5 - 2 ) );
                        pbVar6 = *(basic_string**)( this + 8 );
                        uVar9 = *(ulong*)( param_1 + 0x10 );
                        goto LAB_00129ac3;
                     }

                  }
 else {
                     *(undefined8*)pbVar6 = *(undefined8*)pbVar4;
                     *(undefined8*)( pbVar6 + ( ( uVar9 & 0xffffffff ) - 8 ) ) = *(undefined8*)( pbVar4 + ( ( uVar9 & 0xffffffff ) - 8 ) );
                     lVar7 = (long)pbVar6 - ( ( ulong )(pbVar6 + 8) & 0xfffffffffffffff8 );
                     uVar3 = (int)lVar7 + uVar3 & 0xfffffff8;
                     if (7 < uVar3) {
                        uVar8 = 0;
                        do {
                           uVar9 = (ulong)uVar8;
                           uVar8 = uVar8 + 8;
                           *(undefined8*)( ( ( ulong )(pbVar6 + 8) & 0xfffffffffffffff8 ) + uVar9 ) = *(undefined8*)( pbVar4 + ( uVar9 - lVar7 ) );
                        }
 while ( uVar8 < uVar3 );
                     }

                  }

                  pbVar6 = *(basic_string**)( this + 8 );
                  uVar9 = *(ulong*)( param_1 + 0x10 );
               }

            }

            LAB_00129ac3:*(ulong*)( this + 0x10 ) = uVar9;
            pbVar6[uVar9] = (basic_string)0x0;
            *(undefined8*)( param_1 + 0x10 ) = 0;
            **(undefined1**)( param_1 + 8 ) = 0;
            return;
         }

         goto LAB_00129a1c;
      }

      if (*(long*)this == *(long*)param_1) {
         *(basic_string**)( this + 8 ) = pbVar4;
         uVar2 = *(undefined8*)( this + 0x18 );
         *(undefined8*)( this + 0x10 ) = *(undefined8*)( param_1 + 0x10 );
         *(undefined8*)( this + 0x18 ) = *(undefined8*)( param_1 + 0x18 );
         if (pbVar6 != (basic_string*)0x0) {
            *(basic_string**)( param_1 + 8 ) = pbVar6;
            *(undefined8*)( param_1 + 0x18 ) = uVar2;
            *(undefined8*)( param_1 + 0x10 ) = 0;
            *pbVar6 = (basic_string)0x0;
            return;
         }

         LAB_00129b05:*(basic_string**)( param_1 + 8 ) = pbVar1;
         *(undefined8*)( param_1 + 0x10 ) = 0;
         *pbVar1 = (basic_string)0x0;
         return;
      }

   }

   _M_assign(this, param_1);
   pbVar4 = *(basic_string**)( param_1 + 8 );
   LAB_00129a1c:*(undefined8*)( param_1 + 0x10 ) = 0;
   *pbVar4 = (basic_string)0x0;
   return;
}
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address *//* glslang::TParseContext::builtInOpCheck(glslang::TSourceLoc const&, glslang::TFunction const&,
   glslang::TIntermOperator&) */void glslang::TParseContext::builtInOpCheck(TParseContext *this, TSourceLoc *param_1, TFunction *param_2, TIntermOperator *param_3) {
   undefined1 uVar1;
   byte bVar2;
   undefined4 uVar3;
   uint uVar4;
   undefined1 *puVar5;
   char cVar6;
   int iVar7;
   uint uVar8;
   int iVar9;
   long lVar10;
   long *plVar11;
   long *plVar12;
   ulong uVar13;
   long lVar14;
   long lVar15;
   long *plVar16;
   basic_string *pbVar17;
   TIntermOperator *pTVar18;
   long *plVar19;
   uint uVar20;
   undefined **ppuVar21;
   undefined8 uVar22;
   char *pcVar23;
   bool bVar24;
   code *pcVar25;
   code *pcVar26;
   long in_FS_OFFSET;
   code *local_140;
   code *local_138;
   char local_102;
   char local_101;
   undefined1 *local_100;
   undefined8 local_f8;
   undefined1 *local_f0;
   undefined8 local_e8;
   undefined1 local_e0[24];
   undefined8 local_c8;
   undefined1 *local_c0;
   undefined1 local_b0[24];
   undefined1 **local_98;
   undefined1 *local_90;
   undefined1 *local_88;
   undefined1 local_80[24];
   undefined1 local_68[16];
   code *local_58;
   code *pcStack_50;
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   lVar10 = ( **(code**)( *(long*)param_3 + 0x30 ) )(param_3);
   if (lVar10 == 0) {
      plVar12 = (long*)( **(code**)( *(long*)param_3 + 0x38 ) )(param_3);
      plVar11 = (long*)0x0;
      if (*(code**)( *plVar12 + 0x188 ) == TIntermUnary::getOperand) {
         plVar12 = (long*)plVar12[0x18];
      }
 else {
         plVar12 = (long*)( **(code**)( *plVar12 + 0x188 ) )();
      }

   }
 else {
      plVar11 = (long*)( **(code**)( *(long*)param_3 + 0x30 ) )(param_3);
      if (*(code**)( *plVar11 + 400 ) == TIntermAggregate::getSequence) {
         plVar11 = plVar11 + 0x18;
      }
 else {
         plVar11 = (long*)( **(code**)( *plVar11 + 400 ) )();
      }

      plVar12 = (long*)0x0;
      if ((undefined8*)plVar11[1] != (undefined8*)plVar11[2]) {
         plVar12 = (long*)( **(code**)( **(long**)plVar11[1] + 0x18 ) )();
      }

   }

   local_f8 = glslang::GetThreadPoolAllocator();
   uVar8 = *(uint*)( param_3 + 0xb8 );
   local_e0[0] = 0;
   local_f0 = local_e0;
   local_e8 = 0;
   if (0x2c7 < uVar8) {
      if (uVar8 < 0x2ff) {
         if (uVar8 < 0x2e4) {
            uVar20 = uVar8 - 0x2d0;
            if (uVar20 < 0x14) {
               if (( 1L << ( (byte)uVar20 & 0x3f ) & 0x337f9U ) != 0) goto LAB_0012b8ec;
               if (uVar20 == 0x13) {
                  lVar10 = ( **(code**)( **(long**)( plVar11[1] + 0x60 ) + 0x28 ) )();
                  if (lVar10 == 0) {
                     ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "argument must be compile-time constant", "payload number", &_LC1);
                     uVar8 = *(uint*)( param_3 + 0xb8 );
                  }
 else {
                     plVar11 = (long*)( **(code**)( **(long**)( plVar11[1] + 0x60 ) + 0x28 ) )();
                     if (*(code**)( *plVar11 + 0x28 ) != TIntermConstantUnion::getAsConstantUnion) {
                        plVar11 = (long*)( **(code**)( *plVar11 + 0x28 ) )(plVar11);
                     }

                     uVar3 = **(undefined4**)( plVar11[0x18] + 8 );
                     cVar6 = ( **(code**)( *(long*)this + 0x40 ) )(this);
                     if (cVar6 == '\0') {
                        iVar9 = glslang::TIntermediate::checkLocationRT((int)*(undefined8*)( this + 0x38 ), 0);
                        if (iVar9 < 0) {
                           ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "with layout(location =", "no rayPayloadEXT/rayPayloadInEXT declared", &_LC1056, uVar3);
                           uVar8 = *(uint*)( param_3 + 0xb8 );
                        }
 else {
                           uVar8 = *(uint*)( param_3 + 0xb8 );
                        }

                     }
 else {
                        uVar8 = *(uint*)( param_3 + 0xb8 );
                     }

                  }

               }
 else if (uVar20 == 0x12) {
                  lVar10 = ( **(code**)( **(long**)( plVar11[1] + 0x58 ) + 0x28 ) )();
                  if (lVar10 == 0) {
                     ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "argument must be compile-time constant", "payload number", &_LC1);
                     uVar8 = *(uint*)( param_3 + 0xb8 );
                  }
 else {
                     plVar11 = (long*)( **(code**)( **(long**)( plVar11[1] + 0x58 ) + 0x28 ) )();
                     if (*(code**)( *plVar11 + 0x28 ) != TIntermConstantUnion::getAsConstantUnion) {
                        plVar11 = (long*)( **(code**)( *plVar11 + 0x28 ) )(plVar11);
                     }

                     uVar3 = **(undefined4**)( plVar11[0x18] + 8 );
                     cVar6 = ( **(code**)( *(long*)this + 0x40 ) )(this);
                     if (cVar6 == '\0') {
                        iVar9 = glslang::TIntermediate::checkLocationRT((int)*(undefined8*)( this + 0x38 ), 0);
                        if (iVar9 < 0) {
                           ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "with layout(location =", "no rayPayloadEXT/rayPayloadInEXT declared", &_LC1056, uVar3);
                           uVar8 = *(uint*)( param_3 + 0xb8 );
                        }
 else {
                           uVar8 = *(uint*)( param_3 + 0xb8 );
                        }

                     }
 else {
                        uVar8 = *(uint*)( param_3 + 0xb8 );
                     }

                  }

               }

            }

         }
 else {
            switch (uVar8) {
               case 0x2e4:
          lVar10 = (**(code **)(**(long **)(plVar11[1] + 0x60) + 0x28))();
          if (lVar10 == 0) {
            (**(code **)(*(long *)this + 0x158))
                      (this,param_1,"argument must be compile-time constant",
                       "hitobjectattribute number",&_LC1);
            uVar8 = *(uint *)(param_3 + 0xb8);
          }
          else {
            plVar11 = (long *)(**(code **)(**(long **)(plVar11[1] + 0x60) + 0x28))();
            if (*(code **)(*plVar11 + 0x28) != TIntermConstantUnion::getAsConstantUnion) {
              plVar11 = (long *)(**(code **)(*plVar11 + 0x28))(plVar11);
            }
            uVar3 = **(undefined4 **)(plVar11[0x18] + 8);
            cVar6 = (**(code **)(*(long *)this + 0x40))(this,"GL_EXT_spirv_intrinsics");
            if (cVar6 == '\0') {
              iVar9 = glslang::TIntermediate::checkLocationRT((int)*(undefined8 *)(this + 0x38),2);
              if (iVar9 < 0) {
                (**(code **)(*(long *)this + 0x158))
                          (this,param_1,"with layout(location =","no hitObjectAttributeNV declared",
                           &_LC1056,uVar3);
                uVar8 = *(uint *)(param_3 + 0xb8);
              }
              else {
                uVar8 = *(uint *)(param_3 + 0xb8);
              }
            }
            else {
              uVar8 = *(uint *)(param_3 + 0xb8);
            }
          }
          break;
               case 0x2e5:
          lVar10 = (**(code **)(**(long **)(plVar11[1] + 0x68) + 0x28))();
          if (lVar10 == 0) {
            (**(code **)(*(long *)this + 0x158))
                      (this,param_1,"argument must be compile-time constant",
                       "hitobjectattribute number",&_LC1);
            uVar8 = *(uint *)(param_3 + 0xb8);
          }
          else {
            plVar11 = (long *)(**(code **)(**(long **)(plVar11[1] + 0x68) + 0x28))();
            if (*(code **)(*plVar11 + 0x28) != TIntermConstantUnion::getAsConstantUnion) {
              plVar11 = (long *)(**(code **)(*plVar11 + 0x28))(plVar11);
            }
            uVar3 = **(undefined4 **)(plVar11[0x18] + 8);
            cVar6 = (**(code **)(*(long *)this + 0x40))(this,"GL_EXT_spirv_intrinsics");
            if (cVar6 == '\0') {
              iVar9 = glslang::TIntermediate::checkLocationRT((int)*(undefined8 *)(this + 0x38),2);
              if (iVar9 < 0) {
                (**(code **)(*(long *)this + 0x158))
                          (this,param_1,"with layout(location =","no hitObjectAttributeNV declared",
                           &_LC1056,uVar3);
                uVar8 = *(uint *)(param_3 + 0xb8);
              }
              else {
                uVar8 = *(uint *)(param_3 + 0xb8);
              }
            }
            else {
              uVar8 = *(uint *)(param_3 + 0xb8);
            }
          }
          break;
               case 0x2e6:
          lVar10 = (**(code **)(**(long **)(plVar11[1] + 0x58) + 0x28))();
          if (lVar10 == 0) {
            (**(code **)(*(long *)this + 0x158))
                      (this,param_1,"argument must be compile-time constant",
                       "hitobjectattribute number",&_LC1);
            uVar8 = *(uint *)(param_3 + 0xb8);
          }
          else {
            plVar11 = (long *)(**(code **)(**(long **)(plVar11[1] + 0x58) + 0x28))();
            if (*(code **)(*plVar11 + 0x28) != TIntermConstantUnion::getAsConstantUnion) {
              plVar11 = (long *)(**(code **)(*plVar11 + 0x28))(plVar11);
            }
            uVar3 = **(undefined4 **)(plVar11[0x18] + 8);
            cVar6 = (**(code **)(*(long *)this + 0x40))(this,"GL_EXT_spirv_intrinsics");
            if (cVar6 == '\0') {
              iVar9 = glslang::TIntermediate::checkLocationRT((int)*(undefined8 *)(this + 0x38),2);
              if (iVar9 < 0) {
                (**(code **)(*(long *)this + 0x158))
                          (this,param_1,"with layout(location =","no hitObjectAttributeNV declared",
                           &_LC1056,uVar3);
                uVar8 = *(uint *)(param_3 + 0xb8);
              }
              else {
                uVar8 = *(uint *)(param_3 + 0xb8);
              }
            }
            else {
              uVar8 = *(uint *)(param_3 + 0xb8);
            }
          }
          break;
               case 0x2e7:
          lVar10 = (**(code **)(**(long **)(plVar11[1] + 0x60) + 0x28))();
          if (lVar10 == 0) {
            (**(code **)(*(long *)this + 0x158))
                      (this,param_1,"argument must be compile-time constant",
                       "hitobjectattribute number",&_LC1);
            uVar8 = *(uint *)(param_3 + 0xb8);
          }
          else {
            plVar11 = (long *)(**(code **)(**(long **)(plVar11[1] + 0x60) + 0x28))();
            if (*(code **)(*plVar11 + 0x28) != TIntermConstantUnion::getAsConstantUnion) {
              plVar11 = (long *)(**(code **)(*plVar11 + 0x28))(plVar11);
            }
            uVar3 = **(undefined4 **)(plVar11[0x18] + 8);
            cVar6 = (**(code **)(*(long *)this + 0x40))(this,"GL_EXT_spirv_intrinsics");
            if (cVar6 == '\0') {
              iVar9 = glslang::TIntermediate::checkLocationRT((int)*(undefined8 *)(this + 0x38),2);
              if (iVar9 < 0) {
                (**(code **)(*(long *)this + 0x158))
                          (this,param_1,"with layout(location =","no hitObjectAttributeNV declared",
                           &_LC1056,uVar3);
                uVar8 = *(uint *)(param_3 + 0xb8);
              }
              else {
                uVar8 = *(uint *)(param_3 + 0xb8);
              }
            }
            else {
              uVar8 = *(uint *)(param_3 + 0xb8);
            }
          }
          break;
               case 0x2eb:
          lVar10 = (**(code **)(**(long **)(plVar11[1] + 8) + 0x28))();
          if (lVar10 == 0) {
            (**(code **)(*(long *)this + 0x158))
                      (this,param_1,"argument must be compile-time constant","payload number",&_LC1)
            ;
            uVar8 = *(uint *)(param_3 + 0xb8);
          }
          else {
            plVar11 = (long *)(**(code **)(**(long **)(plVar11[1] + 8) + 0x28))();
            if (*(code **)(*plVar11 + 0x28) != TIntermConstantUnion::getAsConstantUnion) {
              plVar11 = (long *)(**(code **)(*plVar11 + 0x28))(plVar11);
            }
            uVar3 = **(undefined4 **)(plVar11[0x18] + 8);
            cVar6 = (**(code **)(*(long *)this + 0x40))(this);
            if (cVar6 == '\0') {
              iVar9 = glslang::TIntermediate::checkLocationRT((int)*(undefined8 *)(this + 0x38),0);
              if (iVar9 < 0) {
                (**(code **)(*(long *)this + 0x158))
                          (this,param_1,"with layout(location =",
                           "no rayPayloadEXT/rayPayloadInEXT declared",&_LC1056,uVar3);
                uVar8 = *(uint *)(param_3 + 0xb8);
              }
              else {
                uVar8 = *(uint *)(param_3 + 0xb8);
              }
            }
            else {
              uVar8 = *(uint *)(param_3 + 0xb8);
            }
          }
          break;
               case 0x2fe:
          lVar10 = (**(code **)(**(long **)(plVar11[1] + 8) + 0x28))();
          if (lVar10 == 0) {
            (**(code **)(*(long *)this + 0x158))
                      (this,param_1,"argument must be compile-time constant",
                       "hitobjectattribute number",&_LC1);
            uVar8 = *(uint *)(param_3 + 0xb8);
          }
          else {
            plVar11 = (long *)(**(code **)(**(long **)(plVar11[1] + 8) + 0x28))();
            if (*(code **)(*plVar11 + 0x28) != TIntermConstantUnion::getAsConstantUnion) {
              plVar11 = (long *)(**(code **)(*plVar11 + 0x28))(plVar11);
            }
            uVar3 = **(undefined4 **)(plVar11[0x18] + 8);
            cVar6 = (**(code **)(*(long *)this + 0x40))(this,"GL_EXT_spirv_intrinsics");
            if (cVar6 == '\0') {
              iVar9 = glslang::TIntermediate::checkLocationRT((int)*(undefined8 *)(this + 0x38),2);
              if (iVar9 < 0) {
                (**(code **)(*(long *)this + 0x158))
                          (this,param_1,"with layout(location =","no hitObjectAttributeNV declared",
                           &_LC1056,uVar3);
                uVar8 = *(uint *)(param_3 + 0xb8);
              }
              else {
                uVar8 = *(uint *)(param_3 + 0xb8);
              }
            }
            else {
              uVar8 = *(uint *)(param_3 + 0xb8);
            }
          }
            }

         }

      }
 else if (uVar8 == 0x34a) {
         LAB_0012b8ec:lVar10 = ( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x28 ) )();
         if (lVar10 == 0) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "argument must be compile-time constant", "committed", &_LC1);
            uVar8 = *(uint*)( param_3 + 0xb8 );
         }
 else {
            uVar8 = *(uint*)( param_3 + 0xb8 );
         }

      }

      goto switchD_00129e7d_caseD_25c;
   }

   if (0x2a0 < uVar8) {
      switch (uVar8) {
         case 0x2a1:
         case 0x2a2:
         case 0x2a3:
      pcVar25 = *(code **)(*(long *)this + 0x28);
      if (*(code **)(*(long *)param_2 + 0x18) == TSymbol::getName_abi_cxx11_) {
        lVar10 = *(long *)(param_2 + 8);
      }
      else {
        lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
      }
      (*pcVar25)(this,param_1,1,&E_GL_ARB_sparse_texture2,*(undefined8 *)(lVar10 + 8));
      uVar8 = *(uint *)(param_3 + 0xb8);
      break;
         case 0x2c0:
      lVar10 = (**(code **)(**(long **)(plVar11[1] + 0x50) + 0x28))();
      if (lVar10 == 0) {
        (**(code **)(*(long *)this + 0x158))
                  (this,param_1,"argument must be compile-time constant","payload number",&_LC1054);
        uVar8 = *(uint *)(param_3 + 0xb8);
      }
      else {
        uVar8 = *(uint *)(param_3 + 0xb8);
      }
      break;
         case 0x2c1:
      lVar10 = (**(code **)(**(long **)(plVar11[1] + 0x58) + 0x28))();
      if (lVar10 == 0) {
        (**(code **)(*(long *)this + 0x158))
                  (this,param_1,"argument must be compile-time constant","payload number",&_LC1054);
        uVar8 = *(uint *)(param_3 + 0xb8);
      }
      else {
        uVar8 = *(uint *)(param_3 + 0xb8);
      }
      break;
         case 0x2c2:
      lVar10 = (**(code **)(**(long **)(plVar11[1] + 0x50) + 0x28))();
      if (lVar10 == 0) {
        (**(code **)(*(long *)this + 0x158))
                  (this,param_1,"argument must be compile-time constant","payload number",&_LC1054);
        uVar8 = *(uint *)(param_3 + 0xb8);
      }
      else {
        plVar11 = (long *)(**(code **)(**(long **)(plVar11[1] + 0x50) + 0x28))();
        if (*(code **)(*plVar11 + 0x28) != TIntermConstantUnion::getAsConstantUnion) {
          plVar11 = (long *)(**(code **)(*plVar11 + 0x28))(plVar11);
        }
        uVar3 = **(undefined4 **)(plVar11[0x18] + 8);
        cVar6 = (**(code **)(*(long *)this + 0x40))(this);
        if (cVar6 == '\0') {
          iVar9 = glslang::TIntermediate::checkLocationRT((int)*(undefined8 *)(this + 0x38),0);
          if (iVar9 < 0) {
            (**(code **)(*(long *)this + 0x158))
                      (this,param_1,"with layout(location =",
                       "no rayPayloadEXT/rayPayloadInEXT declared",&_LC1056,uVar3);
            uVar8 = *(uint *)(param_3 + 0xb8);
          }
          else {
            uVar8 = *(uint *)(param_3 + 0xb8);
          }
        }
        else {
          uVar8 = *(uint *)(param_3 + 0xb8);
        }
      }
      break;
         case 0x2c6:
      lVar10 = (**(code **)(**(long **)(plVar11[1] + 8) + 0x28))();
      if (lVar10 == 0) {
        (**(code **)(*(long *)this + 0x158))
                  (this,param_1,"argument must be compile-time constant","callable data number",
                   &_LC1);
        uVar8 = *(uint *)(param_3 + 0xb8);
      }
      else {
        uVar8 = *(uint *)(param_3 + 0xb8);
      }
      break;
         case 0x2c7:
      lVar10 = (**(code **)(**(long **)(plVar11[1] + 8) + 0x28))();
      if (lVar10 == 0) {
        (**(code **)(*(long *)this + 0x158))
                  (this,param_1,"argument must be compile-time constant","callable data number",
                   &_LC1);
        uVar8 = *(uint *)(param_3 + 0xb8);
      }
      else {
        plVar11 = (long *)(**(code **)(**(long **)(plVar11[1] + 8) + 0x28))();
        if (*(code **)(*plVar11 + 0x28) != TIntermConstantUnion::getAsConstantUnion) {
          plVar11 = (long *)(**(code **)(*plVar11 + 0x28))(plVar11);
        }
        uVar3 = **(undefined4 **)(plVar11[0x18] + 8);
        cVar6 = (**(code **)(*(long *)this + 0x40))(this,"GL_EXT_spirv_intrinsics");
        if (cVar6 == '\0') {
          iVar9 = glslang::TIntermediate::checkLocationRT((int)*(undefined8 *)(this + 0x38),1);
          if (iVar9 < 0) {
            (**(code **)(*(long *)this + 0x158))
                      (this,param_1,"with layout(location =",
                       "no callableDataEXT/callableDataInEXT declared",&_LC1056,uVar3);
            uVar8 = *(uint *)(param_3 + 0xb8);
          }
          else {
            uVar8 = *(uint *)(param_3 + 0xb8);
          }
        }
        else {
          uVar8 = *(uint *)(param_3 + 0xb8);
        }
      }
      }

      goto switchD_00129e7d_caseD_25c;
   }

   if (uVar8 == 0x1a7) {
      lVar10 = ( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x28 ) )();
      if (lVar10 == 0) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "argument must be compile-time constant", &_LC1047, &_LC1);
         uVar8 = *(uint*)( param_3 + 0xb8 );
      }
 else {
         lVar10 = ( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x28 ) )();
         uVar8 = **(uint**)( *(long*)( lVar10 + 0xc0 ) + 8 );
         lVar10 = ( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x28 ) )();
         uVar20 = *(uint*)( *(long*)( *(long*)( lVar10 + 0xc0 ) + 8 ) + 0x10 );
         lVar10 = ( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x28 ) )();
         if (( uVar8 | uVar20 | *(uint*)( *(long*)( *(long*)( lVar10 + 0xc0 ) + 8 ) + 0x20 ) ) < 0x20) {
            uVar8 = *(uint*)( param_3 + 0xb8 );
         }
 else {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "components must be in the range [0, 31]", &_LC1047, &_LC1);
            uVar8 = *(uint*)( param_3 + 0xb8 );
         }

      }

      goto switchD_00129e7d_caseD_25c;
   }

   if (uVar8 < 0x1a8) {
      if (uVar8 < 0x136) {
         if (uVar8 < 0x134) {
            if (uVar8 < 0x129) {
               if (uVar8 < 0x125) {
                  if (uVar8 == 0xdd) {
                     if (*(int*)( this + 0xc ) == 8) {
                        if (*(int*)( this + 0x18 ) < 0x136) {
                           plVar16 = (long*)( **(code**)( **(long**)plVar11[1] + 0x18 ) )();
                           if (*(code**)( *plVar16 + 0x100 ) == TIntermTyped::getBasicType) {
                              uVar8 = ( uint ) * (byte*)( plVar16 + 5 );
                           }
 else {
                              uVar8 = ( **(code**)( *plVar16 + 0x100 ) )();
                           }

                           if (uVar8 != 1) {
                              plVar16 = (long*)( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x18 ) )();
                              if (*(code**)( *plVar16 + 0x100 ) == TIntermTyped::getBasicType) {
                                 uVar8 = ( uint ) * (byte*)( plVar16 + 5 );
                              }
 else {
                                 uVar8 = ( **(code**)( *plVar16 + 0x100 ) )();
                              }

                              if (uVar8 != 1) {
                                 plVar16 = (long*)( **(code**)( **(long**)( plVar11[1] + 0x10 ) + 0x18 ) )();
                                 if (*(code**)( *plVar16 + 0x100 ) == TIntermTyped::getBasicType) {
                                    uVar8 = ( uint ) * (byte*)( plVar16 + 5 );
                                 }
 else {
                                    uVar8 = ( **(code**)( *plVar16 + 0x100 ) )();
                                 }

                                 if (uVar8 == 0xc) {
                                    ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_EXT_shader_integer_mix, "specific signature of builtin mix");
                                 }

                              }

                           }

                           if (*(int*)( this + 0xc ) != 8) goto LAB_00129cf1;
                           uVar8 = *(uint*)( param_3 + 0xb8 );
                        }

                     }
 else {
                        LAB_00129cf1:if (*(int*)( this + 0x18 ) < 0x1c2) {
                           plVar16 = (long*)( **(code**)( **(long**)plVar11[1] + 0x18 ) )();
                           if (*(code**)( *plVar16 + 0x100 ) == TIntermTyped::getBasicType) {
                              uVar8 = ( uint ) * (byte*)( plVar16 + 5 );
                           }
 else {
                              uVar8 = ( **(code**)( *plVar16 + 0x100 ) )();
                           }

                           if (uVar8 == 1) {
                              uVar8 = *(uint*)( param_3 + 0xb8 );
                           }
 else {
                              plVar16 = (long*)( **(code**)( **(long**)plVar11[1] + 0x18 ) )();
                              if (*(code**)( *plVar16 + 0x100 ) == TIntermTyped::getBasicType) {
                                 uVar8 = ( uint ) * (byte*)( plVar16 + 5 );
                              }
 else {
                                 uVar8 = ( **(code**)( *plVar16 + 0x100 ) )(plVar16);
                              }

                              if (uVar8 == 2) {
                                 uVar8 = *(uint*)( param_3 + 0xb8 );
                              }
 else {
                                 plVar16 = (long*)( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x18 ) )();
                                 if (*(code**)( *plVar16 + 0x100 ) == TIntermTyped::getBasicType) {
                                    uVar8 = ( uint ) * (byte*)( plVar16 + 5 );
                                 }
 else {
                                    uVar8 = ( **(code**)( *plVar16 + 0x100 ) )();
                                 }

                                 if (uVar8 == 1) {
                                    uVar8 = *(uint*)( param_3 + 0xb8 );
                                 }
 else {
                                    plVar16 = (long*)( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x18 ) )();
                                    if (*(code**)( *plVar16 + 0x100 ) == TIntermTyped::getBasicType) {
                                       uVar8 = ( uint ) * (byte*)( plVar16 + 5 );
                                    }
 else {
                                       uVar8 = ( **(code**)( *plVar16 + 0x100 ) )();
                                    }

                                    if (uVar8 == 2) {
                                       uVar8 = *(uint*)( param_3 + 0xb8 );
                                    }
 else {
                                       plVar11 = (long*)( **(code**)( **(long**)( plVar11[1] + 0x10 ) + 0x18 ) )();
                                       if (*(code**)( *plVar11 + 0x100 ) == TIntermTyped::getBasicType) {
                                          uVar8 = ( uint ) * (byte*)( plVar11 + 5 );
                                       }
 else {
                                          uVar8 = ( **(code**)( *plVar11 + 0x100 ) )();
                                       }

                                       if (uVar8 == 0xc) {
                                          pcVar25 = *(code**)( *(long*)this + 0x28 );
                                          lVar10 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
                                          ( *pcVar25 )(this, param_1, 1, &E_GL_EXT_shader_integer_mix, *(undefined8*)( lVar10 + 8 ));
                                          uVar8 = *(uint*)( param_3 + 0xb8 );
                                       }
 else {
                                          uVar8 = *(uint*)( param_3 + 0xb8 );
                                       }

                                    }

                                 }

                              }

                           }

                        }
 else {
                           uVar8 = *(uint*)( param_3 + 0xb8 );
                        }

                     }

                  }

               }
 else {
                  if (*(code**)( *plVar12 + 0xf0 ) == TIntermTyped::getType) {
                     plVar16 = plVar12 + 4;
                  }
 else {
                     plVar16 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
                  }

                  if (*(code**)( *plVar16 + 0x58 ) == TType::getQualifier) {
                     plVar16 = plVar16 + 2;
                  }
 else {
                     plVar16 = (long*)( **(code**)( *plVar16 + 0x58 ) )();
                  }

                  if (( *(byte*)( plVar16 + 1 ) & 0x7f ) != 3) {
                     bVar24 = false;
                     iVar9 = *(int*)( this + 0xc );
                     if (iVar9 != 8) {
                        bVar24 = 0x1b7 < *(int*)( this + 0x18 );
                     }

                     local_100 = (undefined1*)0x43;
                     local_98 = &local_88;
                     local_98 = (undefined1**)std::__cxx11::string::_M_create((ulong*)&local_98, ( ulong ) & local_100);
                     puVar5 = _UNK_00168788;
                     local_88 = local_100;
                     *local_98 = __LC1088;
                     local_98[1] = puVar5;
                     puVar5 = _UNK_00168798;
                     local_98[2] = __LC1089;
                     local_98[3] = puVar5;
                     puVar5 = _UNK_001687a8;
                     local_98[4] = __LC1090;
                     local_98[5] = puVar5;
                     puVar5 = _UNK_001687b8;
                     local_98[6] = __LC1091;
                     local_98[7] = puVar5;
                     *(undefined4*)( (long)local_98 + 0x3f ) = 0x746e656d;
                     local_90 = local_100;
                     *(undefined1*)( (long)local_98 + (long)local_100 ) = 0;
                     local_68 = (undefined1[16])0x0;
                     local_102 = '\x01';
                     local_101 = '\0';
                     local_100 = (undefined1*)( (ulong)local_100 & 0xffffffffffffff00 );
                     local_58 = (code*)0x0;
                     pcStack_50 = (code*)0x0;
                     plVar16 = (long*)operator_new(0x28);
                     local_68._0_8_ = plVar16;
                     *(bool*)( plVar16 + 3 ) = iVar9 == 8;
                     plVar16[2] = (long)&local_98;
                     plVar16[4] = (long)&local_100;
                     *plVar16 = (long)&local_102;
                     plVar16[1] = (long)&local_101;
                     local_58 = std::_Function_handler<bool(TIntermNode_const &),glslang::TParseContext::builtInOpCheck(glslang::TSourceLoc_const&,glslang::TFunction_const&,glslang::TIntermOperator&)::{lambda(TIntermNode_const&)#1}>::_M_manager;
                     pcStack_50 = std::_Function_handler<bool(TIntermNode_const &),glslang::TParseContext::builtInOpCheck(glslang::TSourceLoc_const&,glslang::TFunction_const&,glslang::TIntermOperator&)::{lambda(TIntermNode_const&)#1}>::_M_invoke;
                     glslang::TIntermediate::traverseLValueBase(plVar12, bVar24, 0);
                     if (local_58 != (code*)0x0) {
                        ( *local_58 )(local_68, local_68, 3);
                     }

                     if (( local_101 == '\0' ) || ( local_102 == '\0' )) {
                        pcVar25 = *(code**)( *(long*)this + 0x158 );
                        if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                           lVar10 = *(long*)( param_2 + 8 );
                        }
 else {
                           lVar10 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
                        }

                        ( *pcVar25 )(this, param_1, local_98, *(undefined8*)( lVar10 + 8 ), &_LC1);
                     }

                     if (local_98 != &local_88) {
                        operator_delete(local_98, ( ulong )(local_88 + 1));
                     }

                  }

                  uVar8 = *(uint*)( param_3 + 0xb8 );
                  if (uVar8 == 0x128) {
                     if (*(code**)( *plVar12 + 0xf0 ) == TIntermTyped::getType) {
                        plVar16 = plVar12 + 4;
                     }
 else {
                        plVar16 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
                     }

                     if (*(code**)( *plVar16 + 0x58 ) == TType::getQualifier) {
                        plVar16 = plVar16 + 2;
                     }
 else {
                        plVar16 = (long*)( **(code**)( *plVar16 + 0x58 ) )();
                     }

                     if (( *(byte*)( (long)plVar16 + 0xc ) & 0x40 ) == 0) {
                        ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "argument must be qualified as __explicitInterpAMD in", "interpolant", &_LC1);
                        uVar8 = *(uint*)( param_3 + 0xb8 );
                     }
 else {
                        lVar10 = ( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x28 ) )();
                        if (lVar10 == 0) {
                           ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "argument must be compile-time constant", "vertex index", &_LC1);
                           uVar8 = *(uint*)( param_3 + 0xb8 );
                        }
 else {
                           lVar10 = ( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x28 ) )();
                           if (**(uint**)( *(long*)( lVar10 + 0xc0 ) + 8 ) < 3) {
                              uVar8 = *(uint*)( param_3 + 0xb8 );
                           }
 else {
                              ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "must be in the range [0, 2]", "vertex index", &_LC1);
                              uVar8 = *(uint*)( param_3 + 0xb8 );
                           }

                        }

                     }

                  }

               }

            }
 else if (uVar8 - 0x132 < 2) {
               if (*(int*)( this + 0x18 ) == 0x96) {
                  ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_ARB_gpu_shader5, "if the verison is 150 , the EmitStreamVertex and EndStreamPrimitive only support at extension GL_ARB_gpu_shader5");
                  uVar8 = *(uint*)( param_3 + 0xb8 );
               }

               *(undefined1*)( *(long*)( this + 0x38 ) + 0x360 ) = 1;
            }

         }
 else {
            if (plVar11[1] == plVar11[2]) goto LAB_00129da0;
            pcVar25 = *(code**)( *(long*)this + 0x28 );
            if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
               lVar10 = *(long*)( param_2 + 8 );
            }
 else {
               lVar10 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
            }

            ( *pcVar25 )(this, param_1, 1, &E_GL_KHR_memory_scope_semantics, *(undefined8*)( lVar10 + 8 ));
            memorySemanticsCheck(this, param_1, param_2, param_3);
            uVar8 = *(uint*)( param_3 + 0xb8 );
         }

         goto switchD_00129e7d_caseD_25c;
      }

      if (uVar8 != 0x177) {
         if (uVar8 < 0x178) {
            if (uVar8 == 0x14b) goto LAB_0012adf0;
            if (uVar8 - 0x170 < 7) {
               lVar10 = ( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x28 ) )();
               if (lVar10 == 0) {
                  ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "argument must be compile-time constant", "cluster size", &_LC1);
                  uVar8 = *(uint*)( param_3 + 0xb8 );
               }
 else {
                  lVar10 = ( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x28 ) )();
                  uVar8 = **(uint**)( *(long*)( lVar10 + 0xc0 ) + 8 );
                  if ((int)uVar8 < 1) {
                     ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "argument must be at least 1", "cluster size", &_LC1);
                     uVar8 = *(uint*)( param_3 + 0xb8 );
                  }
 else if (( uVar8 - 1 & uVar8 ) == 0) {
                     uVar8 = *(uint*)( param_3 + 0xb8 );
                  }
 else {
                     ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "argument must be a power of 2", "cluster size", &_LC1);
                     uVar8 = *(uint*)( param_3 + 0xb8 );
                  }

               }

            }

         }
 else if (uVar8 == 0x1a6) {
            lVar10 = ( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x28 ) )();
            if (lVar10 == 0) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "argument must be compile-time constant", "offset", &_LC1);
               uVar8 = *(uint*)( param_3 + 0xb8 );
            }
 else {
               lVar10 = ( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x28 ) )();
               uVar8 = **(uint**)( *(long*)( lVar10 + 0xc0 ) + 8 );
               lVar10 = ( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x28 ) )();
               uVar20 = *(uint*)( *(long*)( *(long*)( lVar10 + 0xc0 ) + 8 ) + 0x10 );
               lVar10 = ( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x28 ) )();
               uVar4 = *(uint*)( *(long*)( *(long*)( lVar10 + 0xc0 ) + 8 ) + 0x20 );
               lVar10 = ( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x28 ) )();
               if (( uVar8 | uVar20 | uVar4 | *(uint*)( *(long*)( *(long*)( lVar10 + 0xc0 ) + 8 ) + 0x30 ) ) < 4) {
                  uVar8 = *(uint*)( param_3 + 0xb8 );
               }
 else {
                  ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "components must be in the range [0, 3]", "offset", &_LC1);
                  uVar8 = *(uint*)( param_3 + 0xb8 );
               }

            }

         }

         goto switchD_00129e7d_caseD_25c;
      }

      LAB_0012adf0:if (*(uint*)( this + 0x20 ) < 0x10500) {
         lVar10 = ( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x28 ) )();
         if (lVar10 == 0) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "argument must be compile-time constant", &_LC1084, &_LC1);
            uVar8 = *(uint*)( param_3 + 0xb8 );
         }
 else {
            uVar8 = *(uint*)( param_3 + 0xb8 );
         }

         goto switchD_00129e7d_caseD_25c;
      }

      goto LAB_0012a387;
   }

   iVar9 = (int)param_1;
   if (uVar8 < 0x279) {
      if (uVar8 < 0x25b) {
         if (uVar8 - 0x1ad < 0xb) {
            if (( ulong )(plVar11[2] - plVar11[1]) < 0x19) {
               if (*(code**)( *plVar12 + 0xf0 ) == TIntermTyped::getType) {
                  plVar11 = plVar12 + 4;
               }
 else {
                  plVar11 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
               }

               if (*(code**)( *plVar11 + 0x38 ) == TType::getBasicType) {
                  uVar8 = ( uint ) * (byte*)( plVar11 + 1 );
               }
 else {
                  uVar8 = ( **(code**)( *plVar11 + 0x38 ) )();
               }

               if (uVar8 != 10) {
                  if (*(code**)( *plVar12 + 0xf0 ) == TIntermTyped::getType) {
                     plVar11 = plVar12 + 4;
                  }
 else {
                     plVar11 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
                  }

                  if (*(code**)( *plVar11 + 0x38 ) == TType::getBasicType) {
                     uVar8 = ( uint ) * (byte*)( plVar11 + 1 );
                  }
 else {
                     uVar8 = ( **(code**)( *plVar11 + 0x38 ) )();
                  }

                  if (uVar8 != 0xb) {
                     iVar9 = *(int*)( param_3 + 0xb8 );
                     uVar13 = ( ulong )(iVar9 - 0x1adU);
                     if (iVar9 - 0x1adU < 8) {
                        if (( 0x8dUL >> ( uVar13 & 0x3f ) & 1 ) == 0) {
                           if (( iVar9 != 0x1ad ) && ( iVar9 != 0x1b4 )) goto LAB_0012bdbb;
                           LAB_0012bd32:if (*(code**)( *plVar12 + 0xf0 ) == TIntermTyped::getType) {
                              plVar11 = plVar12 + 4;
                           }
 else {
                              plVar11 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
                           }

                           if (*(code**)( *plVar11 + 0x38 ) == TType::getBasicType) {
                              uVar8 = ( uint ) * (byte*)( plVar11 + 1 );
                           }
 else {
                              uVar8 = ( **(code**)( *plVar11 + 0x38 ) )();
                           }

                           if (uVar8 != 1) {
                              if (*(code**)( *plVar12 + 0xf0 ) == TIntermTyped::getType) {
                                 plVar11 = plVar12 + 4;
                              }
 else {
                                 plVar11 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
                              }

                              if (*(code**)( *plVar11 + 0x38 ) == TType::getBasicType) {
                                 uVar8 = ( uint ) * (byte*)( plVar11 + 1 );
                              }
 else {
                                 uVar8 = ( **(code**)( *plVar11 + 0x38 ) )();
                              }

                              if (uVar8 != 2) {
                                 iVar9 = *(int*)( param_3 + 0xb8 );
                                 goto LAB_0012bda4;
                              }

                           }

                           pcVar26 = *(code**)( *(long*)this + 0x28 );
                           pcVar25 = *(code**)( *(long*)param_2 + 0x18 );
                           goto joined_r0x0012d5f7;
                        }

                        if (*(code**)( *plVar12 + 0xf0 ) == TIntermTyped::getType) {
                           plVar11 = plVar12 + 4;
                        }
 else {
                           plVar11 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
                        }

                        if (*(code**)( *plVar11 + 0x38 ) == TType::getBasicType) {
                           uVar8 = ( uint ) * (byte*)( plVar11 + 1 );
                        }
 else {
                           uVar8 = ( **(code**)( *plVar11 + 0x38 ) )();
                        }

                        if (uVar8 != 3) {
                           iVar9 = *(int*)( param_3 + 0xb8 );
                           LAB_0012bd22:if (( iVar9 == 0x1ad ) || ( iVar9 == 0x1b4 )) goto LAB_0012bd32;
                           LAB_0012bda4:uVar13 = ( ulong )(iVar9 - 0x1ad);
                           goto LAB_0012bdaa;
                        }

                        plVar11 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
                        iVar9 = ( **(code**)( *plVar11 + 0x60 ) )(plVar11);
                        if (iVar9 != 2) {
                           plVar11 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
                           iVar9 = ( **(code**)( *plVar11 + 0x60 ) )(plVar11);
                           if (iVar9 != 4) {
                              iVar9 = *(int*)( param_3 + 0xb8 );
                              goto LAB_0012bd22;
                           }

                        }

                        pcVar26 = *(code**)( *(long*)this + 0x28 );
                        lVar10 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
                        ppuVar21 = &E_GL_NV_shader_atomic_fp16_vector;
                        uVar22 = *(undefined8*)( lVar10 + 8 );
                        goto LAB_0012b502;
                     }

                     LAB_0012bdaa:if (10 < (uint)uVar13) goto LAB_0012b518;
                     LAB_0012bdbb:if (( 0x68dUL >> ( uVar13 & 0x3f ) & 1 ) != 0) {
                        if (*(code**)( *plVar12 + 0xf0 ) == TIntermTyped::getType) {
                           plVar11 = plVar12 + 4;
                        }
 else {
                           plVar11 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
                        }

                        if (*(code**)( *plVar11 + 0x130 ) == TType::isFloatingDomain) {
                           if (( byte )((char)plVar11[1] - 1U) < 3) {
                              LAB_0012be1c:pcVar26 = *(code**)( *(long*)this + 0x28 );
                              lVar10 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
                              goto LAB_0012b4f7;
                           }

                        }
 else {
                           cVar6 = ( **(code**)( *plVar11 + 0x130 ) )();
                           if (cVar6 != '\0') goto LAB_0012be1c;
                        }

                     }

                     goto LAB_0012b518;
                  }

               }

               pcVar25 = *(code**)( *(long*)this + 0x28 );
               local_68._8_8_ = "GL_EXT_shader_atomic_int64";
               local_68._0_8_ = "GL_NV_shader_atomic_int64";
               if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                  lVar10 = *(long*)( param_2 + 8 );
               }
 else {
                  lVar10 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
               }

               ( *pcVar25 )(this, param_1, 2, local_68, *(undefined8*)( lVar10 + 8 ));
            }
 else {
               pcVar25 = *(code**)( *(long*)this + 0x28 );
               if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                  lVar10 = *(long*)( param_2 + 8 );
               }
 else {
                  lVar10 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
               }

               ( *pcVar25 )(this, param_1, 1, &E_GL_KHR_memory_scope_semantics, *(undefined8*)( lVar10 + 8 ));
               memorySemanticsCheck(this, param_1, param_2, param_3);
               uVar13 = ( ulong )(*(int*)( param_3 + 0xb8 ) - 0x1adU);
               if (10 < *(int*)( param_3 + 0xb8 ) - 0x1adU) goto LAB_0012b518;
               if (( 0x681UL >> ( uVar13 & 0x3f ) & 1 ) == 0) {
                  LAB_0012b47d:if (( 0x68dUL >> ( uVar13 & 0x3f ) & 1 ) != 0) {
                     if (*(code**)( *plVar12 + 0xf0 ) == TIntermTyped::getType) {
                        plVar11 = plVar12 + 4;
                     }
 else {
                        plVar11 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
                     }

                     if (*(code**)( *plVar11 + 0x130 ) == TType::isFloatingDomain) {
                        if (( byte )((char)plVar11[1] - 1U) < 3) goto LAB_0012b4d5;
                     }
 else {
                        cVar6 = ( **(code**)( *plVar11 + 0x130 ) )();
                        if (cVar6 != '\0') {
                           LAB_0012b4d5:pcVar26 = *(code**)( *(long*)this + 0x28 );
                           if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                              lVar10 = *(long*)( param_2 + 8 );
                           }
 else {
                              lVar10 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
                           }

                           LAB_0012b4f7:uVar22 = *(undefined8*)( lVar10 + 8 );
                           ppuVar21 = &E_GL_EXT_shader_atomic_float2;
                           goto LAB_0012b502;
                        }

                     }

                  }

               }
 else {
                  if (*(code**)( *plVar12 + 0xf0 ) == TIntermTyped::getType) {
                     plVar11 = plVar12 + 4;
                  }
 else {
                     plVar11 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
                  }

                  if (*(code**)( *plVar11 + 0x38 ) == TType::getBasicType) {
                     uVar8 = ( uint ) * (byte*)( plVar11 + 1 );
                  }
 else {
                     uVar8 = ( **(code**)( *plVar11 + 0x38 ) )();
                  }

                  if (uVar8 != 1) {
                     if (*(code**)( *plVar12 + 0xf0 ) == TIntermTyped::getType) {
                        plVar11 = plVar12 + 4;
                     }
 else {
                        plVar11 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
                     }

                     if (*(code**)( *plVar11 + 0x38 ) == TType::getBasicType) {
                        uVar8 = ( uint ) * (byte*)( plVar11 + 1 );
                     }
 else {
                        uVar8 = ( **(code**)( *plVar11 + 0x38 ) )();
                     }

                     if (uVar8 != 2) {
                        uVar13 = ( ulong )(*(int*)( param_3 + 0xb8 ) - 0x1adU);
                        if (10 < *(int*)( param_3 + 0xb8 ) - 0x1adU) goto LAB_0012b518;
                        goto LAB_0012b47d;
                     }

                  }

                  pcVar26 = *(code**)( *(long*)this + 0x28 );
                  pcVar25 = *(code**)( *(long*)param_2 + 0x18 );
                  joined_r0x0012d5f7:if (pcVar25 == TSymbol::getName_abi_cxx11_) {
                     lVar10 = *(long*)( param_2 + 8 );
                  }
 else {
                     lVar10 = ( *pcVar25 )(param_2);
                  }

                  uVar22 = *(undefined8*)( lVar10 + 8 );
                  ppuVar21 = &E_GL_EXT_shader_atomic_float;
                  LAB_0012b502:( *pcVar26 )(this, param_1, 1, ppuVar21, uVar22);
               }

            }

            LAB_0012b518:local_58 = (code*)0x0;
            pcStack_50 = (code*)0x0;
            local_68 = (undefined1[16])0x0;
            plVar11 = (long*)glslang::TIntermediate::traverseLValueBase(plVar12, 1, 1);
            if (local_58 != (code*)0x0) {
               ( *local_58 )(local_68, local_68, 3);
            }

            if (plVar11 == (long*)0x0) {
               pcVar25 = *(code**)( *(long*)this + 0x158 );
               if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                  lVar10 = *(long*)( param_2 + 8 );
               }
 else {
                  lVar10 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
               }

               ( *pcVar25 )(this, param_1, "Only l-values corresponding to shader block storage or shared variables can be used with atomic memory functions.", *(undefined8*)( lVar10 + 8 ), &_LC1);
               uVar8 = *(uint*)( param_3 + 0xb8 );
            }
 else {
               if (*(code**)( *plVar11 + 0xf0 ) == TIntermTyped::getType) {
                  plVar16 = plVar11 + 4;
               }
 else {
                  plVar16 = (long*)( **(code**)( *plVar11 + 0xf0 ) )(plVar11);
               }

               if (*(code**)( *plVar16 + 0x38 ) == TType::getBasicType) {
                  uVar8 = ( uint ) * (byte*)( plVar16 + 1 );
               }
 else {
                  uVar8 = ( **(code**)( *plVar16 + 0x38 ) )();
               }

               lVar10 = *plVar11;
               if (uVar8 == 0x12) {
                  if (*(code**)( lVar10 + 0xf0 ) == TIntermTyped::getType) {
                     plVar16 = plVar11 + 4;
                  }
 else {
                     plVar16 = (long*)( **(code**)( lVar10 + 0xf0 ) )(plVar11);
                  }

                  if (*(code**)( *plVar16 + 0xa8 ) == TType::getReferentType) {
                     plVar16 = (long*)plVar16[0xd];
                  }
 else {
                     plVar16 = (long*)( **(code**)( *plVar16 + 0xa8 ) )();
                  }

                  if (plVar16 == (long*)0x0) {
                     lVar10 = *plVar11;
                     goto LAB_0012b5ca;
                  }

               }
 else {
                  LAB_0012b5ca:if (*(code**)( lVar10 + 0xf0 ) == TIntermTyped::getType) {
                     plVar16 = plVar11 + 4;
                  }
 else {
                     plVar16 = (long*)( **(code**)( lVar10 + 0xf0 ) )(plVar11);
                  }

               }

               if (*(code**)( *plVar16 + 0x58 ) == TType::getQualifier) {
                  plVar16 = plVar16 + 2;
               }
 else {
                  plVar16 = (long*)( **(code**)( *plVar16 + 0x58 ) )();
               }

               if (( ( *(byte*)( plVar16 + 1 ) & 0x7e ) == 6 ) || ( ( *(byte*)( plVar16 + 1 ) & 0x7f ) == 0xf )) {
                  uVar8 = *(uint*)( param_3 + 0xb8 );
               }
 else {
                  pcVar25 = *(code**)( *(long*)this + 0x158 );
                  if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                     lVar10 = *(long*)( param_2 + 8 );
                  }
 else {
                     lVar10 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
                  }

                  ( *pcVar25 )(this, param_1, "Only l-values corresponding to shader block storage or shared variables can be used with atomic memory functions.", *(undefined8*)( lVar10 + 8 ), &_LC1);
                  uVar8 = *(uint*)( param_3 + 0xb8 );
               }

            }

         }

         goto switchD_00129e7d_caseD_25c;
      }

      switch (uVar8) {
         case 0x25b:
         case 0x274:
      glslang::TParseVersions::profileRequires
                ((TSourceLoc *)this,iVar9,-9,(char *)0x1c2,"GL_ARB_shader_texture_image_samples");
      uVar8 = *(uint *)(param_3 + 0xb8);
      break;
         case 0x260:
         case 0x261:
         case 0x262:
         case 0x263:
         case 0x264:
         case 0x265:
         case 0x266:
         case 0x267:
         case 0x268:
         case 0x269:
      if (*(code **)(*plVar12 + 0xf0) == TIntermTyped::getType) {
        plVar16 = plVar12 + 4;
      }
      else {
        plVar16 = (long *)(**(code **)(*plVar12 + 0xf0))(plVar12);
      }
      lVar10 = *plVar16;
      if (*(code **)(lVar10 + 0x40) == TType::getSampler) {
        cVar6 = (char)plVar16[0x10];
        if (cVar6 == '\b') goto LAB_0012bad3;
LAB_0012ab1b:
        if (cVar6 == '\t') goto LAB_0012bad3;
LAB_0012ab24:
        if (cVar6 == '\n') goto LAB_0012bad3;
LAB_0012ab2d:
        if (cVar6 == '\v') goto LAB_0012cb63;
        if (*(code **)(*(long *)param_3 + 0xf0) == TIntermTyped::getType) {
          pTVar18 = param_3 + 0x20;
        }
        else {
          pTVar18 = (TIntermOperator *)(**(code **)(*(long *)param_3 + 0xf0))(param_3);
        }
        if (*(code **)(*(long *)pTVar18 + 0x38) == TType::getBasicType) {
          uVar8 = (uint)(byte)pTVar18[8];
        }
        else {
          uVar8 = (**(code **)(*(long *)pTVar18 + 0x38))();
        }
        if (uVar8 != 3) {
LAB_0012ab71:
          if (*(code **)(*plVar16 + 0x40) == TType::getSampler) {
            plVar19 = plVar16 + 0x10;
          }
          else {
            plVar19 = (long *)(**(code **)(*plVar16 + 0x40))(plVar16);
          }
          pcVar26 = *(code **)(*(long *)param_2 + 0x18);
          if ((char)*plVar19 != '\x01') {
            pcVar25 = *(code **)(*(long *)this + 0x158);
            if (pcVar26 == TSymbol::getName_abi_cxx11_) {
              lVar10 = *(long *)(param_2 + 8);
            }
            else {
              lVar10 = (*pcVar26)(param_2);
            }
            uVar22 = *(undefined8 *)(lVar10 + 8);
            pcVar23 = "not supported on this image type";
            goto LAB_0012abd6;
          }
          if (pcVar26 == TSymbol::getName_abi_cxx11_) {
            lVar10 = *(long *)(param_2 + 8);
          }
          else {
            lVar10 = (*pcVar26)(param_2);
          }
          cVar6 = StartsWith(*(glslang **)(lVar10 + 8),*(basic_string **)(lVar10 + 0x10),
                             "imageAtomicExchange");
          if (cVar6 == '\0') {
            lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
            cVar6 = StartsWith(*(glslang **)(lVar10 + 8),*(basic_string **)(lVar10 + 0x10),
                               "imageAtomicAdd");
            if (cVar6 == '\0') {
              lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
              cVar6 = StartsWith(*(glslang **)(lVar10 + 8),*(basic_string **)(lVar10 + 0x10),
                                 "imageAtomicLoad");
              if (cVar6 != '\0') goto LAB_0012dda1;
              lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
              cVar6 = StartsWith(*(glslang **)(lVar10 + 8),*(basic_string **)(lVar10 + 0x10),
                                 "imageAtomicStore");
              if (cVar6 != '\0') goto LAB_0012dda1;
              lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
              cVar6 = StartsWith(*(glslang **)(lVar10 + 8),*(basic_string **)(lVar10 + 0x10),
                                 "imageAtomicMin");
              if (cVar6 == '\0') {
                lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
                cVar6 = StartsWith(*(glslang **)(lVar10 + 8),*(basic_string **)(lVar10 + 0x10),
                                   "imageAtomicMax");
                if (cVar6 == '\0') {
                  pcVar25 = *(code **)(*(long *)this + 0x158);
                  lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
                  (*pcVar25)(this,param_1,"only supported on integer images",
                             *(undefined8 *)(lVar10 + 8),&_LC1);
                  goto LAB_0012d7e9;
                }
              }
              local_140 = *(code **)(*(long *)this + 0x28);
              lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
              ppuVar21 = &E_GL_EXT_shader_atomic_float2;
              uVar22 = *(undefined8 *)(lVar10 + 8);
            }
            else {
LAB_0012dda1:
              local_140 = *(code **)(*(long *)this + 0x28);
              lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
              ppuVar21 = &E_GL_EXT_shader_atomic_float;
              uVar22 = *(undefined8 *)(lVar10 + 8);
            }
            (*local_140)(this,param_1,1,ppuVar21,uVar22);
          }
LAB_0012d7e9:
          if (*(code **)(*plVar16 + 0x58) == TType::getQualifier) {
            plVar19 = plVar16 + 2;
          }
          else {
            plVar19 = (long *)(**(code **)(*plVar16 + 0x58))(plVar16);
          }
          if ((*(char *)((long)plVar19 + 0x2c) != '\x03') && (*(int *)(this + 0xc) == 8)) {
            local_140 = *(code **)(*(long *)this + 0x158);
            lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
            pcVar23 = "only supported on image with format r32f";
            uVar22 = *(undefined8 *)(lVar10 + 8);
            goto LAB_0012d5ac;
          }
          goto LAB_0012abe6;
        }
        if (*(code **)(*(long *)param_3 + 0xf0) == TIntermTyped::getType) {
          pTVar18 = param_3 + 0x20;
        }
        else {
          pTVar18 = (TIntermOperator *)(**(code **)(*(long *)param_3 + 0xf0))(param_3);
        }
        if (*(code **)(*(long *)pTVar18 + 0x60) == TType::getVectorSize) {
          uVar8 = (byte)pTVar18[9] & 0xf;
        }
        else {
          uVar8 = (**(code **)(*(long *)pTVar18 + 0x60))();
        }
        if (uVar8 != 2) {
LAB_0012d45f:
          pTVar18 = param_3 + 0x20;
          if (*(code **)(*(long *)param_3 + 0xf0) != TIntermTyped::getType) {
            pTVar18 = (TIntermOperator *)(**(code **)(*(long *)param_3 + 0xf0))(param_3);
          }
          if (*(code **)(*(long *)pTVar18 + 0x60) == TType::getVectorSize) {
            uVar8 = (byte)pTVar18[9] & 0xf;
          }
          else {
            uVar8 = (**(code **)(*(long *)pTVar18 + 0x60))();
          }
          if (uVar8 == 4) {
            plVar19 = (long *)(**(code **)(*plVar12 + 0xf0))(plVar12);
            lVar10 = (**(code **)(*plVar19 + 0x58))(plVar19);
            if (*(char *)(lVar10 + 0x2c) == '\x02') goto LAB_0012d4c5;
          }
          goto LAB_0012ab71;
        }
        plVar19 = (long *)(**(code **)(*plVar12 + 0xf0))(plVar12);
        lVar10 = (**(code **)(*plVar19 + 0x58))(plVar19);
        if (*(char *)(lVar10 + 0x2c) != '\b') goto LAB_0012d45f;
LAB_0012d4c5:
        lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
        cVar6 = StartsWith(*(glslang **)(lVar10 + 8),*(basic_string **)(lVar10 + 0x10),
                           "imageAtomicAdd");
        if (cVar6 == '\0') {
          lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
          cVar6 = StartsWith(*(glslang **)(lVar10 + 8),*(basic_string **)(lVar10 + 0x10),
                             "imageAtomicExchange");
          if (cVar6 != '\0') goto LAB_0012e071;
          lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
          cVar6 = StartsWith(*(glslang **)(lVar10 + 8),*(basic_string **)(lVar10 + 0x10),
                             "imageAtomicMin");
          if (cVar6 != '\0') goto LAB_0012e071;
          lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
          cVar6 = StartsWith(*(glslang **)(lVar10 + 8),*(basic_string **)(lVar10 + 0x10),
                             "imageAtomicMax");
          if (cVar6 != '\0') goto LAB_0012e071;
          local_140 = *(code **)(*(long *)this + 0x158);
          lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
          pcVar23 = "f16vec2/4 operation not supported on: ";
          uVar22 = *(undefined8 *)(lVar10 + 8);
LAB_0012d5ac:
          (*local_140)(this,param_1,pcVar23,uVar22,&_LC1);
          lVar10 = *plVar16;
        }
        else {
LAB_0012e071:
          pcVar25 = *(code **)(*(long *)this + 0x28);
          lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
          (*pcVar25)(this,param_1,1,&E_GL_NV_shader_atomic_fp16_vector,*(undefined8 *)(lVar10 + 8));
          lVar10 = *plVar16;
        }
      }
      else {
        pcVar23 = (char *)(**(code **)(lVar10 + 0x40))(plVar16);
        if (*pcVar23 != '\b') {
          lVar10 = *plVar16;
          if (*(code **)(lVar10 + 0x40) == TType::getSampler) {
            cVar6 = (char)plVar16[0x10];
            goto LAB_0012ab1b;
          }
          pcVar23 = (char *)(**(code **)(lVar10 + 0x40))(plVar16);
          if (*pcVar23 != '\t') {
            lVar10 = *plVar16;
            if (*(code **)(lVar10 + 0x40) == TType::getSampler) {
              cVar6 = (char)plVar16[0x10];
              goto LAB_0012ab24;
            }
            pcVar23 = (char *)(**(code **)(lVar10 + 0x40))(plVar16);
            lVar10 = *plVar16;
            if (*pcVar23 == '\n') goto LAB_0012bad3;
            if (*(code **)(lVar10 + 0x40) == TType::getSampler) {
              cVar6 = (char)plVar16[0x10];
            }
            else {
              pcVar23 = (char *)(**(code **)(lVar10 + 0x40))(plVar16);
              cVar6 = *pcVar23;
            }
            goto LAB_0012ab2d;
          }
        }
LAB_0012cb63:
        lVar10 = *plVar16;
LAB_0012bad3:
        if (*(code **)(lVar10 + 0x58) == TType::getQualifier) {
          cVar6 = *(char *)((long)plVar16 + 0x3c);
          if (cVar6 != '\x1a') {
LAB_0012baf5:
            if (cVar6 != '&') {
LAB_0012baf9:
              if (cVar6 != '!') {
LAB_0012bafd:
                if (cVar6 != '.') {
                  pcVar25 = *(code **)(*(long *)this + 0x158);
                  if (*(code **)(*(long *)param_2 + 0x18) == TSymbol::getName_abi_cxx11_) {
                    lVar10 = *(long *)(param_2 + 8);
                  }
                  else {
                    lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
                  }
                  (*pcVar25)(this,param_1,"only supported on image with format r32i or r32ui",
                             *(undefined8 *)(lVar10 + 8),&_LC1);
                }
              }
            }
          }
        }
        else {
          lVar10 = (**(code **)(lVar10 + 0x58))(plVar16);
          if (*(char *)(lVar10 + 0x2c) != '\x1a') {
            if (*(code **)(*plVar16 + 0x58) == TType::getQualifier) {
              cVar6 = *(char *)((long)plVar16 + 0x3c);
              goto LAB_0012baf5;
            }
            lVar10 = (**(code **)(*plVar16 + 0x58))(plVar16);
            if (*(char *)(lVar10 + 0x2c) != '&') {
              if (*(code **)(*plVar16 + 0x58) == TType::getQualifier) {
                cVar6 = *(char *)((long)plVar16 + 0x3c);
                goto LAB_0012baf9;
              }
              lVar10 = (**(code **)(*plVar16 + 0x58))(plVar16);
              if (*(char *)(lVar10 + 0x2c) != '!') {
                if (*(code **)(*plVar16 + 0x58) == TType::getQualifier) {
                  cVar6 = *(char *)((long)plVar16 + 0x3c);
                }
                else {
                  lVar10 = (**(code **)(*plVar16 + 0x58))(plVar16);
                  cVar6 = *(char *)(lVar10 + 0x2c);
                }
                goto LAB_0012bafd;
              }
            }
          }
        }
        if (*(code **)(*(long *)param_3 + 0xf0) == TIntermTyped::getType) {
          pTVar18 = param_3 + 0x20;
        }
        else {
          pTVar18 = (TIntermOperator *)(**(code **)(*(long *)param_3 + 0xf0))(param_3);
        }
        if (*(code **)(*(long *)pTVar18 + 0x38) == TType::getBasicType) {
          uVar8 = (uint)(byte)pTVar18[8];
        }
        else {
          uVar8 = (**(code **)(*(long *)pTVar18 + 0x38))();
        }
        if (uVar8 == 10) {
          if (*(code **)(*plVar16 + 0x58) == TType::getQualifier) {
            plVar19 = plVar16 + 2;
          }
          else {
            plVar19 = (long *)(**(code **)(*plVar16 + 0x58))(plVar16);
          }
          if (*(char *)((long)plVar19 + 0x2c) == '!') goto LAB_0012bb9b;
          pcVar25 = *(code **)(*(long *)this + 0x158);
          if (*(code **)(*(long *)param_2 + 0x18) == TSymbol::getName_abi_cxx11_) {
            lVar10 = *(long *)(param_2 + 8);
          }
          else {
            lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
          }
          uVar22 = *(undefined8 *)(lVar10 + 8);
          pcVar23 = "only supported on image with format r64i";
LAB_0012abd6:
          (*pcVar25)(this,param_1,pcVar23,uVar22,&_LC1);
        }
        else {
LAB_0012bb9b:
          pTVar18 = param_3 + 0x20;
          if (*(code **)(*(long *)param_3 + 0xf0) != TIntermTyped::getType) {
            pTVar18 = (TIntermOperator *)(**(code **)(*(long *)param_3 + 0xf0))(param_3);
          }
          if (*(code **)(*(long *)pTVar18 + 0x38) == TType::getBasicType) {
            uVar8 = (uint)(byte)pTVar18[8];
          }
          else {
            uVar8 = (**(code **)(*(long *)pTVar18 + 0x38))();
          }
          lVar10 = *plVar16;
          if (uVar8 != 0xb) goto LAB_0012abe9;
          if (*(code **)(lVar10 + 0x58) == TType::getQualifier) {
            plVar19 = plVar16 + 2;
          }
          else {
            plVar19 = (long *)(**(code **)(lVar10 + 0x58))(plVar16);
          }
          if (*(char *)((long)plVar19 + 0x2c) != '.') {
            pcVar25 = *(code **)(*(long *)this + 0x158);
            if (*(code **)(*(long *)param_2 + 0x18) == TSymbol::getName_abi_cxx11_) {
              lVar10 = *(long *)(param_2 + 8);
            }
            else {
              lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
            }
            uVar22 = *(undefined8 *)(lVar10 + 8);
            pcVar23 = "only supported on image with format r64ui";
            goto LAB_0012abd6;
          }
        }
LAB_0012abe6:
        lVar10 = *plVar16;
      }
LAB_0012abe9:
      if (*(code **)(lVar10 + 0x40) == TType::getSampler) {
        plVar16 = plVar16 + 0x10;
      }
      else {
        plVar16 = (long *)(**(code **)(lVar10 + 0x40))(plVar16);
      }
      if (5 - (ulong)((*(byte *)((long)plVar16 + 2) >> 2 & 1) == 0) <
          (ulong)(plVar11[2] - plVar11[1] >> 3)) {
        pcVar25 = *(code **)(*(long *)this + 0x28);
        if (*(code **)(*(long *)param_2 + 0x18) == TSymbol::getName_abi_cxx11_) {
          lVar10 = *(long *)(param_2 + 8);
        }
        else {
          lVar10 = (**(code **)(*(long *)param_2 + 0x18))(param_2);
        }
        (*pcVar25)(this,param_1,1,&E_GL_KHR_memory_scope_semantics,*(undefined8 *)(lVar10 + 8));
        memorySemanticsCheck(this,param_1,param_2,param_3);
        uVar8 = *(uint *)(param_3 + 0xb8);
      }
      else {
        uVar8 = *(uint *)(param_3 + 0xb8);
      }
      break;
         case 0x276:
         case 0x278:
      if (*(code **)(*(long *)param_2 + 0x120) != TFunction::getParamCount) {
        iVar7 = (**(code **)(*(long *)param_2 + 0x120))(param_2);
        if (2 < iVar7) goto LAB_0012b132;
        uVar8 = *(uint *)(param_3 + 0xb8);
        break;
      }
      if (2 < (int)(*(long *)(param_2 + 0x38) - *(long *)(param_2 + 0x30) >> 3) * -0x55555555) {
LAB_0012b132:
        plVar16 = (long *)(**(code **)(**(long **)(plVar11[1] + 8) + 0x18))();
        if (*(code **)(*plVar16 + 0xf0) == TIntermTyped::getType) {
          plVar16 = plVar16 + 4;
        }
        else {
          plVar16 = (long *)(**(code **)(*plVar16 + 0xf0))();
        }
        if (*(code **)(*plVar16 + 0x38) == TType::getBasicType) {
          uVar8 = (uint)*(byte *)(plVar16 + 1);
        }
        else {
          uVar8 = (**(code **)(*plVar16 + 0x38))();
        }
        if (uVar8 == 1) {
          plVar11 = (long *)(**(code **)(**(long **)(plVar11[1] + 8) + 0x18))();
          if (*(code **)(*plVar11 + 0xf0) == TIntermTyped::getType) {
            plVar11 = plVar11 + 4;
          }
          else {
            plVar11 = (long *)(**(code **)(*plVar11 + 0xf0))();
          }
          if (*(code **)(*plVar11 + 0x60) == TType::getVectorSize) {
            uVar8 = *(byte *)((long)plVar11 + 9) & 0xf;
          }
          else {
            uVar8 = (**(code **)(*plVar11 + 0x60))();
          }
          if (uVar8 == 4) {
            if (*(code **)(*(long *)param_2 + 0x140) == TFunction::operator[]) {
              lVar10 = *(long *)(param_2 + 0x30);
            }
            else {
              lVar10 = (**(code **)(*(long *)param_2 + 0x140))(param_2,0);
            }
            pcVar25 = *(code **)(**(long **)(lVar10 + 8) + 0x48);
            if (pcVar25 == TType::getSampler) {
              plVar11 = *(long **)(lVar10 + 8) + 0x10;
            }
            else {
              plVar11 = (long *)(*pcVar25)();
            }
            if ((*plVar11 & 0x20000) == 0) {
              uVar8 = *(uint *)(param_3 + 0xb8);
            }
            else {
              pbVar17 = (basic_string *)(**(code **)(*(long *)param_2 + 0x18))(param_2);
              std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>
              ::_M_assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *
                          )&local_f8,pbVar17);
              if (*(int *)(param_3 + 0xb8) == 0x276) {
                std::__cxx11::
                basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append
                          ((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>
                            *)&local_f8,"(..., float bias)");
              }
              else {
                std::__cxx11::
                basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append
                          ((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>
                            *)&local_f8,"(..., float lod)");
              }
              puVar5 = local_f0;
              lVar10 = (**(code **)(*(long *)param_2 + 0x140))(param_2,0);
              lVar10 = (**(code **)(**(long **)(lVar10 + 8) + 0x48))();
              if (*(char *)(lVar10 + 1) == '\x02') {
                lVar10 = (**(code **)(*(long *)param_2 + 0x140))(param_2,0);
                lVar10 = (**(code **)(**(long **)(lVar10 + 8) + 0x48))();
                if ((*(byte *)(lVar10 + 2) & 1) == 0) goto LAB_0012dd32;
LAB_0012e2fc:
                (**(code **)(*(long *)this + 0x28))(this,param_1,1,&E_GL_EXT_texture_shadow_lod);
                if (*(int *)(this + 0xc) == 8) {
                  if ((*(int *)(this + 0x18) < 0x140) &&
                     (cVar6 = (**(code **)(*(long *)this + 0x48))(this,2,AEP_texture_cube_map_array)
                     , cVar6 == '\0')) {
                    (**(code **)(*(long *)this + 0x158))
                              (this,param_1,
                               "GL_EXT_texture_shadow_lod not supported for this ES version",puVar5,
                               &_LC1);
                    uVar8 = *(uint *)(param_3 + 0xb8);
                  }
                  else {
                    glslang::TParseVersions::profileRequires
                              ((TSourceLoc *)this,iVar9,8,(char *)0x140,(char *)0x0);
                    uVar8 = *(uint *)(param_3 + 0xb8);
                  }
                }
                else {
                  glslang::TParseVersions::profileRequires
                            ((TSourceLoc *)this,iVar9,-9,(char *)0x82,(char *)0x0);
                  uVar8 = *(uint *)(param_3 + 0xb8);
                }
              }
              else {
LAB_0012dd32:
                lVar10 = (**(code **)(*(long *)param_2 + 0x140))(param_2,0);
                lVar10 = (**(code **)(**(long **)(lVar10 + 8) + 0x48))();
                if (*(char *)(lVar10 + 1) == '\x04') {
                  lVar10 = (**(code **)(*(long *)param_2 + 0x140))(param_2,0);
                  lVar10 = (**(code **)(**(long **)(lVar10 + 8) + 0x48))();
                  if (((*(byte *)(lVar10 + 2) & 1) != 0) &&
                     (iVar7 = (**(code **)(*(long *)param_2 + 0x120))(param_2), 3 < iVar7))
                  goto LAB_0012e2fc;
                }
                lVar10 = (**(code **)(*(long *)param_2 + 0x140))(param_2,0);
                lVar10 = (**(code **)(**(long **)(lVar10 + 8) + 0x48))();
                if (*(char *)(lVar10 + 1) == '\x04') {
                  uVar8 = *(uint *)(param_3 + 0xb8);
                  if (uVar8 == 0x278) goto LAB_0012e2fc;
                }
                else {
                  uVar8 = *(uint *)(param_3 + 0xb8);
                }
              }
            }
          }
          else {
            uVar8 = *(uint *)(param_3 + 0xb8);
          }
        }
        else {
          uVar8 = *(uint *)(param_3 + 0xb8);
        }
        break;
      }
      goto LAB_0012a378;
      }

      goto switchD_00129e7d_caseD_25c;
   }

   uVar20 = uVar8 - 0x279;
   if (0x22 < uVar20) goto switchD_00129e7d_caseD_25c;
   uVar13 = 1L << ( (byte)uVar20 & 0x3f );
   if (( uVar13 & 0x55d ) == 0) {
      if (( uVar13 & 0x700000000 ) == 0) {
         if (( uVar13 & 0x3800 ) != 0) {
            if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
               pbVar17 = *(basic_string**)( param_2 + 8 );
            }
 else {
               pbVar17 = (basic_string*)( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
            }

            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_f8, pbVar17);
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_f8, "(...)");
            puVar5 = local_f0;
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar9, 8, (char*)0x136, (char*)0x0);
            uVar8 = *(uint*)( param_3 + 0xb8 );
            if (uVar8 == 0x285) {
               if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                  lVar10 = *(long*)( param_2 + 0x30 );
               }
 else {
                  lVar10 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
               }

               pcVar25 = *(code**)( **(long**)( lVar10 + 8 ) + 0x48 );
               if (pcVar25 == TType::getSampler) {
                  plVar16 = *(long**)( lVar10 + 8 ) + 0x10;
               }
 else {
                  plVar16 = (long*)( *pcVar25 )();
               }

               if (*(char*)( (long)plVar16 + 1 ) == '\x02') {
                  if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                     lVar10 = *(long*)( param_2 + 0x30 );
                  }
 else {
                     lVar10 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
                  }

                  pcVar25 = *(code**)( **(long**)( lVar10 + 8 ) + 0x48 );
                  if (pcVar25 == TType::getSampler) {
                     plVar16 = *(long**)( lVar10 + 8 ) + 0x10;
                  }
 else {
                     plVar16 = (long*)( *pcVar25 )();
                  }

                  if (( *plVar16 & 0x20000 ) != 0) goto LAB_0012c8fc;
                  if (*(code**)( *(long*)param_2 + 0x120 ) == TFunction::getParamCount) {
                     iVar7 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
                  }
 else {
                     iVar7 = ( **(code**)( *(long*)param_2 + 0x120 ) )(param_2);
                  }

                  if (iVar7 != 3) goto LAB_0012c8fc;
                  pcVar23 = "GL_ARB_texture_gather";
               }
 else {
                  LAB_0012c8fc:pcVar23 = "GL_ARB_gpu_shader5";
               }

               glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar9, -9, (char*)0x190, pcVar23);
               if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                  lVar10 = *(long*)( param_2 + 0x30 );
               }
 else {
                  lVar10 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
               }

               pcVar25 = *(code**)( **(long**)( lVar10 + 8 ) + 0x48 );
               if (pcVar25 == TType::getSampler) {
                  plVar16 = *(long**)( lVar10 + 8 ) + 0x10;
               }
 else {
                  plVar16 = (long*)( *pcVar25 )();
               }

               lVar10 = ( **(code**)( **(long**)( plVar11[1] + 0x10 + ( ulong )(*(byte*)( (long)plVar16 + 2 ) >> 1 & 1) * 8 ) + 0x28 ) )();
               if (lVar10 == 0) {
                  glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar9, 8, 0x140, (char**)0x2, AEP_gpu_shader5);
               }

               if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                  lVar10 = *(long*)( param_2 + 0x30 );
               }
 else {
                  lVar10 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
               }

               pcVar25 = *(code**)( **(long**)( lVar10 + 8 ) + 0x48 );
               if (pcVar25 == TType::getSampler) {
                  plVar16 = *(long**)( lVar10 + 8 ) + 0x10;
               }
 else {
                  plVar16 = (long*)( *pcVar25 )();
               }

               if (( *plVar16 & 0x20000 ) == 0) {
                  LAB_0012c831:lVar10 = 3;
                  LAB_0012a128:if (*(code**)( *(long*)param_2 + 0x120 ) == TFunction::getParamCount) {
                     iVar7 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
                  }
 else {
                     iVar7 = ( **(code**)( *(long*)param_2 + 0x120 ) )(param_2);
                     lVar10 = (long)(int)lVar10;
                  }

                  if ((int)lVar10 < iVar7) {
                     lVar14 = ( **(code**)( **(long**)( plVar11[1] + lVar10 * 8 ) + 0x28 ) )();
                     if (lVar14 == 0) {
                        lVar10 = *(long*)this;
                        pcVar23 = "must be a compile-time constant:";
                     }
 else {
                        lVar10 = ( **(code**)( **(long**)( plVar11[1] + lVar10 * 8 ) + 0x28 ) )();
                        if (**(uint**)( *(long*)( lVar10 + 0xc0 ) + 8 ) < 4) goto LAB_0012a1c0;
                        lVar10 = *(long*)this;
                        pcVar23 = "must be 0, 1, 2, or 3:";
                     }

                     ( **(code**)( lVar10 + 0x158 ) )(this, param_1, pcVar23, puVar5);
                  }

               }

               LAB_0012a1c0:uVar8 = *(uint*)( param_3 + 0xb8 );
            }
 else {
               if (uVar8 == 0x286) {
                  glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar9, -9, (char*)0x190, "GL_ARB_gpu_shader5");
                  if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                     lVar10 = *(long*)( param_2 + 0x30 );
                  }
 else {
                     lVar10 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
                  }

                  pcVar25 = *(code**)( **(long**)( lVar10 + 8 ) + 0x48 );
                  if (pcVar25 == TType::getSampler) {
                     plVar16 = *(long**)( lVar10 + 8 ) + 0x10;
                  }
 else {
                     plVar16 = (long*)( *pcVar25 )();
                  }

                  bVar2 = *(byte*)( (long)plVar16 + 2 );
                  if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                     lVar10 = *(long*)( param_2 + 0x30 );
                  }
 else {
                     lVar10 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
                  }

                  pcVar25 = *(code**)( **(long**)( lVar10 + 8 ) + 0x48 );
                  if (pcVar25 == TType::getSampler) {
                     plVar16 = *(long**)( lVar10 + 8 ) + 0x10;
                  }
 else {
                     plVar16 = (long*)( *pcVar25 )();
                  }

                  lVar10 = ( **(code**)( **(long**)( plVar11[1] + 0x10 + ( ulong )(*(byte*)( (long)plVar16 + 2 ) >> 1 & 1) * 8 ) + 0x28 ) )();
                  if (lVar10 == 0) {
                     ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "must be a compile-time constant:", puVar5);
                  }

                  if (0 < (int)( ( -(uint)((bVar2 >> 1 & 1) == 0) & 4 ) - 1 )) goto LAB_0012c831;
                  goto LAB_0012a1c0;
               }

               if (uVar8 != 0x284) goto switchD_00129e7d_caseD_25c;
               if (*(code**)( *(long*)param_2 + 0x120 ) == TFunction::getParamCount) {
                  iVar7 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
               }
 else {
                  iVar7 = ( **(code**)( *(long*)param_2 + 0x120 ) )(param_2);
               }

               if (2 < iVar7) {
                  LAB_0012a0af:glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar9, -9, (char*)0x190, "GL_ARB_gpu_shader5");
                  if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                     lVar10 = *(long*)( param_2 + 0x30 );
                  }
 else {
                     lVar10 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
                  }

                  pcVar25 = *(code**)( **(long**)( lVar10 + 8 ) + 0x48 );
                  if (pcVar25 == TType::getSampler) {
                     plVar16 = *(long**)( lVar10 + 8 ) + 0x10;
                  }
 else {
                     plVar16 = (long*)( *pcVar25 )();
                  }

                  if (( *plVar16 & 0x20000 ) != 0) goto LAB_0012a1c0;
                  lVar10 = 2;
                  goto LAB_0012a128;
               }

               if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                  lVar10 = *(long*)( param_2 + 0x30 );
               }
 else {
                  lVar10 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
               }

               pcVar25 = *(code**)( **(long**)( lVar10 + 8 ) + 0x48 );
               if (pcVar25 == TType::getSampler) {
                  plVar16 = *(long**)( lVar10 + 8 ) + 0x10;
               }
 else {
                  plVar16 = (long*)( *pcVar25 )();
               }

               if (*(char*)( (long)plVar16 + 1 ) == '\x05') goto LAB_0012a0af;
               if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                  lVar10 = *(long*)( param_2 + 0x30 );
               }
 else {
                  lVar10 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
               }

               pcVar25 = *(code**)( **(long**)( lVar10 + 8 ) + 0x48 );
               if (pcVar25 == TType::getSampler) {
                  plVar16 = *(long**)( lVar10 + 8 ) + 0x10;
               }
 else {
                  plVar16 = (long*)( *pcVar25 )();
               }

               if (( *plVar16 & 0x20000 ) != 0) goto LAB_0012a0af;
               glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar9, -9, (char*)0x190, "GL_ARB_texture_gather");
               uVar8 = *(uint*)( param_3 + 0xb8 );
            }

            if (uVar8 == 0x284) {
               if (*(code**)( *(long*)param_2 + 0x120 ) == TFunction::getParamCount) {
                  iVar7 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
               }
 else {
                  iVar7 = ( **(code**)( *(long*)param_2 + 0x120 ) )(param_2);
               }

               if (iVar7 < 4) {
                  LAB_0012b345:uVar8 = *(uint*)( param_3 + 0xb8 );
               }
 else {
                  LAB_0012a208:if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                     pbVar17 = *(basic_string**)( param_2 + 8 );
                  }
 else {
                     pbVar17 = (basic_string*)( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
                  }

                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_f8, pbVar17);
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_f8, "with bias argument");
                  puVar5 = local_f0;
                  glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar9, -9, (char*)0x1c2, (char*)0x0);
                  ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_AMD_texture_gather_bias_lod, puVar5);
                  uVar8 = *(uint*)( param_3 + 0xb8 );
               }

            }
 else if (uVar8 - 0x285 < 2) {
               if (*(code**)( *(long*)param_2 + 0x120 ) == TFunction::getParamCount) {
                  iVar7 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
               }
 else {
                  iVar7 = ( **(code**)( *(long*)param_2 + 0x120 ) )(param_2);
               }

               if (iVar7 < 5) goto LAB_0012b345;
               goto LAB_0012a208;
            }

         }

      }
 else {
         pcVar25 = *(code**)( *(long*)param_2 + 0x120 );
         if (uVar8 == 0x299) {
            if (pcVar25 == TFunction::getParamCount) {
               iVar7 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
            }
 else {
               iVar7 = ( *pcVar25 )(param_2);
            }

            bVar24 = 4 < iVar7;
         }
 else {
            if (pcVar25 == TFunction::getParamCount) {
               iVar7 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
            }
 else {
               iVar7 = ( *pcVar25 )(param_2);
            }

            bVar24 = 5 < iVar7;
         }

         if (bVar24) {
            if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
               pbVar17 = *(basic_string**)( param_2 + 8 );
            }
 else {
               pbVar17 = (basic_string*)( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
            }

            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_f8, pbVar17);
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_f8, "with bias argument");
            puVar5 = local_f0;
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar9, -9, (char*)0x1c2, (char*)0x0);
            ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_AMD_texture_gather_bias_lod, puVar5);
         }

         uVar8 = *(uint*)( param_3 + 0xb8 );
         if (uVar8 == 0x29b) {
            if (*(code**)( *plVar12 + 0xf0 ) == TIntermTyped::getType) {
               plVar16 = plVar12 + 4;
            }
 else {
               plVar16 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
            }

            if (*(code**)( *plVar16 + 0x40 ) == TType::getSampler) {
               plVar16 = plVar16 + 0x10;
            }
 else {
               plVar16 = (long*)( **(code**)( *plVar16 + 0x40 ) )();
            }

            lVar10 = ( **(code**)( **(long**)( plVar11[1] + 0x10 + ( ulong )(*(byte*)( (long)plVar16 + 2 ) >> 1 & 1) * 8 ) + 0x28 ) )();
            if (lVar10 == 0) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "argument must be compile-time constant", "offsets", &_LC1);
               uVar8 = *(uint*)( param_3 + 0xb8 );
            }
 else {
               uVar8 = *(uint*)( param_3 + 0xb8 );
            }

         }

      }

      goto switchD_00129e7d_caseD_25c;
   }

   switch (uVar20) {
      default:
    goto switchD_00129e7d_caseD_25c;
      case 2:
    if (*(code **)(*plVar12 + 0xf0) == TIntermTyped::getType) {
      plVar16 = plVar12 + 4;
    }
    else {
      plVar16 = (long *)(**(code **)(*plVar12 + 0xf0))(plVar12);
    }
    if (*(code **)(*plVar16 + 0x40) == TType::getSampler) {
      plVar16 = plVar16 + 0x10;
    }
    else {
      plVar16 = (long *)(**(code **)(*plVar16 + 0x40))();
    }
    if (*(char *)((long)plVar16 + 1) != '\x05') goto switchD_0012b927_caseD_4;
      case 0:
      case 3:
    local_140._0_4_ = 2;
    break;
      case 4:
      case 6:
switchD_0012b927_caseD_4:
    local_140._0_4_ = 3;
    break;
      case 8:
      case 10:
    local_140._0_4_ = 4;
   }

   plVar16 = (long*)( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x18 ) )();
   if (*(code**)( *plVar16 + 0x100 ) == TIntermTyped::getBasicType) {
      uVar8 = ( uint ) * (byte*)( plVar16 + 5 );
   }
 else {
      uVar8 = ( **(code**)( *plVar16 + 0x100 ) )();
   }

   if (uVar8 == 3) {
      if (*(code**)( *plVar12 + 0xf0 ) == TIntermTyped::getType) {
         plVar16 = plVar12 + 4;
      }
 else {
         plVar16 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
      }

      if (*(code**)( *plVar16 + 0x40 ) == TType::getSampler) {
         plVar16 = plVar16 + 0x10;
      }
 else {
         plVar16 = (long*)( **(code**)( *plVar16 + 0x40 ) )();
      }

      local_140._0_4_ = ( (int)local_140 + 1 ) - ( uint )(( *(byte*)( (long)plVar16 + 2 ) >> 1 & 1 ) == 0);
   }

   lVar10 = (long)(int)local_140;
   plVar16 = (long*)( **(code**)( **(long**)( plVar11[1] + lVar10 * 8 ) + 0x18 ) )();
   if (*(code**)( *plVar16 + 0x108 ) == TIntermTyped::getQualifier) {
      plVar16 = plVar16 + 6;
   }
 else {
      plVar16 = (long*)( **(code**)( *plVar16 + 0x108 ) )(plVar16);
   }

   if (( ( *(byte*)( plVar16 + 1 ) & 0x7f ) == 2 ) || ( ( *(byte*)( (long)plVar16 + 0xc ) & 1 ) != 0 )) {
      lVar14 = ( **(code**)( **(long**)( plVar11[1] + lVar10 * 8 ) + 0x28 ) )();
      if (lVar14 != 0) {
         plVar16 = (long*)( **(code**)( **(long**)( plVar11[1] + lVar10 * 8 ) + 0x18 ) )();
         if (*(code**)( *plVar16 + 0xf0 ) == TIntermTyped::getType) {
            plVar16 = plVar16 + 4;
         }
 else {
            plVar16 = (long*)( **(code**)( *plVar16 + 0xf0 ) )();
         }

         lVar14 = 0;
         while (true) {
            if (*(code**)( *plVar16 + 0x60 ) == TType::getVectorSize) {
               uVar8 = *(byte*)( (long)plVar16 + 9 ) & 0xf;
            }
 else {
               uVar8 = ( **(code**)( *plVar16 + 0x60 ) )(plVar16);
            }

            if ((int)uVar8 <= (int)lVar14) break;
            lVar15 = ( **(code**)( **(long**)( plVar11[1] + lVar10 * 8 ) + 0x28 ) )();
            iVar7 = *(int*)( lVar14 * 0x10 + *(long*)( *(long*)( lVar15 + 0xc0 ) + 8 ) );
            if (( *(int*)( this + 0x608 ) < iVar7 ) || ( iVar7 < *(int*)( this + 0x604 ) )) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "value is out of range:", "texel offset");
            }

            lVar14 = lVar14 + 1;
         }
;
      }

   }
 else {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "argument must be compile-time constant", "texel offset");
   }

   uVar8 = *(uint*)( param_3 + 0xb8 );
   if (uVar8 == 0x279) {
      if (*(code**)( *plVar12 + 0xf0 ) == TIntermTyped::getType) {
         plVar16 = plVar12 + 4;
      }
 else {
         plVar16 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
      }

      if (*(code**)( *plVar16 + 0x40 ) == TType::getSampler) {
         plVar16 = plVar16 + 0x10;
      }
 else {
         plVar16 = (long*)( **(code**)( *plVar16 + 0x40 ) )();
      }

      if (( ( *(byte*)( (long)plVar16 + 2 ) >> 1 & *(byte*)( (long)plVar16 + 2 ) & 1 ) != 0 ) && ( *(char*)( (long)plVar16 + 1 ) == '\x02' )) {
         plVar16 = (long*)( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x18 ) )();
         plVar16 = (long*)( **(code**)( *plVar16 + 0xf0 ) )(plVar16);
         iVar7 = ( **(code**)( *plVar16 + 0x38 ) )(plVar16);
         if (iVar7 == 1) {
            plVar16 = (long*)( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x18 ) )();
            plVar16 = (long*)( **(code**)( *plVar16 + 0xf0 ) )(plVar16);
            iVar7 = ( **(code**)( *plVar16 + 0x60 ) )(plVar16);
            if (( iVar7 == 4 ) && ( iVar7 = ( **(code**)( *(long*)param_2 + 0x120 ) )(param_2) ),iVar7 == 4) {
               pcVar23 = (char*)( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
               std::operator +((basic_string*)local_68, pcVar23);
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::operator =((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_f8, (basic_string*)local_68);
               ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_EXT_texture_shadow_lod);
               glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar9, 8, (char*)0x12c, (char*)0x0);
               glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar9, -9, (char*)0x82, (char*)0x0);
               uVar8 = *(uint*)( param_3 + 0xb8 );
               goto LAB_0012ba0a;
            }

         }

         if (*(int*)( this + 0xc ) == 8) {
            lVar10 = *(long*)this;
         }
 else {
            if (0x1a4 < *(int*)( this + 0x18 )) goto LAB_0012c743;
            lVar10 = *(long*)this;
         }

         ( **(code**)( lVar10 + 0x158 ) )(this, param_1, "TextureOffset does not support sampler2DArrayShadow : ", "sampler");
      }

      LAB_0012c743:uVar8 = *(uint*)( param_3 + 0xb8 );
   }

   LAB_0012ba0a:if (uVar8 == 0x27d) {
      if (*(code**)( *plVar12 + 0xf0 ) == TIntermTyped::getType) {
         plVar16 = plVar12 + 4;
      }
 else {
         plVar16 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
      }

      if (*(code**)( *plVar16 + 0x40 ) == TType::getSampler) {
         plVar16 = plVar16 + 0x10;
      }
 else {
         plVar16 = (long*)( **(code**)( *plVar16 + 0x40 ) )();
      }

      if (( ( *(byte*)( (long)plVar16 + 2 ) >> 1 & *(byte*)( (long)plVar16 + 2 ) & 1 ) == 0 ) || ( *(char*)( (long)plVar16 + 1 ) != '\x02' )) {
         uVar8 = *(uint*)( param_3 + 0xb8 );
      }
 else {
         plVar16 = (long*)( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x18 ) )();
         plVar16 = (long*)( **(code**)( *plVar16 + 0xf0 ) )(plVar16);
         iVar7 = ( **(code**)( *plVar16 + 0x38 ) )(plVar16);
         if (iVar7 == 1) {
            plVar11 = (long*)( **(code**)( **(long**)( plVar11[1] + 8 ) + 0x18 ) )();
            plVar11 = (long*)( **(code**)( *plVar11 + 0xf0 ) )(plVar11);
            iVar7 = ( **(code**)( *plVar11 + 0x60 ) )(plVar11);
            if (iVar7 == 4) {
               iVar7 = ( **(code**)( *(long*)param_2 + 0x120 ) )(param_2);
               if (iVar7 == 4) {
                  pcVar23 = (char*)( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
                  std::operator +((basic_string*)local_68, pcVar23);
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::operator =((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_f8, (basic_string*)local_68);
                  puVar5 = local_f0;
                  glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar9, 8, (char*)0x12c, (char*)0x0);
                  glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar9, -9, (char*)0x82, (char*)0x0);
                  ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_EXT_texture_shadow_lod, puVar5);
                  uVar8 = *(uint*)( param_3 + 0xb8 );
               }
 else {
                  uVar8 = *(uint*)( param_3 + 0xb8 );
               }

            }
 else {
               uVar8 = *(uint*)( param_3 + 0xb8 );
            }

         }
 else {
            uVar8 = *(uint*)( param_3 + 0xb8 );
         }

      }

   }

   switchD_00129e7d_caseD_25c:if (uVar8 - 0x271 < 0xb) {
      if (( 0x60dUL >> ( ( ulong )(uVar8 - 0x271) & 0x3f ) & 1 ) == 0) goto LAB_00129da0;
      if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
         lVar10 = *(long*)( param_2 + 0x30 );
      }
 else {
         lVar10 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
      }

      pcVar25 = *(code**)( **(long**)( lVar10 + 8 ) + 0x48 );
      if (pcVar25 == TType::getSampler) {
         plVar11 = *(long**)( lVar10 + 8 ) + 0x10;
      }
 else {
         plVar11 = (long*)( *pcVar25 )();
      }

      lVar10 = *plVar11;
      uVar8 = *(uint*)( param_3 + 0xb8 );
      if (( ( ( lVar10 & 0x200000 ) == 0 ) && ( ( lVar10 & 0x80000 ) == 0 ) ) && ( ( lVar10 & 0x100000 ) == 0 )) {
         if (( *(char*)( (long)plVar11 + 1 ) == '\x06' ) && ( uVar8 - 0x27a < 2 )) goto LAB_00129da0;
         pcVar25 = *(code**)( *(long*)this + 0x28 );
         if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            lVar10 = *(long*)( param_2 + 8 );
         }
 else {
            lVar10 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
         }

         ( *pcVar25 )(this, param_1, 1, &E_GL_EXT_samplerless_texture_functions, *(undefined8*)( lVar10 + 8 ));
         uVar8 = *(uint*)( param_3 + 0xb8 );
      }

   }

   LAB_0012a378:if (uVar8 - 0x142 < 0x51) {
      LAB_0012a387:if (*(int*)( this + 0x20 ) - 1U < 0x102ff) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "requires SPIR-V 1.3", "subgroup op", &_LC1);
      }

      if (plVar12 != (long*)0x0) {
         if (*(code**)( *plVar12 + 0xf0 ) == TIntermTyped::getType) {
            plVar12 = plVar12 + 4;
         }
 else {
            plVar12 = (long*)( **(code**)( *plVar12 + 0xf0 ) )(plVar12);
         }

         uVar1 = *(undefined1*)( *(long*)( this + 0x38 ) + 0x26f );
         if (*(code**)( *plVar12 + 0x38 ) == TType::getBasicType) {
            uVar8 = ( uint ) * (byte*)( plVar12 + 1 );
         }
 else {
            uVar8 = ( **(code**)( *plVar12 + 0x38 ) )(plVar12);
         }

         if (uVar8 < 8) {
            if (uVar8 < 6) {
               if (uVar8 == 3) {
                  local_138 = *(code**)( *(long*)this + 0x28 );
                  local_98 = (undefined1**)glslang::GetThreadPoolAllocator();
                  local_90 = local_80;
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
                  local_c8 = glslang::GetThreadPoolAllocator();
                  local_c0 = local_b0;
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_c8, &_LC1, &_LC1);
                  TType::getCompleteString(local_68, plVar12, uVar1, 1, 1, 1, &local_c8);
                  ppuVar21 = &E_GL_EXT_shader_subgroup_extended_types_float16;
               }
 else {
                  if (1 < uVar8 - 4) goto LAB_00129da0;
                  local_138 = *(code**)( *(long*)this + 0x28 );
                  local_98 = (undefined1**)glslang::GetThreadPoolAllocator();
                  local_90 = local_80;
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
                  local_c8 = glslang::GetThreadPoolAllocator();
                  local_c0 = local_b0;
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_c8, &_LC1, &_LC1);
                  TType::getCompleteString(local_68, plVar12, uVar1, 1, 1, 1, &local_c8);
                  ppuVar21 = &E_GL_EXT_shader_subgroup_extended_types_int8;
               }

            }
 else {
               local_138 = *(code**)( *(long*)this + 0x28 );
               local_98 = (undefined1**)glslang::GetThreadPoolAllocator();
               local_90 = local_80;
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
               local_c8 = glslang::GetThreadPoolAllocator();
               local_c0 = local_b0;
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_c8, &_LC1, &_LC1);
               TType::getCompleteString(local_68, plVar12, uVar1, 1, 1, 1, &local_c8);
               ppuVar21 = &E_GL_EXT_shader_subgroup_extended_types_int16;
            }

         }
 else {
            if (1 < uVar8 - 10) goto LAB_00129da0;
            local_138 = *(code**)( *(long*)this + 0x28 );
            local_98 = (undefined1**)glslang::GetThreadPoolAllocator();
            local_90 = local_80;
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
            local_c8 = glslang::GetThreadPoolAllocator();
            local_c0 = local_b0;
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_c8, &_LC1, &_LC1);
            TType::getCompleteString(local_68, plVar12, uVar1, 1, 1, 1, &local_c8);
            ppuVar21 = &E_GL_EXT_shader_subgroup_extended_types_int64;
         }

         ( *local_138 )(this, param_1, 1, ppuVar21, local_68._8_8_);
      }

   }

   LAB_00129da0:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   return;
}
/* glslang::TParseContext::handleBuiltInFunctionCall(glslang::TSourceLoc, TIntermNode*,
   glslang::TFunction const&) */TIntermTyped *glslang::TParseContext::handleBuiltInFunctionCall(TParseContext *param_1, undefined8 *param_2, TFunction *param_3) {
   undefined1 uVar1;
   undefined8 uVar2;
   int iVar3;
   undefined4 uVar4;
   TIntermTyped *pTVar5;
   long lVar6;
   TIntermOperator *pTVar7;
   long *plVar8;
   long *plVar9;
   code *pcVar10;
   long *plVar11;
   TFunction *pTVar12;
   basic_string *pbVar13;
   uint uVar14;
   ulong uVar15;
   long in_FS_OFFSET;
   undefined1 local_c8[8];
   undefined8 local_c0;
   undefined8 local_98;
   undefined1 *local_90;
   undefined1 local_80[24];
   undefined8 local_68;
   undefined1 *local_60;
   undefined1 local_50[16];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(code**)( *(long*)param_3 + 0xd8 ) == TFunction::getBuiltInOp) {
      uVar4 = *(undefined4*)( param_3 + 0x110 );
   }
 else {
      uVar4 = ( **(code**)( *(long*)param_3 + 0xd8 ) )(param_3);
   }

   checkLocation(param_1, &stack0x00000008, uVar4);
   lVar6 = *(long*)param_3;
   uVar2 = *(undefined8*)( param_1 + 0x38 );
   if (*(code**)( lVar6 + 0x60 ) == TFunction::getType) {
      pTVar12 = param_3 + 0x48;
   }
 else {
      pTVar12 = (TFunction*)( **(code**)( lVar6 + 0x60 ) )(param_3);
      lVar6 = *(long*)param_3;
   }

   if (*(code**)( lVar6 + 0x120 ) == TFunction::getParamCount) {
      iVar3 = (int)( *(long*)( param_3 + 0x38 ) - *(long*)( param_3 + 0x30 ) >> 3 ) * -0x55555555;
   }
 else {
      iVar3 = ( **(code**)( lVar6 + 0x120 ) )(param_3);
      lVar6 = *(long*)param_3;
   }

   if (*(code**)( lVar6 + 0xd8 ) == TFunction::getBuiltInOp) {
      uVar4 = *(undefined4*)( param_3 + 0x110 );
   }
 else {
      uVar4 = ( **(code**)( lVar6 + 0xd8 ) )(param_3);
   }

   pTVar5 = (TIntermTyped*)glslang::TIntermediate::addBuiltInFunctionCall(uVar2, &stack0x00000008, uVar4, iVar3 == 1, param_2, pTVar12);
   if (pTVar5 == (TIntermTyped*)0x0) {
      pcVar10 = *(code**)( *(long*)param_1 + 0x158 );
      if (param_2 == (undefined8*)0x0) {
         ( *pcVar10 )(param_1, &stack0x00000008, " wrong operand type", "Internal Error", "built in unary operator function.  Type: %s", &_LC1);
         goto LAB_0012e672;
      }

      uVar1 = *(undefined1*)( *(long*)( param_1 + 0x38 ) + 0x26f );
      local_68 = glslang::GetThreadPoolAllocator();
      local_60 = local_50;
      std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, &_LC1, &_LC1);
      local_98 = glslang::GetThreadPoolAllocator();
      local_90 = local_80;
      std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
      TType::getCompleteString(local_c8, param_2 + 4, uVar1, 1, 1, 1, &local_98);
      if (*(code**)*param_2 == TIntermNode::getLoc) {
         param_2 = param_2 + 1;
      }
 else {
         param_2 = (undefined8*)( **(code**)*param_2 )(param_2);
      }

      ( *pcVar10 )(param_1, param_2, " wrong operand type", "Internal Error", "built in unary operator function.  Type: %s", local_c0);
      pcVar10 = *(code**)( *(long*)param_3 + 0xd8 );
      if (pcVar10 != TFunction::getBuiltInOp) goto LAB_0012e980;
   }
 else {
      if (param_1[0x7378] == (TParseContext)0x0) {
         lVar6 = ( **(code**)( *(long*)pTVar5 + 0x20 ) )(pTVar5);
      }
 else {
         computeBuiltinPrecisions(param_1, pTVar5, param_3);
         lVar6 = ( **(code**)( *(long*)pTVar5 + 0x20 ) )(pTVar5);
      }

      if (lVar6 != 0) {
         pTVar7 = (TIntermOperator*)( **(code**)( *(long*)pTVar5 + 0x20 ) )(pTVar5);
         builtInOpCheck(param_1, (TSourceLoc*)&stack0x00000008, param_3, pTVar7);
      }

      LAB_0012e672:pcVar10 = *(code**)( *(long*)param_3 + 0xd8 );
      if (pcVar10 != TFunction::getBuiltInOp) {
         LAB_0012e980:iVar3 = ( *pcVar10 )(param_3);
         goto LAB_0012e68b;
      }

   }

   iVar3 = *(int*)( param_3 + 0x110 );
   LAB_0012e68b:if (iVar3 == 7) {
      plVar8 = (long*)( **(code**)( *(long*)pTVar5 + 0x30 ) )(pTVar5);
      if (plVar8 == (long*)0x0) {
         plVar8 = (long*)( **(code**)( *(long*)pTVar5 + 0x38 ) )(pTVar5);
         if (plVar8 != (long*)0x0) {
            if (*(code**)( *(long*)param_3 + 0x140 ) == TFunction::operator []) {
               lVar6 = *(long*)( param_3 + 0x30 );
            }
 else {
               lVar6 = ( **(code**)( *(long*)param_3 + 0x140 ) )(param_3, 0);
            }

            pcVar10 = *(code**)( **(long**)( lVar6 + 8 ) + 0x50 );
            if (pcVar10 == TType::getQualifier) {
               plVar11 = *(long**)( lVar6 + 8 ) + 2;
            }
 else {
               plVar11 = (long*)( *pcVar10 )();
            }

            if (( *(byte*)( (long)plVar11 + 0xf ) & 4 ) != 0) {
               if (*(code**)( *plVar8 + 0x188 ) == TIntermUnary::getOperand) {
                  plVar11 = (long*)plVar8[0x18];
               }
 else {
                  plVar11 = (long*)( **(code**)( *plVar8 + 0x188 ) )(plVar8);
               }

               if (*(code**)( *plVar11 + 0x108 ) == TIntermTyped::getQualifier) {
                  plVar11 = plVar11 + 6;
               }
 else {
                  plVar11 = (long*)( **(code**)( *plVar11 + 0x108 ) )();
               }

               *(byte*)( (long)plVar11 + 0xf ) = *(byte*)( (long)plVar11 + 0xf ) | 4;
            }

            if (*(code**)( *(long*)param_3 + 0x140 ) == TFunction::operator []) {
               lVar6 = *(long*)( param_3 + 0x30 );
            }
 else {
               lVar6 = ( **(code**)( *(long*)param_3 + 0x140 ) )(param_3, 0);
            }

            pcVar10 = *(code**)( **(long**)( lVar6 + 8 ) + 0x50 );
            if (pcVar10 == TType::getQualifier) {
               plVar11 = *(long**)( lVar6 + 8 ) + 2;
            }
 else {
               plVar11 = (long*)( *pcVar10 )();
            }

            if (( *(byte*)( (long)plVar11 + 0xf ) & 8 ) != 0) {
               if (*(code**)( *plVar8 + 0x188 ) == TIntermUnary::getOperand) {
                  plVar11 = (long*)plVar8[0x18];
               }
 else {
                  plVar11 = (long*)( **(code**)( *plVar8 + 0x188 ) )(plVar8);
               }

               if (*(code**)( *plVar11 + 0x108 ) == TIntermTyped::getQualifier) {
                  plVar11 = plVar11 + 6;
               }
 else {
                  plVar11 = (long*)( **(code**)( *plVar11 + 0x108 ) )();
               }

               *(byte*)( (long)plVar11 + 0xf ) = *(byte*)( (long)plVar11 + 0xf ) | 8;
            }

            if (*(code**)( *(long*)param_3 + 0x150 ) == TFunction::getSpirvInstruction) {
               pbVar13 = (basic_string*)( param_3 + 0x120 );
            }
 else {
               pbVar13 = (basic_string*)( **(code**)( *(long*)param_3 + 0x150 ) )(param_3);
            }

            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( plVar8 + 0x19 ), pbVar13);
            *(undefined4*)( plVar8 + 0x1e ) = *(undefined4*)( pbVar13 + 0x28 );
         }

      }
 else {
         if (*(code**)( *plVar8 + 400 ) == TIntermAggregate::getSequence) {
            plVar11 = plVar8 + 0x18;
         }
 else {
            plVar11 = (long*)( **(code**)( *plVar8 + 400 ) )(plVar8);
         }

         uVar14 = 0;
         uVar15 = 0;
         if (plVar11[2] != plVar11[1]) {
            do {
               if (*(code**)( *(long*)param_3 + 0x140 ) == TFunction::operator []) {
                  lVar6 = *(long*)( param_3 + 0x30 ) + (long)(int)uVar14 * 0x18;
               }
 else {
                  lVar6 = ( **(code**)( *(long*)param_3 + 0x140 ) )(param_3, uVar14);
               }

               pcVar10 = *(code**)( **(long**)( lVar6 + 8 ) + 0x50 );
               if (pcVar10 == TType::getQualifier) {
                  plVar9 = *(long**)( lVar6 + 8 ) + 2;
               }
 else {
                  plVar9 = (long*)( *pcVar10 )();
               }

               if (( *(byte*)( (long)plVar9 + 0xf ) & 4 ) != 0) {
                  plVar9 = (long*)( **(code**)( **(long**)( plVar11[1] + uVar15 * 8 ) + 0x18 ) )();
                  if (*(code**)( *plVar9 + 0x108 ) == TIntermTyped::getQualifier) {
                     plVar9 = plVar9 + 6;
                  }
 else {
                     plVar9 = (long*)( **(code**)( *plVar9 + 0x108 ) )(plVar9);
                  }

                  *(byte*)( (long)plVar9 + 0xf ) = *(byte*)( (long)plVar9 + 0xf ) | 4;
               }

               if (*(code**)( *(long*)param_3 + 0x140 ) == TFunction::operator []) {
                  lVar6 = *(long*)( param_3 + 0x30 ) + (long)(int)uVar14 * 0x18;
               }
 else {
                  lVar6 = ( **(code**)( *(long*)param_3 + 0x140 ) )(param_3, uVar14);
               }

               pcVar10 = *(code**)( **(long**)( lVar6 + 8 ) + 0x50 );
               if (pcVar10 == TType::getQualifier) {
                  plVar9 = *(long**)( lVar6 + 8 ) + 2;
               }
 else {
                  plVar9 = (long*)( *pcVar10 )();
               }

               if (( *(byte*)( (long)plVar9 + 0xf ) & 8 ) != 0) {
                  plVar9 = (long*)( **(code**)( **(long**)( plVar11[1] + uVar15 * 8 ) + 0x18 ) )();
                  if (*(code**)( *plVar9 + 0x108 ) == TIntermTyped::getQualifier) {
                     plVar9 = plVar9 + 6;
                  }
 else {
                     plVar9 = (long*)( **(code**)( *plVar9 + 0x108 ) )(plVar9);
                  }

                  *(byte*)( (long)plVar9 + 0xf ) = *(byte*)( (long)plVar9 + 0xf ) | 8;
               }

               uVar14 = uVar14 + 1;
               uVar15 = (ulong)uVar14;
            }
 while ( uVar15 < ( ulong )(plVar11[2] - plVar11[1] >> 3) );
         }

         pTVar12 = param_3 + 0x120;
         if (*(code**)( *(long*)param_3 + 0x150 ) != TFunction::getSpirvInstruction) {
            pTVar12 = (TFunction*)( **(code**)( *(long*)param_3 + 0x150 ) )(param_3);
         }

         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( plVar8 + 0x27 ), (basic_string*)pTVar12);
         *(undefined4*)( plVar8 + 0x2c ) = *(undefined4*)( (basic_string*)pTVar12 + 0x28 );
      }

   }

   if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return pTVar5;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::handleVariable(glslang::TSourceLoc const&, glslang::TSymbol*,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const*)
    */long *__thiscallglslang::TParseContext::handleVariable(TParseContext *this, TSourceLoc *param_1, TSymbol *param_2, basic_string *param_3) {
   undefined1 uVar1;
   TSourceLoc TVar2;
   code *pcVar3;
   _Rb_tree_node_base *__src;
   TVariable *pTVar4;
   long lVar5;
   long lVar6;
   char cVar7;
   int iVar8;
   undefined4 uVar9;
   uint uVar10;
   undefined8 uVar11;
   long *plVar12;
   undefined8 uVar13;
   long *plVar14;
   _Rb_tree_node_base *p_Var15;
   ulong uVar16;
   _Rb_tree_node_base *p_Var17;
   ulong uVar18;
   ulong uVar19;
   _Rb_tree_node_base *p_Var20;
   TType *pTVar21;
   long lVar22;
   byte bVar23;
   byte bVar24;
   byte bVar25;
   long lVar26;
   byte bVar27;
   uint uVar28;
   size_t __n;
   _Rb_tree_node_base *p_Var29;
   TSourceLoc *pTVar30;
   TSourceLoc *pTVar31;
   void *__s2;
   bool bVar32;
   long in_FS_OFFSET;
   void *local_118;
   TSymbol *local_110;
   undefined **local_108;
   undefined4 local_100;
   undefined8 local_f8;
   ulong local_f0;
   byte local_e8;
   undefined8 local_e4;
   undefined1 uStack_dc;
   uint7 local_db;
   undefined4 uStack_d4;
   undefined4 local_d0;
   undefined4 uStack_cc;
   undefined1 local_c8;
   undefined8 local_c4;
   undefined4 local_bc;
   undefined8 local_b8;
   undefined2 local_b0;
   undefined1 local_a8[16];
   undefined1 local_98[16];
   uint local_88;
   undefined1 local_80[16];
   long *local_68;
   long local_60;
   long local_58[3];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   local_110 = param_2;
   if (param_2 == (TSymbol*)0x0) {
      LAB_0012f70b:uVar19 = glslang::GetThreadPoolAllocator();
      pTVar31 = (TSourceLoc*)glslang::TPoolAllocator::allocate(uVar19);
      local_88 = local_88 & 0x9fc00000;
      local_108 = &PTR__TType_00167f00;
      local_e8 = local_e8 & 0xf0;
      local_c8 = 0;
      local_100 = CONCAT22(local_100._2_2_, 0x100) & 0xf800ffff;
      local_f8 = 0;
      local_c4 = 0xfffff800;
      local_b0 = 0;
      local_e4 = 0xffffffffffffffff;
      local_bc = 0xffffffff;
      local_80 = (undefined1[16])0x0;
      local_a8 = (undefined1[16])0x0;
      uStack_cc = 0;
      local_db = local_db & 0xffc000 | 0xffffffff001fcf;
      local_b8 = 0;
      uStack_dc = 0xff;
      local_98 = (undefined1[16])0x0;
      uVar19 = CONCAT44(local_d0, uStack_d4) & 0xfe07ff00ffffffff | 0x1ffffff7fffffff;
      uStack_d4 = (undefined4)uVar19;
      local_d0 = ( undefined4 )(uVar19 >> 0x20);
      local_f0 = local_f0 & 0x8000000400000000;
      TVariable::TVariable((TVariable*)pTVar31, param_3, (TType*)&local_108, false);
      LAB_0012f842:if (*(code**)( *(long*)pTVar31 + 0x60 ) == TVariable::getType) {
         pTVar30 = pTVar31 + 0x28;
      }
 else {
         pTVar30 = (TSourceLoc*)( **(code**)( *(long*)pTVar31 + 0x60 ) )(pTVar31);
      }

      if (*(code**)( *(long*)pTVar30 + 0x58 ) == TType::getQualifier) {
         pTVar30 = pTVar30 + 0x10;
      }
 else {
         pTVar30 = (TSourceLoc*)( **(code**)( *(long*)pTVar30 + 0x58 ) )();
      }

      pTVar4 = *(TVariable**)( this + 0x38 );
      if (( ( (byte)pTVar30[8] & 0x7f ) == 2 ) && ( ( (byte)pTVar30[0xc] & 1 ) == 0 )) {
         lVar22 = *(long*)pTVar31;
         if (*(code**)( lVar22 + 0x60 ) == TVariable::getType) {
            pTVar30 = pTVar31 + 0x28;
         }
 else {
            pTVar30 = (TSourceLoc*)( **(code**)( lVar22 + 0x60 ) )(pTVar31);
            lVar22 = *(long*)pTVar31;
         }

         if (*(code**)( lVar22 + 0xb8 ) == TVariable::getConstArray) {
            pTVar21 = (TType*)( pTVar31 + 200 );
         }
 else {
            pTVar21 = (TType*)( **(code**)( lVar22 + 0xb8 ) )(pTVar31);
         }

         plVar14 = (long*)glslang::TIntermediate::addConstantUnion((TConstUnionArray*)pTVar4, pTVar21, pTVar30, SUB81(param_1, 0));
      }
 else {
         plVar14 = (long*)glslang::TIntermediate::addSymbol(pTVar4, pTVar31);
      }

   }
 else {
      iVar8 = ( **(code**)( *(long*)param_2 + 0x88 ) )(param_2);
      if (iVar8 != 0) {
         lVar22 = *(long*)local_110;
         pcVar3 = *(code**)( *(long*)this + 0x28 );
         if (*(code**)( lVar22 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            lVar26 = *(long*)( local_110 + 8 );
         }
 else {
            lVar26 = ( **(code**)( lVar22 + 0x18 ) )();
            lVar22 = *(long*)local_110;
         }

         uVar13 = *(undefined8*)( lVar26 + 8 );
         uVar11 = ( **(code**)( lVar22 + 0x90 ) )();
         uVar9 = ( **(code**)( *(long*)local_110 + 0x88 ) )();
         ( *pcVar3 )(this, param_1, uVar9, uVar11, uVar13);
      }

      if (local_110 == (TSymbol*)0x0) goto LAB_0012f70b;
      lVar22 = *(long*)local_110;
      if (*(code**)( lVar22 + 0xa0 ) != TSymbol::isReadOnly) {
         cVar7 = ( **(code**)( lVar22 + 0xa0 ) )();
         if (cVar7 != '\0') {
            lVar22 = *(long*)local_110;
            goto LAB_0012f1e2;
         }

         goto LAB_0012f3b0;
      }

      if (local_110[0x20] != (TSymbol)0x0) {
         plVar12 = (long*)( **(code**)( lVar22 + 0x58 ) )();
         if (plVar12 != (long*)0x0) goto LAB_0012eda1;
         LAB_0012f3d0:if (local_110 == (TSymbol*)0x0) goto LAB_0012f70b;
         pTVar31 = (TSourceLoc*)( **(code**)( *(long*)local_110 + 0x48 ) )();
         if (pTVar31 == (TSourceLoc*)0x0) {
            if (local_110 != (TSymbol*)0x0) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "variable name expected", *(undefined8*)( param_3 + 8 ), &_LC1);
            }

            goto LAB_0012f70b;
         }

         if (*(code**)( *(long*)pTVar31 + 0x60 ) == TVariable::getType) {
            pTVar30 = pTVar31 + 0x28;
         }
 else {
            pTVar30 = (TSourceLoc*)( **(code**)( *(long*)pTVar31 + 0x60 ) )(pTVar31);
         }

         pcVar3 = *(code**)( *(long*)pTVar30 + 0x180 );
         if (pcVar3 != TType::isUnusableName) {
            cVar7 = ( *pcVar3 )(pTVar30);
            if (cVar7 == '\0') goto LAB_0012f451;
            LAB_0012fb1d:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot be used (maybe an instance name is needed)", *(undefined8*)( param_3 + 8 ), &_LC1);
            goto LAB_0012f70b;
         }

         pcVar3 = *(code**)( *(long*)pTVar30 + 0x128 );
         if (pcVar3 == TType::isStruct) {
            if (( byte )((char)pTVar30[8] - 0xfU) < 2) {
               LAB_0012f446:if (*(long*)( pTVar30 + 0x68 ) == 0) goto LAB_0012fb1d;
            }

         }
 else {
            cVar7 = ( *pcVar3 )(pTVar30);
            if (cVar7 != '\0') goto LAB_0012f446;
         }

         LAB_0012f451:if (*(int*)( this + 0x1c ) != 0xd) goto LAB_0012f842;
         lVar22 = *(long*)pTVar31;
         iVar8 = *(int*)( *(long*)( this + 0x38 ) + 0x314 );
         if (*(code**)( lVar22 + 0x30 ) != TSymbol::getMangledName_abi_cxx11_) {
            lVar22 = ( **(code**)( lVar22 + 0x30 ) )(pTVar31);
            LAB_0012fd32:if (*(long*)( lVar22 + 0x10 ) != 0x1e) {
               LAB_0012fd3d:lVar22 = *(long*)pTVar31;
               if (*(code**)( lVar22 + 0x30 ) == TSymbol::getMangledName_abi_cxx11_) goto LAB_0012fe9f;
               lVar26 = ( **(code**)( lVar22 + 0x30 ) )(pTVar31);
               LAB_0012fd56:if (*(long*)( lVar26 + 0x10 ) == 0x1a) goto LAB_0012fe20;
               LAB_0012fd61:lVar22 = *(long*)pTVar31;
               if (*(code**)( lVar22 + 0x30 ) == TSymbol::getMangledName_abi_cxx11_) goto LAB_0012f4ad;
               lVar22 = ( **(code**)( lVar22 + 0x30 ) )(pTVar31);
               goto LAB_0012f4bf;
            }

            plVar12 = *(long**)( lVar22 + 8 );
            if (( *plVar12 == 0x696d6972505f6c67 && plVar12[1] == 0x6169725465766974 ) && ( *(long*)( (long)plVar12 + 0xe ) == 0x6e49656c676e6169 && *(long*)( (long)plVar12 + 0x16 ) == 0x5458457365636964 )) {
               bVar32 = false;
            }
 else {
               bVar32 = true;
            }

            if (( bVar32 ) || ( iVar8 == 5 )) goto LAB_0012fd3d;
            LAB_0012f509:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot be used (ouput primitive type mismatch)", *(undefined8*)( param_3 + 8 ), &_LC1);
            goto LAB_0012f70b;
         }

         if (*(code**)( lVar22 + 0x18 ) != TSymbol::getName_abi_cxx11_) {
            lVar22 = ( **(code**)( lVar22 + 0x18 ) )(pTVar31);
            goto LAB_0012fd32;
         }

         lVar26 = *(long*)( pTVar31 + 8 );
         if (*(long*)( lVar26 + 0x10 ) == 0x1e) {
            plVar12 = *(long**)( lVar26 + 8 );
            if (( *plVar12 == 0x696d6972505f6c67 && plVar12[1] == 0x6169725465766974 ) && ( *(long*)( (long)plVar12 + 0xe ) == 0x6e49656c676e6169 && *(long*)( (long)plVar12 + 0x16 ) == 0x5458457365636964 )) {
               bVar32 = false;
            }
 else {
               bVar32 = true;
            }

            if (( !bVar32 ) && ( iVar8 != 5 )) goto LAB_0012f509;
            LAB_0012fe9f:if (*(code**)( lVar22 + 0x18 ) != TSymbol::getName_abi_cxx11_) {
               lVar26 = ( **(code**)( lVar22 + 0x18 ) )(pTVar31);
               goto LAB_0012fd56;
            }

            lVar26 = *(long*)( pTVar31 + 8 );
         }

         if (*(long*)( lVar26 + 0x10 ) == 0x1a) {
            LAB_0012fe20:plVar12 = *(long**)( lVar26 + 8 );
            if (( *plVar12 == 0x696d6972505f6c67 && plVar12[1] == 0x656e694c65766974 ) && ( *(long*)( (long)plVar12 + 10 ) == 0x6e49656e694c6576 && *(long*)( (long)plVar12 + 0x12 ) == 0x5458457365636964 )) {
               bVar32 = false;
            }
 else {
               bVar32 = true;
            }

            if (( iVar8 == 2 ) || ( bVar32 )) goto LAB_0012fd61;
            goto LAB_0012f509;
         }

         LAB_0012f4ad:if (*(code**)( lVar22 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            lVar22 = *(long*)( pTVar31 + 8 );
         }
 else {
            lVar22 = ( **(code**)( lVar22 + 0x18 ) )(pTVar31);
         }

         LAB_0012f4bf:if (*(long*)( lVar22 + 0x10 ) == 0x1b) {
            plVar12 = *(long**)( lVar22 + 8 );
            if (( *plVar12 == 0x696d6972505f6c67 && plVar12[1] == 0x6e696f5065766974 ) && ( *(long*)( (long)plVar12 + 0xb ) == 0x6e49746e696f5065 && *(long*)( (long)plVar12 + 0x13 ) == 0x5458457365636964 )) {
               bVar32 = false;
            }
 else {
               bVar32 = true;
            }

            if (( iVar8 != 1 ) && ( !bVar32 )) goto LAB_0012f509;
         }

         goto LAB_0012f842;
      }

      LAB_0012f1e2:plVar12 = (long*)( **(code**)( lVar22 + 0x60 ) )();
      pcVar3 = *(code**)( *plVar12 + 0x180 );
      if (pcVar3 != TType::isUnusableName) {
         cVar7 = ( *pcVar3 )(plVar12);
         if (cVar7 == '\0') goto LAB_0012f229;
         goto LAB_0012f3b0;
      }

      pcVar3 = *(code**)( *plVar12 + 0x128 );
      if (pcVar3 == TType::isStruct) {
         if (( byte )((char)plVar12[1] - 0xfU) < 2) {
            LAB_0012f90d:if (plVar12[0xd] == 0) goto LAB_0012f3b0;
         }

      }
 else {
         cVar7 = ( *pcVar3 )(plVar12);
         if (cVar7 != '\0') goto LAB_0012f90d;
      }

      LAB_0012f229:plVar12 = (long*)( **(code**)( *(long*)local_110 + 0x60 ) )();
      lVar22 = *plVar12;
      if (*(code**)( lVar22 + 0x1a8 ) == TType::containsUnsizedArray) {
         if (*(code**)( lVar22 + 0xf8 ) == TType::isUnsizedArray) {
            if (*(code**)( lVar22 + 0xe8 ) != TType::isArray) {
               cVar7 = ( **(code**)( lVar22 + 0xe8 ) )(plVar12);
               if (cVar7 == '\0') goto LAB_0012fa17;
               lVar26 = plVar12[0xc];
               LAB_0012f9de:if (**(int**)( *(long*)( lVar26 + 8 ) + 8 ) == 0) goto LAB_0012f9f7;
               goto LAB_0012fa17;
            }

            lVar26 = plVar12[0xc];
            if (lVar26 != 0) goto LAB_0012f9de;
         }
 else {
            cVar7 = ( **(code**)( lVar22 + 0xf8 ) )(plVar12);
            if (cVar7 != '\0') goto LAB_0012f9f7;
            LAB_0012fa17:lVar22 = *plVar12;
         }

         if (*(code**)( lVar22 + 0x128 ) == TType::isStruct) {
            if (( byte )((char)plVar12[1] - 0xfU) < 2) {
               LAB_0012fcee:lVar22 = *(long*)( plVar12[0xd] + 0x10 );
               lVar26 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsUnsizedArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsUnsizedArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar12[0xd] + 8 ),lVar22 ));
               if (lVar22 != lVar26) goto LAB_0012f9f7;
            }

         }
 else {
            cVar7 = ( **(code**)( lVar22 + 0x128 ) )(plVar12);
            if (cVar7 != '\0') goto LAB_0012fcee;
         }

         LAB_0012f2b3:lVar22 = ( **(code**)( *(long*)local_110 + 0x58 ) )();
         if (lVar22 != 0) {
            plVar12 = (long*)( **(code**)( *(long*)local_110 + 0x58 ) )();
            if (*(code**)( *plVar12 + 0xb0 ) == TAnonMember::getAnonContainer) {
               plVar12 = (long*)plVar12[5];
            }
 else {
               plVar12 = (long*)( **(code**)( *plVar12 + 0xb0 ) )(plVar12);
            }

            if (*(code**)( *plVar12 + 0x60 ) == TVariable::getType) {
               plVar12 = plVar12 + 5;
            }
 else {
               plVar12 = (long*)( **(code**)( *plVar12 + 0x60 ) )();
            }

            lVar22 = *plVar12;
            if (*(code**)( lVar22 + 0x1a8 ) == TType::containsUnsizedArray) {
               if (*(code**)( lVar22 + 0xf8 ) == TType::isUnsizedArray) {
                  if (*(code**)( lVar22 + 0xe8 ) != TType::isArray) {
                     cVar7 = ( **(code**)( lVar22 + 0xe8 ) )(plVar12);
                     if (cVar7 == '\0') goto LAB_0012f36b;
                     lVar26 = plVar12[0xc];
                     LAB_0012f359:if (**(int**)( *(long*)( lVar26 + 8 ) + 8 ) == 0) goto LAB_0012f9f7;
                     goto LAB_0012f36b;
                  }

                  lVar26 = plVar12[0xc];
                  if (lVar26 != 0) goto LAB_0012f359;
               }
 else {
                  cVar7 = ( **(code**)( lVar22 + 0xf8 ) )(plVar12);
                  if (cVar7 != '\0') goto LAB_0012f9f7;
                  LAB_0012f36b:lVar22 = *plVar12;
               }

               if (*(code**)( lVar22 + 0x128 ) == TType::isStruct) {
                  if (( byte )((char)plVar12[1] - 0xfU) < 2) {
                     LAB_0012f391:lVar22 = *(long*)( plVar12[0xd] + 0x10 );
                     lVar26 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsUnsizedArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsUnsizedArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar12[0xd] + 8 ),lVar22 ));
                     if (lVar22 != lVar26) goto LAB_0012f9f7;
                  }

               }
 else {
                  cVar7 = ( **(code**)( lVar22 + 0x128 ) )(plVar12);
                  if (cVar7 != '\0') goto LAB_0012f391;
               }

            }
 else {
               cVar7 = ( **(code**)( lVar22 + 0x1a8 ) )(plVar12);
               if (cVar7 != '\0') goto LAB_0012f9f7;
            }

         }

      }
 else {
         cVar7 = ( **(code**)( lVar22 + 0x1a8 ) )(plVar12);
         if (cVar7 == '\0') goto LAB_0012f2b3;
         LAB_0012f9f7:( **(code**)( *(long*)this + 0x260 ) )(this, &local_110);
      }

      LAB_0012f3b0:if (local_110 == (TSymbol*)0x0) goto LAB_0012f70b;
      plVar12 = (long*)( **(code**)( *(long*)local_110 + 0x58 ) )();
      if (plVar12 == (long*)0x0) goto LAB_0012f3d0;
      LAB_0012eda1:if (*(code**)( *plVar12 + 0xb0 ) == TAnonMember::getAnonContainer) {
         pTVar31 = (TSourceLoc*)plVar12[5];
      }
 else {
         pTVar31 = (TSourceLoc*)( **(code**)( *plVar12 + 0xb0 ) )(plVar12);
      }

      if (*(code**)( *(long*)pTVar31 + 0x50 ) != TVariable::getAsVariable) {
         pTVar31 = (TSourceLoc*)( **(code**)( *(long*)pTVar31 + 0x50 ) )(pTVar31);
      }

      uVar11 = glslang::TIntermediate::addSymbol(*(TVariable**)( this + 0x38 ), pTVar31);
      uVar13 = *(undefined8*)( this + 0x38 );
      if (*(code**)( *plVar12 + 0xb8 ) == TAnonMember::getMemberNumber) {
         uVar10 = *(uint*)( plVar12 + 6 );
      }
 else {
         uVar10 = ( **(code**)( *plVar12 + 0xb8 ) )(plVar12);
      }

      uVar13 = glslang::TIntermediate::addConstantUnion((uint)uVar13, (TSourceLoc*)(ulong)uVar10, SUB81(param_1, 0));
      plVar14 = (long*)glslang::TIntermediate::addIndex(*(undefined8*)( this + 0x38 ), 0xb8, uVar11, uVar13, param_1);
      pcVar3 = *(code**)( *plVar14 + 0xe8 );
      if (*(code**)( *(long*)pTVar31 + 0x60 ) == TVariable::getType) {
         pTVar30 = pTVar31 + 0x28;
      }
 else {
         pTVar30 = (TSourceLoc*)( **(code**)( *(long*)pTVar31 + 0x60 ) )(pTVar31);
      }

      lVar22 = *(long*)( pTVar30 + 0x68 );
      if (*(code**)( *plVar12 + 0xb8 ) == TAnonMember::getMemberNumber) {
         uVar10 = *(uint*)( plVar12 + 6 );
      }
 else {
         uVar10 = ( **(code**)( *plVar12 + 0xb8 ) )(plVar12);
      }

      lVar22 = *(long*)( (ulong)uVar10 * 0x20 + *(long*)( lVar22 + 8 ) );
      if (pcVar3 == TIntermTyped::setType) {
         lVar26 = *(long*)( lVar22 + 0x18 );
         uVar1 = *(undefined1*)( lVar22 + 8 );
         uVar9 = *(undefined4*)( lVar22 + 0x80 );
         plVar14[6] = *(long*)( lVar22 + 0x10 );
         plVar14[7] = lVar26;
         lVar26 = *(long*)( lVar22 + 0x20 );
         lVar5 = *(long*)( lVar22 + 0x28 );
         *(undefined4*)( plVar14 + 0x14 ) = uVar9;
         plVar14[8] = lVar26;
         plVar14[9] = lVar5;
         lVar26 = *(long*)( lVar22 + 0x30 );
         lVar5 = *(long*)( lVar22 + 0x38 );
         *(undefined1*)( plVar14 + 5 ) = uVar1;
         plVar14[10] = lVar26;
         plVar14[0xb] = lVar5;
         lVar26 = *(long*)( lVar22 + 0x48 );
         plVar14[0xc] = *(long*)( lVar22 + 0x40 );
         plVar14[0xd] = lVar26;
         lVar26 = *(long*)( lVar22 + 0x58 );
         plVar14[0xe] = *(long*)( lVar22 + 0x50 );
         plVar14[0xf] = lVar26;
         bVar23 = *(byte*)( lVar22 + 9 ) & 0xf;
         *(byte*)( (long)plVar14 + 0x29 ) = *(byte*)( (long)plVar14 + 0x29 ) & 0xf0 | bVar23;
         *(byte*)( (long)plVar14 + 0x29 ) = bVar23 | *(byte*)( lVar22 + 9 ) & 0xf0;
         bVar23 = *(byte*)( (long)plVar14 + 0x2a );
         bVar24 = *(byte*)( lVar22 + 10 ) & 0xf;
         *(byte*)( (long)plVar14 + 0x2a ) = bVar23 & 0xf0 | bVar24;
         bVar25 = *(byte*)( lVar22 + 10 ) & 0x10;
         *(byte*)( (long)plVar14 + 0x2a ) = bVar23 & 0xe0 | bVar24 | bVar25;
         lVar5 = *(long*)( lVar22 + 0x70 );
         lVar6 = *(long*)( lVar22 + 0x78 );
         plVar14[0x10] = *(long*)( lVar22 + 0x60 );
         lVar26 = *(long*)( lVar22 + 0x68 );
         plVar14[0x12] = lVar5;
         plVar14[0x13] = lVar6;
         plVar14[0x11] = lVar26;
         lVar26 = *(long*)( lVar22 + 0x90 );
         plVar14[0x15] = *(long*)( lVar22 + 0x88 );
         plVar14[0x16] = lVar26;
         bVar27 = *(byte*)( lVar22 + 10 ) & 0x20;
         *(byte*)( (long)plVar14 + 0x2a ) = bVar23 & 0xc0 | bVar24 | bVar25 | bVar27;
         *(byte*)( (long)plVar14 + 0x2a ) = bVar23 & 0x80 | bVar24 | bVar25 | bVar27 | *(byte*)( lVar22 + 10 ) & 0x40;
         *(ushort*)( (long)plVar14 + 0x2a ) = *(ushort*)( (long)plVar14 + 0x2a ) & 0xfc7f | *(ushort*)( lVar22 + 10 ) & 0x380;
         *(byte*)( (long)plVar14 + 0x2b ) = *(byte*)( (long)plVar14 + 0x2b ) & 0xfb | *(byte*)( lVar22 + 0xb ) & 4;
      }
 else {
         ( *pcVar3 )(plVar14);
      }

      if (*(code**)( *plVar14 + 0xf0 ) == TIntermTyped::getType) {
         plVar12 = plVar14 + 4;
      }
 else {
         plVar12 = (long*)( **(code**)( *plVar14 + 0xf0 ) )(plVar14);
      }

      if (*(code**)( *plVar12 + 0x18 ) == TType::hiddenMember) {
         if ((char)plVar12[1] == '\0') {
            LAB_0012f54a:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "member of nameless block was not redeclared", *(undefined8*)( param_3 + 8 ), &_LC1);
         }

      }
 else {
         cVar7 = ( **(code**)( *plVar12 + 0x18 ) )();
         if (cVar7 != '\0') goto LAB_0012f54a;
      }

   }

   if (*(code**)( *(long*)pTVar31 + 0x60 ) == TVariable::getType) {
      pTVar30 = pTVar31 + 0x28;
   }
 else {
      pTVar30 = (TSourceLoc*)( **(code**)( *(long*)pTVar31 + 0x60 ) )(pTVar31);
   }

   if (*(code**)( *(long*)pTVar30 + 0x58 ) == TType::getQualifier) {
      pTVar30 = pTVar30 + 0x10;
   }
 else {
      pTVar30 = (TSourceLoc*)( **(code**)( *(long*)pTVar30 + 0x58 ) )();
   }

   bVar23 = (byte)pTVar30[8] & 0x7f;
   if (bVar23 < 7) {
      if (bVar23 < 3) goto LAB_0012f160;
   }
 else if (10 < ( bVar23 + 0x6c & 0x7f )) goto LAB_0012f160;
   lVar22 = *(long*)( this + 0x38 );
   p_Var15 = (_Rb_tree_node_base*)( lVar22 + 0x738 );
   if (*(_Rb_tree_node_base**)( lVar22 + 0x740 ) == (_Rb_tree_node_base*)0x0) {
      p_Var29 = p_Var15;
      if (p_Var15 != *(_Rb_tree_node_base**)( lVar22 + 0x748 )) {
         local_118 = *(void**)( param_3 + 8 );
         uVar19 = *(ulong*)( param_3 + 0x10 );
         LAB_0012fa32:lVar26 = std::_Rb_tree_decrement(p_Var29);
         uVar18 = *(ulong*)( lVar26 + 0x30 );
         __s2 = *(void**)( lVar26 + 0x28 );
         __n = uVar19;
         if (uVar18 <= uVar19) {
            __n = uVar18;
         }

         LAB_0012f11c:if (( __n == 0 ) || ( iVar8 = iVar8 == 0 )) {
            lVar26 = uVar18 - uVar19;
            if (0x7fffffff < lVar26) goto LAB_0012f160;
            if (lVar26 < -0x80000000) goto LAB_0012f5a0;
            iVar8 = (int)lVar26;
         }

         if (-1 < iVar8) goto LAB_0012f160;
         goto LAB_0012f5a0;
      }

      LAB_0012fd15:bVar32 = true;
   }
 else {
      local_118 = *(void**)( param_3 + 8 );
      uVar19 = *(ulong*)( param_3 + 0x10 );
      p_Var20 = *(_Rb_tree_node_base**)( lVar22 + 0x740 );
      do {
         p_Var29 = p_Var20;
         uVar18 = *(ulong*)( p_Var29 + 0x30 );
         __s2 = *(void**)( p_Var29 + 0x28 );
         __n = uVar18;
         if (uVar19 <= uVar18) {
            __n = uVar19;
         }

         if (__n == 0) {
            LAB_0012f0ca:uVar16 = uVar19 - uVar18;
            if ((long)uVar16 < 0x80000000) {
               if (-0x80000001 < (long)uVar16) goto LAB_0012f0e9;
               goto LAB_0012f090;
            }

            LAB_0012f0ed:p_Var20 = *(_Rb_tree_node_base**)( p_Var29 + 0x18 );
            bVar32 = false;
         }
 else {
            uVar10 = memcmp(local_118, __s2, __n);
            uVar16 = (ulong)uVar10;
            if (uVar10 == 0) goto LAB_0012f0ca;
            LAB_0012f0e9:if (-1 < (int)uVar16) goto LAB_0012f0ed;
            LAB_0012f090:p_Var20 = *(_Rb_tree_node_base**)( p_Var29 + 0x10 );
            bVar32 = true;
         }

      }
 while ( p_Var20 != (_Rb_tree_node_base*)0x0 );
      if (!bVar32) goto LAB_0012f11c;
      if (*(_Rb_tree_node_base**)( lVar22 + 0x748 ) != p_Var29) goto LAB_0012fa32;
      LAB_0012f5a0:bVar32 = true;
      if (p_Var15 != p_Var29) {
         uVar18 = *(ulong*)( p_Var29 + 0x30 );
         uVar16 = uVar18;
         if (uVar19 <= uVar18) {
            uVar16 = uVar19;
         }

         if (uVar16 == 0) {
            LAB_0012f9a5:uVar16 = uVar19 - uVar18;
            bVar32 = false;
            if (0x7fffffff < (long)uVar16) goto LAB_0012f5b1;
            if ((long)uVar16 < -0x80000000) goto LAB_0012fd15;
         }
 else {
            uVar10 = memcmp(local_118, *(void**)( p_Var29 + 0x28 ), uVar16);
            uVar16 = (ulong)uVar10;
            if (uVar10 == 0) goto LAB_0012f9a5;
         }

         bVar32 = (bool)( ( byte )(uVar16 >> 0x1f) & 1 );
      }

   }

   LAB_0012f5b1:p_Var17 = (_Rb_tree_node_base*)operator_new(0x48);
   uVar18 = glslang::GetThreadPoolAllocator();
   p_Var20 = p_Var17 + 0x38;
   *(ulong*)( p_Var17 + 0x20 ) = uVar18;
   uVar19 = *(ulong*)( param_3 + 0x10 );
   __src = *(_Rb_tree_node_base**)( param_3 + 8 );
   *(_Rb_tree_node_base**)( p_Var17 + 0x28 ) = p_Var20;
   if (uVar19 < 0x10) {
      if (uVar19 == 1) {
         p_Var17[0x38] = *__src;
      }
 else if (uVar19 != 0) goto LAB_0012f964;
   }
 else {
      if ((long)uVar19 < 0) {
         /* WARNING: Subroutine does not return */
         std::__throw_length_error("basic_string::_M_create");
      }

      p_Var20 = (_Rb_tree_node_base*)glslang::TPoolAllocator::allocate(uVar18);
      *(_Rb_tree_node_base**)( p_Var17 + 0x28 ) = p_Var20;
      *(ulong*)( p_Var17 + 0x38 ) = uVar19;
      LAB_0012f964:memcpy(p_Var20, __src, uVar19);
      p_Var20 = *(_Rb_tree_node_base**)( p_Var17 + 0x28 );
   }

   *(ulong*)( p_Var17 + 0x30 ) = uVar19;
   p_Var20[uVar19] = (_Rb_tree_node_base)0x0;
   std::_Rb_tree_insert_and_rebalance(bVar32, p_Var17, p_Var29, p_Var15);
   *(long*)( lVar22 + 0x758 ) = *(long*)( lVar22 + 0x758 ) + 1;
   LAB_0012f160:if (*(code**)( *(long*)pTVar31 + 0x60 ) == TVariable::getType) {
      pTVar30 = pTVar31 + 0x28;
   }
 else {
      pTVar30 = (TSourceLoc*)( **(code**)( *(long*)pTVar31 + 0x60 ) )(pTVar31);
   }

   if (*(code**)( *(long*)pTVar30 + 0x38 ) == TType::getBasicType) {
      uVar10 = (uint)(byte)pTVar30[8];
   }
 else {
      uVar10 = ( **(code**)( *(long*)pTVar30 + 0x38 ) )();
   }

   if (uVar10 == 0x12) {
      if (*(code**)( *(long*)pTVar31 + 0x60 ) == TVariable::getType) {
         pTVar31 = pTVar31 + 0x28;
      }
 else {
         pTVar31 = (TSourceLoc*)( **(code**)( *(long*)pTVar31 + 0x60 ) )(pTVar31);
      }

      if (*(code**)( *(long*)pTVar31 + 0x58 ) == TType::getQualifier) {
         pTVar31 = pTVar31 + 0x10;
      }
 else {
         pTVar31 = (TSourceLoc*)( **(code**)( *(long*)pTVar31 + 0x58 ) )();
      }

      TVar2 = pTVar31[0xe];
      if (( ( ( ( ( (byte)TVar2 & 0x40 ) != 0 ) || ( ( (byte)TVar2 & 0x20 ) != 0 ) ) || ( ( (byte)TVar2 & 0x10 ) != 0 ) ) || ( ( ( (byte)TVar2 & 8 ) != 0 || ( ( (byte)TVar2 & 2 ) != 0 ) ) ) ) || ( ( (byte)pTVar31[0xf] & 1 ) != 0 )) {
         lVar22 = *(long*)( this + 0x38 );
         *(undefined1*)( lVar22 + 0x304 ) = 1;
         local_68 = local_58;
         std::__cxx11::string::_M_construct<char_const*>(&local_68, "use-vulkan-memory-model");
         plVar12 = *(long**)( lVar22 + 0x7d8 );
         if (plVar12 == *(long**)( lVar22 + 0x7e0 )) {
            std::vector<std::__cxx11::string,std::allocator<std::__cxx11::string>>::_M_realloc_insert<std::__cxx11::string>((vector<std::__cxx11::string,std::allocator<std::__cxx11::string>>*)( lVar22 + 2000 ), plVar12, &local_68);
            if (local_68 != local_58) {
               operator_delete(local_68, local_58[0] + 1);
            }

         }
 else {
            *plVar12 = (long)( plVar12 + 2 );
            if (local_68 == local_58) {
               uVar19 = local_60 + 1;
               uVar10 = (uint)uVar19;
               if (uVar10 < 8) {
                  if (( uVar19 & 4 ) == 0) {
                     if (( uVar10 != 0 ) && ( *(char*)( plVar12 + 2 ) = (char)*local_68(uVar19 & 2) != 0 )) {
                        *(undefined2*)( (long)plVar12 + ( uVar19 & 0xffffffff ) + 0xe ) = *(undefined2*)( (long)local_68 + ( ( uVar19 & 0xffffffff ) - 2 ) );
                     }

                  }
 else {
                     *(int*)( plVar12 + 2 ) = (int)*local_68;
                     *(undefined4*)( (long)plVar12 + ( uVar19 & 0xffffffff ) + 0xc ) = *(undefined4*)( (long)local_68 + ( ( uVar19 & 0xffffffff ) - 4 ) );
                  }

               }
 else {
                  plVar12[2] = *local_68;
                  *(undefined8*)( (long)plVar12 + ( uVar19 & 0xffffffff ) + 8 ) = *(undefined8*)( (long)local_68 + ( ( uVar19 & 0xffffffff ) - 8 ) );
                  lVar26 = (long)( plVar12 + 2 ) - ( ( ulong )(plVar12 + 3) & 0xfffffffffffffff8 );
                  uVar10 = uVar10 + (int)lVar26 & 0xfffffff8;
                  if (7 < uVar10) {
                     uVar28 = 0;
                     do {
                        uVar19 = (ulong)uVar28;
                        uVar28 = uVar28 + 8;
                        *(undefined8*)( ( ( ulong )(plVar12 + 3) & 0xfffffffffffffff8 ) + uVar19 ) = *(undefined8*)( (long)local_68 + ( uVar19 - lVar26 ) );
                     }
 while ( uVar28 < uVar10 );
                  }

               }

            }
 else {
               *plVar12 = (long)local_68;
               plVar12[2] = local_58[0];
            }

            plVar12[1] = local_60;
            *(long*)( lVar22 + 0x7d8 ) = *(long*)( lVar22 + 0x7d8 ) + 0x20;
         }

      }

   }

   if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return plVar14;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::handlePragma(glslang::TSourceLoc const&,
   glslang::TVector<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > > const&) */void glslang::TParseContext::handlePragma(TParseContext *this, TSourceLoc *param_1, TVector *param_2) {
   long lVar1;
   short *psVar2;
   TParseContext TVar3;
   int iVar4;
   int iVar5;
   long lVar6;
   uint uVar7;
   char *pcVar8;
   uint uVar9;
   char *pcVar10;
   size_t sVar11;
   ulong uVar12;
   long *plVar13;
   code *UNRECOVERED_JUMPTABLE;
   long lVar14;
   long in_FS_OFFSET;
   undefined4 local_6c;
   long *local_68;
   long local_60;
   long local_58[3];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(long*)( this + 0x400 ) != 0) {
      local_6c = *(undefined4*)( param_1 + 0xc );
      ( **(code**)( this + 0x408 ) )(this + 0x3f0, &local_6c);
   }

   lVar6 = *(long*)( param_2 + 8 );
   lVar14 = *(long*)( param_2 + 0x10 ) - lVar6;
   if (lVar6 != *(long*)( param_2 + 0x10 )) {
      uVar12 = *(ulong*)( lVar6 + 0x10 );
      plVar13 = *(long**)( lVar6 + 8 );
      iVar4 = (int)uVar12;
      if (uVar12 < 9) {
         if (uVar12 == 0) {
            uVar7 = *(uint*)( this + 0x20 );
            goto joined_r0x00130a79;
         }

         iVar5 = memcmp(plVar13, "optimize", uVar12);
         if (( iVar5 == 0 ) && ( iVar4 == 8 )) {
            if (lVar14 != 0xa0) {
               if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) goto LAB_001310b3;
               pcVar8 = "#pragma";
               pcVar10 = "optimize pragma syntax is incorrect";
               UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
               goto LAB_001305b0;
            }

            if (( ( ( *(long*)( lVar6 + 0x38 ) == 0 ) || ( **(char**)( lVar6 + 0x30 ) != '(' ) ) || ( lVar14 = *(long*)( lVar6 + 0x38 ) + -1 ),0x7fffffff < lVar14 )) {
               if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                  pcVar8 = "#pragma";
                  pcVar10 = "\"(\" expected after \'optimize\' keyword";
                  UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                  goto LAB_001305b0;
               }

               goto LAB_001310b3;
            }

            uVar12 = *(ulong*)( lVar6 + 0x60 );
            psVar2 = *(short**)( lVar6 + 0x58 );
            if (uVar12 < 3) {
               if (uVar12 == 0) goto LAB_001309b8;
               iVar4 = memcmp(psVar2, &_LC1128, uVar12);
               if (( iVar4 != 0 ) || ( (int)uVar12 != 2 )) goto LAB_001308f1;
               TVar3 = (TParseContext)0x1;
            }
 else {
               if (*psVar2 == 0x6e6f) {
                  sVar11 = 3;
                  if (( (long)( uVar12 - 2 ) < 0x80000000 ) && ( -0x80000001 < (long)( uVar12 - 2 ) )) goto LAB_001308f1;
               }
 else {
                  LAB_001308f1:sVar11 = 3;
                  if (uVar12 < 4) {
                     sVar11 = uVar12;
                  }

               }

               iVar4 = memcmp(psVar2, &_LC1103, sVar11);
               if (( ( ( iVar4 != 0 ) || ( lVar14 = uVar12 - 3 ),0x7fffffff < lVar14 ) ) || ( lVar14 < -0x80000000 )) {
                  LAB_001309b8:if (( (byte)this[0xd0] & 1 ) != 0) {
                     if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                        pcVar8 = "#pragma";
                        pcVar10 = "\"on\" or \"off\" expected after \'(\' for \'optimize\' pragma";
                        UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x160 );
                        goto LAB_001305b0;
                     }

                     goto LAB_001310b3;
                  }

                  goto LAB_001303a8;
               }

               TVar3 = (TParseContext)0x0;
            }

            this[0x178] = TVar3;
            if (( ( *(long*)( lVar6 + 0x88 ) == 0 ) || ( **(char**)( lVar6 + 0x80 ) != ')' ) ) || ( ( lVar6 = *(long*)( lVar6 + 0x88 ) + -1 ),0x7fffffff < lVar6 || ( ( lVar6 < -0x80000000 || ( (int)lVar6 != 0 ) ) ) )) {
               if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                  pcVar8 = "#pragma";
                  pcVar10 = "\")\" expected to end \'optimize\' pragma";
                  UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                  LAB_001305b0:/* WARNING: Could not recover jumptable at 0x001305c6. Too many branches *//* WARNING: Treating indirect jump as call */( *UNRECOVERED_JUMPTABLE )(this, param_1, pcVar10, pcVar8, &_LC1, UNRECOVERED_JUMPTABLE);
                  return;
               }

               goto LAB_001310b3;
            }

            goto LAB_001303a8;
         }

         if (uVar12 < 6) {
            iVar5 = memcmp(plVar13, "debug", uVar12);
            if (( iVar5 == 0 ) && ( iVar4 == 5 )) {
               LAB_00130642:if (lVar14 != 0xa0) {
                  if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) goto LAB_001310b3;
                  pcVar8 = "#pragma";
                  pcVar10 = "debug pragma syntax is incorrect";
                  UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                  goto LAB_001305b0;
               }

               if (( ( ( *(long*)( lVar6 + 0x38 ) == 0 ) || ( **(char**)( lVar6 + 0x30 ) != '(' ) ) || ( lVar14 = *(long*)( lVar6 + 0x38 ) + -1 ),0x7fffffff < lVar14 )) {
                  if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                     pcVar8 = "#pragma";
                     pcVar10 = "\"(\" expected after \'debug\' keyword";
                     UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                     goto LAB_001305b0;
                  }

                  goto LAB_001310b3;
               }

               uVar12 = *(ulong*)( lVar6 + 0x60 );
               psVar2 = *(short**)( lVar6 + 0x58 );
               if (uVar12 < 3) {
                  if (uVar12 == 0) goto LAB_00130c7b;
                  iVar4 = memcmp(psVar2, &_LC1128, uVar12);
                  if (( iVar4 != 0 ) || ( (int)uVar12 != 2 )) goto LAB_00130c58;
                  TVar3 = (TParseContext)0x1;
               }
 else {
                  if (*psVar2 == 0x6e6f) {
                     sVar11 = 3;
                     if ((long)( uVar12 - 2 ) < 0x80000000) {
                        if (-0x80000001 < (long)( uVar12 - 2 )) goto LAB_00130c58;
                        sVar11 = 3;
                     }

                  }
 else {
                     LAB_00130c58:sVar11 = 3;
                     if (uVar12 < 4) {
                        sVar11 = uVar12;
                     }

                  }

                  iVar4 = memcmp(psVar2, &_LC1103, sVar11);
                  if (( ( ( iVar4 != 0 ) || ( lVar14 = uVar12 - 3 ),0x7fffffff < lVar14 ) ) || ( lVar14 < -0x80000000 )) {
                     LAB_00130c7b:if (( (byte)this[0xd0] & 1 ) != 0) {
                        if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                           pcVar8 = "#pragma";
                           pcVar10 = "\"on\" or \"off\" expected after \'(\' for \'debug\' pragma";
                           UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x160 );
                           goto LAB_001305b0;
                        }

                        goto LAB_001310b3;
                     }

                     goto LAB_001303a8;
                  }

                  TVar3 = (TParseContext)0x0;
               }

               this[0x179] = TVar3;
               if (( ( *(long*)( lVar6 + 0x88 ) == 0 ) || ( **(char**)( lVar6 + 0x80 ) != ')' ) ) || ( ( lVar6 = *(long*)( lVar6 + 0x88 ) + -1 ),0x7fffffff < lVar6 || ( ( lVar6 < -0x80000000 || ( (int)lVar6 != 0 ) ) ) )) {
                  if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                     pcVar8 = "#pragma";
                     pcVar10 = "\")\" expected to end \'debug\' pragma";
                     UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                     goto LAB_001305b0;
                  }

                  goto LAB_001310b3;
               }

               goto LAB_001303a8;
            }

         }
 else if (( (int)*plVar13 == 0x75626564 ) && ( *(char*)( (long)plVar13 + 4 ) == 'g' )) goto LAB_001309a7;
         uVar7 = *(uint*)( this + 0x20 );
         if (uVar7 == 0) goto LAB_00130a20;
         LAB_001306ab:iVar5 = memcmp(plVar13, "use_storage_buffer", uVar12);
         if (iVar5 == 0) {
            LAB_001306d3:if (iVar4 == 0x12) {
               if (lVar14 != 0x28) {
                  ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "extra tokens", "#pragma", &_LC1);
               }

               *(undefined1*)( *(long*)( this + 0x38 ) + 0x271 ) = 1;
               goto LAB_001303a8;
            }

         }

         LAB_00130450:sVar11 = 0x17;
         if (uVar12 < 0x18) {
            sVar11 = uVar12;
         }

         LAB_0013045c:iVar5 = memcmp(plVar13, "use_vulkan_memory_model", sVar11);
         if (iVar5 == 0) {
            lVar1 = uVar12 - 0x17;
            if (0x7fffffff < lVar1) {
               LAB_00130de2:if (( ( *plVar13 != 0x697261765f657375 || plVar13[1] != 0x696f705f656c6261 ) || ( *(long*)( (long)plVar13 + 0xd ) != 0x737265746e696f70 ) ) || ( 0x7fffffff < (long)( uVar12 - 0x15 ) )) goto LAB_00130bd4;
               goto LAB_00130e2a;
            }

            if (lVar1 < -0x80000000) {
               LAB_00130f79:if (( *plVar13 != 0x697261765f657375 || plVar13[1] != 0x696f705f656c6261 ) || ( *(long*)( (long)plVar13 + 0xd ) != 0x737265746e696f70 )) goto LAB_00130a20;
               goto LAB_00130ec8;
            }

            if ((int)lVar1 != 0) goto LAB_00130ab8;
            if (lVar14 != 0x28) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "extra tokens", "#pragma", &_LC1);
            }

            lVar6 = *(long*)( this + 0x38 );
            *(undefined1*)( lVar6 + 0x304 ) = 1;
            local_68 = local_58;
            std::__cxx11::string::_M_construct<char_const*>(&local_68, "use-vulkan-memory-model");
            plVar13 = *(long**)( lVar6 + 0x7d8 );
            if (plVar13 == *(long**)( lVar6 + 0x7e0 )) goto LAB_00130380;
            *plVar13 = (long)( plVar13 + 2 );
            if (local_68 == local_58) {
               uVar12 = local_60 + 1;
               uVar7 = (uint)uVar12;
               if (uVar7 < 8) {
                  if (( uVar12 & 4 ) == 0) {
                     if (( uVar7 != 0 ) && ( *(char*)( plVar13 + 2 ) = (char)*local_68(uVar12 & 2) != 0 )) {
                        *(undefined2*)( (long)plVar13 + ( uVar12 & 0xffffffff ) + 0xe ) = *(undefined2*)( (long)local_68 + ( ( uVar12 & 0xffffffff ) - 2 ) );
                     }

                  }
 else {
                     *(int*)( plVar13 + 2 ) = (int)*local_68;
                     *(undefined4*)( (long)plVar13 + ( uVar12 & 0xffffffff ) + 0xc ) = *(undefined4*)( (long)local_68 + ( ( uVar12 & 0xffffffff ) - 4 ) );
                  }

               }
 else {
                  plVar13[2] = *local_68;
                  *(undefined8*)( (long)plVar13 + ( uVar12 & 0xffffffff ) + 8 ) = *(undefined8*)( (long)local_68 + ( ( uVar12 & 0xffffffff ) - 8 ) );
                  lVar14 = (long)( plVar13 + 2 ) - ( ( ulong )(plVar13 + 3) & 0xfffffffffffffff8 );
                  uVar7 = uVar7 + (int)lVar14 & 0xfffffff8;
                  if (7 < uVar7) {
                     uVar9 = 0;
                     do {
                        uVar12 = (ulong)uVar9;
                        uVar9 = uVar9 + 8;
                        *(undefined8*)( ( ( ulong )(plVar13 + 3) & 0xfffffffffffffff8 ) + uVar12 ) = *(undefined8*)( (long)local_68 + ( uVar12 - lVar14 ) );
                     }
 while ( uVar9 < uVar7 );
                  }

               }

            }
 else {
               *plVar13 = (long)local_68;
               plVar13[2] = local_58[0];
            }

            LAB_0013053a:plVar13[1] = local_60;
            *(long*)( lVar6 + 0x7d8 ) = *(long*)( lVar6 + 0x7d8 ) + 0x20;
            goto LAB_001303a8;
         }

         LAB_00130ab8:if (0x15 < uVar12) goto LAB_00130e94;
         if (uVar12 != 0) {
            iVar5 = memcmp(plVar13, "use_variable_pointers", uVar12);
            if (( iVar5 != 0 ) || ( iVar4 != 0x15 )) goto LAB_00130a20;
            if (lVar14 != 0x28) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "extra tokens", "#pragma", &_LC1);
               uVar7 = *(uint*)( this + 0x20 );
            }

            if (uVar7 < 0x10300) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "requires SPIR-V 1.3", "#pragma use_variable_pointers", &_LC1);
            }

            lVar6 = *(long*)( this + 0x38 );
            *(undefined1*)( lVar6 + 0x4d6 ) = 1;
            local_68 = local_58;
            std::__cxx11::string::_M_construct<char_const*>(&local_68, "use-variable-pointers");
            plVar13 = *(long**)( lVar6 + 0x7d8 );
            if (plVar13 == *(long**)( lVar6 + 0x7e0 )) {
               LAB_00130380:std::vector<std::__cxx11::string,std::allocator<std::__cxx11::string>>::_M_realloc_insert<std::__cxx11::string>((vector<std::__cxx11::string,std::allocator<std::__cxx11::string>>*)( lVar6 + 2000 ), plVar13, &local_68);
               if (local_68 != local_58) {
                  operator_delete(local_68, local_58[0] + 1);
               }

               goto LAB_001303a8;
            }

            *plVar13 = (long)( plVar13 + 2 );
            if (local_68 == local_58) {
               uVar12 = local_60 + 1;
               uVar7 = (uint)uVar12;
               if (uVar7 < 8) {
                  if (( uVar12 & 4 ) == 0) {
                     if (( uVar7 != 0 ) && ( *(char*)( plVar13 + 2 ) = (char)*local_68(uVar12 & 2) != 0 )) {
                        *(undefined2*)( (long)plVar13 + ( uVar12 & 0xffffffff ) + 0xe ) = *(undefined2*)( (long)local_68 + ( ( uVar12 & 0xffffffff ) - 2 ) );
                     }

                  }
 else {
                     *(int*)( plVar13 + 2 ) = (int)*local_68;
                     *(undefined4*)( (long)plVar13 + ( uVar12 & 0xffffffff ) + 0xc ) = *(undefined4*)( (long)local_68 + ( ( uVar12 & 0xffffffff ) - 4 ) );
                  }

               }
 else {
                  plVar13[2] = *local_68;
                  *(undefined8*)( (long)plVar13 + ( uVar12 & 0xffffffff ) + 8 ) = *(undefined8*)( (long)local_68 + ( ( uVar12 & 0xffffffff ) - 8 ) );
                  lVar14 = (long)( plVar13 + 2 ) - ( ( ulong )(plVar13 + 3) & 0xfffffffffffffff8 );
                  uVar7 = (int)lVar14 + uVar7 & 0xfffffff8;
                  if (7 < uVar7) {
                     uVar12 = 0;
                     do {
                        uVar9 = (int)uVar12 + 8;
                        *(undefined8*)( ( ( ulong )(plVar13 + 3) & 0xfffffffffffffff8 ) + uVar12 ) = *(undefined8*)( (long)local_68 + ( uVar12 - lVar14 ) );
                        uVar12 = (ulong)uVar9;
                     }
 while ( uVar9 < uVar7 );
                  }

               }

            }
 else {
               *plVar13 = (long)local_68;
               plVar13[2] = local_58[0];
            }

            goto LAB_0013053a;
         }

         LAB_0013013b:iVar4 = std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::compare((char*)plVar13);
         if (( ( iVar4 == 0 ) && ( iVar4 = std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::compare(*(char**)( lVar6 + 0x30 )) ),iVar4 == 0 )) {
            *(undefined1*)( *(long*)( this + 0x38 ) + 0x272 ) = 1;
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_Position");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_PointSize");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_ClipDistance");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_CullDistance");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_TessLevelOuter");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_TessLevelInner");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_PrimitiveID");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_Layer");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_ViewportIndex");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_FragDepth");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_SampleMask");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_ClipVertex");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_FrontColor");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_BackColor");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_FrontSecondaryColor");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_BackSecondaryColor");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_TexCoord");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_FogFragCoord");
            ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_FragColor");
            if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
               /* WARNING: Could not recover jumptable at 0x00130379. Too many branches */
               /* WARNING: Treating indirect jump as call */
               ( **(code**)( *(long*)this + 0x240 ) )(this, param_1, "gl_FragData");
               return;
            }

            goto LAB_001310b3;
         }

      }
 else {
         if (( ( *plVar13 != 0x657a696d6974706f ) || ( 0x7fffffff < (long)( uVar12 - 8 ) ) ) || ( -0x80000001 < (long)( uVar12 - 8 ) )) {
            if (( (int)*plVar13 != 0x75626564 ) || ( *(char*)( (long)plVar13 + 4 ) != 'g' )) {
               LAB_0013040d:uVar7 = *(uint*)( this + 0x20 );
               if (uVar7 != 0) {
                  if (0x12 < uVar12) goto LAB_00130422;
                  goto LAB_001306ab;
               }

               goto LAB_00130a20;
            }

            if ((long)( uVar12 - 5 ) < 0x80000000) goto LAB_0013099b;
            uVar7 = *(uint*)( this + 0x20 );
            if (uVar7 != 0) goto LAB_00130cf0;
            goto LAB_00130bd4;
         }

         if (( (int)*plVar13 == 0x75626564 ) && ( *(char*)( (long)plVar13 + 4 ) == 'g' )) {
            LAB_0013099b:if (-0x80000001 < (long)( uVar12 - 5 )) {
               LAB_001309a7:if (iVar4 == 5) goto LAB_00130642;
               goto LAB_0013040d;
            }

            uVar7 = *(uint*)( this + 0x20 );
            if (uVar7 != 0) {
               LAB_00130cf0:if (( *plVar13 == 0x726f74735f657375 && plVar13[1] == 0x666675625f656761 ) && ( (short)plVar13[2] == 0x7265 )) goto LAB_00130e56;
               sVar11 = 0x17;
               goto LAB_0013045c;
            }

            if ((int)*plVar13 == 0x65636e6f) goto LAB_00130d96;
            LAB_00130a4b:if (0x1c < uVar12) goto LAB_00130bd4;
            iVar5 = memcmp(plVar13, "glslang_binary_double_output", uVar12);
            if (iVar5 != 0) goto joined_r0x00130a79;
         }
 else {
            uVar7 = *(uint*)( this + 0x20 );
            if (uVar7 == 0) goto LAB_00130a20;
            LAB_00130422:if (( *plVar13 != 0x726f74735f657375 || plVar13[1] != 0x666675625f656761 ) || ( (short)plVar13[2] != 0x7265 )) goto LAB_00130450;
            LAB_00130e56:if (( (long)( uVar12 - 0x12 ) < 0x80000000 ) && ( -0x80000001 < (long)( uVar12 - 0x12 ) )) goto LAB_001306d3;
            if (( *plVar13 == 0x6b6c75765f657375 && plVar13[1] == 0x726f6d656d5f6e61 ) && ( *(long*)( (long)plVar13 + 0xf ) == 0x6c65646f6d5f7972 )) {
               if (0x7fffffff < (long)( uVar12 - 0x17 )) goto LAB_00130de2;
               if ((long)( uVar12 - 0x17 ) < -0x80000000) goto LAB_00130f79;
               goto LAB_00130ab8;
            }

            LAB_00130e94:iVar5 = memcmp(plVar13, "use_variable_pointers", 0x15);
            if (iVar5 == 0) {
               if ((long)( uVar12 - 0x15 ) < 0x80000000) {
                  LAB_00130ec8:if (-0x80000001 < (long)( uVar12 - 0x15 )) goto LAB_00130a20;
                  LAB_00130e2a:if ((int)*plVar13 == 0x65636e6f) goto LAB_00130d96;
               }

            }
 else {
               LAB_00130a20:sVar11 = 4;
               if (uVar12 < 5) {
                  sVar11 = uVar12;
               }

               iVar5 = memcmp(plVar13, &_LC1114, sVar11);
               if (iVar5 != 0) goto LAB_00130a4b;
               if ((long)( uVar12 - 4 ) < 0x80000000) {
                  LAB_00130d96:if (-0x80000001 < (long)( uVar12 - 4 )) {
                     if ((int)( uVar12 - 4 ) == 0) {
                        if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                           pcVar8 = "#pragma once";
                           pcVar10 = "not implemented";
                           UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x160 );
                           goto LAB_001305b0;
                        }

                        goto LAB_001310b3;
                     }

                     goto LAB_00130a4b;
                  }

               }

            }

            LAB_00130bd4:if (( ( ( *plVar13 != 0x5f676e616c736c67 || plVar13[1] != 0x645f7972616e6962 ) || ( *(long*)( (long)plVar13 + 0xc ) != 0x6c62756f645f7972 || *(long*)( (long)plVar13 + 0x14 ) != 0x74757074756f5f65 ) ) || ( 0x7fffffff < (long)( uVar12 - 0x1c ) ) ) || ( (long)( uVar12 - 0x1c ) < -0x80000000 )) goto joined_r0x00130a79;
         }

         if (iVar4 == 0x1c) {
            *(undefined1*)( *(long*)( this + 0x38 ) + 0x50d ) = 1;
         }
 else {
            joined_r0x00130a79:if (uVar7 != 0) goto LAB_0013013b;
         }

      }

   }

   LAB_001303a8:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return;
   }

   LAB_001310b3:/* WARNING: Subroutine does not return */__stack_chk_fail();
}
/* void 
   glslang::ForEachOpaque<glslang::TParseContext::vkRelaxedRemapFunctionParameter(glslang::TFunction*,
   glslang::TParameter&, std::vector<int, std::allocator<int> >*)::{lambda(glslang::TType const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >
   const&)#1}>(glslang::TType const&, std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const&,
   glslang::TParseContext::vkRelaxedRemapFunctionParameter(glslang::TFunction*,
   glslang::TParameter&, std::vector<int, std::allocator<int> >*)::{lambda(glslang::TType const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >
   const&)#1})::{lambda(glslang::TType const&, std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const&, bool,
   auto:1&)#1}::TEMPNAMEPLACEHOLDERVALUE(glslang::TType const&, std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const&, bool, {lambda(glslang::TType
   const&, std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >
   const&, bool, auto:1&)#1}&) const */void glslang::ForEachOpaque {
   lambda(glslang::TType_const&,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const&)
   #1
   ::
{lambda(glslang::TType_const&,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const&,bool,auto:1&)
   #1
   ::operator ()(_lambda_glslang__TType_const__std____cxx11__basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> const__bool_auto_1___1_*this, TType *param_1, basic_string *param_2, bool param_3, _lambda_glslang__TType_const__std____cxx11__basic_string<char,std::char_traits<char>,glslang::std::allocator<char>_> _const__bool_auto_1___1_*param_4) {
      undefined4 *__s;
      ulong uVar1;
      int *piVar2;
      TType TVar3;
      basic_string bVar4;
      undefined4 uVar5;
      undefined1 *puVar6;
      char *pcVar7;
      long *plVar8;
      vector<int,std::allocator<int>> *pvVar9;
      code *pcVar10;
      long lVar11;
      char cVar12;
      undefined4 *puVar13;
      int *piVar14;
      size_t sVar15;
      undefined8 *puVar16;
      undefined8 uVar17;
      basic_string *pbVar18;
      long *plVar19;
      long lVar20;
      long lVar21;
      basic_string *pbVar22;
      byte bVar23;
      byte bVar24;
      ulong uVar25;
      int iVar26;
      long *plVar27;
      ulong uVar28;
      ulong uVar29;
      ulong uVar30;
      int iVar31;
      ulong uVar32;
      long in_FS_OFFSET;
      undefined4 *local_128;
      int local_10c;
      undefined8 *local_108;
      basic_string *pbStack_100;
      long local_f8;
      ulong local_e8;
      ulong *local_e0;
      ulong local_d8;
      ulong local_d0[3];
      undefined8 local_b8;
      char *local_b0;
      ulong local_a8;
      char local_a0[24];
      ulong local_88;
      ulong *local_80;
      ulong local_78;
      ulong local_70[3];
      char local_58[24];
      long local_40;
      local_40 = *(long*)( in_FS_OFFSET + 0x28 );
      lVar21 = *(long*)param_1;
      if (!param_3) {
         if (*(code**)( lVar21 + 0xe8 ) == TType::isArray) {
            if (*(long*)( param_1 + 0x60 ) != 0) {
               LAB_00131162:if (*(code**)( lVar21 + 0x98 ) == TType::getArraySizes) {
                  lVar21 = *(long*)( param_1 + 0x60 );
               }
 else {
                  lVar21 = ( **(code**)( lVar21 + 0x98 ) )(param_1);
               }

               lVar21 = *(long*)( lVar21 + 8 );
               if (lVar21 != 0) {
                  uVar30 = (ulong)(int)( *(long*)( lVar21 + 0x10 ) - *(long*)( lVar21 + 8 ) >> 4 );
                  if (uVar30 >> 0x3d != 0) {
                     /* WARNING: Subroutine does not return */
                     std::__throw_length_error("cannot create std::vector larger than max_size()");
                  }

                  if (uVar30 != 0) {
                     uVar29 = uVar30 * 4;
                     puVar13 = (undefined4*)operator_new(uVar29);
                     *puVar13 = 0;
                     __s = puVar13 + 1;
                     if (uVar30 == 1) {
                        uVar29 = 4;
                        uVar30 = 1;
                        local_128 = __s;
                     }
 else {
                        local_128 = puVar13 + uVar30;
                        uVar30 = 1;
                        if (local_128 != __s) {
                           memset(__s, 0, uVar29 - 4);
                           uVar30 = (long)uVar29 >> 2;
                        }

                     }

                     goto LAB_001311fc;
                  }

               }

               local_128 = (undefined4*)0x0;
               uVar30 = 0;
               uVar29 = 0;
               puVar13 = (undefined4*)0x0;
               LAB_001311fc:lVar21 = *(long*)param_1;
               iVar31 = 0;
               do {
                  if (*(code**)( lVar21 + 0x98 ) == TType::getArraySizes) {
                     lVar21 = *(long*)( param_1 + 0x60 );
                  }
 else {
                     lVar21 = ( **(code**)( lVar21 + 0x98 ) )(param_1);
                  }

                  lVar21 = *(long*)( lVar21 + 8 );
                  if (lVar21 == 0) {
                     LAB_00131db8:iVar26 = 1;
                  }
 else {
                     piVar14 = *(int**)( lVar21 + 8 );
                     iVar26 = (int)( *(long*)( lVar21 + 0x10 ) - (long)piVar14 >> 4 );
                     if (iVar26 < 1) goto LAB_00131db8;
                     piVar2 = piVar14 + ( ulong )(iVar26 - 1) * 4 + 4;
                     iVar26 = 1;
                     do {
                        iVar26 = iVar26 * *piVar14;
                        piVar14 = piVar14 + 4;
                     }
 while ( piVar14 != piVar2 );
                  }

                  if (iVar26 <= iVar31) {
                     if (puVar13 == (undefined4*)0x0) goto LAB_00131890;
                     if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                        operator_delete(puVar13, uVar29);
                        return;
                     }

                     goto LAB_00131f39;
                  }

                  local_e8 = glslang::GetThreadPoolAllocator();
                  uVar28 = *(ulong*)( param_2 + 0x10 );
                  puVar6 = *(undefined1**)( param_2 + 8 );
                  local_e0 = local_d0;
                  if (uVar28 < 0x10) {
                     if (uVar28 == 1) {
                        local_d0[0] = CONCAT71(local_d0[0]._1_7_, *puVar6);
                     }
 else if (uVar28 != 0) goto LAB_00131c82;
                  }
 else {
                     if ((long)uVar28 < 0) goto LAB_00131f4a;
                     local_e0 = (ulong*)glslang::TPoolAllocator::allocate(local_e8);
                     local_d0[0] = uVar28;
                     LAB_00131c82:memcpy(local_e0, puVar6, uVar28);
                  }

                  uVar32 = 0;
                  *(undefined1*)( (long)local_e0 + uVar28 ) = 0;
                  local_d8 = uVar28;
                  if (local_128 != puVar13) {
                     do {
                        uVar28 = local_d8;
                        uVar5 = puVar13[uVar32];
                        if (local_d8 == 0x7fffffffffffffff) goto LAB_00131f21;
                        uVar1 = local_d8 + 1;
                        uVar25 = local_d0[0];
                        if (local_e0 == local_d0) {
                           uVar25 = 0xf;
                        }

                        if (uVar25 < uVar1) {
                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_e8, local_d8, 0, "[", 1);
                        }
 else {
                           *(undefined1*)( (long)local_e0 + local_d8 ) = 0x5b;
                        }

                        *(undefined1*)( (long)local_e0 + uVar28 + 1 ) = 0;
                        local_d8 = uVar1;
                        __snprintf_chk(local_58, 0x10, 2, 0x10, &_LC524, uVar5);
                        local_b8 = glslang::GetThreadPoolAllocator();
                        local_b0 = local_a0;
                        sVar15 = strlen(local_58);
                        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_b8, local_58, local_58 + sVar15);
                        if (0x7fffffffffffffff - local_d8 < local_a8) goto LAB_00131f21;
                        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_append((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_e8, local_b0, local_a8);
                        uVar28 = local_d8;
                        if (local_d8 == 0x7fffffffffffffff) goto LAB_00131f21;
                        uVar1 = local_d8 + 1;
                        uVar25 = local_d0[0];
                        if (local_e0 == local_d0) {
                           uVar25 = 0xf;
                        }

                        if (uVar25 < uVar1) {
                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_e8, local_d8, 0, "]", 1);
                        }
 else {
                           *(undefined1*)( (long)local_e0 + local_d8 ) = 0x5d;
                        }

                        uVar32 = uVar32 + 1;
                        *(undefined1*)( (long)local_e0 + uVar28 + 1 ) = 0;
                        local_d8 = uVar1;
                     }
 while ( uVar32 < uVar30 );
                  }

                  operator()((_lambda_glslang__TType_const__std____cxx11__basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const__bool_auto_1___1_
                      *)
                  param_4,param_1,(basic_string*)&local_e8,true,param_4;
                  if (uVar30 == 0) {
                     lVar21 = *(long*)param_1;
                  }
 else {
                     uVar28 = 0;
                     lVar21 = *(long*)param_1;
                     do {
                        iVar26 = puVar13[uVar28];
                        pcVar10 = *(code**)( lVar21 + 0x98 );
                        puVar13[uVar28] = iVar26 + 1;
                        if (pcVar10 == TType::getArraySizes) {
                           lVar20 = *(long*)( param_1 + 0x60 );
                        }
 else {
                           lVar20 = ( *pcVar10 )(param_1);
                           lVar21 = *(long*)param_1;
                        }

                        if (iVar26 + 1 < *(int*)( uVar28 * 0x10 + *(long*)( *(long*)( lVar20 + 8 ) + 8 ) )) break;
                        puVar13[uVar28] = 0;
                        uVar28 = uVar28 + 1;
                     }
 while ( uVar28 != uVar30 );
                  }

                  iVar31 = iVar31 + 1;
               }
 while ( true );
            }

         }
 else {
            cVar12 = ( **(code**)( lVar21 + 0xe8 ) )(param_1);
            if (cVar12 != '\0') {
               lVar21 = *(long*)param_1;
               goto LAB_00131162;
            }

            lVar21 = *(long*)param_1;
         }

      }

      if (*(code**)( lVar21 + 0x128 ) == TType::isStruct) {
         if (( byte )((char)param_1[8] - 0xfU) < 2) {
            LAB_001318d0:if (*(code**)( lVar21 + 0x1b0 ) == TType::containsOpaque) {
               if (*(code**)( lVar21 + 0x140 ) == TType::isOpaque) {
                  if (( 0x14 < (byte)param_1[8] ) || ( ( 0x1a6000UL >> ( (ulong)(byte)param_1[8] & 0x3f ) & 1 ) == 0 )) {
                     LAB_00131aee:if (*(code**)( lVar21 + 0x128 ) == TType::isStruct) {
                        if (1 < ( byte )((char)param_1[8] - 0xfU)) goto LAB_001314bf;
                        LAB_00131b0f:lVar21 = *(long*)( *(long*)( param_1 + 0x68 ) + 0x10 );
                        lVar20 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_1 + 0x68 ) + 8 ),lVar21 ));
                        if (lVar21 != lVar20) goto LAB_0013191b;
                     }
 else {
                        cVar12 = ( **(code**)( lVar21 + 0x128 ) )(param_1);
                        if (cVar12 != '\0') goto LAB_00131b0f;
                     }

                     lVar21 = *(long*)param_1;
                     goto LAB_001314bf;
                  }

               }
 else {
                  cVar12 = ( **(code**)( lVar21 + 0x140 ) )(param_1);
                  if (cVar12 == '\0') {
                     lVar21 = *(long*)param_1;
                     goto LAB_00131aee;
                  }

               }

               LAB_0013191b:plVar27 = *(long**)( *(long*)( param_1 + 0x68 ) + 8 );
               plVar8 = *(long**)( *(long*)( param_1 + 0x68 ) + 0x10 );
               if (plVar8 != plVar27) {
                  do {
                     local_88 = glslang::GetThreadPoolAllocator();
                     uVar30 = *(ulong*)( param_2 + 0x10 );
                     puVar6 = *(undefined1**)( param_2 + 8 );
                     local_80 = local_70;
                     if (uVar30 < 0x10) {
                        if (uVar30 == 1) {
                           local_70[0] = CONCAT71(local_70[0]._1_7_, *puVar6);
                        }
 else if (uVar30 != 0) goto LAB_00131d32;
                     }
 else {
                        if ((long)uVar30 < 0) {
                           LAB_00131f4a:/* WARNING: Subroutine does not return */std::__throw_length_error("basic_string::_M_create");
                        }

                        local_80 = (ulong*)glslang::TPoolAllocator::allocate(local_88);
                        local_70[0] = uVar30;
                        LAB_00131d32:memcpy(local_80, puVar6, uVar30);
                     }

                     *(undefined1*)( (long)local_80 + uVar30 ) = 0;
                     local_78 = uVar30;
                     if (uVar30 == 0x7fffffffffffffff) {
                        LAB_00131f21:/* WARNING: Subroutine does not return */std::__throw_length_error("basic_string::append");
                     }

                     uVar29 = uVar30 + 1;
                     uVar28 = local_70[0];
                     if (local_80 == local_70) {
                        uVar28 = 0xf;
                     }

                     if (uVar28 < uVar29) {
                        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_88, uVar30, 0, ".", 1);
                     }
 else {
                        *(undefined1*)( (long)local_80 + uVar30 ) = 0x2e;
                     }

                     *(undefined1*)( (long)local_80 + uVar30 + 1 ) = 0;
                     pcVar10 = *(code**)( *(long*)*plVar27 + 0x30 );
                     local_78 = uVar29;
                     if (pcVar10 == TType::getFieldName_abi_cxx11_) {
                        lVar21 = ( (long*)*plVar27 )[0xe];
                     }
 else {
                        lVar21 = ( *pcVar10 )();
                     }

                     uVar30 = *(ulong*)( lVar21 + 0x10 );
                     pcVar7 = *(char**)( lVar21 + 8 );
                     if (0x7fffffffffffffff - local_78 < uVar30) goto LAB_00131f21;
                     uVar29 = uVar30 + local_78;
                     uVar28 = local_70[0];
                     if (local_80 == local_70) {
                        uVar28 = 0xf;
                     }

                     if (uVar28 < uVar29) {
                        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_88, local_78, 0, pcVar7, uVar30);
                     }
 else if (uVar30 != 0) {
                        if (uVar30 == 1) {
                           *(char*)( (long)local_80 + local_78 ) = *pcVar7;
                        }
 else {
                           memcpy((char*)( (long)local_80 + local_78 ), pcVar7, uVar30);
                        }

                     }

                     plVar19 = plVar27 + 4;
                     *(undefined1*)( (long)local_80 + uVar29 ) = 0;
                     local_78 = uVar29;
                     operator()((_lambda_glslang__TType_const__std____cxx11__basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const__bool_auto_1___1_
                        *)
                     param_4,(TType*)*plVar27,(basic_string*)&local_88,false,param_4;
                     plVar27 = plVar19;
                  }
 while ( plVar8 != plVar19 );
               }

               goto LAB_00131890;
            }

            cVar12 = ( **(code**)( lVar21 + 0x1b0 ) )(param_1);
            if (cVar12 != '\0') goto LAB_0013191b;
            lVar21 = *(long*)param_1;
         }

      }
 else {
         cVar12 = ( **(code**)( lVar21 + 0x128 ) )(param_1);
         lVar21 = *(long*)param_1;
         if (cVar12 != '\0') goto LAB_001318d0;
      }

      LAB_001314bf:if (*(code**)( lVar21 + 0x140 ) == TType::isOpaque) {
         if (( 0x14 < (byte)param_1[8] ) || ( ( 0x1a6000UL >> ( (ulong)(byte)param_1[8] & 0x3f ) & 1 ) == 0 )) goto LAB_00131890;
      }
 else {
         cVar12 = ( **(code**)( lVar21 + 0x140 ) )(param_1);
         if (cVar12 == '\0') goto LAB_00131890;
      }

      plVar27 = *(long**)this;
      pcVar7 = *(char**)( param_2 + 8 );
      uVar30 = glslang::GetThreadPoolAllocator();
      puVar16 = (undefined8*)glslang::TPoolAllocator::allocate(uVar30);
      uVar17 = glslang::GetThreadPoolAllocator();
      *puVar16 = uVar17;
      puVar16[1] = puVar16 + 3;
      if (pcVar7 == (char*)0x0) {
         /* WARNING: Subroutine does not return */
         std::__throw_logic_error("basic_string: construction from null is not valid");
      }

      sVar15 = strlen(pcVar7);
      std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(puVar16, pcVar7, pcVar7 + sVar15);
      uVar30 = glslang::GetThreadPoolAllocator();
      pbVar18 = (basic_string*)glslang::TPoolAllocator::allocate(uVar30);
      *(undefined***)pbVar18 = &PTR__TType_00167f00;
      *(uint*)( pbVar18 + 0x80 ) = *(uint*)( pbVar18 + 0x80 ) & 0x9fc00000;
      pbVar18[0x20] = ( basic_string )((byte)pbVar18[0x20] & 0xf0);
      *(undefined1(*) [16])( pbVar18 + 0x88 ) = (undefined1[16])0x0;
      *(uint*)( pbVar18 + 8 ) = CONCAT22((short)( ( uint ) * (undefined4*)( pbVar18 + 8 ) >> 0x10 ), 0x100) & 0xf800ffff;
      *(undefined8*)( pbVar18 + 0x44 ) = 0xfffff800;
      *(undefined2*)( pbVar18 + 0x58 ) = 0;
      *(undefined1(*) [16])( pbVar18 + 0x60 ) = (undefined1[16])0x0;
      *(ulong*)( pbVar18 + 0x2d ) = *(ulong*)( pbVar18 + 0x2d ) & 0xffffff0000ffc07f | 0xffff001f80;
      *(undefined1(*) [16])( pbVar18 + 0x70 ) = (undefined1[16])0x0;
      *(long*)( pbVar18 + 0x10 ) = 0;
      *(undefined8*)( pbVar18 + 0x24 ) = 0xffffffffffffffff;
      *(ulong*)( pbVar18 + 0x38 ) = ( ulong )(( uint ) * (long*)( pbVar18 + 0x38 ) & 0xfe07ff00) | 0x1f800ff;
      pbVar18[0x40] = (basic_string)0x0;
      *(ulong*)( pbVar18 + 0x2c ) = *(ulong*)( pbVar18 + 0x2c ) & 0xffffffff8000 | 0xffff000000004fff;
      *(undefined4*)( pbVar18 + 0x4c ) = 0xffffffff;
      *(ulong*)( pbVar18 + 0x34 ) = *(ulong*)( pbVar18 + 0x34 ) | 0x7ff007fffffff;
      *(long*)( pbVar18 + 0x50 ) = 0;
      *(ulong*)( pbVar18 + 0x18 ) = *(ulong*)( pbVar18 + 0x18 ) & 0x8000000400000000;
      TVar3 = param_1[8];
      lVar21 = *(long*)( param_1 + 0x10 );
      lVar20 = *(long*)( param_1 + 0x18 );
      *(undefined4*)( pbVar18 + 0x80 ) = *(undefined4*)( param_1 + 0x80 );
      *(TType*)( pbVar18 + 8 ) = TVar3;
      *(long*)( pbVar18 + 0x10 ) = lVar21;
      *(long*)( pbVar18 + 0x18 ) = lVar20;
      for (int i = 0; i < 4; i++) {
         lVar21 = *(long*)( param_1 + ( 16*i + 40 ) );
         *(long*)( pbVar18 + ( 16*i + 32 ) ) = *(long*)( param_1 + ( 16*i + 32 ) );
         *(long*)( pbVar18 + ( 16*i + 40 ) ) = lVar21;
      }

      TVar3 = param_1[9];
      pbVar18[9] = ( basic_string )((byte)pbVar18[9] & 0xf0 | (byte)TVar3 & 0xf);
      pbVar18[9] = ( basic_string )((byte)TVar3 & 0xf | (byte)param_1[9] & 0xf0);
      bVar4 = pbVar18[10];
      bVar23 = (byte)param_1[10] & 0xf;
      pbVar18[10] = ( basic_string )((byte)bVar4 & 0xf0 | bVar23);
      bVar24 = (byte)param_1[10] & 0x10;
      pbVar18[10] = ( basic_string )((byte)bVar4 & 0xe0 | bVar23 | bVar24);
      lVar20 = *(long*)( param_1 + 0x70 );
      lVar11 = *(long*)( param_1 + 0x78 );
      lVar21 = *(long*)( param_1 + 0x68 );
      *(long*)( pbVar18 + 0x60 ) = *(long*)( param_1 + 0x60 );
      *(long*)( pbVar18 + 0x68 ) = lVar21;
      *(long*)( pbVar18 + 0x70 ) = lVar20;
      *(long*)( pbVar18 + 0x78 ) = lVar11;
      lVar21 = *(long*)( param_1 + 0x90 );
      *(long*)( pbVar18 + 0x88 ) = *(long*)( param_1 + 0x88 );
      *(long*)( pbVar18 + 0x90 ) = lVar21;
      TVar3 = param_1[10];
      pbVar18[10] = ( basic_string )((byte)bVar4 & 0xc0 | bVar23 | bVar24 | (byte)TVar3 & 0x20);
      pbVar18[10] = ( basic_string )((byte)bVar4 & 0x80 | bVar23 | bVar24 | (byte)TVar3 & 0x20 | (byte)param_1[10] & 0x40);
      *(ushort*)( pbVar18 + 10 ) = *(ushort*)( pbVar18 + 10 ) & 0xfc7f | *(ushort*)( param_1 + 10 ) & 0x380;
      pbVar18[0xb] = ( basic_string )((byte)pbVar18[0xb] & 0xfb | (byte)param_1[0xb] & 4);
      pcVar10 = *(code**)( *(long*)plVar27[2] + 0x50 );
      if (pcVar10 == TType::getQualifier) {
         bVar23 = *(byte*)( (long*)plVar27[2] + 3 ) & 0x7f;
         LAB_00131755:pbVar22 = pbVar18 + 0x10;
      }
 else {
         lVar21 = ( *pcVar10 )();
         bVar23 = *(byte*)( lVar21 + 8 ) & 0x7f;
         if (*(code**)( *(long*)pbVar18 + 0x50 ) == TType::getQualifier) goto LAB_00131755;
         pbVar22 = (basic_string*)( **(code**)( *(long*)pbVar18 + 0x50 ) )(pbVar18);
      }

      pbVar22[8] = ( basic_string )((byte)pbVar22[8] & 0x80 | bVar23);
      *(long*)( pbVar18 + 0x60 ) = 0;
      plVar8 = (long*)*plVar27;
      local_f8 = 0;
      local_108 = puVar16;
      pbStack_100 = pbVar18;
      if (*(code**)( *plVar8 + 0xb0 ) == TFunction::addParameter) {
         plVar19 = (long*)plVar8[7];
         if (plVar19 == (long*)plVar8[8]) {
            std::vector<glslang::TParameter,glslang::pool_allocator<glslang::TParameter>>::_M_realloc_insert<glslang::TParameter_const&>((vector<glslang::TParameter,glslang::pool_allocator<glslang::TParameter>>*)( plVar8 + 5 ), plVar19, &local_108);
         }
 else {
            *plVar19 = (long)puVar16;
            plVar19[1] = (long)pbVar18;
            plVar19[2] = 0;
            plVar8[7] = (long)( plVar19 + 3 );
         }

         glslang::TType::buildMangledName(pbStack_100);
         uVar30 = plVar8[0x1f];
         plVar19 = (long*)plVar8[0x1e];
         if (plVar19 == plVar8 + 0x20) {
            uVar29 = 0xf;
         }
 else {
            uVar29 = plVar8[0x20];
         }

         if (uVar29 < uVar30 + 1) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( plVar8 + 0x1d ), uVar30, 0, (char*)0x0, 1);
            plVar19 = (long*)plVar8[0x1e];
         }

         *(undefined1*)( (long)plVar19 + uVar30 ) = 0x3b;
         plVar8[0x1f] = uVar30 + 1;
         *(undefined1*)( plVar8[0x1e] + 1 + uVar30 ) = 0;
         if (local_f8 != 0) {
            *(int*)( plVar8 + 0x23 ) = (int)plVar8[0x23] + 1;
         }

      }
 else {
         ( **(code**)( *plVar8 + 0xb0 ) )(plVar8, &local_108);
      }

      pvVar9 = (vector<int,std::allocator<int>>*)plVar27[4];
      if (pvVar9 != (vector<int,std::allocator<int>>*)0x0) {
         plVar27 = (long*)*plVar27;
         if (*(code**)( *plVar27 + 0x120 ) == TFunction::getParamCount) {
            local_10c = (int)( plVar27[7] - plVar27[6] >> 3 ) * -0x55555555;
         }
 else {
            local_10c = ( **(code**)( *plVar27 + 0x120 ) )();
         }

         local_10c = local_10c + -1;
         piVar14 = *(int**)( pvVar9 + 8 );
         if (piVar14 == *(int**)( pvVar9 + 0x10 )) {
            std::vector<int,std::allocator<int>>::_M_realloc_insert<int>(pvVar9, piVar14, &local_10c);
         }
 else {
            *piVar14 = local_10c;
            *(int**)( pvVar9 + 8 ) = piVar14 + 1;
         }

      }

      LAB_00131890:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
         return;
      }

      LAB_00131f39:/* WARNING: Subroutine does not return */__stack_chk_fail();
   }

   /* glslang::TParseContext::vkRelaxedRemapFunctionParameter(glslang::TFunction*,
   glslang::TParameter&, std::vector<int, std::allocator<int> >*) */
   void glslang::TParseContext::vkRelaxedRemapFunctionParameter(TParseContext *this, TFunction *param_1, TParameter *param_2, vector *param_3) {
      undefined8 *puVar1;
      ulong uVar2;
      basic_string *pbVar3;
      undefined8 uVar4;
      char cVar5;
      TFunction *pTVar6;
      long lVar7;
      long lVar8;
      basic_string *pbVar9;
      ulong uVar10;
      TType *pTVar11;
      TType *pTVar12;
      long in_FS_OFFSET;
      TFunction **local_70;
      TFunction *local_68;
      basic_string *local_60;
      TType *local_58;
      undefined8 local_50;
      vector *local_48;
      long local_40;
      local_40 = *(long*)( in_FS_OFFSET + 0x28 );
      if (*(code**)( *(long*)param_1 + 0xb0 ) == TFunction::addParameter) {
         puVar1 = *(undefined8**)( param_1 + 0x38 );
         if (puVar1 == *(undefined8**)( param_1 + 0x40 )) {
            std::vector<glslang::TParameter,glslang::pool_allocator<glslang::TParameter>>::_M_realloc_insert<glslang::TParameter_const&>((vector<glslang::TParameter,glslang::pool_allocator<glslang::TParameter>>*)( param_1 + 0x28 ), puVar1, param_2);
         }
 else {
            uVar4 = *(undefined8*)( param_2 + 8 );
            *puVar1 = *(undefined8*)param_2;
            puVar1[1] = uVar4;
            puVar1[2] = *(undefined8*)( param_2 + 0x10 );
            *(undefined8**)( param_1 + 0x38 ) = puVar1 + 3;
         }

         glslang::TType::buildMangledName(*(basic_string**)( param_2 + 8 ));
         uVar2 = *(ulong*)( param_1 + 0xf8 );
         pTVar6 = *(TFunction**)( param_1 + 0xf0 );
         if (pTVar6 == param_1 + 0x100) {
            uVar10 = 0xf;
         }
 else {
            uVar10 = *(ulong*)( param_1 + 0x100 );
         }

         if (uVar10 < uVar2 + 1) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( param_1 + 0xe8 ), uVar2, 0, (char*)0x0, 1);
            pTVar6 = *(TFunction**)( param_1 + 0xf0 );
         }

         pTVar6[uVar2] = (TFunction)0x3b;
         *(ulong*)( param_1 + 0xf8 ) = uVar2 + 1;
         *(undefined1*)( *(long*)( param_1 + 0xf0 ) + 1 + uVar2 ) = 0;
         if (*(long*)( param_2 + 0x10 ) != 0) {
            *(int*)( param_1 + 0x118 ) = *(int*)( param_1 + 0x118 ) + 1;
         }

      }
 else {
         ( **(code**)( *(long*)param_1 + 0xb0 ) )(param_1, param_2);
      }

      pTVar12 = *(TType**)( param_2 + 8 );
      lVar7 = *(long*)pTVar12;
      if (*(code**)( lVar7 + 0x128 ) == TType::isStruct) {
         if (1 < ( byte )((char)pTVar12[8] - 0xfU)) goto LAB_001320f9;
      }
 else {
         cVar5 = ( **(code**)( lVar7 + 0x128 ) )(pTVar12);
         if (cVar5 == '\0') goto LAB_001320f9;
         pTVar12 = *(TType**)( param_2 + 8 );
         lVar7 = *(long*)pTVar12;
      }

      if (*(code**)( lVar7 + 0x1b0 ) == TType::containsOpaque) {
         if (*(code**)( lVar7 + 0x140 ) != TType::isOpaque) {
            cVar5 = ( **(code**)( lVar7 + 0x140 ) )(pTVar12);
            if (cVar5 == '\0') {
               lVar7 = *(long*)pTVar12;
               goto LAB_0013212d;
            }

            goto LAB_00132164;
         }

         if (( 0x14 < (byte)pTVar12[8] ) || ( ( 0x1a6000UL >> ( (ulong)(byte)pTVar12[8] & 0x3f ) & 1 ) == 0 )) {
            LAB_0013212d:if (*(code**)( lVar7 + 0x128 ) == TType::isStruct) {
               if (1 < ( byte )((char)pTVar12[8] - 0xfU)) goto LAB_001320f9;
            }
 else {
               cVar5 = ( **(code**)( lVar7 + 0x128 ) )(pTVar12);
               if (cVar5 == '\0') goto LAB_001320f9;
            }

            lVar7 = *(long*)( *(long*)( pTVar12 + 0x68 ) + 0x10 );
            lVar8 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( pTVar12 + 0x68 ) + 8 ),lVar7 ));
            if (lVar7 == lVar8) goto LAB_001320f9;
            goto LAB_00132164;
         }

      }
 else {
         cVar5 = ( **(code**)( lVar7 + 0x1b0 ) )(pTVar12);
         if (cVar5 == '\0') goto LAB_001320f9;
         LAB_00132164:pTVar12 = *(TType**)( param_2 + 8 );
      }

      pbVar3 = *(basic_string**)param_2;
      uVar4 = *(undefined8*)( param_2 + 0x10 );
      pbVar9 = pbVar3;
      pTVar11 = pTVar12;
      if (pbVar3 == (basic_string*)0x0) {
         if (*(code**)( *(long*)pTVar12 + 0x30 ) == TType::getFieldName_abi_cxx11_) {
            pbVar9 = *(basic_string**)( pTVar12 + 0x70 );
         }
 else {
            pbVar9 = (basic_string*)( **(code**)( *(long*)pTVar12 + 0x30 ) )(pTVar12);
            pTVar11 = *(TType**)( param_2 + 8 );
         }

      }

      local_70 = &local_68;
      local_68 = param_1;
      local_60 = pbVar3;
      local_58 = pTVar12;
      local_50 = uVar4;
      local_48 = param_3;
      ForEachOpaque<glslang::TParseContext::vkRelaxedRemapFunctionParameter(glslang::TFunction*,glslang::TParameter&,std::vector<int,std::allocator<int>>*)::{
         lambda(glslang::TType_const&,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const&)
         #1
         ::
  {lambda(glslang::TType_const&,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const&,bool,auto:1&)
         #1
         ::operator ()((_lambda_glslang__TType_const__std____cxx11__basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const__bool_auto_1___1_*)&local_70, pTVar11, pbVar9, false, (_lambda_glslang__TType_const__std____cxx11__basic_string<char,std::char_traits<char>,glslang::std::allocator<char>_>_const__bool_auto_1___1_*)&local_70);
         LAB_001320f9:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
            /* WARNING: Subroutine does not return */
            __stack_chk_fail();
         }

         return;
      }

      /* glslang::TParseContext::vkRelaxedRemapFunctionArgument(glslang::TSourceLoc const&,
   glslang::TFunction*, glslang::TIntermTyped*) */
      TIntermTyped * __thiscallglslang::TParseContext::vkRelaxedRemapFunctionArgument(TParseContext * this, TSourceLoc * param_1, TFunction * param_2, TIntermTyped * param_3);
      {
         TIntermTyped TVar1;
         undefined4 uVar2;
         char *__s;
         byte bVar3;
         char cVar4;
         ulong uVar5;
         undefined8 *puVar6;
         undefined8 uVar7;
         size_t sVar8;
         long *plVar9;
         long lVar10;
         TSourceLoc *pTVar11;
         long lVar12;
         TFunction *pTVar13;
         TVariable *pTVar14;
         TIntermTyped *pTVar15;
         ulong uVar16;
         code *pcVar17;
         int *piVar18;
         long in_FS_OFFSET;
         undefined1 local_e8[16];
         undefined8 local_d8;
         undefined1 local_c8[16];
         long local_b8;
         undefined **local_a8;
         undefined4 local_a0;
         undefined8 local_9c;
         undefined8 local_90;
         undefined8 local_88;
         undefined8 local_80;
         undefined8 local_78;
         undefined8 local_70;
         char *local_68;
         char local_58[16];
         int local_48;
         long local_40;
         local_40 = *(long*)( in_FS_OFFSET + 0x28 );
         local_a0 = 0x10000;
         local_9c = 0;
         local_a8 = &PTR__TIntermTraverser_00168108;
         local_90 = glslang::GetThreadPoolAllocator();
         local_88 = 0;
         local_80 = 0;
         local_78 = 0;
         local_a8 = &PTR__AccessChainTraverser_00168418;
         local_70 = glslang::GetThreadPoolAllocator();
         local_68 = local_58;
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_70, &_LC1, &_LC1);
         local_48 = 0x20;
         ( **(code**)( *(long*)param_3 + 0x10 ) )(param_3, &local_a8);
         __s = local_68;
         if (local_48 == 5) {
            local_c8 = (undefined1[16])0x0;
            local_b8 = 0;
            uVar5 = glslang::GetThreadPoolAllocator();
            plVar9 = (long*)glslang::TPoolAllocator::allocate(uVar5);
            *plVar9 = (long)&PTR__TType_00167f00;
            *(undefined2*)( plVar9 + 0xb ) = 0;
            *(byte*)( plVar9 + 4 ) = *(byte*)( plVar9 + 4 ) & 0xf0;
            *(undefined1(*) [16])( plVar9 + 0xc ) = (undefined1[16])0x0;
            *(uint*)( plVar9 + 1 ) = CONCAT22((short)( (uint)(int)plVar9[1] >> 0x10 ), 0x100) & 0xf800ffff;
            *(undefined8*)( (long)plVar9 + 0x44 ) = 0xfffff800;
            *(undefined1(*) [16])( plVar9 + 0x11 ) = (undefined1[16])0x0;
            *(ulong*)( (long)plVar9 + 0x2d ) = *(ulong*)( (long)plVar9 + 0x2d ) & 0xffffff0000ffc07f | 0xffff001f80;
            *(undefined1(*) [16])( plVar9 + 0xe ) = (undefined1[16])0x0;
            *(undefined1*)( plVar9 + 8 ) = 0;
            plVar9[2] = 0;
            plVar9[7] = ( ulong )((uint)plVar9[7] & 0xfe07ff00) | 0x1f800ff;
            *(uint*)( plVar9 + 0x10 ) = *(uint*)( plVar9 + 0x10 ) & 0x9fc00000;
            *(ulong*)( (long)plVar9 + 0x2c ) = *(ulong*)( (long)plVar9 + 0x2c ) & 0xffffffff8000 | 0xffff000000004fff;
            *(ulong*)( (long)plVar9 + 0x34 ) = *(ulong*)( (long)plVar9 + 0x34 ) | 0x7ff007fffffff;
            plVar9[3] = plVar9[3] & 0x8000000400000000;
            lVar10 = *(long*)param_3;
            *(undefined8*)( (long)plVar9 + 0x24 ) = 0xffffffffffffffff;
            *(undefined4*)( (long)plVar9 + 0x4c ) = 0xffffffff;
            pcVar17 = *(code**)( lVar10 + 0xf0 );
            plVar9[10] = 0;
            local_c8._8_8_ = plVar9;
            if (pcVar17 == TIntermTyped::getType) {
               pTVar15 = param_3 + 0x20;
               pcVar17 = TType::isStruct;
            }
 else {
               pTVar15 = (TIntermTyped*)( *pcVar17 )(param_3);
               pcVar17 = *(code**)( *plVar9 + 0x128 );
            }

            lVar10 = *(long*)( pTVar15 + 0x18 );
            TVar1 = pTVar15[8];
            uVar2 = *(undefined4*)( pTVar15 + 0x80 );
            plVar9[2] = *(long*)( pTVar15 + 0x10 );
            plVar9[3] = lVar10;
            lVar10 = *(long*)( pTVar15 + 0x20 );
            lVar12 = *(long*)( pTVar15 + 0x28 );
            *(undefined4*)( plVar9 + 0x10 ) = uVar2;
            plVar9[4] = lVar10;
            plVar9[5] = lVar12;
            lVar10 = *(long*)( pTVar15 + 0x30 );
            lVar12 = *(long*)( pTVar15 + 0x38 );
            *(TIntermTyped*)( plVar9 + 1 ) = TVar1;
            plVar9[6] = lVar10;
            plVar9[7] = lVar12;
            lVar10 = *(long*)( pTVar15 + 0x48 );
            plVar9[8] = *(long*)( pTVar15 + 0x40 );
            plVar9[9] = lVar10;
            lVar10 = *(long*)( pTVar15 + 0x58 );
            plVar9[10] = *(long*)( pTVar15 + 0x50 );
            plVar9[0xb] = lVar10;
            TVar1 = pTVar15[9];
            *(byte*)( (long)plVar9 + 9 ) = *(byte*)( (long)plVar9 + 9 ) & 0xf0 | (byte)TVar1 & 0xf;
            *(byte*)( (long)plVar9 + 9 ) = (byte)TVar1 & 0xf | (byte)pTVar15[9] & 0xf0;
            bVar3 = *(byte*)( (long)plVar9 + 10 );
            TVar1 = pTVar15[10];
            *(byte*)( (long)plVar9 + 10 ) = bVar3 & 0xf0 | (byte)TVar1 & 0xf;
            bVar3 = bVar3 & 0xe0 | (byte)TVar1 & 0xf | (byte)pTVar15[10] & 0x10;
            *(byte*)( (long)plVar9 + 10 ) = bVar3;
            lVar10 = *(long*)( pTVar15 + 0x70 );
            lVar12 = *(long*)( pTVar15 + 0x78 );
            plVar9[0xc] = *(long*)( pTVar15 + 0x60 );
            plVar9[0xe] = lVar10;
            plVar9[0xf] = lVar12;
            if (pcVar17 != TType::isStruct) {
               ( *pcVar17 )(plVar9);
               bVar3 = *(byte*)( (long)plVar9 + 10 );
            }

            plVar9[0xd] = *(long*)( pTVar15 + 0x68 );
            lVar10 = *(long*)( pTVar15 + 0x90 );
            plVar9[0x11] = *(long*)( pTVar15 + 0x88 );
            plVar9[0x12] = lVar10;
            TVar1 = pTVar15[10];
            *(byte*)( (long)plVar9 + 10 ) = bVar3 & 0xdf | (byte)TVar1 & 0x20;
            *(byte*)( (long)plVar9 + 10 ) = bVar3 & 0x9f | (byte)TVar1 & 0x20 | (byte)pTVar15[10] & 0x40;
            *(ushort*)( (long)plVar9 + 10 ) = *(ushort*)( (long)plVar9 + 10 ) & 0xfc7f | *(ushort*)( pTVar15 + 10 ) & 0x380;
            *(byte*)( (long)plVar9 + 0xb ) = *(byte*)( (long)plVar9 + 0xb ) & 0xfb | (byte)pTVar15[0xb] & 4;
            if (*(code**)( *(long*)param_2 + 0xb0 ) == TFunction::addParameter) {
               puVar6 = *(undefined8**)( param_2 + 0x38 );
               if (puVar6 == *(undefined8**)( param_2 + 0x40 )) {
                  std::vector<glslang::TParameter,glslang::pool_allocator<glslang::TParameter>>::_M_realloc_insert<glslang::TParameter_const&>((vector<glslang::TParameter,glslang::pool_allocator<glslang::TParameter>>*)( param_2 + 0x28 ), puVar6, local_c8);
               }
 else {
                  *puVar6 = local_c8._0_8_;
                  puVar6[1] = local_c8._8_8_;
                  puVar6[2] = local_b8;
                  *(undefined8**)( param_2 + 0x38 ) = puVar6 + 3;
               }

               glslang::TType::buildMangledName((basic_string*)local_c8._8_8_);
               uVar5 = *(ulong*)( param_2 + 0xf8 );
               pTVar13 = *(TFunction**)( param_2 + 0xf0 );
               if (pTVar13 == param_2 + 0x100) {
                  uVar16 = 0xf;
               }
 else {
                  uVar16 = *(ulong*)( param_2 + 0x100 );
               }

               if (uVar16 < uVar5 + 1) {
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( param_2 + 0xe8 ), uVar5, 0, (char*)0x0, 1);
                  pTVar13 = *(TFunction**)( param_2 + 0xf0 );
               }

               pTVar13[uVar5] = (TFunction)0x3b;
               *(ulong*)( param_2 + 0xf8 ) = uVar5 + 1;
               *(undefined1*)( *(long*)( param_2 + 0xf0 ) + 1 + uVar5 ) = 0;
               if (local_b8 != 0) {
                  *(int*)( param_2 + 0x118 ) = *(int*)( param_2 + 0x118 ) + 1;
               }

            }
 else {
               ( **(code**)( *(long*)param_2 + 0xb0 ) )(param_2, local_c8);
            }

            goto LAB_001328c7;
         }

         local_e8 = (undefined1[16])0x0;
         local_d8 = 0;
         uVar5 = glslang::GetThreadPoolAllocator();
         puVar6 = (undefined8*)glslang::TPoolAllocator::allocate(uVar5);
         uVar7 = glslang::GetThreadPoolAllocator();
         *puVar6 = uVar7;
         puVar6[1] = puVar6 + 3;
         if (__s == (char*)0x0) {
            /* WARNING: Subroutine does not return */
            std::__throw_logic_error("basic_string: construction from null is not valid");
         }

         sVar8 = strlen(__s);
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(puVar6, __s, __s + sVar8);
         local_e8._0_8_ = puVar6;
         uVar5 = glslang::GetThreadPoolAllocator();
         plVar9 = (long*)glslang::TPoolAllocator::allocate(uVar5);
         *plVar9 = (long)&PTR__TType_00167f00;
         *(byte*)( plVar9 + 4 ) = *(byte*)( plVar9 + 4 ) & 0xf0;
         *(undefined1(*) [16])( plVar9 + 0x11 ) = (undefined1[16])0x0;
         *(undefined1(*) [16])( plVar9 + 0xc ) = (undefined1[16])0x0;
         *(uint*)( plVar9 + 1 ) = CONCAT22((short)( (uint)(int)plVar9[1] >> 0x10 ), 0x100) & 0xf800ffff;
         *(undefined8*)( (long)plVar9 + 0x44 ) = 0xfffff800;
         *(undefined2*)( plVar9 + 0xb ) = 0;
         *(undefined1(*) [16])( plVar9 + 0xe ) = (undefined1[16])0x0;
         *(ulong*)( (long)plVar9 + 0x2d ) = *(ulong*)( (long)plVar9 + 0x2d ) & 0xffffff0000ffc07f | 0xffff001f80;
         *(uint*)( plVar9 + 0x10 ) = *(uint*)( plVar9 + 0x10 ) & 0x9fc00000;
         plVar9[2] = 0;
         *(undefined8*)( (long)plVar9 + 0x24 ) = 0xffffffffffffffff;
         plVar9[7] = ( ulong )((uint)plVar9[7] & 0xfe07ff00) | 0x1f800ff;
         *(undefined1*)( plVar9 + 8 ) = 0;
         *(ulong*)( (long)plVar9 + 0x2c ) = *(ulong*)( (long)plVar9 + 0x2c ) & 0xffffffff8000 | 0xffff000000004fff;
         *(ulong*)( (long)plVar9 + 0x34 ) = *(ulong*)( (long)plVar9 + 0x34 ) | 0x7ff007fffffff;
         plVar9[3] = plVar9[3] & 0x8000000400000000;
         lVar10 = *(long*)param_3;
         *(undefined4*)( (long)plVar9 + 0x4c ) = 0xffffffff;
         pcVar17 = *(code**)( lVar10 + 0xf0 );
         plVar9[10] = 0;
         local_e8._8_8_ = plVar9;
         if (pcVar17 == TIntermTyped::getType) {
            pTVar15 = param_3 + 0x20;
            pcVar17 = TType::isStruct;
         }
 else {
            pTVar15 = (TIntermTyped*)( *pcVar17 )(param_3);
            pcVar17 = *(code**)( *plVar9 + 0x128 );
         }

         lVar10 = *(long*)( pTVar15 + 0x18 );
         TVar1 = pTVar15[8];
         uVar2 = *(undefined4*)( pTVar15 + 0x80 );
         plVar9[2] = *(long*)( pTVar15 + 0x10 );
         plVar9[3] = lVar10;
         lVar10 = *(long*)( pTVar15 + 0x20 );
         lVar12 = *(long*)( pTVar15 + 0x28 );
         *(undefined4*)( plVar9 + 0x10 ) = uVar2;
         plVar9[4] = lVar10;
         plVar9[5] = lVar12;
         lVar10 = *(long*)( pTVar15 + 0x30 );
         lVar12 = *(long*)( pTVar15 + 0x38 );
         *(TIntermTyped*)( plVar9 + 1 ) = TVar1;
         plVar9[6] = lVar10;
         plVar9[7] = lVar12;
         lVar10 = *(long*)( pTVar15 + 0x48 );
         plVar9[8] = *(long*)( pTVar15 + 0x40 );
         plVar9[9] = lVar10;
         lVar10 = *(long*)( pTVar15 + 0x58 );
         plVar9[10] = *(long*)( pTVar15 + 0x50 );
         plVar9[0xb] = lVar10;
         TVar1 = pTVar15[9];
         *(byte*)( (long)plVar9 + 9 ) = *(byte*)( (long)plVar9 + 9 ) & 0xf0 | (byte)TVar1 & 0xf;
         *(byte*)( (long)plVar9 + 9 ) = (byte)TVar1 & 0xf | (byte)pTVar15[9] & 0xf0;
         bVar3 = *(byte*)( (long)plVar9 + 10 );
         TVar1 = pTVar15[10];
         *(byte*)( (long)plVar9 + 10 ) = bVar3 & 0xf0 | (byte)TVar1 & 0xf;
         bVar3 = bVar3 & 0xe0 | (byte)TVar1 & 0xf | (byte)pTVar15[10] & 0x10;
         *(byte*)( (long)plVar9 + 10 ) = bVar3;
         lVar10 = *(long*)( pTVar15 + 0x70 );
         lVar12 = *(long*)( pTVar15 + 0x78 );
         plVar9[0xc] = *(long*)( pTVar15 + 0x60 );
         plVar9[0xe] = lVar10;
         plVar9[0xf] = lVar12;
         if (pcVar17 != TType::isStruct) {
            ( *pcVar17 )(plVar9);
            bVar3 = *(byte*)( (long)plVar9 + 10 );
         }

         plVar9[0xd] = *(long*)( pTVar15 + 0x68 );
         lVar10 = *(long*)( pTVar15 + 0x90 );
         plVar9[0x11] = *(long*)( pTVar15 + 0x88 );
         plVar9[0x12] = lVar10;
         TVar1 = pTVar15[10];
         *(byte*)( (long)plVar9 + 10 ) = bVar3 & 0xdf | (byte)TVar1 & 0x20;
         *(byte*)( (long)plVar9 + 10 ) = bVar3 & 0x9f | (byte)TVar1 & 0x20 | (byte)pTVar15[10] & 0x40;
         *(ushort*)( (long)plVar9 + 10 ) = *(ushort*)( (long)plVar9 + 10 ) & 0xfc7f | *(ushort*)( pTVar15 + 10 ) & 0x380;
         *(byte*)( (long)plVar9 + 0xb ) = *(byte*)( (long)plVar9 + 0xb ) & 0xfb | (byte)pTVar15[0xb] & 4;
         local_b8 = 0;
         local_c8 = (undefined1[16])0x0;
         vkRelaxedRemapFunctionParameter(this, param_2, (TParameter*)local_e8, (vector*)local_c8);
         if (*(code**)( *(long*)param_3 + 0xf0 ) == TIntermTyped::getType) {
            pTVar15 = param_3 + 0x20;
         }
 else {
            pTVar15 = (TIntermTyped*)( **(code**)( *(long*)param_3 + 0xf0 ) )(param_3);
         }

         if (*(code**)( *(long*)pTVar15 + 0x140 ) == TType::isOpaque) {
            if (( 0x14 < (byte)pTVar15[8] ) || ( ( 0x1a6000UL >> ( (ulong)(byte)pTVar15[8] & 0x3f ) & 1 ) == 0 )) goto LAB_001326a5;
            LAB_00132631:plVar9 = (long*)TSymbolTable::find(*(TSymbolTable**)( this + 0xe8 ), (basic_string*)local_e8._0_8_, (bool*)0x0, (bool*)0x0, (int*)0x0);
            if (( plVar9 == (long*)0x0 ) || ( lVar10 = lVar10 == 0 )) {
               uVar5 = glslang::GetThreadPoolAllocator();
               pTVar14 = (TVariable*)glslang::TPoolAllocator::allocate(uVar5);
               TVariable::TVariable(pTVar14, (basic_string*)local_e8._0_8_, (TType*)local_e8._8_8_, false);
               param_3 = (TIntermTyped*)glslang::TIntermediate::addSymbol(*(TVariable**)( this + 0x38 ), (TSourceLoc*)pTVar14);
               piVar18 = (int*)local_c8._0_8_;
            }
 else {
               pTVar14 = *(TVariable**)( this + 0x38 );
               pTVar11 = (TSourceLoc*)( **(code**)( *plVar9 + 0x48 ) )(plVar9);
               param_3 = (TIntermTyped*)glslang::TIntermediate::addSymbol(pTVar14, pTVar11);
               piVar18 = (int*)local_c8._0_8_;
            }

            goto LAB_001328b5;
         }

         cVar4 = ( **(code**)( *(long*)pTVar15 + 0x140 ) )();
         if (cVar4 != '\0') goto LAB_00132631;
         LAB_001326a5:lVar10 = *(long*)param_3;
         if (*(code**)( lVar10 + 0x168 ) == TIntermTyped::isStruct) {
            if (1 < ( byte )((char)param_3[0x28] - 0xfU)) goto LAB_001328b0;
            LAB_001326ce:if (*(code**)( lVar10 + 0xf0 ) == TIntermTyped::getType) {
               pTVar15 = param_3 + 0x20;
            }
 else {
               pTVar15 = (TIntermTyped*)( **(code**)( lVar10 + 0xf0 ) )(param_3);
            }

            lVar10 = *(long*)pTVar15;
            if (*(code**)( lVar10 + 0x1b0 ) != TType::containsOpaque) {
               cVar4 = ( **(code**)( lVar10 + 0x1b0 ) )(pTVar15);
               if (cVar4 != '\0') goto LAB_00132729;
               goto LAB_001328b0;
            }

            if (*(code**)( lVar10 + 0x140 ) == TType::isOpaque) {
               if (( 0x14 < (byte)pTVar15[8] ) || ( ( 0x1a6000UL >> ( (ulong)(byte)pTVar15[8] & 0x3f ) & 1 ) == 0 )) {
                  LAB_00132908:if (*(code**)( lVar10 + 0x128 ) == TType::isStruct) {
                     if (( byte )((char)pTVar15[8] - 0xfU) < 2) {
                        LAB_00132924:lVar10 = *(long*)( *(long*)( pTVar15 + 0x68 ) + 0x10 );
                        lVar12 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( pTVar15 + 0x68 ) + 8 ),lVar10 ));
                        if (lVar10 != lVar12) goto LAB_00132729;
                     }

                  }
 else {
                     cVar4 = ( **(code**)( lVar10 + 0x128 ) )(pTVar15);
                     if (cVar4 != '\0') goto LAB_00132924;
                  }

                  goto LAB_001328b0;
               }

            }
 else {
               cVar4 = ( **(code**)( lVar10 + 0x140 ) )(pTVar15);
               if (cVar4 == '\0') {
                  lVar10 = *(long*)pTVar15;
                  goto LAB_00132908;
               }

            }

            LAB_00132729:plVar9 = (long*)TSymbolTable::find(*(TSymbolTable**)( this + 0xe8 ), (basic_string*)local_e8._0_8_, (bool*)0x0, (bool*)0x0, (int*)0x0);
            if (( plVar9 != (long*)0x0 ) && ( lVar10 = lVar10 != 0 )) {
               pTVar14 = *(TVariable**)( this + 0x38 );
               pTVar11 = (TSourceLoc*)( **(code**)( *plVar9 + 0x48 ) )(plVar9);
               param_3 = (TIntermTyped*)glslang::TIntermediate::addSymbol(pTVar14, pTVar11);
            }

            piVar18 = (int*)local_c8._8_8_;
            if (local_c8._0_8_ != local_c8._8_8_) {
               param_3 = (TIntermTyped*)glslang::TIntermediate::makeAggregate(*(TIntermNode**)( this + 0x38 ), (TSourceLoc*)param_3);
               uVar7 = local_c8._8_8_;
               piVar18 = (int*)local_c8._0_8_;
               if (local_c8._8_8_ != local_c8._0_8_) {
                  do {
                     if (*(code**)( *(long*)param_2 + 0x138 ) == TFunction::operator []) {
                        puVar6 = (undefined8*)( *(long*)( param_2 + 0x30 ) + (long)*piVar18 * 0x18 );
                     }
 else {
                        puVar6 = (undefined8*)( **(code**)( *(long*)param_2 + 0x138 ) )(param_2);
                     }

                     plVar9 = (long*)TSymbolTable::find(*(TSymbolTable**)( this + 0xe8 ), (basic_string*)*puVar6, (bool*)0x0, (bool*)0x0, (int*)0x0);
                     if (( plVar9 == (long*)0x0 ) || ( lVar10 = lVar10 == 0 )) {
                        uVar5 = glslang::GetThreadPoolAllocator();
                        pTVar14 = (TVariable*)glslang::TPoolAllocator::allocate(uVar5);
                        TVariable::TVariable(pTVar14, (basic_string*)*puVar6, (TType*)puVar6[1], false);
                        glslang::TIntermediate::addSymbol(*(TVariable**)( this + 0x38 ), (TSourceLoc*)pTVar14);
                     }
 else {
                        pTVar14 = *(TVariable**)( this + 0x38 );
                        pTVar11 = (TSourceLoc*)( **(code**)( *plVar9 + 0x48 ) )();
                        glslang::TIntermediate::addSymbol(pTVar14, pTVar11);
                     }

                     piVar18 = piVar18 + 1;
                     param_3 = (TIntermTyped*)glslang::TIntermediate::growAggregate(*(TIntermNode**)( this + 0x38 ), (TIntermNode*)param_3);
                  }
 while ( (int*)uVar7 != piVar18 );
                  goto LAB_001328b0;
               }

            }

         }
 else {
            cVar4 = ( **(code**)( lVar10 + 0x168 ) )(param_3);
            if (cVar4 != '\0') {
               lVar10 = *(long*)param_3;
               goto LAB_001326ce;
            }

            LAB_001328b0:piVar18 = (int*)local_c8._0_8_;
         }

         LAB_001328b5:if (piVar18 != (int*)0x0) {
            operator_delete(piVar18, local_b8 - (long)piVar18);
         }

         LAB_001328c7:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
            /* WARNING: Subroutine does not return */
            __stack_chk_fail();
         }

         return param_3;
      }

      /* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::assign(char const*) [clone .isra.0] */
      void std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::assign(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *this, char *param_1) {
         ulong uVar1;
         size_t __n;
         ulong uVar2;
         basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *__dest;
         __n = strlen(param_1);
         __dest = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 );
         uVar1 = *(ulong*)( this + 0x10 );
         if (__dest == this + 0x18) {
            uVar2 = 0xf;
         }
 else {
            uVar2 = *(ulong*)( this + 0x18 );
         }

         if (__n <= uVar2) {
            if (( param_1 < __dest ) || ( __dest + uVar1 < param_1 )) {
               if (__n != 0) {
                  if (__n == 1) {
                     *__dest = ( basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> ) * param_1;
                     *(undefined8*)( this + 0x10 ) = 1;
                     *(undefined1*)( *(long*)( this + 8 ) + 1 ) = 0;
                     return;
                  }

                  memcpy(__dest, param_1, __n);
                  __dest = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 );
               }

            }
 else {
               _M_replace_cold(this, (char*)__dest, uVar1, param_1, __n, 0);
               __dest = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 );
            }

            *(size_t*)( this + 0x10 ) = __n;
            __dest[__n] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x0;
            return;
         }

         _M_mutate(this, 0, uVar1, param_1, __n);
         *(size_t*)( this + 0x10 ) = __n;
         *(undefined1*)( *(long*)( this + 8 ) + __n ) = 0;
         return;
      }

      /* glslang::TParseContext::getIoArrayImplicitSize(glslang::TQualifier const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >*) const
    */
      int glslang::TParseContext::getIoArrayImplicitSize(TParseContext *this, TQualifier *param_1, basic_string *param_2) {
         ulong uVar1;
         uint uVar2;
         uint uVar3;
         char *pcVar4;
         int iVar5;
         ushort uVar6;
         char *pcVar7;
         long lVar8;
         int iVar9;
         ulong uVar10;
         long in_FS_OFFSET;
         undefined8 local_68;
         ulong *local_60;
         ulong local_58;
         ulong local_50[2];
         long local_40;
         local_40 = *(long*)( in_FS_OFFSET + 0x28 );
         local_68 = glslang::GetThreadPoolAllocator();
         local_60 = local_50;
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_68, "unknown");
         lVar8 = *(long*)( this + 0x38 );
         iVar5 = *(int*)( lVar8 + 0x30c );
         if (iVar5 == -1) {
            iVar5 = 0;
         }

         iVar9 = *(int*)( this + 0x1c );
         if (iVar9 == 3) {
            iVar5 = 0;
            uVar2 = *(int*)( lVar8 + 0x310 ) - 1;
            if (uVar2 < 6) {
               iVar5 = *(int*)( CSWTCH_3508 + (ulong)uVar2 * 4 );
            }

            switch (*(int*)( lVar8 + 0x310 )) {
               default:
      pcVar4 = "none";
      break;
               case 1:
      pcVar4 = "points";
      break;
               case 2:
      pcVar4 = "lines";
      break;
               case 3:
      pcVar4 = "lines_adjacency";
      break;
               case 4:
      pcVar4 = "line_strip";
      break;
               case 5:
      pcVar4 = "triangles";
      break;
               case 6:
      pcVar4 = "triangles_adjacency";
      break;
               case 7:
      pcVar4 = "triangle_strip";
      break;
               case 8:
      pcVar4 = "quads";
      break;
               case 9:
      pcVar4 = "isolines";
            }

         }
 else {
            if (iVar9 != 1) {
               if (iVar9 == 4) {
                  iVar5 = 3;
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_68, "vertices");
               }
 else if (iVar9 == 0xd) {
                  iVar9 = *(int*)( lVar8 + 0x36c );
                  if (iVar9 == -1) {
                     iVar9 = 0;
                  }

                  uVar6 = *(ushort*)( param_1 + 8 ) & 0xff80;
                  if (uVar6 == 0x3c80) {
                     iVar5 = 0;
                     uVar2 = *(int*)( lVar8 + 0x314 ) - 1;
                     if (uVar2 < 6) {
                        iVar5 = *(int*)( CSWTCH_3508 + (ulong)uVar2 * 4 ) * iVar9;
                     }

                     std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_68, "max_primitives*");
                     switch (*(undefined4*)( *(long*)( this + 0x38 ) + 0x314 )) {
                        default:
            uVar10 = 4;
            pcVar4 = "none";
            break;
                        case 1:
            uVar10 = 6;
            pcVar4 = "points";
            break;
                        case 2:
            uVar10 = 5;
            pcVar4 = "lines";
            break;
                        case 3:
            uVar10 = 0xf;
            pcVar4 = "lines_adjacency";
            break;
                        case 4:
            uVar10 = 10;
            pcVar4 = "line_strip";
            break;
                        case 5:
            uVar10 = 9;
            pcVar4 = "triangles";
            break;
                        case 6:
            uVar10 = 0x13;
            pcVar4 = "triangles_adjacency";
            break;
                        case 7:
            uVar10 = 0xe;
            pcVar4 = "triangle_strip";
            break;
                        case 8:
            uVar10 = 5;
            pcVar4 = "quads";
            break;
                        case 9:
            uVar10 = 8;
            pcVar4 = "isolines";
                     }

                     if (0x7fffffffffffffff - local_58 < uVar10) {
                        /* WARNING: Subroutine does not return */
                        std::__throw_length_error("basic_string::append");
                     }

                     uVar1 = uVar10 + local_58;
                     if (local_60 == local_50) {
                        local_50[0] = 0xf;
                     }

                     if (local_50[0] < uVar1) {
                        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_68, local_58, 0, pcVar4, uVar10);
                     }
 else {
                        pcVar7 = (char*)( local_58 + (long)local_60 );
                        uVar2 = (uint)uVar10;
                        if (uVar2 < 8) {
                           if (( uVar10 & 4 ) == 0) {
                              if (( uVar2 != 0 ) && ( *pcVar7 = *pcVar4(uVar10 & 2) != 0 )) {
                                 *(undefined2*)( pcVar7 + ( uVar10 - 2 ) ) = *(undefined2*)( pcVar4 + ( uVar10 - 2 ) );
                              }

                           }
 else {
                              *(undefined4*)pcVar7 = *(undefined4*)pcVar4;
                              *(undefined4*)( pcVar7 + ( uVar10 - 4 ) ) = *(undefined4*)( pcVar4 + ( uVar10 - 4 ) );
                           }

                        }
 else {
                           *(undefined8*)pcVar7 = *(undefined8*)pcVar4;
                           *(undefined8*)( pcVar7 + ( uVar10 - 8 ) ) = *(undefined8*)( pcVar4 + ( uVar10 - 8 ) );
                           lVar8 = (long)pcVar7 - ( ( ulong )(pcVar7 + 8) & 0xfffffffffffffff8 );
                           uVar2 = uVar2 + (int)lVar8 & 0xfffffff8;
                           if (7 < uVar2) {
                              uVar3 = 0;
                              do {
                                 uVar10 = (ulong)uVar3;
                                 uVar3 = uVar3 + 8;
                                 *(undefined8*)( ( ( ulong )(pcVar7 + 8) & 0xfffffffffffffff8 ) + uVar10 ) = *(undefined8*)( pcVar4 + ( uVar10 - lVar8 ) );
                              }
 while ( uVar3 < uVar2 );
                           }

                        }

                     }

                     *(undefined1*)( (long)local_60 + uVar1 ) = 0;
                     local_58 = uVar1;
                  }
 else if (( ( *(ushort*)( param_1 + 8 ) >> 8 == 0x42 ) || ( uVar6 == 0x4180 ) ) || ( ( (byte)param_1[0xd] & 2 ) != 0 )) {
                     std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_68, "max_primitives");
                     iVar5 = iVar9;
                  }
 else {
                     std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_68, "max_vertices");
                  }

               }
 else {
                  iVar5 = 0;
               }

               goto LAB_00132fae;
            }

            pcVar4 = "vertices";
         }

         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_68, pcVar4);
         LAB_00132fae:if (param_2 != (basic_string*)0x0) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)param_2, (basic_string*)&local_68);
         }

         if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return iVar5;
         }

         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      /* glslang::TParseContext::handleIoResizeArrayAccess(glslang::TSourceLoc const&,
   glslang::TIntermTyped*) */
      void glslang::TParseContext::handleIoResizeArrayAccess(TParseContext *this, TSourceLoc *param_1, TIntermTyped *param_2) {
         code *pcVar1;
         char cVar2;
         int iVar3;
         long *plVar4;
         long lVar5;
         TQualifier *pTVar6;
         long *plVar7;
         plVar4 = (long*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
         if (plVar4 != (long*)0x0) {
            if (*(code**)( *plVar4 + 0xf0 ) == TIntermTyped::getType) {
               plVar7 = plVar4 + 4;
            }
 else {
               plVar7 = (long*)( **(code**)( *plVar4 + 0xf0 ) )(plVar4);
            }

            pcVar1 = *(code**)( *plVar7 + 0xf8 );
            if (pcVar1 == TType::isUnsizedArray) {
               pcVar1 = *(code**)( *plVar7 + 0xe8 );
               if (pcVar1 == TType::isArray) {
                  lVar5 = plVar7[0xc];
                  if (lVar5 == 0) {
                     return;
                  }

               }
 else {
                  cVar2 = ( *pcVar1 )(plVar7);
                  if (cVar2 == '\0') {
                     return;
                  }

                  lVar5 = plVar7[0xc];
               }

               if (**(int**)( *(long*)( lVar5 + 8 ) + 8 ) != 0) {
                  return;
               }

            }
 else {
               cVar2 = ( *pcVar1 )(plVar7);
               if (cVar2 == '\0') {
                  return;
               }

            }

            plVar7 = plVar4 + 4;
            if (*(code**)( *plVar4 + 0xf0 ) != TIntermTyped::getType) {
               plVar7 = (long*)( **(code**)( *plVar4 + 0xf0 ) )(plVar4);
            }

            if (*(code**)( *plVar7 + 0x58 ) == TType::getQualifier) {
               pTVar6 = (TQualifier*)( plVar7 + 2 );
            }
 else {
               pTVar6 = (TQualifier*)( **(code**)( *plVar7 + 0x58 ) )();
            }

            iVar3 = getIoArrayImplicitSize(this, pTVar6, (basic_string*)0x0);
            if (0 < iVar3) {
               if (*(code**)( *plVar4 + 0xf8 ) == TIntermTyped::getWritableType) {
                  plVar4 = plVar4 + 4;
               }
 else {
                  plVar4 = (long*)( **(code**)( *plVar4 + 0xf8 ) )(plVar4);
               }

               lVar5 = plVar4[0xc];
               **(int**)( *(long*)( lVar5 + 8 ) + 8 ) = iVar3;
               *(undefined1*)( lVar5 + 0x14 ) = 0;
            }

         }

         return;
      }

      /* glslang::TParseContext::handleBracketDereference(glslang::TSourceLoc const&,
   glslang::TIntermTyped*, glslang::TIntermTyped*) */
      long *__thiscallglslang::TParseContext::handleBracketDereference(TParseContext *this, TSourceLoc *param_1, TIntermTyped *param_2, TIntermTyped *param_3) {
         TIntermTyped TVar1;
         ushort uVar2;
         undefined4 uVar3;
         long lVar4;
         char cVar5;
         byte bVar6;
         ushort uVar7;
         uint uVar8;
         int iVar9;
         int iVar10;
         long lVar11;
         long *plVar12;
         code *pcVar13;
         TType *pTVar14;
         long *plVar15;
         long lVar16;
         TIntermTyped *pTVar17;
         byte bVar18;
         byte bVar19;
         undefined8 *puVar20;
         TIntermTyped *pTVar21;
         long in_FS_OFFSET;
         TIntermTyped *local_f0[2];
         uint local_dc;
         TType local_d8[8];
         undefined4 local_d0;
         long local_c8;
         ulong uStack_c0;
         long local_b8;
         long lStack_b0;
         long local_a8;
         long lStack_a0;
         long local_98;
         long lStack_90;
         long local_88;
         long lStack_80;
         long local_78;
         long local_70;
         long local_68;
         long lStack_60;
         undefined4 local_58;
         long local_50;
         long lStack_48;
         long local_40;
         local_40 = *(long*)( in_FS_OFFSET + 0x28 );
         local_dc = 0;
         local_f0[0] = param_2;
         if (*(code**)( *(long*)param_3 + 0x108 ) == TIntermTyped::getQualifier) {
            pTVar17 = param_3 + 0x30;
         }
 else {
            pTVar17 = (TIntermTyped*)( **(code**)( *(long*)param_3 + 0x108 ) )(param_3);
         }

         if (( ( (byte)pTVar17[8] & 0x7f ) == 2 ) && ( ( (byte)pTVar17[0xc] & 1 ) == 0 )) {
            lVar11 = ( **(code**)( *(long*)param_3 + 0x28 ) )(param_3);
            local_dc = **(uint**)( *(long*)( lVar11 + 0xc0 ) + 8 );
         }

         variableCheck(this, local_f0);
         pTVar17 = local_f0[0];
         lVar11 = *(long*)local_f0[0];
         if (*(code**)( lVar11 + 0x150 ) != TIntermTyped::isArray) {
            cVar5 = ( **(code**)( lVar11 + 0x150 ) )(local_f0[0]);
            lVar11 = *(long*)pTVar17;
            if (cVar5 == '\0') goto LAB_001335da;
            goto LAB_001335fc;
         }

         if (*(long*)( local_f0[0] + 0x80 ) == 0) {
            LAB_001335da:if (*(code**)( lVar11 + 0x148 ) == TIntermTyped::isMatrix) {
               if (0xf < (byte)pTVar17[0x29]) goto LAB_001335fc;
               LAB_00133c80:if (*(code**)( lVar11 + 0x158 ) == TIntermTyped::isVector) {
                  if (1 < ( (byte)pTVar17[0x29] & 0xf )) goto LAB_001335fc;
                  bVar6 = (byte)pTVar17[0x2a] >> 4 & 1;
               }
 else {
                  bVar6 = ( **(code**)( lVar11 + 0x158 ) )(pTVar17);
                  lVar11 = *(long*)pTVar17;
               }

               if (bVar6 != 0) goto LAB_001335fc;
               if (*(code**)( lVar11 + 0xf0 ) == TIntermTyped::getType) {
                  pTVar21 = pTVar17 + 0x20;
               }
 else {
                  pTVar21 = (TIntermTyped*)( **(code**)( lVar11 + 0xf0 ) )(pTVar17);
                  lVar11 = *(long*)pTVar17;
               }

               if (( ( ( (byte)pTVar21[10] & 0x20 ) == 0 ) && ( ( (byte)pTVar21[10] & 0x40 ) == 0 ) ) && ( pTVar17[0x28] != (TIntermTyped)0x12 )) {
                  lVar11 = ( **(code**)( lVar11 + 0x60 ) )(pTVar17);
                  if (lVar11 == 0) {
                     ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, " left of \'[\' is not of type array, matrix, or vector ", "expression", &_LC1);
                  }
 else {
                     pcVar13 = *(code**)( *(long*)this + 0x158 );
                     plVar12 = (long*)( **(code**)( *(long*)pTVar17 + 0x60 ) )(pTVar17);
                     if (*(code**)( *plVar12 + 400 ) == TIntermSymbol::getName_abi_cxx11_) {
                        plVar12 = plVar12 + 0x19;
                     }
 else {
                        plVar12 = (long*)( **(code**)( *plVar12 + 400 ) )(plVar12);
                     }

                     ( *pcVar13 )(this, param_1, " left of \'[\' is not of type array, matrix, or vector ", plVar12[1], &_LC1);
                  }

                  plVar12 = (long*)glslang::TIntermediate::addConstantUnion(0, *(undefined8*)( this + 0x38 ), 1, param_1, 0);
                  goto LAB_001339ff;
               }

               pcVar13 = *(code**)( lVar11 + 0x150 );
            }
 else {
               cVar5 = ( **(code**)( lVar11 + 0x148 ) )(pTVar17);
               lVar11 = *(long*)pTVar17;
               if (cVar5 == '\0') goto LAB_00133c80;
               LAB_001335fc:pcVar13 = *(code**)( lVar11 + 0x150 );
            }

            if (pcVar13 == TIntermTyped::isArray) goto LAB_00133613;
            cVar5 = ( *pcVar13 )(pTVar17);
            lVar11 = *(long*)pTVar17;
            if (cVar5 == '\0') goto LAB_00133a40;
            LAB_00133621:pcVar13 = *(code**)( lVar11 + 0xf0 );
            if (pcVar13 != TIntermTyped::getType) goto LAB_00133b54;
            LAB_00133631:pTVar21 = pTVar17 + 0x20;
         }
 else {
            LAB_00133613:if (*(long*)( pTVar17 + 0x80 ) != 0) goto LAB_00133621;
            LAB_00133a40:if (*(code**)( lVar11 + 0x158 ) == TIntermTyped::isVector) {
               if (( (byte)pTVar17[0x29] & 0xf ) < 2) {
                  bVar6 = (byte)pTVar17[0x2a] >> 4 & 1;
                  goto LAB_0013460b;
               }

            }
 else {
               bVar6 = ( **(code**)( lVar11 + 0x158 ) )(pTVar17);
               lVar11 = *(long*)pTVar17;
               LAB_0013460b:if (bVar6 == 0) goto LAB_00133621;
            }

            if (*(code**)( lVar11 + 0xf0 ) == TIntermTyped::getType) {
               pTVar21 = pTVar17 + 0x20;
            }
 else {
               pTVar21 = (TIntermTyped*)( **(code**)( lVar11 + 0xf0 ) )(pTVar17);
            }

            pcVar13 = *(code**)( *(long*)pTVar21 + 400 );
            if (pcVar13 == TType::containsBasicType) {
               if (pTVar21[8] == (TIntermTyped)0x3) goto LAB_001347a7;
               pcVar13 = *(code**)( *(long*)pTVar21 + 0x128 );
               if (pcVar13 == TType::isStruct) {
                  if (( byte )((char)pTVar21[8] - 0xfU) < 2) {
                     LAB_00134900:lVar11 = *(long*)( *(long*)( pTVar21 + 0x68 ) + 0x10 );
                     lVar16 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( pTVar21 + 0x68 ) + 8 ),lVar11,3 ));
                     if (lVar11 != lVar16) goto LAB_001347a7;
                  }

               }
 else {
                  cVar5 = ( *pcVar13 )();
                  if (cVar5 != '\0') goto LAB_00134900;
               }

            }
 else {
               cVar5 = ( *pcVar13 )(pTVar21, 3);
               if (cVar5 == '\0') goto LAB_00133ac3;
               LAB_001347a7:( **(code**)( *(long*)this + 0xa8 ) )(this, param_1, &_LC48, "does not operate on types containing float16");
            }

            LAB_00133ac3:if (*(code**)( *(long*)pTVar17 + 0xf0 ) == TIntermTyped::getType) {
               pTVar14 = (TType*)( pTVar17 + 0x20 );
            }
 else {
               pTVar14 = (TType*)( **(code**)( *(long*)pTVar17 + 0xf0 ) )(pTVar17);
            }

            cVar5 = TType::contains16BitInt(pTVar14);
            if (cVar5 != '\0') {
               ( **(code**)( *(long*)this + 0xc0 ) )(this, param_1, &_LC48, "does not operate on types containing (u)int16");
            }

            if (*(code**)( *(long*)pTVar17 + 0xf0 ) == TIntermTyped::getType) {
               pTVar14 = (TType*)( pTVar17 + 0x20 );
            }
 else {
               pTVar14 = (TType*)( **(code**)( *(long*)pTVar17 + 0xf0 ) )(pTVar17);
            }

            cVar5 = TType::contains8BitInt(pTVar14);
            if (cVar5 != '\0') {
               ( **(code**)( *(long*)this + 0xd8 ) )(this, param_1, &_LC48, "does not operate on types containing (u)int8");
            }

            pcVar13 = *(code**)( *(long*)pTVar17 + 0xf0 );
            if (pcVar13 == TIntermTyped::getType) goto LAB_00133631;
            LAB_00133b54:pTVar21 = (TIntermTyped*)( *pcVar13 )(pTVar17);
         }

         if (*(code**)( *(long*)pTVar21 + 0x58 ) == TType::getQualifier) {
            pTVar21 = pTVar21 + 0x10;
         }
 else {
            pTVar21 = (TIntermTyped*)( **(code**)( *(long*)pTVar21 + 0x58 ) )();
         }

         iVar10 = (int)pTVar17;
         if (( ( (byte)pTVar21[8] & 0x7f ) == 2 ) && ( ( (byte)pTVar21[0xc] & 1 ) == 0 )) {
            if (*(code**)( *(long*)param_3 + 0x108 ) == TIntermTyped::getQualifier) {
               pTVar21 = param_3 + 0x30;
            }
 else {
               pTVar21 = (TIntermTyped*)( **(code**)( *(long*)param_3 + 0x108 ) )(param_3);
            }

            lVar11 = *(long*)pTVar17;
            if (( ( (byte)pTVar21[8] & 0x7f ) == 2 ) && ( ( (byte)pTVar21[0xc] & 1 ) == 0 )) {
               if (*(code**)( lVar11 + 0xf0 ) == TIntermTyped::getType) {
                  pTVar17 = pTVar17 + 0x20;
               }
 else {
                  pTVar17 = (TIntermTyped*)( **(code**)( lVar11 + 0xf0 ) )(pTVar17);
               }

               glslang::TParseContextBase::checkIndex((TSourceLoc*)this, (TType*)param_1, (int*)pTVar17);
               plVar12 = (long*)glslang::TIntermediate::foldDereference(*(TIntermTyped**)( this + 0x38 ), iVar10, (TSourceLoc*)(ulong)local_dc);
               goto LAB_001339ff;
            }

         }
 else {
            lVar11 = *(long*)pTVar17;
         }

         if (pTVar17[0x28] == (TIntermTyped)0x12) {
            if (*(code**)( lVar11 + 0x150 ) == TIntermTyped::isArray) {
               if (*(long*)( pTVar17 + 0x80 ) == 0) {
                  LAB_00133fe6:( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_EXT_buffer_reference2, "buffer reference indexing");
                  if (*(code**)( *(long*)pTVar17 + 0xf0 ) == TIntermTyped::getType) {
                     pTVar21 = pTVar17 + 0x20;
                  }
 else {
                     pTVar21 = (TIntermTyped*)( **(code**)( *(long*)pTVar17 + 0xf0 ) )(pTVar17);
                  }

                  if (*(code**)( *(long*)pTVar21 + 0xa8 ) == TType::getReferentType) {
                     plVar12 = *(long**)( pTVar21 + 0x68 );
                  }
 else {
                     plVar12 = (long*)( **(code**)( *(long*)pTVar21 + 0xa8 ) )();
                  }

                  lVar11 = *plVar12;
                  if (*(code**)( lVar11 + 0x1a8 ) == TType::containsUnsizedArray) {
                     if (*(code**)( lVar11 + 0xf8 ) == TType::isUnsizedArray) {
                        if (*(code**)( lVar11 + 0xe8 ) != TType::isArray) {
                           cVar5 = ( **(code**)( lVar11 + 0xe8 ) )(plVar12);
                           if (cVar5 == '\0') goto LAB_001340a2;
                           lVar16 = plVar12[0xc];
                           LAB_0013408e:if (**(int**)( *(long*)( lVar16 + 8 ) + 8 ) == 0) goto LAB_001349d0;
                           goto LAB_001340a2;
                        }

                        lVar16 = plVar12[0xc];
                        if (lVar16 != 0) goto LAB_0013408e;
                     }
 else {
                        cVar5 = ( **(code**)( lVar11 + 0xf8 ) )(plVar12);
                        if (cVar5 != '\0') goto LAB_001349d0;
                        LAB_001340a2:lVar11 = *plVar12;
                     }

                     if (*(code**)( lVar11 + 0x128 ) == TType::isStruct) {
                        if (( byte )((char)plVar12[1] - 0xfU) < 2) {
                           LAB_001349ad:lVar11 = *(long*)( plVar12[0xd] + 0x10 );
                           lVar16 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsUnsizedArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsUnsizedArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar12[0xd] + 8 ),lVar11 ));
                           if (lVar11 != lVar16) goto LAB_001349d0;
                        }

                     }
 else {
                        cVar5 = ( **(code**)( lVar11 + 0x128 ) )(plVar12);
                        if (cVar5 != '\0') goto LAB_001349ad;
                     }

                     LAB_001340cd:plVar12 = (long*)glslang::TIntermediate::addBinaryMath(*(undefined8*)( this + 0x38 ), 0x9c, pTVar17, param_3, param_1);
                     if (plVar12 != (long*)0x0) {
                        pcVar13 = *(code**)( *plVar12 + 0xe8 );
                        if (*(code**)( *(long*)pTVar17 + 0xf0 ) == TIntermTyped::getType) {
                           pTVar17 = pTVar17 + 0x20;
                        }
 else {
                           pTVar17 = (TIntermTyped*)( **(code**)( *(long*)pTVar17 + 0xf0 ) )(pTVar17);
                        }

                        if (pcVar13 == TIntermTyped::setType) {
                           lVar11 = *(long*)( pTVar17 + 0x18 );
                           TVar1 = pTVar17[8];
                           uVar3 = *(undefined4*)( pTVar17 + 0x80 );
                           plVar12[6] = *(long*)( pTVar17 + 0x10 );
                           plVar12[7] = lVar11;
                           lVar11 = *(long*)( pTVar17 + 0x20 );
                           lVar16 = *(long*)( pTVar17 + 0x28 );
                           *(undefined4*)( plVar12 + 0x14 ) = uVar3;
                           plVar12[8] = lVar11;
                           plVar12[9] = lVar16;
                           lVar11 = *(long*)( pTVar17 + 0x30 );
                           lVar16 = *(long*)( pTVar17 + 0x38 );
                           *(TIntermTyped*)( plVar12 + 5 ) = TVar1;
                           plVar12[10] = lVar11;
                           plVar12[0xb] = lVar16;
                           lVar11 = *(long*)( pTVar17 + 0x48 );
                           plVar12[0xc] = *(long*)( pTVar17 + 0x40 );
                           plVar12[0xd] = lVar11;
                           lVar11 = *(long*)( pTVar17 + 0x58 );
                           plVar12[0xe] = *(long*)( pTVar17 + 0x50 );
                           plVar12[0xf] = lVar11;
                           TVar1 = pTVar17[9];
                           *(byte*)( (long)plVar12 + 0x29 ) = *(byte*)( (long)plVar12 + 0x29 ) & 0xf0 | (byte)TVar1 & 0xf;
                           *(byte*)( (long)plVar12 + 0x29 ) = (byte)TVar1 & 0xf | (byte)pTVar17[9] & 0xf0;
                           bVar6 = *(byte*)( (long)plVar12 + 0x2a );
                           bVar18 = (byte)pTVar17[10] & 0xf;
                           *(byte*)( (long)plVar12 + 0x2a ) = bVar6 & 0xf0 | bVar18;
                           bVar19 = (byte)pTVar17[10] & 0x10;
                           *(byte*)( (long)plVar12 + 0x2a ) = bVar6 & 0xe0 | bVar18 | bVar19;
                           lVar16 = *(long*)( pTVar17 + 0x70 );
                           lVar4 = *(long*)( pTVar17 + 0x78 );
                           plVar12[0x10] = *(long*)( pTVar17 + 0x60 );
                           lVar11 = *(long*)( pTVar17 + 0x68 );
                           plVar12[0x12] = lVar16;
                           plVar12[0x13] = lVar4;
                           plVar12[0x11] = lVar11;
                           lVar11 = *(long*)( pTVar17 + 0x90 );
                           plVar12[0x15] = *(long*)( pTVar17 + 0x88 );
                           plVar12[0x16] = lVar11;
                           TVar1 = pTVar17[10];
                           *(byte*)( (long)plVar12 + 0x2a ) = bVar6 & 0xc0 | bVar18 | bVar19 | (byte)TVar1 & 0x20;
                           *(byte*)( (long)plVar12 + 0x2a ) = bVar6 & 0x80 | bVar18 | bVar19 | (byte)TVar1 & 0x20 | (byte)pTVar17[10] & 0x40;
                           *(ushort*)( (long)plVar12 + 0x2a ) = *(ushort*)( (long)plVar12 + 0x2a ) & 0xfc7f | *(ushort*)( pTVar17 + 10 ) & 0x380;
                           *(byte*)( (long)plVar12 + 0x2b ) = *(byte*)( (long)plVar12 + 0x2b ) & 0xfb | (byte)pTVar17[0xb] & 4;
                        }
 else {
                           ( *pcVar13 )(plVar12);
                        }

                        goto LAB_001339ff;
                     }

                  }
 else {
                     cVar5 = ( **(code**)( lVar11 + 0x1a8 ) )(plVar12);
                     if (cVar5 == '\0') goto LAB_001340cd;
                     LAB_001349d0:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot index reference to buffer containing an unsized array", &_LC1);
                  }

                  ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot index buffer reference", &_LC1, &_LC1);
                  plVar12 = (long*)glslang::TIntermediate::addConstantUnion(0, *(undefined8*)( this + 0x38 ), 1, param_1, 0);
                  goto LAB_001339ff;
               }

            }
 else {
               cVar5 = ( **(code**)( lVar11 + 0x150 ) )(pTVar17);
               if (cVar5 == '\0') goto LAB_00133fe6;
               lVar11 = *(long*)pTVar17;
            }

         }

         lVar11 = ( **(code**)( lVar11 + 0x60 ) )(pTVar17);
         if (lVar11 == 0) {
            LAB_0013369f:pcVar13 = *(code**)( *(long*)param_3 + 0x108 );
            if (pcVar13 == TIntermTyped::getQualifier) goto LAB_001336b2;
            LAB_00134322:pTVar21 = (TIntermTyped*)( *pcVar13 )(param_3);
            if (( (byte)pTVar21[8] & 0x7f ) == 2) goto LAB_00133b6c;
            pcVar13 = *(code**)( *(long*)param_3 + 0x108 );
            if (pcVar13 == TIntermTyped::getQualifier) goto LAB_00133b89;
            LAB_0013434a:pTVar21 = (TIntermTyped*)( *pcVar13 )(param_3);
            TVar1 = pTVar21[8];
            LAB_00133b94:pcVar13 = *(code**)( *(long*)pTVar17 + 0xf0 );
            if (( ( (byte)TVar1 & 0x7f ) != 2 ) || ( ( (byte)pTVar21[0xc] & 1 ) != 0 )) goto LAB_001336cb;
            if (pcVar13 == TIntermTyped::getType) {
               pTVar21 = pTVar17 + 0x20;
            }
 else {
               pTVar21 = (TIntermTyped*)( *pcVar13 )(pTVar17);
            }

            pcVar13 = *(code**)( *(long*)pTVar21 + 0xf8 );
            if (pcVar13 == TType::isUnsizedArray) {
               pcVar13 = *(code**)( *(long*)pTVar21 + 0xe8 );
               if (pcVar13 == TType::isArray) {
                  lVar11 = *(long*)( pTVar21 + 0x60 );
                  if (lVar11 != 0) {
                     LAB_001343c1:if (**(int**)( *(long*)( lVar11 + 8 ) + 8 ) == 0) goto LAB_001343d5;
                  }

               }
 else {
                  cVar5 = ( *pcVar13 )(pTVar21);
                  if (cVar5 != '\0') {
                     lVar11 = *(long*)( pTVar21 + 0x60 );
                     goto LAB_001343c1;
                  }

               }

               LAB_00133bfc:if (*(code**)( *(long*)pTVar17 + 0xf0 ) == TIntermTyped::getType) {
                  pTVar21 = pTVar17 + 0x20;
               }
 else {
                  pTVar21 = (TIntermTyped*)( **(code**)( *(long*)pTVar17 + 0xf0 ) )(pTVar17);
               }

               glslang::TParseContextBase::checkIndex((TSourceLoc*)this, (TType*)param_1, (int*)pTVar21);
            }
 else {
               cVar5 = ( *pcVar13 )(pTVar21);
               if (cVar5 == '\0') goto LAB_00133bfc;
               LAB_001343d5:pTVar21 = pTVar17 + 0x20;
               if (*(code**)( *(long*)pTVar17 + 0xf8 ) != TIntermTyped::getWritableType) {
                  pTVar21 = (TIntermTyped*)( **(code**)( *(long*)pTVar17 + 0xf8 ) )(pTVar17);
               }

               if (*(code**)( *(long*)pTVar21 + 0x118 ) == TType::updateImplicitArraySize) {
                  iVar10 = *(int*)( *(long*)( pTVar21 + 0x60 ) + 0x10 );
                  if (iVar10 < (int)( local_dc + 1 )) {
                     iVar10 = local_dc + 1;
                  }

                  *(int*)( *(long*)( pTVar21 + 0x60 ) + 0x10 ) = iVar10;
               }
 else {
                  ( **(code**)( *(long*)pTVar21 + 0x118 ) )();
               }

               if (*(code**)( *(long*)pTVar17 + 0xf8 ) == TIntermTyped::getWritableType) {
                  pTVar21 = pTVar17 + 0x20;
               }
 else {
                  pTVar21 = (TIntermTyped*)( **(code**)( *(long*)pTVar17 + 0xf8 ) )(pTVar17);
               }

               if (*(code**)( *(long*)pTVar21 + 0x120 ) == TType::setImplicitlySized) {
                  *(undefined1*)( *(long*)( pTVar21 + 0x60 ) + 0x14 ) = 1;
               }
 else {
                  ( **(code**)( *(long*)pTVar21 + 0x120 ) )(pTVar21, 1);
               }

               if (*(code**)( *(long*)pTVar17 + 0x108 ) == TIntermTyped::getQualifier) {
                  uVar2 = *(ushort*)( pTVar17 + 0x38 );
                  uVar7 = uVar2 & 0xff80;
                  if (uVar7 == 0x1080) {
                     if (*(int*)( this + 0x60c ) <= (int)local_dc) goto LAB_00134d87;
                     LAB_00134992:uVar7 = uVar2 & 0xff80;
                  }

                  if (uVar7 == 0x1100) {
                     LAB_00134ba3:if ((int)local_dc < *(int*)( this + 0x700 )) goto LAB_00134c20;
                     ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "gl_CullDistance", &_LC48, "array index out of range \'%d\'");
                     goto LAB_00134bda;
                  }

                  LAB_00134497:if (uVar7 == 0x2380) {
                     LAB_00134c45:iVar9 = *(int*)( this + 0x708 ) + 0x1f;
                     iVar10 = *(int*)( this + 0x708 ) + 0x3e;
                     if (-1 < iVar9) {
                        iVar10 = iVar9;
                     }

                     if (iVar10 >> 5 <= (int)local_dc) {
                        ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "gl_SampleMask", &_LC48, "array index out of range \'%d\'");
                     }

                     goto LAB_00134bda;
                  }

                  LAB_001344a1:if (( (byte)pTVar17[0x3d] & 4 ) == 0) goto LAB_00133c30;
                  LAB_001344ac:pTVar21 = pTVar17 + 0x30;
               }
 else {
                  lVar11 = ( **(code**)( *(long*)pTVar17 + 0x108 ) )(pTVar17);
                  if (( ( *(ushort*)( lVar11 + 8 ) & 0xff80 ) == 0x1080 ) && ( *(int*)( this + 0x60c ) <= (int)local_dc )) {
                     LAB_00134d87:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "gl_ClipDistance", &_LC48, "array index out of range \'%d\'");
                  }
 else {
                     if (*(code**)( *(long*)pTVar17 + 0x108 ) == TIntermTyped::getQualifier) {
                        uVar2 = *(ushort*)( pTVar17 + 0x38 );
                        goto LAB_00134992;
                     }

                     lVar11 = ( **(code**)( *(long*)pTVar17 + 0x108 ) )(pTVar17);
                     if (( *(ushort*)( lVar11 + 8 ) & 0xff80 ) == 0x1100) goto LAB_00134ba3;
                     LAB_00134c20:if (*(code**)( *(long*)pTVar17 + 0x108 ) == TIntermTyped::getQualifier) {
                        uVar7 = *(ushort*)( pTVar17 + 0x38 ) & 0xff80;
                        goto LAB_00134497;
                     }

                     lVar11 = ( **(code**)( *(long*)pTVar17 + 0x108 ) )(pTVar17);
                     if (( *(ushort*)( lVar11 + 8 ) & 0xff80 ) == 0x2380) goto LAB_00134c45;
                  }

                  LAB_00134bda:if (*(code**)( *(long*)pTVar17 + 0x108 ) == TIntermTyped::getQualifier) goto LAB_001344a1;
                  lVar11 = ( **(code**)( *(long*)pTVar17 + 0x108 ) )(pTVar17);
                  if (( *(byte*)( lVar11 + 0xd ) & 4 ) == 0) goto LAB_00133c30;
                  if (*(code**)( *(long*)pTVar17 + 0x108 ) == TIntermTyped::getQualifier) goto LAB_001344ac;
                  pTVar21 = (TIntermTyped*)( **(code**)( *(long*)pTVar17 + 0x108 ) )(pTVar17);
               }

               if (( 0x7f < *(ushort*)( pTVar21 + 8 ) ) && ( plVar12 = (long*)( **(code**)( *(long*)pTVar17 + 0x40 ) )(pTVar17) ),plVar12 != (long*)0x0) {
                  if (*(code**)( *plVar12 + 400 ) == TIntermBinary::getLeft) {
                     plVar12 = (long*)plVar12[0x18];
                  }
 else {
                     plVar12 = (long*)( **(code**)( *plVar12 + 400 ) )(plVar12);
                  }

                  if (*(code**)( *plVar12 + 0xf8 ) == TIntermTyped::getWritableType) {
                     plVar12 = plVar12 + 4;
                  }
 else {
                     plVar12 = (long*)( **(code**)( *plVar12 + 0xf8 ) )();
                  }

                  if (*(code**)( *plVar12 + 0xa0 ) == TType::getArraySizes) {
                     lVar11 = plVar12[0xc];
                  }
 else {
                     lVar11 = ( **(code**)( *plVar12 + 0xa0 ) )();
                  }

                  lVar11 = *(long*)( *(long*)( lVar11 + 8 ) + 8 );
                  iVar10 = *(int*)( lVar11 + 0x10 );
                  iVar9 = local_dc + 1;
                  if ((int)( local_dc + 1 ) < iVar10) {
                     iVar9 = iVar10;
                  }

                  *(int*)( lVar11 + 0x10 ) = iVar9;
               }

            }

            LAB_00133c30:plVar12 = (long*)glslang::TIntermediate::addIndex(*(undefined8*)( this + 0x38 ), 0xb6, pTVar17, param_3, param_1);
            pcVar13 = *(code**)( *(long*)pTVar17 + 0xf0 );
            if (pcVar13 == TIntermTyped::getType) goto LAB_001337b0;
            LAB_00133c60:pTVar14 = (TType*)( *pcVar13 )(pTVar17);
         }
 else {
            if (*(code**)( *(long*)pTVar17 + 0xf0 ) == TIntermTyped::getType) {
               pTVar14 = (TType*)( pTVar17 + 0x20 );
            }
 else {
               pTVar14 = (TType*)( **(code**)( *(long*)pTVar17 + 0xf0 ) )(pTVar17);
            }

            cVar5 = isIoResizeArray(this, pTVar14);
            if (cVar5 == '\0') goto LAB_0013369f;
            handleIoResizeArrayAccess(this, param_1, pTVar17);
            pcVar13 = *(code**)( *(long*)param_3 + 0x108 );
            if (pcVar13 != TIntermTyped::getQualifier) goto LAB_00134322;
            LAB_001336b2:if (( (byte)param_3[0x38] & 0x7f ) == 2) {
               pTVar21 = param_3 + 0x30;
               LAB_00133b6c:if (( (byte)pTVar21[0xc] & 1 ) == 0) {
                  if (*(code**)( *(long*)pTVar17 + 0xf0 ) == TIntermTyped::getType) {
                     pTVar21 = pTVar17 + 0x20;
                  }
 else {
                     pTVar21 = (TIntermTyped*)( **(code**)( *(long*)pTVar17 + 0xf0 ) )(pTVar17);
                  }

                  glslang::TParseContextBase::checkIndex((TSourceLoc*)this, (TType*)param_1, (int*)pTVar21);
               }

               pcVar13 = *(code**)( *(long*)param_3 + 0x108 );
               if (pcVar13 != TIntermTyped::getQualifier) goto LAB_0013434a;
               LAB_00133b89:TVar1 = param_3[0x38];
               pTVar21 = param_3 + 0x30;
               goto LAB_00133b94;
            }

            pcVar13 = *(code**)( *(long*)pTVar17 + 0xf0 );
            LAB_001336cb:if (pcVar13 == TIntermTyped::getType) {
               pTVar21 = pTVar17 + 0x20;
            }
 else {
               pTVar21 = (TIntermTyped*)( *pcVar13 )(pTVar17);
            }

            pcVar13 = *(code**)( *(long*)pTVar21 + 0xf8 );
            if (pcVar13 == TType::isUnsizedArray) {
               pcVar13 = *(code**)( *(long*)pTVar21 + 0xe8 );
               if (pcVar13 == TType::isArray) {
                  lVar11 = *(long*)( pTVar21 + 0x60 );
                  if (lVar11 != 0) {
                     LAB_00133712:if (**(int**)( *(long*)( lVar11 + 8 ) + 8 ) == 0) goto LAB_00133d85;
                  }

               }
 else {
                  cVar5 = ( *pcVar13 )(pTVar21);
                  if (cVar5 != '\0') {
                     lVar11 = *(long*)( pTVar21 + 0x60 );
                     goto LAB_00133712;
                  }

               }

            }
 else {
               cVar5 = ( *pcVar13 )(pTVar21);
               if (cVar5 == '\0') goto LAB_00133732;
               LAB_00133d85:lVar11 = ( **(code**)( *(long*)pTVar17 + 0x60 ) )(pTVar17);
               if (lVar11 == 0) {
                  LAB_00133e30:cVar5 = isRuntimeLength(this, pTVar17);
                  if (cVar5 == '\0') {
                     checkRuntimeSizable(this, param_1, pTVar17);
                  }

               }
 else {
                  if (*(code**)( *(long*)pTVar17 + 0xf0 ) == TIntermTyped::getType) {
                     pTVar14 = (TType*)( pTVar17 + 0x20 );
                  }
 else {
                     pTVar14 = (TType*)( **(code**)( *(long*)pTVar17 + 0xf0 ) )(pTVar17);
                  }

                  cVar5 = isIoResizeArray(this, pTVar14);
                  if (cVar5 == '\0') goto LAB_00133e30;
                  ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, &_LC1, &_LC48, "array must be sized by a redeclaration or layout qualifier before being indexed with a variable");
               }

               if (*(code**)( *(long*)pTVar17 + 0xf8 ) == TIntermTyped::getWritableType) {
                  pTVar21 = pTVar17 + 0x20;
               }
 else {
                  pTVar21 = (TIntermTyped*)( **(code**)( *(long*)pTVar17 + 0xf8 ) )(pTVar17);
               }

               if (*(code**)( *(long*)pTVar21 + 0x110 ) == TType::setArrayVariablyIndexed) {
                  *(undefined1*)( *(long*)( pTVar21 + 0x60 ) + 0x15 ) = 1;
               }
 else {
                  ( **(code**)( *(long*)pTVar21 + 0x110 ) )();
               }

            }

            LAB_00133732:puVar20 = *(undefined8**)pTVar17;
            if ((code*)puVar20[0x20] == TIntermTyped::getBasicType) {
               uVar8 = (uint)(byte)pTVar17[0x28];
            }
 else {
               uVar8 = ( *(code*)puVar20[0x20] )(pTVar17);
               puVar20 = *(undefined8**)pTVar17;
            }

            if (uVar8 == 0x10) {
               if ((code*)puVar20[0x21] == TIntermTyped::getQualifier) {
                  bVar6 = (byte)pTVar17[0x38] & 0x7f;
                  if (bVar6 == 6) {
                     LAB_00134848:if ((code*)*puVar20 == TIntermNode::getLoc) {
                        iVar10 = iVar10 + 8;
                     }
 else {
                        iVar10 = ( *(code*)*puVar20 )(pTVar17);
                     }

                     glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar10, (char*)0xfffffff7);
                     goto LAB_00133782;
                  }

               }
 else {
                  lVar11 = ( *(code*)puVar20[0x21] )(pTVar17);
                  if (( *(byte*)( lVar11 + 8 ) & 0x7f ) == 6) {
                     puVar20 = *(undefined8**)pTVar17;
                     goto LAB_00134848;
                  }

                  if (*(code**)( *(long*)pTVar17 + 0x108 ) == TIntermTyped::getQualifier) {
                     bVar6 = (byte)pTVar17[0x38] & 0x7f;
                  }
 else {
                     lVar11 = ( **(code**)( *(long*)pTVar17 + 0x108 ) )(pTVar17);
                     bVar6 = *(byte*)( lVar11 + 8 ) & 0x7f;
                  }

               }

               if (bVar6 == 5) {
                  if ((code*)**(undefined8**)pTVar17 == TIntermNode::getLoc) {
                     iVar10 = iVar10 + 8;
                  }
 else {
                     iVar10 = ( *(code*)**(undefined8**)pTVar17 )(pTVar17);
                  }

                  glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar10, 8, 0x140, (char**)0x2, AEP_gpu_shader5);
               }

            }
 else {
               if (*(int*)( this + 0x1c ) == 4) {
                  if ((code*)puVar20[0x21] == TIntermTyped::getQualifier) {
                     if (( ( byte )((byte)pTVar17[0x38] & 0x7f) < 0x1f ) && ( ( 0x71c00010UL >> ( ( ulong )((byte)pTVar17[0x38] & 0x7f) & 0x3f ) & 1 ) != 0 )) {
                        LAB_0013464f:pTVar21 = pTVar17 + 0x30;
                        LAB_00134653:if (( *(ushort*)( pTVar21 + 8 ) & 0xff80 ) != 0x2380) {
                           if ((code*)*puVar20 == TIntermNode::getLoc) {
                              iVar10 = iVar10 + 8;
                           }
 else {
                              iVar10 = ( *(code*)*puVar20 )(pTVar17);
                           }

                           glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar10, (char*)0xfffffff7);
                           goto LAB_00133782;
                        }

                     }

                  }
 else {
                     lVar11 = ( *(code*)puVar20[0x21] )(pTVar17);
                     uVar8 = *(byte*)( lVar11 + 8 ) & 0x7f;
                     if (( (byte)uVar8 < 0x1f ) && ( ( 0x71c00010UL >> ( (ulong)uVar8 & 0x3f ) & 1 ) != 0 )) {
                        puVar20 = *(undefined8**)pTVar17;
                        if ((code*)puVar20[0x21] == TIntermTyped::getQualifier) goto LAB_0013464f;
                        pTVar21 = (TIntermTyped*)( *(code*)puVar20[0x21] )(pTVar17);
                        puVar20 = *(undefined8**)pTVar17;
                        goto LAB_00134653;
                     }

                     puVar20 = *(undefined8**)pTVar17;
                  }

               }

               if ((code*)puVar20[0x20] == TIntermTyped::getBasicType) {
                  uVar8 = (uint)(byte)pTVar17[0x28];
               }
 else {
                  uVar8 = ( *(code*)puVar20[0x20] )(pTVar17);
               }

               if (( uVar8 == 0xe ) && ( 0x81 < *(int*)( this + 0x18 ) )) {
                  if ((code*)**(undefined8**)pTVar17 == TIntermNode::getLoc) {
                     iVar9 = iVar10 + 8;
                  }
 else {
                     iVar9 = ( *(code*)**(undefined8**)pTVar17 )(pTVar17);
                  }

                  glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar9, (char*)0xe);
                  if ((code*)**(undefined8**)pTVar17 == TIntermNode::getLoc) {
                     iVar9 = iVar10 + 8;
                  }
 else {
                     iVar9 = ( *(code*)**(undefined8**)pTVar17 )(pTVar17);
                  }

                  glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar9, 8, 0x140, (char**)0x2, AEP_gpu_shader5);
                  if ((code*)**(undefined8**)pTVar17 == TIntermNode::getLoc) {
                     iVar10 = iVar10 + 8;
                  }
 else {
                     iVar10 = ( *(code*)**(undefined8**)pTVar17 )(pTVar17);
                  }

                  glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar10, 6, (char*)0x190, (char*)0x0);
               }

            }

            LAB_00133782:plVar12 = (long*)glslang::TIntermediate::addIndex(*(undefined8*)( this + 0x38 ), 0xb7, pTVar17, param_3, param_1);
            pcVar13 = *(code**)( *(long*)pTVar17 + 0xf0 );
            if (pcVar13 != TIntermTyped::getType) goto LAB_00133c60;
            LAB_001337b0:pTVar14 = (TType*)( pTVar17 + 0x20 );
         }

         TType::TType(local_d8, pTVar14, 0, false);
         if (*(code**)( *(long*)pTVar17 + 0xf0 ) == TIntermTyped::getType) {
            pTVar21 = pTVar17 + 0x20;
         }
 else {
            pTVar21 = (TIntermTyped*)( **(code**)( *(long*)pTVar17 + 0xf0 ) )(pTVar17);
         }

         if (*(code**)( *(long*)pTVar21 + 0x58 ) == TType::getQualifier) {
            pTVar21 = pTVar21 + 0x10;
         }
 else {
            pTVar21 = (TIntermTyped*)( **(code**)( *(long*)pTVar21 + 0x58 ) )();
         }

         if (( ( (byte)pTVar21[8] & 0x7f ) == 2 ) || ( ( (byte)pTVar21[0xc] & 1 ) != 0 )) {
            if (*(code**)( *(long*)param_3 + 0x108 ) == TIntermTyped::getQualifier) {
               pTVar21 = param_3 + 0x30;
            }
 else {
               pTVar21 = (TIntermTyped*)( **(code**)( *(long*)param_3 + 0x108 ) )(param_3);
            }

            if (( ( (byte)pTVar21[8] & 0x7f ) != 2 ) && ( ( (byte)pTVar21[0xc] & 1 ) == 0 )) goto LAB_0013381a;
            uStack_c0 = uStack_c0 & 0xffffffffffffff80 | 2;
            if (*(code**)( *(long*)pTVar17 + 0xf0 ) == TIntermTyped::getType) {
               pTVar21 = pTVar17 + 0x20;
            }
 else {
               pTVar21 = (TIntermTyped*)( **(code**)( *(long*)pTVar17 + 0xf0 ) )(pTVar17);
            }

            if (*(code**)( *(long*)pTVar21 + 0x58 ) == TType::getQualifier) {
               pTVar21 = pTVar21 + 0x10;
            }
 else {
               pTVar21 = (TIntermTyped*)( **(code**)( *(long*)pTVar21 + 0x58 ) )();
            }

            if (( (byte)pTVar21[0xc] & 1 ) == 0) {
               if (*(code**)( *(long*)param_3 + 0x108 ) == TIntermTyped::getQualifier) {
                  pTVar21 = param_3 + 0x30;
               }
 else {
                  pTVar21 = (TIntermTyped*)( **(code**)( *(long*)param_3 + 0x108 ) )(param_3);
               }

               if (( (byte)pTVar21[0xc] & 1 ) != 0) goto LAB_00133ee9;
            }
 else {
               LAB_00133ee9:uStack_c0 = uStack_c0 & 0xfffffffeffffff80 | 0x100000002;
            }

         }
 else {
            LAB_0013381a:uStack_c0 = uStack_c0 & 0xfffffffeffffff80;
         }

         lVar11 = *plVar12;
         if (*(code**)( lVar11 + 0xe8 ) == TIntermTyped::setType) {
            plVar12[6] = local_c8;
            plVar12[7] = uStack_c0;
            *(undefined4*)( plVar12 + 0x14 ) = local_58;
            plVar12[8] = local_b8;
            plVar12[9] = lStack_b0;
            plVar12[10] = local_a8;
            plVar12[0xb] = lStack_a0;
            plVar12[0xc] = local_98;
            plVar12[0xd] = lStack_90;
            *(uint*)( plVar12 + 5 ) = *(uint*)( plVar12 + 5 ) & 0xffe00000 | local_d0 & 0x1fffff;
            plVar12[0xe] = local_88;
            plVar12[0xf] = lStack_80;
            plVar12[0x10] = local_78;
            plVar12[0x12] = local_68;
            plVar12[0x13] = lStack_60;
            plVar12[0x11] = local_70;
            plVar12[0x15] = local_50;
            plVar12[0x16] = lStack_48;
            *(ushort*)( (long)plVar12 + 0x2a ) = *(ushort*)( (long)plVar12 + 0x2a ) & 0xf81f | local_d0._2_2_ & 0x7e0;
         }
 else {
            ( **(code**)( lVar11 + 0xe8 ) )(plVar12, local_d8);
            lVar11 = *plVar12;
         }

         if (*(code**)( lVar11 + 0xf8 ) == TIntermTyped::getWritableType) {
            plVar15 = plVar12 + 4;
         }
 else {
            plVar15 = (long*)( **(code**)( lVar11 + 0xf8 ) )(plVar12);
         }

         if (*(code**)( *plVar15 + 0x50 ) == TType::getQualifier) {
            plVar15 = plVar15 + 2;
         }
 else {
            plVar15 = (long*)( **(code**)( *plVar15 + 0x50 ) )();
         }

         if (*(code**)( *(long*)pTVar17 + 0x108 ) == TIntermTyped::getQualifier) {
            pTVar21 = pTVar17 + 0x30;
            pcVar13 = TIntermTyped::getQualifier;
         }
 else {
            pTVar21 = (TIntermTyped*)( **(code**)( *(long*)pTVar17 + 0x108 ) )(pTVar17);
            pcVar13 = *(code**)( *(long*)pTVar17 + 0x108 );
         }

         if ((char)pTVar21[0xd] < '\0') {
            *(byte*)( (long)plVar15 + 0xd ) = *(byte*)( (long)plVar15 + 0xd ) | 0x80;
         }

         TVar1 = pTVar21[0xe];
         if (( (byte)TVar1 & 1 ) != 0) {
            *(byte*)( (long)plVar15 + 0xe ) = *(byte*)( (long)plVar15 + 0xe ) | 1;
            TVar1 = pTVar21[0xe];
         }

         if (( (byte)TVar1 & 2 ) != 0) {
            *(byte*)( (long)plVar15 + 0xe ) = *(byte*)( (long)plVar15 + 0xe ) | 2;
            TVar1 = pTVar21[0xe];
         }

         if (( (byte)TVar1 & 4 ) != 0) {
            *(byte*)( (long)plVar15 + 0xe ) = *(byte*)( (long)plVar15 + 0xe ) | 4;
         }

         if (( (byte)pTVar21[0xd] & 0x40 ) != 0) {
            *(byte*)( (long)plVar15 + 0xd ) = *(byte*)( (long)plVar15 + 0xd ) | 0x40;
         }

         if (pcVar13 == TIntermTyped::getQualifier) {
            pTVar21 = pTVar17 + 0x30;
         }
 else {
            pTVar21 = (TIntermTyped*)( *pcVar13 )(pTVar17);
         }

         if (( (byte)pTVar21[0xc] & 2 ) == 0) {
            if (*(code**)( *(long*)param_3 + 0x108 ) == TIntermTyped::getQualifier) {
               pTVar21 = param_3 + 0x30;
            }
 else {
               pTVar21 = (TIntermTyped*)( **(code**)( *(long*)param_3 + 0x108 ) )(param_3);
            }

            if (( (byte)pTVar21[0xc] & 2 ) != 0) goto LAB_001339be;
         }
 else {
            LAB_001339be:plVar15 = plVar12 + 4;
            if (*(code**)( *plVar12 + 0xf8 ) != TIntermTyped::getWritableType) {
               plVar15 = (long*)( **(code**)( *plVar12 + 0xf8 ) )(plVar12);
            }

            if (*(code**)( *plVar15 + 0x50 ) == TType::getQualifier) {
               plVar15 = plVar15 + 2;
            }
 else {
               plVar15 = (long*)( **(code**)( *plVar15 + 0x50 ) )();
            }

            *(byte*)( (long)plVar15 + 0xc ) = *(byte*)( (long)plVar15 + 0xc ) | 2;
         }

         if (this[0x7540] != (TParseContext)0x0) {
            handleIndexLimits(this, param_1, pTVar17, param_3);
         }

         LAB_001339ff:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
            /* WARNING: Subroutine does not return */
            __stack_chk_fail();
         }

         return plVar12;
      }

      /* glslang::TParseContext::checkIoArraysConsistency(glslang::TSourceLoc const&, bool) */
      void glslang::TParseContext::checkIoArraysConsistency(TParseContext *this, TSourceLoc *param_1, bool param_2) {
         long *plVar1;
         code *pcVar2;
         bool bVar3;
         int iVar4;
         long lVar5;
         TType *pTVar6;
         basic_string *pbVar7;
         TType *pTVar8;
         ulong uVar9;
         ulong uVar10;
         long in_FS_OFFSET;
         undefined8 local_68;
         char *local_60;
         undefined8 local_58;
         char local_50[16];
         long local_40;
         local_40 = *(long*)( in_FS_OFFSET + 0x28 );
         local_68 = glslang::GetThreadPoolAllocator();
         local_58 = 0;
         local_60 = local_50;
         lVar5 = *(long*)( this + 0x7600 );
         local_50[0] = '\0';
         uVar10 = *(long*)( this + 0x7608 ) - lVar5 >> 3;
         uVar9 = uVar10 - 1;
         if (!param_2) {
            uVar9 = 0;
         }

         if (uVar9 < uVar10) {
            bVar3 = true;
            iVar4 = 0;
            do {
               pTVar6 = (TType*)( **(code**)( **(long**)( lVar5 + uVar9 * 8 ) + 0x68 ) )();
               if (( bVar3 ) || ( *(int*)( this + 0x1c ) == 0xd )) {
                  if (*(code**)( *(long*)pTVar6 + 0x50 ) == TType::getQualifier) {
                     pTVar8 = pTVar6 + 0x10;
                  }
 else {
                     pTVar8 = (TType*)( **(code**)( *(long*)pTVar6 + 0x50 ) )(pTVar6);
                  }

                  iVar4 = getIoArrayImplicitSize(this, (TQualifier*)pTVar8, (basic_string*)&local_68);
                  if (iVar4 == 0) break;
               }

               plVar1 = *(long**)( *(long*)( this + 0x7600 ) + uVar9 * 8 );
               pcVar2 = *(code**)( *plVar1 + 0x18 );
               if (pcVar2 == TSymbol::getName_abi_cxx11_) {
                  pbVar7 = (basic_string*)plVar1[1];
               }
 else {
                  pbVar7 = (basic_string*)( *pcVar2 )();
               }

               uVar9 = uVar9 + 1;
               checkIoArrayConsistency(this, param_1, iVar4, local_60, pTVar6, pbVar7);
               if (uVar9 == uVar10) break;
               lVar5 = *(long*)( this + 0x7600 );
               bVar3 = false;
            }
 while ( true );
         }

         if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return;
         }

         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      /* glslang::TParseContext::updateStandaloneQualifierDefaults(glslang::TSourceLoc const&,
   glslang::TPublicType const&) */
      void glslang::TParseContext::updateStandaloneQualifierDefaults(TParseContext *this, TSourceLoc *param_1, TPublicType *param_2) {
         TPublicType TVar1;
         TPublicType TVar2;
         TPublicType TVar3;
         TPublicType TVar4;
         int iVar5;
         undefined4 uVar6;
         byte bVar7;
         char cVar8;
         int iVar9;
         uint uVar10;
         long *plVar11;
         undefined4 *puVar12;
         ulong uVar13;
         ulong uVar14;
         undefined *puVar15;
         char *pcVar16;
         uint uVar17;
         char *pcVar18;
         code *UNRECOVERED_JUMPTABLE;
         long lVar19;
         long lVar20;
         long lVar21;
         long lVar22;
         long in_FS_OFFSET;
         basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *local_70;
         undefined8 local_68;
         char *local_60;
         char local_50[16];
         long local_40;
         local_40 = *(long*)( in_FS_OFFSET + 0x28 );
         iVar9 = *(int*)( param_2 + 100 );
         if (iVar9 != -1) {
            pcVar18 = "vertices";
            if (*(int*)( this + 0x1c ) != 1) {
               pcVar18 = "max_vertices";
            }

            if (( (byte)param_2[0x10] & 0x7f ) != 4) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to \'out\'", pcVar18, &_LC1);
               iVar9 = *(int*)( param_2 + 100 );
            }

            iVar5 = *(int*)( *(long*)( this + 0x38 ) + 0x30c );
            if (iVar5 == -1) {
               *(int*)( *(long*)( this + 0x38 ) + 0x30c ) = iVar9;
               LAB_0013506f:iVar9 = *(int*)( this + 0x1c );
            }
 else {
               if (iVar5 == iVar9) goto LAB_0013506f;
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot change previously set layout value", pcVar18, &_LC1);
               iVar9 = *(int*)( this + 0x1c );
            }

            if (iVar9 == 1) {
               checkIoArraysConsistency(this, param_1, false);
            }

         }

         iVar9 = *(int*)( param_2 + 0xb0 );
         if (iVar9 != -1) {
            if (( (byte)param_2[0x10] & 0x7f ) != 4) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to \'out\'", "max_primitives", &_LC1);
               iVar9 = *(int*)( param_2 + 0xb0 );
            }

            iVar5 = *(int*)( *(long*)( this + 0x38 ) + 0x36c );
            if (iVar5 == -1) {
               *(int*)( *(long*)( this + 0x38 ) + 0x36c ) = iVar9;
            }
 else if (iVar5 != iVar9) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot change previously set layout value", "max_primitives", &_LC1);
            }

         }

         iVar9 = *(int*)( param_2 + 0x60 );
         if (iVar9 != -1) {
            if (( (byte)param_2[0x10] & 0x7f ) != 3) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to \'in\'", "invocations", &_LC1);
               iVar9 = *(int*)( param_2 + 0x60 );
            }

            iVar5 = *(int*)( *(long*)( this + 0x38 ) + 0x308 );
            if (iVar5 == -1) {
               *(int*)( *(long*)( this + 0x38 ) + 0x308 ) = iVar9;
            }
 else if (iVar5 != iVar9) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot change previously set layout value", "invocations", &_LC1);
            }

         }

         uVar10 = *(uint*)( param_2 + 0x58 );
         uVar14 = (ulong)uVar10;
         if (uVar10 == 0) {
            LAB_001351a2:iVar9 = *(int*)( param_2 + 0x68 );
            if (iVar9 == 0) goto LAB_0013520a;
            LAB_001351a9:if (( (byte)param_2[0x10] & 0x7f ) != 3) goto LAB_001351b9;
            lVar21 = *(long*)( this + 0x38 );
            LAB_00136074:if (*(int*)( lVar21 + 0x31c ) == 0) {
               *(int*)( lVar21 + 0x31c ) = iVar9;
            }
 else if (*(int*)( lVar21 + 0x31c ) != iVar9) {
               pcVar18 = "fractional_even_spacing";
               if (( ( iVar9 != 2 ) && ( pcVar18 = "fractional_odd_spacing" ),iVar9 != 3 )) {
                  pcVar18 = "none";
               }

               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot change previously set vertex spacing", pcVar18, &_LC1);
               goto LAB_0013520a;
            }

            iVar9 = *(int*)( param_2 + 0x6c );
            if (iVar9 != 0) goto LAB_00136093;
            LAB_00135266:if (param_2[0x70] != (TPublicType)0x0) {
               if (( (byte)param_2[0x10] & 0x7f ) == 3) {
                  lVar21 = *(long*)( this + 0x38 );
                  LAB_001360b1:*(undefined1*)( lVar21 + 0x328 ) = 1;
               }
 else {
                  ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to \'in\'", "point_mode", &_LC1);
               }

            }

         }
 else {
            bVar7 = (byte)param_2[0x10] & 0x7f;
            if (bVar7 == 3) {
               if (uVar10 < 10) {
                  if (( 0x36eUL >> ( uVar14 & 0x3f ) & 1 ) == 0) {
                     UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                     switch (uVar10) {
                        case 4:
            pcVar18 = "line_strip";
            break;
                        case 5:
            pcVar18 = "triangles";
            break;
                        case 6:
            pcVar18 = "triangles_adjacency";
            break;
                        case 7:
            pcVar18 = "triangle_strip";
            break;
                        case 8:
            pcVar18 = "quads";
            break;
                        case 9:
            pcVar18 = "isolines";
            break;
                        default:
            goto switchD_001368e5_default;
                     }

                     goto LAB_001368f0;
                  }

                  iVar9 = *(int*)( this + 0x1c );
                  if (iVar9 == 0xd) {
                     /* WARNING: Could not recover jumptable at 0x0013698e. Too many branches */
                     /* WARNING: Treating indirect jump as call */
                     ( *(code*)( &DAT_00155f68 + *(int*)( &DAT_00155f68 + uVar14 * 4 ) ) )();
                     return;
                  }

                  lVar21 = *(long*)( this + 0x38 );
                  if (*(uint*)( lVar21 + 0x310 ) == 0) {
                     *(uint*)( lVar21 + 0x310 ) = uVar10;
                  }
 else if (uVar10 != *(uint*)( lVar21 + 0x310 )) {
                     switch (uVar14) {
                        default:
            pcVar18 = "points";
            break;
                        case 2:
            pcVar18 = "lines";
            break;
                        case 3:
            pcVar18 = "lines_adjacency";
            break;
                        case 4:
            pcVar18 = "line_strip";
            break;
                        case 5:
            pcVar18 = "triangles";
            break;
                        case 6:
            pcVar18 = "triangles_adjacency";
            break;
                        case 7:
            pcVar18 = "triangle_strip";
            break;
                        case 8:
            pcVar18 = "quads";
            break;
                        case 9:
            pcVar18 = "isolines";
                     }

                     ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot change previously set input primitive", pcVar18, &_LC1);
                     goto LAB_001351a2;
                  }

                  if (iVar9 == 3) {
                     checkIoArraysConsistency(this, param_1, false);
                     goto LAB_001351a2;
                  }

                  iVar9 = *(int*)( param_2 + 0x68 );
                  if (iVar9 == 0) goto LAB_0013520a;
                  goto LAB_00136074;
               }

               UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
               switchD_001368e5_default:pcVar18 = "none";
               LAB_001368f0:( *UNRECOVERED_JUMPTABLE )(this, param_1, "cannot apply to input", pcVar18, &_LC1);
               iVar9 = *(int*)( param_2 + 0x68 );
               if (iVar9 != 0) goto LAB_001351a9;
            }
 else {
               if (bVar7 != 4) {
                  switch (bVar7) {
                     case 0:
          pcVar18 = "temp";
          break;
                     case 1:
          pcVar18 = "global";
          break;
                     case 2:
          pcVar18 = "const";
          break;
                     case 3:
                     case 0x10:
          pcVar18 = "in";
          break;
                     case 4:
                     case 0x11:
          pcVar18 = "out";
          break;
                     case 5:
          pcVar18 = "uniform";
          break;
                     case 6:
          pcVar18 = "buffer";
          break;
                     case 7:
          pcVar18 = "shared";
          break;
                     case 8:
          pcVar18 = "spirv_storage_class";
          break;
                     case 9:
          pcVar18 = "rayPayloadNV";
          break;
                     case 10:
          pcVar18 = "rayPayloadInNV";
          break;
                     case 0xb:
          pcVar18 = "hitAttributeNV";
          break;
                     case 0xc:
          pcVar18 = "callableDataNV";
          break;
                     case 0xd:
          pcVar18 = "callableDataInNV";
          break;
                     case 0xe:
          pcVar18 = "hitObjectAttributeNV";
          break;
                     case 0xf:
          pcVar18 = "taskPayloadSharedEXT";
          break;
                     case 0x12:
          pcVar18 = "inout";
          break;
                     case 0x13:
          pcVar18 = "const (read only)";
          break;
                     case 0x14:
          pcVar18 = "gl_VertexId";
          break;
                     case 0x15:
          pcVar18 = "gl_InstanceId";
          break;
                     case 0x16:
          pcVar18 = "gl_Position";
          break;
                     case 0x17:
          pcVar18 = "gl_PointSize";
          break;
                     case 0x18:
          pcVar18 = "gl_ClipVertex";
          break;
                     case 0x19:
          pcVar18 = "gl_FrontFacing";
          break;
                     case 0x1a:
          pcVar18 = "gl_FragCoord";
          break;
                     case 0x1b:
          pcVar18 = "gl_PointCoord";
          break;
                     case 0x1c:
          pcVar18 = "fragColor";
          break;
                     case 0x1d:
          pcVar18 = "gl_FragDepth";
          break;
                     case 0x1e:
          pcVar18 = "gl_FragStencilRefARB";
          break;
                     default:
          pcVar18 = "unknown qualifier";
                  }

                  switch (uVar14) {
                     default:
          pcVar16 = "none";
          break;
                     case 1:
          pcVar16 = "points";
          break;
                     case 2:
          pcVar16 = "lines";
          break;
                     case 3:
          pcVar16 = "lines_adjacency";
          break;
                     case 4:
          pcVar16 = "line_strip";
          break;
                     case 5:
          pcVar16 = "triangles";
          break;
                     case 6:
          pcVar16 = "triangles_adjacency";
          break;
                     case 7:
          pcVar16 = "triangle_strip";
          break;
                     case 8:
          pcVar16 = "quads";
          break;
                     case 9:
          pcVar16 = "isolines";
                  }

                  ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot apply to:", pcVar16, pcVar18);
                  goto LAB_001351a2;
               }

               if (7 < uVar10) {
                  LAB_00136512:UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                  switch (uVar10) {
                     case 3:
          pcVar18 = "lines_adjacency";
          break;
                     case 4:
          pcVar18 = "line_strip";
          break;
                     case 5:
          pcVar18 = "triangles";
          break;
                     case 6:
          pcVar18 = "triangles_adjacency";
          break;
                     case 7:
          pcVar18 = "triangle_strip";
          break;
                     case 8:
          pcVar18 = "quads";
          break;
                     case 9:
          pcVar18 = "isolines";
          break;
                     default:
          pcVar18 = "none";
                  }

                  LAB_001361d5:( *UNRECOVERED_JUMPTABLE )(this, param_1, "cannot apply to \'out\'", pcVar18, &_LC1);
                  goto LAB_001351a2;
               }

               uVar13 = 1L << ( (byte)uVar10 & 0x3f );
               if (( uVar13 & 0x92 ) == 0) {
                  if (( uVar13 & 0x24 ) == 0) goto LAB_00136512;
                  if (*(int*)( this + 0x1c ) == 0xd) goto LAB_00136440;
                  UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                  pcVar18 = "line_strip";
                  if (( ( uVar10 != 4 ) && ( pcVar18 = "triangles" ),uVar10 != 5 )) {
                     pcVar18 = "lines";
                  }

                  goto LAB_001361d5;
               }

               LAB_00136440:uVar17 = *(uint*)( *(long*)( this + 0x38 ) + 0x314 );
               if (uVar17 == 0) {
                  *(uint*)( *(long*)( this + 0x38 ) + 0x314 ) = uVar10;
               }
 else if (uVar10 != uVar17) {
                  switch (uVar14) {
                     default:
          pcVar18 = "points";
          break;
                     case 2:
          pcVar18 = "lines";
          break;
                     case 3:
          pcVar18 = "lines_adjacency";
          break;
                     case 4:
          pcVar18 = "line_strip";
          break;
                     case 5:
          pcVar18 = "triangles";
          break;
                     case 6:
          pcVar18 = "triangles_adjacency";
          break;
                     case 7:
          pcVar18 = "triangle_strip";
                  }

                  ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot change previously set output primitive", pcVar18, &_LC1);
                  goto LAB_001351a2;
               }

               iVar9 = *(int*)( param_2 + 0x68 );
               if (iVar9 == 0) goto LAB_0013520a;
               LAB_001351b9:pcVar18 = "fractional_even_spacing";
               if (( ( iVar9 != 2 ) && ( pcVar18 = "fractional_odd_spacing" ),iVar9 != 3 )) {
                  pcVar18 = "none";
               }

               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to \'in\'", pcVar18, &_LC1);
            }

            LAB_0013520a:iVar9 = *(int*)( param_2 + 0x6c );
            if (iVar9 == 0) goto LAB_00135266;
            if (( (byte)param_2[0x10] & 0x7f ) != 3) {
               puVar15 = &_LC499;
               if (( iVar9 != 1 ) && ( puVar15 = iVar9 != 2 )) {
                  puVar15 = &_LC273;
               }

               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to \'in\'", puVar15, &_LC1);
               goto LAB_00135266;
            }

            lVar21 = *(long*)( this + 0x38 );
            LAB_00136093:if (*(int*)( lVar21 + 800 ) == 0) {
               *(int*)( lVar21 + 800 ) = iVar9;
            }
 else if (*(int*)( lVar21 + 800 ) != iVar9) {
               puVar15 = &_LC499;
               if (( iVar9 != 1 ) && ( puVar15 = iVar9 != 2 )) {
                  puVar15 = &_LC273;
               }

               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot change previously set vertex order", puVar15, &_LC1);
               goto LAB_00135266;
            }

            if (param_2[0x70] != (TPublicType)0x0) goto LAB_001360b1;
         }

         lVar21 = 0;
         do {
            if (param_2[lVar21 + 0x80] != (TPublicType)0x0) {
               lVar19 = *(long*)this;
               if (( (byte)param_2[0x10] & 0x7f ) == 3) {
                  lVar20 = *(long*)( this + 0x38 );
                  lVar22 = (long)(int)lVar21;
                  iVar9 = *(int*)( param_2 + lVar21 * 4 + 0x74 );
                  if (*(char*)( lVar20 + 0x284 + lVar22 ) == '\0') {
                     *(undefined1*)( lVar20 + 0x284 + lVar22 ) = 1;
                     *(int*)( lVar20 + 0x278 + lVar22 * 4 ) = iVar9;
                  }
 else if (iVar9 != *(int*)( lVar20 + 0x278 + lVar22 * 4 )) {
                     ( **(code**)( lVar19 + 0x158 ) )(this, param_1, "cannot change previously set size", "local_size", &_LC1);
                     goto LAB_001352b8;
                  }

                  iVar9 = *(int*)( this + 0x1c );
                  if (iVar9 == 5) {
                     if (lVar21 == 1) {
                        uVar10 = *(uint*)( this + 0x620 );
                     }
 else if (lVar21 == 2) {
                        uVar10 = *(uint*)( this + 0x624 );
                     }
 else {
                        uVar10 = *(uint*)( this + 0x61c );
                     }

                     if (uVar10 < *(uint*)( lVar20 + 0x278 + lVar22 * 4 )) {
                        pcVar18 = "too large; see gl_MaxComputeWorkGroupSize";
                        LAB_0013614d:( **(code**)( lVar19 + 0x158 ) )(this, param_1, pcVar18, "local_size", &_LC1);
                        goto LAB_0013615c;
                     }

                  }
 else {
                     if (iVar9 == 0xd) {
                        UNRECOVERED_JUMPTABLE = *(code**)( lVar19 + 0x40 );
                        if (lVar21 == 1) {
                           cVar8 = ( *UNRECOVERED_JUMPTABLE )(this);
                           if (cVar8 == '\0') {
                              uVar10 = *(uint*)( this + 0x718 );
                           }
 else {
                              uVar10 = *(uint*)( this + 0x73c );
                           }

                        }
 else if (lVar21 == 2) {
                           cVar8 = ( *UNRECOVERED_JUMPTABLE )();
                           if (cVar8 == '\0') {
                              uVar10 = *(uint*)( this + 0x71c );
                           }
 else {
                              uVar10 = *(uint*)( this + 0x740 );
                           }

                        }
 else {
                           cVar8 = ( *UNRECOVERED_JUMPTABLE )();
                           if (cVar8 == '\0') {
                              uVar10 = *(uint*)( this + 0x714 );
                           }
 else {
                              uVar10 = *(uint*)( this + 0x738 );
                           }

                        }

                        if (uVar10 < *(uint*)( *(long*)( this + 0x38 ) + 0x278 + lVar22 * 4 )) {
                           local_68 = glslang::GetThreadPoolAllocator();
                           local_60 = local_50;
                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, "too large, see ");
                           cVar8 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_EXT_mesh_shader");
                           pcVar18 = "gl_MaxMeshWorkGroupSizeNV";
                           pcVar16 = "gl_MaxMeshWorkGroupSizeEXT";
                           LAB_00136311:local_70 = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_68;
                           if (cVar8 != '\0') {
                              pcVar18 = pcVar16;
                           }

                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(local_70, pcVar18);
                           lVar19 = *(long*)this;
                           pcVar18 = local_60;
                           goto LAB_0013614d;
                        }

                     }
 else {
                        if (iVar9 != 0xc) goto LAB_00135922;
                        UNRECOVERED_JUMPTABLE = *(code**)( lVar19 + 0x40 );
                        if (lVar21 == 1) {
                           cVar8 = ( *UNRECOVERED_JUMPTABLE )(this);
                           if (cVar8 == '\0') {
                              uVar10 = *(uint*)( this + 0x724 );
                           }
 else {
                              uVar10 = *(uint*)( this + 0x748 );
                           }

                        }
 else if (lVar21 == 2) {
                           cVar8 = ( *UNRECOVERED_JUMPTABLE )();
                           if (cVar8 == '\0') {
                              uVar10 = *(uint*)( this + 0x728 );
                           }
 else {
                              uVar10 = *(uint*)( this + 0x74c );
                           }

                        }
 else {
                           cVar8 = ( *UNRECOVERED_JUMPTABLE )();
                           if (cVar8 == '\0') {
                              uVar10 = *(uint*)( this + 0x720 );
                           }
 else {
                              uVar10 = *(uint*)( this + 0x744 );
                           }

                        }

                        if (uVar10 < *(uint*)( *(long*)( this + 0x38 ) + 0x278 + lVar22 * 4 )) {
                           local_68 = glslang::GetThreadPoolAllocator();
                           local_60 = local_50;
                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, "too large, see ");
                           cVar8 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_EXT_mesh_shader");
                           pcVar18 = "gl_MaxTaskWorkGroupSizeNV";
                           pcVar16 = "gl_MaxTaskWorkGroupSizeEXT";
                           goto LAB_00136311;
                        }

                     }

                     LAB_0013615c:lVar19 = *(long*)this;
                  }

                  LAB_00135922:plVar11 = (long*)( **(code**)( lVar19 + 0x268 ) )(this, "gl_WorkGroupSize");
                  if (plVar11 != (long*)0x0) {
                     if (*(code**)( *plVar11 + 0xc0 ) == TVariable::getWritableConstArray) {
                        plVar11 = plVar11 + 0x19;
                     }
 else {
                        plVar11 = (long*)( **(code**)( *plVar11 + 0xc0 ) )(plVar11);
                     }

                     puVar12 = (undefined4*)( lVar21 * 0x10 + *(long*)( plVar11[1] + 8 ) );
                     uVar6 = *(undefined4*)( *(long*)( this + 0x38 ) + 0x278 + lVar22 * 4 );
                     puVar12[2] = 9;
                     *puVar12 = uVar6;
                  }

               }
 else {
                  ( **(code**)( lVar19 + 0x158 ) )(this, param_1, "can only apply to \'in\'", "local_size", &_LC1);
               }

            }

            LAB_001352b8:iVar9 = *(int*)( param_2 + lVar21 * 4 + 0x84 );
            if (iVar9 != -1) {
               lVar19 = *(long*)this;
               if (( (byte)param_2[0x10] & 0x7f ) == 3) {
                  lVar20 = (long)(int)lVar21 + 0xa0;
                  iVar5 = *(int*)( *(long*)( this + 0x38 ) + 8 + lVar20 * 4 );
                  if (iVar5 == -1) {
                     *(int*)( *(long*)( this + 0x38 ) + 8 + lVar20 * 4 ) = iVar9;
                  }
 else if (iVar9 != iVar5) {
                     pcVar18 = "local_size";
                     pcVar16 = "cannot change previously set size";
                     goto LAB_001352f1;
                  }

               }
 else {
                  pcVar18 = "local_size id";
                  pcVar16 = "can only apply to \'in\'";
                  LAB_001352f1:( **(code**)( lVar19 + 0x158 ) )(this, param_1, pcVar16, pcVar18, &_LC1);
                  lVar19 = *(long*)this;
               }

               plVar11 = (long*)( **(code**)( lVar19 + 0x268 ) )(this, "gl_WorkGroupSize");
               if (plVar11 != (long*)0x0) {
                  if (*(code**)( *plVar11 + 0x68 ) == TVariable::getWritableType) {
                     plVar11 = plVar11 + 5;
                  }
 else {
                     plVar11 = (long*)( **(code**)( *plVar11 + 0x68 ) )();
                  }

                  if (*(code**)( *plVar11 + 0x50 ) == TType::getQualifier) {
                     plVar11 = plVar11 + 2;
                  }
 else {
                     plVar11 = (long*)( **(code**)( *plVar11 + 0x50 ) )();
                  }

                  *(byte*)( (long)plVar11 + 0xc ) = *(byte*)( (long)plVar11 + 0xc ) | 1;
               }

            }

            lVar21 = lVar21 + 1;
         }
 while ( lVar21 != 3 );
         if (param_2[0x90] != (TPublicType)0x0) {
            if (( (byte)param_2[0x10] & 0x7f ) == 3) {
               *(undefined1*)( *(long*)( this + 0x38 ) + 0x329 ) = 1;
            }
 else {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to \'in\'", "early_fragment_tests", &_LC1);
            }

         }

         if (param_2[0x92] != (TPublicType)0x0) {
            if (( (byte)param_2[0x10] & 0x7f ) == 3) {
               *(undefined1*)( *(long*)( this + 0x38 ) + 0x32b ) = 1;
            }
 else {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to \'in\'", "early_and_late_fragment_tests_amd", &_LC1);
            }

         }

         if (param_2[0x91] != (TPublicType)0x0) {
            if (( (byte)param_2[0x10] & 0x7f ) == 3) {
               *(undefined1*)( *(long*)( this + 0x38 ) + 0x32a ) = 1;
            }
 else {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to \'in\'", "post_coverage_coverage", &_LC1);
            }

         }

         if (param_2[0x93] != (TPublicType)0x0) {
            if (( (byte)param_2[0x10] & 0x7f ) == 3) {
               *(undefined1*)( *(long*)( this + 0x38 ) + 0x32c ) = 1;
            }
 else {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to \'in\'", "non_coherent_color_attachment_readEXT", &_LC1);
            }

         }

         if (param_2[0x94] != (TPublicType)0x0) {
            if (( (byte)param_2[0x10] & 0x7f ) == 3) {
               *(undefined1*)( *(long*)( this + 0x38 ) + 0x32d ) = 1;
            }
 else {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to \'in\'", "non_coherent_depth_attachment_readEXT", &_LC1);
            }

         }

         if (param_2[0x95] != (TPublicType)0x0) {
            if (( (byte)param_2[0x10] & 0x7f ) == 3) {
               *(undefined1*)( *(long*)( this + 0x38 ) + 0x32e ) = 1;
            }
 else {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to \'in\'", "non_coherent_stencil_attachment_readEXT", &_LC1);
            }

         }

         if (param_2[0xa0] == (TPublicType)0x0) {
            LAB_00135525:iVar9 = *(int*)( param_2 + 0xa8 );
            if (iVar9 != 0) {
               if (( (byte)param_2[0x10] & 0x7f ) != 3) goto LAB_0013553f;
               iVar5 = *(int*)( *(long*)( this + 0x38 ) + 0x324 );
               if (iVar5 == 0) {
                  *(int*)( *(long*)( this + 0x38 ) + 0x324 ) = iVar9;
               }
 else if (iVar9 != iVar5) {
                  switch (iVar9) {
                     default:
          pcVar18 = "none";
          break;
                     case 1:
          pcVar18 = "pixel_interlock_ordered";
          break;
                     case 2:
          pcVar18 = "pixel_interlock_unordered";
          break;
                     case 3:
          pcVar18 = "sample_interlock_ordered";
          break;
                     case 4:
          pcVar18 = "sample_interlock_unordered";
          break;
                     case 5:
          pcVar18 = "shading_rate_interlock_ordered";
          break;
                     case 6:
          pcVar18 = "shading_rate_interlock_unordered";
                  }

                  ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot change previously set fragment shader interlock ordering", pcVar18, &_LC1);
               }

            }

         }
 else {
            if (( (byte)param_2[0x10] & 0x7f ) != 4) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to \'out\'", "blend equation", &_LC1);
               goto LAB_00135525;
            }

            iVar9 = *(int*)( param_2 + 0xa8 );
            if (iVar9 != 0) {
               LAB_0013553f:switch (iVar9) {
                  default:
        pcVar18 = "none";
        break;
                  case 1:
        pcVar18 = "pixel_interlock_ordered";
        break;
                  case 2:
        pcVar18 = "pixel_interlock_unordered";
        break;
                  case 3:
        pcVar18 = "sample_interlock_ordered";
        break;
                  case 4:
        pcVar18 = "sample_interlock_unordered";
        break;
                  case 5:
        pcVar18 = "shading_rate_interlock_ordered";
        break;
                  case 6:
        pcVar18 = "shading_rate_interlock_unordered";
               }

               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to \'in\'", pcVar18, &_LC1);
            }

         }

         if (( param_2[0xad] == (TPublicType)0x0 ) || ( ( param_2[0xae] != (TPublicType)0x0 && ( ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot be both specified", "derivative_group_quadsNV and derivative_group_linearNV", &_LC1),param_2[0xad] == (TPublicType)0x0 ) ) )) {
            LAB_00135605:TVar1 = param_2[0xae];
            joined_r0x0013560c:if (TVar1 == (TPublicType)0x0) goto LAB_00135612;
            if (( (byte)param_2[0x10] & 0x7f ) == 3) {
               lVar21 = *(long*)( this + 0x38 );
               if (( *(int*)( lVar21 + 0x27c ) * *(int*)( lVar21 + 0x278 ) * *(int*)( lVar21 + 0x280 ) & 3U ) == 0) goto LAB_0013625f;
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "requires total group size to be multiple of four", "derivative_group_linearNV", &_LC1);
               goto LAB_00135612;
            }

            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to \'in\'", "derivative_group_linearNV", &_LC1);
            iVar9 = *(int*)( this + 0x1c );
         }
 else {
            if (( (byte)param_2[0x10] & 0x7f ) != 3) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply to \'in\'", "derivative_group_quadsNV", &_LC1);
               goto LAB_00135605;
            }

            lVar21 = *(long*)( this + 0x38 );
            if (( ( *(byte*)( lVar21 + 0x278 ) & 1 ) != 0 ) || ( ( *(byte*)( lVar21 + 0x27c ) & 1 ) != 0 )) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "requires local_size_x and local_size_y to be multiple of two", "derivative_group_quadsNV", &_LC1);
               TVar1 = param_2[0xae];
               goto joined_r0x0013560c;
            }

            TVar1 = param_2[0xae];
            *(undefined4*)( lVar21 + 0x368 ) = 1;
            if (TVar1 != (TPublicType)0x0) {
               LAB_0013625f:*(undefined4*)( lVar21 + 0x368 ) = 2;
            }

            LAB_00135612:iVar9 = *(int*)( this + 0x1c );
         }

         if (( ( ( iVar9 == 0xd ) && ( lVar21 = *(long*)( this + 0x38 ) * (int*)( lVar21 + 0x30c ) != -1 ) ) && ( *(int*)( lVar21 + 0x36c ) != -1 ) ) && ( *(int*)( lVar21 + 0x314 ) != 0 )) {
            checkIoArraysConsistency(this, param_1, false);
         }

         if (param_2[0xb4] == (TPublicType)0x0) {
            TVar1 = param_2[0x13];
            if (( ( ( ( ( ( (byte)TVar1 & 0x20 ) != 0 ) || ( TVar2 = param_2[0x15]((byte)TVar2 & 0x10) != 0 ) ) || ( ( ( (byte)TVar2 & 0x20 ) != 0 || ( ( TVar3 = param_2[0x14] ),(char)TVar3 < '\0' || ( ( (byte)TVar2 & 1 ) != 0 ) ) ) ) ) ) || ( TVar4 = param_2[0x16] ),(char)TVar4 < '\0' )) ( ( ( ( ( ( (byte)TVar4 & 0x40 ) != 0 || ( ( (byte)TVar4 & 0x20 ) != 0 ) ) || ( ( (byte)TVar4 & 0x10 ) != 0 ) ) || ( ( ( (byte)TVar4 & 8 ) != 0 || ( ( (byte)TVar4 & 2 ) != 0 ) ) ) ) || ( ( (byte)TVar4 & 4 ) != 0 ) ) ) || ( ( ( ( (byte)TVar2 & 0x40 ) != 0 || ( (char)TVar2 < '\0' ) ) || ( ( ( ( (byte)TVar4 & 1 ) != 0 || ( ( ( ( (byte)param_2[0x17] & 1 ) != 0 || ( (char)TVar1 < '\0' ) ) || ( ( (byte)TVar1 & 0x40 ) != 0 ) ) ) ) || ( ( ( ( (byte)TVar3 & 0x20 ) != 0 || ( ( (byte)TVar3 & 0x40 ) != 0 ) ) || ( ( (byte)TVar1 & 0xe ) != 0 ) ) ) ) ) ) )(**(code**)( *(long*)this + 0x158 ))(this, param_1, "cannot use auxiliary, memory, interpolation, or precision qualifier in a default qualifier declaration (declaration with no type)", "qualifier", &_LC1);
         }

         if (( *(int*)( param_2 + 0x1c ) != -1 ) || ( *(int*)( param_2 + 0x20 ) != -1 )) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot use offset or align qualifiers in a default qualifier declaration (declaration with no type)", "layout qualifier", &_LC1);
         }

         layoutQualifierCheck(this, param_1, (TQualifier*)( param_2 + 8 ));
         switch ((char)param_2[0x10] + 0x7dU & 0x7f) {
            case 0:
      break;
            case 1:
      if (param_2[0x2b] != (TPublicType)0xff) {
        *(TPublicType *)(this + 0x7493) = param_2[0x2b];
      }
      if (((byte)param_2[0x2c] & 0xf) != 0xf) {
        this[0x7494] = (TParseContext)((byte)param_2[0x2c] & 0xf | (byte)this[0x7494] & 0xf0);
      }
      if ((((byte)this[0x7494] & 0xf) != 0xf) && ((~*(uint *)(param_2 + 0x2c) & 0x3fff0) != 0)) {
        uVar17 = *(uint *)(param_2 + 0x2c) >> 4 & 0x3fff;
        lVar21 = *(long *)(*(long *)(this + 0x38) + 0x348) +
                 (ulong)((byte)this[0x7494] & 0xf) * 0x28;
        uVar10 = *(uint *)(lVar21 + 0x18);
        if (uVar10 == 0x3fff) {
          *(uint *)(lVar21 + 0x18) = uVar17;
        }
        else if (uVar17 != uVar10) {
          (**(code **)(*(long *)this + 0x158))
                    (this,param_1,"all stride settings must match for xfb buffer","xfb_stride",
                     &_LC524,(byte)param_2[0x2c] & 0xf);
        }
      }
      break;
            case 2:
      if (((byte)param_2[0x17] & 0x70) != 0) {
        this[0x73df] = (TParseContext)((byte)param_2[0x17] & 0x70 | (byte)this[0x73df] & 0x8f);
      }
      if (((byte)param_2[0x18] & 0xf) != 0) {
        this[0x73e0] = (TParseContext)((byte)param_2[0x18] & 0xf | (byte)this[0x73e0] & 0xf0);
      }
      break;
            case 3:
      if (((byte)param_2[0x17] & 0x70) != 0) {
        this[0x738f] = (TParseContext)((byte)param_2[0x17] & 0x70 | (byte)this[0x738f] & 0x8f);
      }
      if (((byte)param_2[0x18] & 0xf) != 0) {
        this[0x7390] = (TParseContext)((byte)param_2[0x18] & 0xf | (byte)this[0x7390] & 0xf0);
      }
      break;
            case 4:
      if (((byte)param_2[0x17] & 0x70) != 0) {
        this[0x74cf] = (TParseContext)((byte)param_2[0x17] & 0x70 | (byte)this[0x74cf] & 0x8f);
      }
      if (((byte)param_2[0x18] & 0xf) != 0) {
        this[0x74d0] = (TParseContext)((byte)param_2[0x18] & 0xf | (byte)this[0x74d0] & 0xf0);
      }
      break;
            default:
      if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) goto LAB_00136a46;
      pcVar18 = "";
      pcVar16 = 
      "default qualifier requires \'uniform\', \'buffer\', \'in\', \'out\' or \'shared\' storage qualification"
      ;
      UNRECOVERED_JUMPTABLE = *(code **)(*(long *)this + 0x158);
      goto LAB_00135879;
         }

         if (*(short*)( param_2 + 0x28 ) != -1) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot declare a default, include a type or full declaration", "binding", &_LC1);
         }

         if (( ( ( ~*(ushort *)(param_2 + 0x24) & 0xfff ) != 0 ) || ( ( (byte)param_2[0x25] & 0x70 ) != 0x40 ) ) || ( param_2[0x2a] != (TPublicType)0xff )) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot declare a default, use a full declaration", "location/component/index", &_LC1);
         }

         if (( ~*(ushort *)(param_2 + 0x2e) & 0x7ffc ) != 0) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot declare a default, use a full declaration", "xfb_offset", &_LC1);
         }

         if (param_2[0x35] != (TPublicType)0x0) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot declare a default, can only be used on a block", "push_constant", &_LC1);
         }

         if (param_2[0x36] != (TPublicType)0x0) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot declare a default, can only be used on a block", "buffer_reference", &_LC1);
         }

         if (( ~*(uint *)(param_2 + 0x30) & 0x7ff00 ) != 0) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot declare a default, can only be used on a scalar", "constant_id", &_LC1);
         }

         if (param_2[0x40] != (TPublicType)0x0) {
            if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
               pcVar18 = "shaderRecordNV";
               pcVar16 = "cannot declare a default, can only be used on a block";
               UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
               LAB_00135879:/* WARNING: Could not recover jumptable at 0x0013588f. Too many branches *//* WARNING: Treating indirect jump as call */( *UNRECOVERED_JUMPTABLE )(this, param_1, pcVar16, pcVar18, &_LC1, UNRECOVERED_JUMPTABLE);
               return;
            }

            goto LAB_00136a46;
         }

      }

      else{if (((byte)param_2[0x10] & 0x7f) != 0){if (local_40 == *(long *)(in_FS_OFFSET + 0x28)){/* WARNING: Could not recover jumptable at 0x00135cbd. Too many branches *//* WARNING: Treating indirect jump as call */( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "layout qualifier can not have storage qualifiers", "primitive_culling", &_LC1);
        return;}goto LAB_00136a46;} * (undefined1*)( *(long*)( this + 0x38 ) + 0x374 ) = 1;
   }

   if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return;
   }

   LAB_00136a46:/* WARNING: Subroutine does not return */__stack_chk_fail();
}
/* glslang::TParseContext::declareArray(glslang::TSourceLoc const&, std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const&, glslang::TType const&,
   glslang::TSymbol*&) */void glslang::TParseContext::declareArray(TParseContext *this, TSourceLoc *param_1, basic_string *param_2, TType *param_3, TSymbol **param_4) {
   TSymbolTable *this_00;
   long lVar1;
   long lVar2;
   long *plVar3;
   undefined8 *puVar4;
   TSymbolTableLevel *this_01;
   basic_string *pbVar5;
   char cVar6;
   int iVar7;
   int iVar8;
   TType *pTVar9;
   TSymbol *pTVar10;
   long lVar11;
   long lVar12;
   TVariable *this_02;
   ulong uVar13;
   vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>> *this_03;
   undefined8 uVar14;
   bool bVar15;
   char *pcVar16;
   size_t __n;
   vector *pvVar17;
   code *UNRECOVERED_JUMPTABLE;
   long in_FS_OFFSET;
   bool local_69;
   undefined8 local_68;
   undefined1 *local_60;
   undefined8 local_58;
   undefined1 local_50[16];
   long local_40;
   pTVar10 = *param_4;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (pTVar10 != (TSymbol*)0x0) {
      LAB_00136aaa:pTVar9 = (TType*)( **(code**)( *(long*)pTVar10 + 0x68 ) )();
      if (*(code**)( *(long*)pTVar9 + 0xe8 ) == TType::isArray) {
         if (*(long*)( pTVar9 + 0x60 ) != 0) {
            LAB_00136b29:if (( pTVar9[8] != param_3[8] ) || ( cVar6 = TType::sameElementShape(pTVar9, param_3, (int*)0x0, (int*)0x0) ),cVar6 == '\0') {
               if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                  uVar14 = *(undefined8*)( param_2 + 8 );
                  pcVar16 = "redeclaration of array with a different element type";
                  UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                  goto LAB_00136b01;
               }

               goto LAB_00137272;
            }

            lVar11 = *(long*)( *(long*)( pTVar9 + 0x60 ) + 8 );
            lVar12 = *(long*)( *(long*)( param_3 + 0x60 ) + 8 );
            if (lVar11 != 0) {
               lVar1 = *(long*)( lVar11 + 8 );
               iVar8 = (int)( *(long*)( lVar11 + 0x10 ) - lVar1 >> 4 );
               if (lVar12 == 0) goto LAB_00136d51;
               lVar2 = *(long*)( lVar12 + 8 );
               if (iVar8 == (int)( *(long*)( lVar12 + 0x10 ) - lVar2 >> 4 )) {
                  if (1 < iVar8) {
                     lVar12 = 0x10;
                     do {
                        if (( *(int*)( lVar1 + lVar12 ) != *(int*)( lVar2 + lVar12 ) ) || ( *(long*)( lVar1 + 8 + lVar12 ) != *(long*)( lVar2 + 8 + lVar12 ) )) goto LAB_00136d00;
                        lVar12 = lVar12 + 0x10;
                     }
 while ( lVar12 != ( ( ulong )(iVar8 - 2) + 2 ) * 0x10 );
                  }

                  goto LAB_00136d58;
               }

               LAB_00136d00:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                  uVar14 = *(undefined8*)( param_2 + 8 );
                  pcVar16 = "redeclaration of array with a different array dimensions or sizes";
                  UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                  goto LAB_00136b01;
               }

               goto LAB_00137272;
            }

            if (lVar12 != 0) {
               iVar8 = (int)( *(long*)( lVar12 + 0x10 ) - *(long*)( lVar12 + 8 ) >> 4 );
               LAB_00136d51:if (iVar8 != 0) goto LAB_00136d00;
            }

            LAB_00136d58:UNRECOVERED_JUMPTABLE = *(code**)( *(long*)pTVar9 + 0xf0 );
            if (UNRECOVERED_JUMPTABLE == TType::isSizedArray) {
               UNRECOVERED_JUMPTABLE = *(code**)( *(long*)pTVar9 + 0xe8 );
               if (UNRECOVERED_JUMPTABLE != TType::isArray) {
                  cVar6 = ( *UNRECOVERED_JUMPTABLE )(pTVar9);
                  if (cVar6 == '\0') goto LAB_00136e35;
                  lVar11 = *(long*)( *(long*)( pTVar9 + 0x60 ) + 8 );
               }

               if (**(int**)( lVar11 + 8 ) == 0) {
                  LAB_00136e35:if (*(code**)( *(long*)param_3 + 0x78 ) == TType::getOuterArraySize) {
                     iVar8 = **(int**)( *(long*)( *(long*)( param_3 + 0x60 ) + 8 ) + 8 );
                  }
 else {
                     iVar8 = ( **(code**)( *(long*)param_3 + 0x78 ) )(param_3);
                  }

                  arrayLimitCheck(this, param_1, param_2, iVar8);
                  lVar11 = *(long*)( param_3 + 0x60 );
                  lVar12 = *(long*)( pTVar9 + 0x60 );
                  pvVar17 = *(vector**)( lVar11 + 8 );
                  *(undefined4*)( lVar12 + 0x10 ) = *(undefined4*)( lVar11 + 0x10 );
                  *(undefined1*)( lVar12 + 0x15 ) = *(undefined1*)( lVar11 + 0x15 );
                  if (pvVar17 == (vector*)0x0) {
                     *(undefined8*)( lVar12 + 8 ) = 0;
                  }
 else {
                     this_03 = *(vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>**)( lVar12 + 8 );
                     if (this_03 == (vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>*)0x0) {
                        uVar13 = glslang::GetThreadPoolAllocator();
                        this_03 = (vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>*)glslang::TPoolAllocator::allocate(uVar13);
                        uVar14 = glslang::GetThreadPoolAllocator();
                        *(undefined8*)this_03 = uVar14;
                        for (int i = 0; i < 3; i++) {
                           *(undefined8*)( this_03 + ( 8*i + 8 ) ) = 0;
                        }

                        *(vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>**)( lVar12 + 8 ) = this_03;
                        pvVar17 = *(vector**)( lVar11 + 8 );
                     }

                     std::vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>::operator =(this_03, pvVar17);
                  }

                  *(undefined1*)( lVar12 + 0x14 ) = *(undefined1*)( lVar11 + 0x14 );
                  cVar6 = isIoResizeArray(this, param_3);
                  if (cVar6 != '\0') {
                     if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                        bVar15 = false;
                        goto LAB_00136ed4;
                     }

                     goto LAB_00137272;
                  }

                  goto LAB_00136bf8;
               }

            }
 else {
               cVar6 = ( *UNRECOVERED_JUMPTABLE )(pTVar9);
               if (cVar6 == '\0') goto LAB_00136e35;
            }

            cVar6 = isIoResizeArray(this, param_3);
            if (cVar6 != '\0') {
               if (*(code**)( *(long*)pTVar9 + 0x78 ) == TType::getOuterArraySize) {
                  iVar8 = **(int**)( *(long*)( *(long*)( pTVar9 + 0x60 ) + 8 ) + 8 );
               }
 else {
                  iVar8 = ( **(code**)( *(long*)pTVar9 + 0x78 ) )(pTVar9);
               }

               if (*(code**)( *(long*)param_3 + 0x78 ) == TType::getOuterArraySize) {
                  iVar7 = **(int**)( *(long*)( *(long*)( param_3 + 0x60 ) + 8 ) + 8 );
               }
 else {
                  iVar7 = ( **(code**)( *(long*)param_3 + 0x78 ) )(param_3);
               }

               if (iVar8 == iVar7) goto LAB_00136bf8;
            }

            if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
               uVar14 = *(undefined8*)( param_2 + 8 );
               pcVar16 = "redeclaration of array with size";
               UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
               goto LAB_00136b01;
            }

            goto LAB_00137272;
         }

      }
 else {
         cVar6 = ( **(code**)( *(long*)pTVar9 + 0xe8 ) )(pTVar9);
         if (cVar6 != '\0') goto LAB_00136b29;
      }

      if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
         uVar14 = *(undefined8*)( param_2 + 8 );
         pcVar16 = "redeclaring non-array as array";
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         LAB_00136b01:/* WARNING: Could not recover jumptable at 0x00136b17. Too many branches *//* WARNING: Treating indirect jump as call */( *UNRECOVERED_JUMPTABLE )(this, param_1, pcVar16, uVar14, &_LC1, UNRECOVERED_JUMPTABLE);
         return;
      }

      goto LAB_00137272;
   }

   this_00 = *(TSymbolTable**)( this + 0xe8 );
   pTVar10 = (TSymbol*)TSymbolTable::find(this_00, param_2, (bool*)0x0, &local_69, (int*)0x0);
   *param_4 = pTVar10;
   if (pTVar10 == (TSymbol*)0x0) {
      LAB_00136ef0:uVar13 = glslang::GetThreadPoolAllocator();
      this_02 = (TVariable*)glslang::TPoolAllocator::allocate(uVar13);
      TVariable::TVariable(this_02, param_2, param_3, false);
      plVar3 = *(long**)( this + 0xe8 );
      lVar11 = plVar3[3];
      puVar4 = (undefined8*)*plVar3;
      *param_4 = (TSymbol*)this_02;
      lVar12 = plVar3[1];
      cVar6 = *(char*)( (long)plVar3 + 0x21 );
      plVar3[3] = lVar11 + 1;
      *(long*)( this_02 + 0x10 ) = lVar11 + 1;
      if (cVar6 == '\0') {
         iVar8 = (int)( lVar12 - (long)puVar4 >> 3 );
         cVar6 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)puVar4[iVar8 + -1], *(basic_string**)( this_02 + 8 ));
         if (cVar6 == '\0') goto LAB_00136f52;
         LAB_00136fca:if (iVar8 < 5) {
            this_02 = (TVariable*)*param_4;
            goto LAB_001370e4;
         }

      }
 else {
         iVar8 = (int)( lVar12 - (long)puVar4 >> 3 );
         LAB_00136f52:if (( (char)plVar3[4] == '\0' ) || ( 2 < iVar8 - 2U )) {
            LAB_00136f66:this_01 = (TSymbolTableLevel*)puVar4[iVar8 + -1];
            local_68 = glslang::GetThreadPoolAllocator();
            local_60 = local_50;
            local_58 = 0;
            local_50[0] = 0;
            TSymbolTableLevel::insert(this_01, (TSymbol*)this_02, *(bool*)( (long)plVar3 + 0x21 ), (basic_string*)&local_68);
            iVar8 = (int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 );
            goto LAB_00136fca;
         }

         pbVar5 = *(basic_string**)( this_02 + 8 );
         cVar6 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)*puVar4, pbVar5);
         if (( cVar6 == '\0' ) && ( ( iVar8 == 2 || ( cVar6 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)puVar4[1], pbVar5) ),cVar6 == '\0' ) )) goto LAB_00136f66;
         LAB_001370e4:( **(code**)( *(long*)this + 600 ) )(this, this_02);
         if ((int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 ) < 4) goto LAB_00136bf8;
      }

      cVar6 = isIoResizeArray(this, param_3);
      if (cVar6 == '\0') {
         pTVar9 = (TType*)( **(code**)( *(long*)*param_4 + 0x68 ) )();
         if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
            fixIoArraySize(this, param_1, pTVar9);
            return;
         }

      }
 else {
         puVar4 = *(undefined8**)( this + 0x7608 );
         if (puVar4 == *(undefined8**)( this + 0x7610 )) {
            std::vector<glslang::TSymbol*,glslang::pool_allocator<glslang::TSymbol*>>::_M_realloc_insert<glslang::TSymbol*const&>((vector<glslang::TSymbol*,glslang::pool_allocator<glslang::TSymbol*>>*)( this + 0x75f8 ), puVar4, param_4);
         }
 else {
            *puVar4 = *param_4;
            *(undefined8**)( this + 0x7608 ) = puVar4 + 1;
         }

         if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
            bVar15 = true;
            LAB_00136ed4:checkIoArraysConsistency(this, param_1, bVar15);
            return;
         }

      }

   }
 else {
      uVar13 = *(ulong*)( param_2 + 0x10 );
      if (uVar13 == 0) {
         LAB_00136bb2:if (local_69 == false) goto LAB_00136ef0;
         lVar11 = ( **(code**)( *(long*)pTVar10 + 0x58 ) )(pTVar10);
         if (lVar11 == 0) {
            pTVar10 = *param_4;
            if (pTVar10 == (TSymbol*)0x0) {
               if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                  uVar14 = *(undefined8*)( param_2 + 8 );
                  pcVar16 = "array variable name expected";
                  UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                  goto LAB_00136b01;
               }

               goto LAB_00137272;
            }

            goto LAB_00136aaa;
         }

         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot redeclare a user-block member array", *(undefined8*)( param_2 + 8 ), &_LC1);
      }
 else {
         __n = 3;
         if (uVar13 < 4) {
            __n = uVar13;
         }

         iVar8 = memcmp(*(void**)( param_2 + 8 ), &_LC61, __n);
         if (( iVar8 != 0 || (int)__n != 3 ) || ( (int)( *(long*)( this_00 + 8 ) - *(long*)this_00 >> 3 ) < 4 )) goto LAB_00136bb2;
      }

      *param_4 = (TSymbol*)0x0;
      LAB_00136bf8:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
         return;
      }

   }

   LAB_00137272:/* WARNING: Subroutine does not return */__stack_chk_fail();
}
/* glslang::TParseContext::redeclareBuiltinBlock(glslang::TSourceLoc const&,
   glslang::TVector<glslang::TTypeLoc>&, std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const*, glslang::TArraySizes*) */void glslang::TParseContext::redeclareBuiltinBlock(TParseContext *this, TSourceLoc *param_1, TVector *param_2, basic_string *param_3, basic_string *param_4, TArraySizes *param_5) {
   ushort uVar1;
   ulong uVar2;
   TSymbolTable *this_00;
   TType *this_01;
   undefined8 *puVar3;
   TType TVar4;
   char cVar5;
   int iVar6;
   int iVar7;
   uint uVar8;
   undefined4 uVar9;
   TSymbol *pTVar10;
   TType *pTVar11;
   size_t sVar12;
   code *UNRECOVERED_JUMPTABLE;
   long lVar13;
   long lVar14;
   long *plVar15;
   TType *pTVar16;
   long *plVar17;
   long lVar18;
   basic_string *pbVar19;
   undefined8 uVar20;
   char *pcVar21;
   long *plVar22;
   char *pcVar23;
   byte bVar24;
   TParseContext TVar25;
   long *plVar26;
   code *pcVar27;
   long in_FS_OFFSET;
   char cVar28;
   bool bVar29;
   bool bVar30;
   ulong local_80;
   bool local_61;
   TSymbol *local_60;
   long local_58;
   long lStack_50;
   ulong local_48;
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   glslang::TParseVersions::profileRequires((TSourceLoc*)this, (int)param_1, 8, 0x140, (char**)0x2, AEP_shader_io_blocks);
   glslang::TParseVersions::profileRequires((TSourceLoc*)this, (int)param_1, -9, (char*)0x19a, "GL_ARB_separate_shader_objects");
   lVar18 = *(long*)( param_3 + 0x10 );
   if (lVar18 == 0xc) {
      plVar26 = *(long**)( param_3 + 8 );
      if (( *plVar26 != 0x65567265505f6c67 ) || ( (int)plVar26[1] != 0x78657472 )) goto LAB_0013742c;
   }
 else {
      plVar26 = *(long**)( param_3 + 8 );
      if (lVar18 == 0xe) {
         if (( *plVar26 != 0x72467265505f6c67 ) || ( *(long*)( (long)plVar26 + 6 ) != 0x746e656d67617246 )) goto LAB_0013742c;
      }
 else if (lVar18 == 0x12) {
         if (( *plVar26 != 0x506873654d5f6c67 || plVar26[1] != 0x7865747265567265 ) || ( (short)plVar26[2] != 0x564e )) goto LAB_0013742c;
      }
 else if (lVar18 == 0x15) {
         if (( *plVar26 != 0x506873654d5f6c67 || plVar26[1] != 0x74696d6972507265 ) || ( *(long*)( (long)plVar26 + 0xd ) != 0x564e65766974696d )) goto LAB_0013742c;
      }
 else if (lVar18 == 0x13) {
         if (( *plVar26 != 0x506873654d5f6c67 || plVar26[1] != 0x7865747265567265 ) || ( *(int*)( (long)plVar26 + 0xf ) != 0x54584578 )) {
            LAB_0013742c:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
               pcVar23 = "block declaration";
               pcVar21 = "cannot redeclare block: ";
               UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
               goto LAB_001373a9;
            }

            goto LAB_00139520;
         }

      }
 else if (( ( lVar18 != 0x16 ) || ( *plVar26 != 0x506873654d5f6c67 || plVar26[1] != 0x74696d6972507265 ) ) || ( *(long*)( (long)plVar26 + 0xe ) != 0x5458456576697469 )) goto LAB_0013742c;
   }

   if (param_4 != (basic_string*)0x0) {
      pcVar23 = *(char**)( param_4 + 8 );
      uVar2 = *(ulong*)( param_4 + 0x10 );
      if (uVar2 != 0) {
         sVar12 = 3;
         if (uVar2 < 4) {
            sVar12 = uVar2;
         }

         iVar6 = memcmp(pcVar23, &_LC61, sVar12);
         if (iVar6 == 0 && (int)sVar12 == 3) {
            pTVar10 = (TSymbol*)TSymbolTable::find(*(TSymbolTable**)( this + 0xe8 ), param_4, &local_61, (bool*)0x0, (int*)0x0);
            local_60 = pTVar10;
            goto joined_r0x001375ba;
         }

      }

      if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
         plVar26 = (long*)&_LC1;
         pcVar21 = "cannot redeclare a built-in block with a user name";
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         LAB_001373a9:/* WARNING: Could not recover jumptable at 0x001373c4. Too many branches *//* WARNING: Treating indirect jump as call */( *UNRECOVERED_JUMPTABLE )(this, param_1, pcVar21, pcVar23, plVar26, UNRECOVERED_JUMPTABLE);
         return;
      }

      goto LAB_00139520;
   }

   this_00 = *(TSymbolTable**)( this + 0xe8 );
   UNRECOVERED_JUMPTABLE = *(code**)( *(long*)**(long**)( param_2 + 8 ) + 0x30 );
   if (UNRECOVERED_JUMPTABLE == TType::getFieldName_abi_cxx11_) {
      pbVar19 = (basic_string*)( (long*)**(long**)( param_2 + 8 ) )[0xe];
   }
 else {
      pbVar19 = (basic_string*)( *UNRECOVERED_JUMPTABLE )();
   }

   pTVar10 = (TSymbol*)TSymbolTable::find(this_00, pbVar19, &local_61, (bool*)0x0, (int*)0x0);
   UNRECOVERED_JUMPTABLE = *(code**)( *(long*)**(long**)( param_2 + 8 ) + 0x30 );
   local_60 = pTVar10;
   if (UNRECOVERED_JUMPTABLE == TType::getFieldName_abi_cxx11_) {
      lVar18 = ( (long*)**(long**)( param_2 + 8 ) )[0xe];
   }
 else {
      lVar18 = ( *UNRECOVERED_JUMPTABLE )();
   }

   pcVar23 = *(char**)( lVar18 + 8 );
   joined_r0x001375ba:if (pTVar10 == (TSymbol*)0x0) {
      if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
         plVar26 = (long*)&_LC1;
         pcVar21 = "no declaration found for redeclaration";
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         goto LAB_001373a9;
      }

      goto LAB_00139520;
   }

   if (local_61 == false) {
      if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
         plVar26 = (long*)&_LC1;
         pcVar21 = "can only redeclare a built-in block once, and before any use";
         pcVar23 = *(char**)( param_3 + 8 );
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         goto LAB_001373a9;
      }

      goto LAB_00139520;
   }

   pTVar10 = (TSymbol*)TSymbolTable::copyUpDeferredInsert(pTVar10);
   local_60 = pTVar10;
   plVar26 = (long*)( **(code**)( *(long*)pTVar10 + 0x60 ) )(pTVar10);
   if (*(code**)( *plVar26 + 0x38 ) == TType::getBasicType) {
      uVar8 = ( uint ) * (byte*)( plVar26 + 1 );
   }
 else {
      uVar8 = ( **(code**)( *plVar26 + 0x38 ) )();
   }

   if (uVar8 != 0x10) {
      if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
         plVar26 = (long*)&_LC1;
         pcVar21 = "cannot redeclare a non block as a block";
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         goto LAB_001373a9;
      }

      goto LAB_00139520;
   }

   if (( ( (byte)this[0x518] & 0x7f ) == 4 ) && ( ( (byte)this[0x7494] & 0xf ) != 0xf )) {
      if (( ~(byte)this[0x534] & 0xf ) == 0) {
         this[0x534] = ( TParseContext )((byte)this[0x7494] & 0xf | (byte)this[0x534] & 0xf0);
      }

      if (this[0x533] == (TParseContext)0xff) {
         this[0x533] = this[0x7493];
      }

      fixXfbOffsets(this, (TQualifier*)( this + 0x510 ), param_2);
   }

   plVar26 = (long*)( **(code**)( *(long*)pTVar10 + 0x68 ) )(pTVar10);
   if (this[0x53f] != (TParseContext)0x0) {
      if (*(code**)( *plVar26 + 0x50 ) == TType::getQualifier) {
         *(undefined1*)( (long)plVar26 + 0x3f ) = 1;
         bVar24 = (byte)this[0x518] & 0x7f;
         LAB_001376c6:*(byte*)( plVar26 + 3 ) = *(byte*)( plVar26 + 3 ) & 0x80 | bVar24;
         TVar25 = this[0x533];
         LAB_001376db:*(TParseContext*)( (long)plVar26 + 0x33 ) = TVar25;
         bVar24 = (byte)this[0x534] & 0xf;
         LAB_001376e9:plVar17 = plVar26 + 2;
      }
 else {
         lVar18 = ( **(code**)( *plVar26 + 0x50 ) )(plVar26);
         UNRECOVERED_JUMPTABLE = *(code**)( *plVar26 + 0x50 );
         *(undefined1*)( lVar18 + 0x2f ) = 1;
         bVar24 = (byte)this[0x518] & 0x7f;
         if (UNRECOVERED_JUMPTABLE == TType::getQualifier) goto LAB_001376c6;
         lVar18 = ( *UNRECOVERED_JUMPTABLE )(plVar26);
         UNRECOVERED_JUMPTABLE = *(code**)( *plVar26 + 0x50 );
         *(byte*)( lVar18 + 8 ) = *(byte*)( lVar18 + 8 ) & 0x80 | bVar24;
         TVar25 = this[0x533];
         if (UNRECOVERED_JUMPTABLE == TType::getQualifier) goto LAB_001376db;
         lVar18 = ( *UNRECOVERED_JUMPTABLE )(plVar26);
         UNRECOVERED_JUMPTABLE = *(code**)( *plVar26 + 0x50 );
         *(TParseContext*)( lVar18 + 0x23 ) = TVar25;
         bVar24 = (byte)this[0x534] & 0xf;
         if (UNRECOVERED_JUMPTABLE == TType::getQualifier) goto LAB_001376e9;
         plVar17 = (long*)( *UNRECOVERED_JUMPTABLE )(plVar26);
      }

      *(byte*)( (long)plVar17 + 0x24 ) = *(byte*)( (long)plVar17 + 0x24 ) & 0xf0 | bVar24;
   }

   local_80 = 0;
   plVar17 = *(long**)( plVar26[0xd] + 8 );
   if (plVar17 != *(long**)( plVar26[0xd] + 0x10 )) {
      do {
         local_58 = 0;
         plVar15 = *(long**)( param_2 + 8 );
         lStack_50 = 0;
         local_48 = local_48 & 0xffffffff00000000;
         if (plVar15 != *(long**)( param_2 + 0x10 )) {
            do {
               UNRECOVERED_JUMPTABLE = *(code**)( *(long*)*plVar15 + 0x30 );
               if (UNRECOVERED_JUMPTABLE == TType::getFieldName_abi_cxx11_) {
                  lVar18 = ( (long*)*plVar15 )[0xe];
               }
 else {
                  lVar18 = ( *UNRECOVERED_JUMPTABLE )();
               }

               UNRECOVERED_JUMPTABLE = *(code**)( *(long*)*plVar17 + 0x30 );
               if (UNRECOVERED_JUMPTABLE == TType::getFieldName_abi_cxx11_) {
                  lVar14 = ( (long*)*plVar17 )[0xe];
               }
 else {
                  lVar14 = ( *UNRECOVERED_JUMPTABLE )();
               }

               sVar12 = *(size_t*)( lVar14 + 0x10 );
               if (sVar12 == *(size_t*)( lVar18 + 0x10 )) {
                  if (( sVar12 == 0 ) || ( iVar6 = memcmp(*(void**)( lVar14 + 8 ), *(void**)( lVar18 + 8 ), sVar12) ),iVar6 == 0) {
                     local_58 = plVar15[1];
                     lStack_50 = plVar15[2];
                     local_48 = plVar15[3];
                     pTVar11 = (TType*)*plVar17;
                     this_01 = (TType*)*plVar15;
                     pTVar16 = pTVar11;
                     if (this_01[8] == pTVar11[8]) {
                        cVar5 = TType::sameElementShape(this_01, pTVar11, (int*)0x0, (int*)0x0);
                        if (cVar5 == '\0') {
                           pTVar16 = (TType*)*plVar17;
                           goto LAB_001377fe;
                        }

                     }
 else {
                        LAB_001377fe:UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                        if (*(code**)( *(long*)pTVar16 + 0x30 ) == TType::getFieldName_abi_cxx11_) {
                           lVar18 = *(long*)( pTVar16 + 0x70 );
                        }
 else {
                           lVar18 = ( **(code**)( *(long*)pTVar16 + 0x30 ) )();
                        }

                        ( *UNRECOVERED_JUMPTABLE )(this, &local_58, "cannot redeclare block member with a different type", *(undefined8*)( lVar18 + 8 ), &_LC1);
                     }

                     if (*(code**)( *(long*)pTVar11 + 0xe8 ) == TType::isArray) {
                        cVar5 = *(long*)( pTVar11 + 0x60 ) != 0;
                     }
 else {
                        cVar5 = ( **(code**)( *(long*)pTVar11 + 0xe8 ) )(pTVar11);
                     }

                     if (*(code**)( *(long*)this_01 + 0xe8 ) == TType::isArray) {
                        cVar28 = *(long*)( this_01 + 0x60 ) != 0;
                     }
 else {
                        cVar28 = ( **(code**)( *(long*)this_01 + 0xe8 ) )(this_01);
                     }

                     if (cVar5 != cVar28) {
                        UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                        pcVar27 = *(code**)( *(long*)*plVar17 + 0x30 );
                        if (pcVar27 == TType::getFieldName_abi_cxx11_) {
                           lVar18 = ( (long*)*plVar17 )[0xe];
                        }
 else {
                           lVar18 = ( *pcVar27 )();
                        }

                        ( *UNRECOVERED_JUMPTABLE )(this, &local_58, "cannot change arrayness of redeclared block member", *(undefined8*)( lVar18 + 8 ), &_LC1);
                        goto LAB_001378e0;
                     }

                     if (*(code**)( *(long*)pTVar11 + 0x50 ) != TType::getQualifier) {
                        lVar18 = ( **(code**)( *(long*)pTVar11 + 0x50 ) )(pTVar11);
                        if (( *(byte*)( lVar18 + 0xd ) & 4 ) == 0) goto LAB_0013859f;
                        goto LAB_00138de1;
                     }

                     if (( (byte)pTVar11[0x1d] & 4 ) == 0) {
                        LAB_0013859f:lVar14 = *(long*)( pTVar11 + 0x60 );
                        lVar18 = *(long*)( this_01 + 0x60 );
                        if (lVar14 == 0) {
                           lVar13 = *(long*)pTVar11;
                           if (lVar18 != 0) goto LAB_001385ff;
                           LAB_00138de5:if (*(code**)( lVar13 + 0x50 ) == TType::getQualifier) {
                              if (( (byte)pTVar11[0x1d] & 4 ) != 0) goto LAB_001382a0;
                           }
 else {
                              lVar18 = ( **(code**)( lVar13 + 0x50 ) )(pTVar11);
                              if (( *(byte*)( lVar18 + 0xd ) & 4 ) != 0) goto LAB_001378e0;
                           }

                           lVar18 = *(long*)this_01;
                           if (*(code**)( lVar18 + 0xe8 ) == TType::isArray) {
                              if (*(long*)( this_01 + 0x60 ) != 0) {
                                 LAB_00138e25:if (*(code**)( lVar18 + 0x78 ) == TType::getOuterArraySize) {
                                    iVar6 = **(int**)( *(long*)( *(long*)( this_01 + 0x60 ) + 8 ) + 8 );
                                 }
 else {
                                    iVar6 = ( **(code**)( lVar18 + 0x78 ) )(this_01);
                                 }

                                 UNRECOVERED_JUMPTABLE = *(code**)( *(long*)*plVar17 + 0x30 );
                                 if (UNRECOVERED_JUMPTABLE == TType::getFieldName_abi_cxx11_) {
                                    pbVar19 = (basic_string*)( (long*)*plVar17 )[0xe];
                                 }
 else {
                                    pbVar19 = (basic_string*)( *UNRECOVERED_JUMPTABLE )();
                                 }

                                 arrayLimitCheck(this, param_1, pbVar19, iVar6);
                              }

                           }
 else {
                              cVar5 = ( **(code**)( lVar18 + 0xe8 ) )(this_01);
                              if (cVar5 != '\0') {
                                 lVar18 = *(long*)this_01;
                                 goto LAB_00138e25;
                              }

                           }

                        }
 else {
                           if (lVar18 == 0) {
                              lVar13 = *(long*)pTVar11;
                           }
 else {
                              cVar5 = TSmallArrayVector::operator ==(*(TSmallArrayVector**)( lVar14 + 8 ), *(TSmallArrayVector**)( lVar18 + 8 ));
                              if (cVar5 != '\0') goto LAB_00138de1;
                              lVar14 = *(long*)( pTVar11 + 0x60 );
                              lVar13 = *(long*)pTVar11;
                              if (( ( *(char*)( lVar14 + 0x14 ) != '\0' ) && ( *(char*)( *(long*)( this_01 + 0x60 ) + 0x14 ) != '\0' ) ) && ( ( *(int*)( *(long*)( this_01 + 0x60 ) + 0x10 ) == 0 || ( *(int*)( lVar14 + 0x10 ) == 0 ) ) )) goto LAB_00138de5;
                           }

                           LAB_001385ff:if (*(code**)( lVar13 + 0xf0 ) == TType::isSizedArray) {
                              if (*(code**)( lVar13 + 0xe8 ) == TType::isArray) {
                                 if (lVar14 == 0) goto LAB_00138de5;
                              }
 else {
                                 cVar5 = ( **(code**)( lVar13 + 0xe8 ) )(pTVar11);
                                 if (cVar5 == '\0') goto LAB_00138de1;
                                 lVar14 = *(long*)( pTVar11 + 0x60 );
                              }

                              if (**(int**)( *(long*)( lVar14 + 8 ) + 8 ) == 0) {
                                 LAB_00138de1:lVar13 = *(long*)pTVar11;
                                 goto LAB_00138de5;
                              }

                           }
 else {
                              cVar5 = ( **(code**)( lVar13 + 0xf0 ) )(pTVar11);
                              if (cVar5 == '\0') goto LAB_00138de1;
                           }

                           UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                           pcVar27 = *(code**)( *(long*)*plVar17 + 0x30 );
                           if (pcVar27 == TType::getFieldName_abi_cxx11_) {
                              lVar18 = ( (long*)*plVar17 )[0xe];
                           }
 else {
                              lVar18 = ( *pcVar27 )();
                           }

                           ( *UNRECOVERED_JUMPTABLE )(this, &local_58, "cannot change array size of redeclared block member", *(undefined8*)( lVar18 + 8 ), &_LC1);
                        }

                        LAB_001378e0:if (*(code**)( *(long*)pTVar11 + 0x50 ) != TType::getQualifier) {
                           lVar18 = ( **(code**)( *(long*)pTVar11 + 0x50 ) )(pTVar11);
                           if (( *(byte*)( lVar18 + 0xd ) & 4 ) != 0) goto LAB_001382a0;
                           goto LAB_0013841e;
                        }

                        if (( (byte)pTVar11[0x1d] & 4 ) != 0) goto LAB_001382a0;
                        UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this_01 + 0x58 );
                        LAB_0013790f:if (UNRECOVERED_JUMPTABLE == TType::getQualifier) {
                           if (( (byte)this_01[0x1d] & 4 ) == 0) goto LAB_0013830d;
                        }
 else {
                           lVar18 = ( *UNRECOVERED_JUMPTABLE )(this_01);
                           if (( *(byte*)( lVar18 + 0xd ) & 4 ) == 0) {
                              lVar18 = *(long*)this_01;
                              goto LAB_0013844e;
                           }

                        }

                        UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                        pcVar27 = *(code**)( *(long*)*plVar17 + 0x30 );
                        if (pcVar27 == TType::getFieldName_abi_cxx11_) {
                           lVar18 = ( (long*)*plVar17 )[0xe];
                        }
 else {
                           lVar18 = ( *pcVar27 )();
                        }

                        ( *UNRECOVERED_JUMPTABLE )(this, &local_58, "cannot add perviewNV qualifier to redeclared block member", *(undefined8*)( lVar18 + 8 ), &_LC1);
                        lVar18 = *(long*)pTVar11;
                        LAB_00137979:UNRECOVERED_JUMPTABLE = *(code**)( lVar18 + 0x50 );
                        if (UNRECOVERED_JUMPTABLE == TType::getQualifier) goto LAB_0013798a;
                        LAB_0013832e:lVar18 = ( *UNRECOVERED_JUMPTABLE )(pTVar11);
                        if (( *(byte*)( lVar18 + 0xd ) & 2 ) != 0) goto LAB_00138340;
                        LAB_00138530:if (*(code**)( *(long*)pTVar11 + 0x50 ) == TType::getQualifier) {
                           TVar4 = pTVar11[0x1d];
                        }
 else {
                           lVar18 = ( **(code**)( *(long*)pTVar11 + 0x50 ) )(pTVar11);
                           TVar4 = *(TType*)( lVar18 + 0xd );
                        }

                        lVar18 = *(long*)this_01;
                        UNRECOVERED_JUMPTABLE = *(code**)( lVar18 + 0x58 );
                        if (( (byte)TVar4 >> 1 & 1 ) == 0) {
                           LAB_0013799d:if (UNRECOVERED_JUMPTABLE != TType::getQualifier) {
                              lVar18 = ( *UNRECOVERED_JUMPTABLE )(this_01);
                              if (( *(byte*)( lVar18 + 0xd ) & 2 ) != 0) goto LAB_001379ac;
                              LAB_001379f3:lVar18 = *(long*)this_01;
                              goto LAB_001379f7;
                           }

                           if (( (byte)this_01[0x1d] & 2 ) != 0) {
                              LAB_001379ac:UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                              pcVar27 = *(code**)( *(long*)*plVar17 + 0x30 );
                              if (pcVar27 == TType::getFieldName_abi_cxx11_) {
                                 lVar18 = ( (long*)*plVar17 )[0xe];
                              }
 else {
                                 lVar18 = ( *pcVar27 )();
                              }

                              ( *UNRECOVERED_JUMPTABLE )(this, &local_58, "cannot add perprimitiveNV qualifier to redeclared block member", *(undefined8*)( lVar18 + 8 ), &_LC1);
                              goto LAB_001379f3;
                           }

                        }
 else {
                           LAB_001379f7:UNRECOVERED_JUMPTABLE = *(code**)( lVar18 + 0x58 );
                           if (UNRECOVERED_JUMPTABLE != TType::getQualifier) goto LAB_001383b7;
                        }

                        LAB_00137a04:pTVar16 = this_01 + 0x10;
                     }
 else {
                        LAB_001382a0:pTVar16 = this_01 + 0x10;
                        if (*(code**)( *(long*)this_01 + 0x58 ) != TType::getQualifier) {
                           pTVar16 = (TType*)( **(code**)( *(long*)this_01 + 0x58 ) )(this_01);
                        }

                        if (( (byte)pTVar16[0xd] & 4 ) != 0) {
                           LAB_0013841e:if (*(code**)( *(long*)pTVar11 + 0x50 ) == TType::getQualifier) {
                              TVar4 = pTVar11[0x1d];
                           }
 else {
                              lVar18 = ( **(code**)( *(long*)pTVar11 + 0x50 ) )(pTVar11);
                              TVar4 = *(TType*)( lVar18 + 0xd );
                           }

                           lVar18 = *(long*)this_01;
                           UNRECOVERED_JUMPTABLE = *(code**)( lVar18 + 0x58 );
                           if (( (byte)TVar4 >> 2 & 1 ) == 0) goto LAB_0013790f;
                           LAB_0013844e:if (*(code**)( lVar18 + 0x58 ) == TType::getQualifier) {
                              TVar4 = this_01[0x1d];
                           }
 else {
                              lVar18 = ( **(code**)( lVar18 + 0x58 ) )(this_01);
                              TVar4 = *(TType*)( lVar18 + 0xd );
                           }

                           lVar18 = *(long*)pTVar11;
                           if (( (byte)TVar4 >> 2 & 1 ) != 0) {
                              if (*(code**)( lVar18 + 0xa0 ) == TType::getArraySizes) {
                                 lVar18 = *(long*)( pTVar11 + 0x60 );
                              }
 else {
                                 lVar18 = ( **(code**)( lVar18 + 0xa0 ) )(pTVar11);
                              }

                              lVar18 = *(long*)( lVar18 + 8 );
                              if (lVar18 == 0) {
                                 iVar6 = 0;
                              }
 else {
                                 iVar6 = (int)( *(long*)( lVar18 + 0x10 ) - *(long*)( lVar18 + 8 ) >> 4 );
                              }

                              if (*(code**)( *(long*)this_01 + 0x98 ) == TType::getArraySizes) {
                                 lVar18 = *(long*)( this_01 + 0x60 );
                              }
 else {
                                 lVar18 = ( **(code**)( *(long*)this_01 + 0x98 ) )(this_01);
                              }

                              lVar18 = *(long*)( lVar18 + 8 );
                              if (lVar18 == 0) {
                                 iVar7 = 0;
                              }
 else {
                                 iVar7 = (int)( *(long*)( lVar18 + 0x10 ) - *(long*)( lVar18 + 8 ) >> 4 );
                              }

                              if (iVar6 != iVar7) {
                                 pcVar27 = *(code**)( *(long*)this + 0x158 );
                                 UNRECOVERED_JUMPTABLE = *(code**)( *(long*)*plVar17 + 0x30 );
                                 if (UNRECOVERED_JUMPTABLE == TType::getFieldName_abi_cxx11_) {
                                    lVar18 = ( (long*)*plVar17 )[0xe];
                                 }
 else {
                                    lVar18 = ( *UNRECOVERED_JUMPTABLE )();
                                 }

                                 uVar20 = *(undefined8*)( lVar18 + 8 );
                                 pcVar23 = "cannot change arrayness of redeclared block member";
                                 goto LAB_00138303;
                              }

                              lVar18 = *(long*)this_01;
                              if (*(code**)( lVar18 + 0xf8 ) == TType::isUnsizedArray) {
                                 if (*(code**)( lVar18 + 0xe8 ) == TType::isArray) {
                                    lVar14 = *(long*)( this_01 + 0x60 );
                                    if (lVar14 != 0) {
                                       LAB_00138b0a:if (**(int**)( *(long*)( lVar14 + 8 ) + 8 ) == 0) goto LAB_00138d81;
                                    }

                                 }
 else {
                                    cVar5 = ( **(code**)( lVar18 + 0xe8 ) )(this_01);
                                    if (cVar5 != '\0') {
                                       lVar14 = *(long*)( this_01 + 0x60 );
                                       lVar18 = *(long*)this_01;
                                       goto LAB_00138b0a;
                                    }

                                    lVar18 = *(long*)this_01;
                                 }

                                 LAB_00138b1e:if (*(code**)( lVar18 + 0x78 ) == TType::getOuterArraySize) {
                                    iVar6 = **(int**)( *(long*)( *(long*)( this_01 + 0x60 ) + 8 ) + 8 );
                                 }
 else {
                                    iVar6 = ( **(code**)( lVar18 + 0x78 ) )(this_01);
                                 }

                                 if (iVar6 != *(int*)( this + 0x72c )) {
                                    ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "mesh view output array size must be gl_MaxMeshViewCountNV or implicitly sized", &_LC38, &_LC1);
                                    lVar18 = *(long*)pTVar11;
                                    goto LAB_00137979;
                                 }

                                 lVar18 = *(long*)this_01;
                              }
 else {
                                 cVar5 = ( **(code**)( lVar18 + 0xf8 ) )(this_01);
                                 lVar18 = *(long*)this_01;
                                 if (cVar5 == '\0') goto LAB_00138b1e;
                              }

                              LAB_00138d81:if (*(code**)( lVar18 + 0x98 ) == TType::getArraySizes) {
                                 lVar18 = *(long*)( this_01 + 0x60 );
                              }
 else {
                                 lVar18 = ( **(code**)( lVar18 + 0x98 ) )(this_01);
                              }

                              lVar18 = *(long*)( lVar18 + 8 );
                              if (( lVar18 == 0 ) || ( (int)( *(long*)( lVar18 + 0x10 ) - *(long*)( lVar18 + 8 ) >> 4 ) != 2 )) {
                                 lVar18 = *(long*)pTVar11;
                              }
 else {
                                 if (*(code**)( *(long*)this_01 + 0x98 ) == TType::getArraySizes) {
                                    lVar18 = *(long*)( this_01 + 0x60 );
                                 }
 else {
                                    lVar18 = ( **(code**)( *(long*)this_01 + 0x98 ) )(this_01);
                                 }

                                 iVar6 = *(int*)( *(long*)( *(long*)( lVar18 + 8 ) + 8 ) + 0x10 );
                                 UNRECOVERED_JUMPTABLE = *(code**)( *(long*)*plVar17 + 0x30 );
                                 if (UNRECOVERED_JUMPTABLE == TType::getFieldName_abi_cxx11_) {
                                    pbVar19 = (basic_string*)( (long*)*plVar17 )[0xe];
                                 }
 else {
                                    pbVar19 = (basic_string*)( *UNRECOVERED_JUMPTABLE )();
                                 }

                                 arrayLimitCheck(this, (TSourceLoc*)&local_58, pbVar19, iVar6);
                                 lVar18 = *(long*)pTVar11;
                                 if (*(code**)( lVar18 + 0xa0 ) == TType::getArraySizes) {
                                    lVar14 = *(long*)( pTVar11 + 0x60 );
                                 }
 else {
                                    lVar14 = ( **(code**)( lVar18 + 0xa0 ) )(pTVar11);
                                    lVar18 = *(long*)pTVar11;
                                 }

                                 *(int*)( *(long*)( *(long*)( lVar14 + 8 ) + 8 ) + 0x10 ) = iVar6;
                              }

                           }

                           goto LAB_00137979;
                        }

                        pcVar27 = *(code**)( *(long*)this + 0x158 );
                        UNRECOVERED_JUMPTABLE = *(code**)( *(long*)*plVar17 + 0x30 );
                        if (UNRECOVERED_JUMPTABLE == TType::getFieldName_abi_cxx11_) {
                           lVar18 = ( (long*)*plVar17 )[0xe];
                        }
 else {
                           lVar18 = ( *UNRECOVERED_JUMPTABLE )();
                        }

                        uVar20 = *(undefined8*)( lVar18 + 8 );
                        pcVar23 = "missing perviewNV qualifier to redeclared block member";
                        LAB_00138303:( *pcVar27 )(this, &local_58, pcVar23, uVar20, &_LC1);
                        LAB_0013830d:UNRECOVERED_JUMPTABLE = *(code**)( *(long*)pTVar11 + 0x50 );
                        if (UNRECOVERED_JUMPTABLE != TType::getQualifier) goto LAB_0013832e;
                        LAB_0013798a:if (( (byte)pTVar11[0x1d] & 2 ) == 0) {
                           UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this_01 + 0x58 );
                           goto LAB_0013799d;
                        }

                        LAB_00138340:pTVar16 = this_01 + 0x10;
                        if (*(code**)( *(long*)this_01 + 0x58 ) != TType::getQualifier) {
                           pTVar16 = (TType*)( **(code**)( *(long*)this_01 + 0x58 ) )(this_01);
                        }

                        if (( (byte)pTVar16[0xd] & 2 ) != 0) goto LAB_00138530;
                        UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                        pcVar27 = *(code**)( *(long*)*plVar17 + 0x30 );
                        if (pcVar27 == TType::getFieldName_abi_cxx11_) {
                           lVar18 = ( (long*)*plVar17 )[0xe];
                        }
 else {
                           lVar18 = ( *pcVar27 )();
                        }

                        ( *UNRECOVERED_JUMPTABLE )(this, &local_58, "missing perprimitiveNV qualifier to redeclared block member", *(undefined8*)( lVar18 + 8 ), &_LC1);
                        UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this_01 + 0x58 );
                        if (UNRECOVERED_JUMPTABLE == TType::getQualifier) goto LAB_00137a04;
                        LAB_001383b7:pTVar16 = (TType*)( *UNRECOVERED_JUMPTABLE )(this_01);
                     }

                     TVar4 = pTVar16[0xe];
                     if (( ( ( ( ( (char)TVar4 < '\0' ) || ( ( (byte)TVar4 & 0x40 ) != 0 ) ) || ( ( (byte)TVar4 & 0x20 ) != 0 ) ) || ( ( ( (byte)TVar4 & 0x10 ) != 0 || ( ( (byte)TVar4 & 8 ) != 0 ) ) ) ) || ( ( (byte)TVar4 & 2 ) != 0 ) ) || ( ( ( ( (byte)TVar4 & 4 ) != 0 || ( ( (byte)pTVar16[0xd] & 0x40 ) != 0 ) ) || ( ( (char)pTVar16[0xd] < '\0' || ( ( ( (byte)TVar4 & 1 ) != 0 || ( ( (byte)pTVar16[0xf] & 1 ) != 0 ) ) ) ) ) ) )) {
                        UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                        pcVar27 = *(code**)( *(long*)*plVar17 + 0x30 );
                        if (pcVar27 == TType::getFieldName_abi_cxx11_) {
                           lVar18 = ( (long*)*plVar17 )[0xe];
                        }
 else {
                           lVar18 = ( *pcVar27 )();
                        }

                        ( *UNRECOVERED_JUMPTABLE )(this, &local_58, "cannot add memory qualifier to redeclared block member", *(undefined8*)( lVar18 + 8 ), &_LC1);
                     }

                     if (*(code**)( *(long*)this_01 + 0x58 ) == TType::getQualifier) {
                        pTVar16 = this_01 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)this_01 + 0x58 ) )(this_01);
                     }

                     if (( ( ( ( ( ( (byte)pTVar16[0xf] & 0x70 ) != 0 ) || ( ( (byte)pTVar16[0x10] & 0xf ) != 0 ) ) || ( *(int*)( pTVar16 + 0x14 ) != -1 ) ) || ( ( *(short*)( pTVar16 + 0x20 ) != -1 || ( ( *(uint*)( pTVar16 + 0x1c ) & 0x3f8000 ) != 0x1f8000 ) ) ) ) || ( ( ( *(int*)( pTVar16 + 0x18 ) != -1 || ( ( ( ~*(ushort *)(pTVar16 + 0x1c) & 0xfff ) != 0 || ( ( (byte)pTVar16[0x1d] & 0x70 ) != 0x40 ) ) ) ) || ( pTVar16[0x22] != (TType)0xff ) ) ) ) || ( ( ( ( pTVar16[0x23] != (TType)0xff || ( pTVar16[0x2c] != (TType)0x0 ) ) || ( pTVar16[0x38] != (TType)0x0 ) ) || ( ( pTVar16[0x2d] != (TType)0x0 || ( pTVar16[0x2e] != (TType)0x0 ) ) ) ) )) {
                        UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                        pcVar27 = *(code**)( *(long*)*plVar17 + 0x30 );
                        if (pcVar27 == TType::getFieldName_abi_cxx11_) {
                           lVar18 = ( (long*)*plVar17 )[0xe];
                        }
 else {
                           lVar18 = ( *pcVar27 )();
                        }

                        ( *UNRECOVERED_JUMPTABLE )(this, &local_58, "cannot add non-XFB layout to redeclared block member", *(undefined8*)( lVar18 + 8 ), &_LC1);
                     }

                     lVar18 = *(long*)this_01;
                     if (*(code**)( lVar18 + 0x58 ) == TType::getQualifier) {
                        if (( (byte)this_01[0x1d] & 0x10 ) != 0) {
                           LAB_00137afe:UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
                           pcVar27 = *(code**)( *(long*)*plVar17 + 0x30 );
                           if (pcVar27 == TType::getFieldName_abi_cxx11_) {
                              lVar18 = ( (long*)*plVar17 )[0xe];
                           }
 else {
                              lVar18 = ( *pcVar27 )();
                           }

                           ( *UNRECOVERED_JUMPTABLE )(this, &local_58, "cannot add patch to redeclared block member", *(undefined8*)( lVar18 + 8 ), &_LC1);
                           goto LAB_00137b45;
                        }

                        LAB_00137b56:TVar4 = this_01[0x34];
                        if (( ~(byte)TVar4 & 0xf ) == 0) goto LAB_00137baf;
                        LAB_00137b63:if (( (byte)this[0x534] & 0xf ) != ( (byte)TVar4 & 0xf )) {
                           LAB_00137b80:( **(code**)( *(long*)this + 0x158 ) )(this, &local_58, "member cannot contradict block (or what block inherited from global)", "xfb_buffer", &_LC1);
                           lVar18 = *(long*)this_01;
                           goto LAB_00137baf;
                        }

                        LAB_00137bbc:TVar4 = this_01[0x33];
                        if (TVar4 == (TType)0xff) goto LAB_00137c00;
                        LAB_00137bc4:if (*(TType*)( this + 0x533 ) != TVar4) {
                           LAB_00137bd1:( **(code**)( *(long*)this + 0x158 ) )(this, &local_58, "member cannot contradict block (or what block inherited from global)", "xfb_stream", &_LC1);
                           lVar18 = *(long*)this_01;
                           goto LAB_00137c00;
                        }

                        LAB_00137c0d:pTVar16 = this_01 + 0x10;
                     }
 else {
                        lVar18 = ( **(code**)( lVar18 + 0x58 ) )(this_01);
                        if (( *(byte*)( lVar18 + 0xd ) & 0x10 ) != 0) goto LAB_00137afe;
                        LAB_00137b45:lVar18 = *(long*)this_01;
                        if (*(code**)( lVar18 + 0x58 ) == TType::getQualifier) goto LAB_00137b56;
                        lVar14 = ( **(code**)( lVar18 + 0x58 ) )(this_01);
                        lVar18 = *(long*)this_01;
                        if (( ~*(byte *)(lVar14 + 0x24) & 0xf ) != 0) {
                           if (*(code**)( lVar18 + 0x58 ) == TType::getQualifier) {
                              TVar4 = this_01[0x34];
                              goto LAB_00137b63;
                           }

                           lVar18 = ( **(code**)( lVar18 + 0x58 ) )(this_01);
                           if (( *(byte*)( lVar18 + 0x24 ) & 0xf ) == ( (byte)this[0x534] & 0xf )) {
                              lVar18 = *(long*)this_01;
                              goto LAB_00137baf;
                           }

                           goto LAB_00137b80;
                        }

                        LAB_00137baf:if (*(code**)( lVar18 + 0x58 ) == TType::getQualifier) goto LAB_00137bbc;
                        lVar18 = ( **(code**)( lVar18 + 0x58 ) )(this_01);
                        if (*(char*)( lVar18 + 0x23 ) != -1) {
                           if (*(code**)( *(long*)this_01 + 0x58 ) == TType::getQualifier) {
                              TVar4 = this_01[0x33];
                              goto LAB_00137bc4;
                           }

                           lVar18 = ( **(code**)( *(long*)this_01 + 0x58 ) )(this_01);
                           if (*(TParseContext*)( lVar18 + 0x23 ) == this[0x533]) goto LAB_00138907;
                           goto LAB_00137bd1;
                        }

                        LAB_00138907:lVar18 = *(long*)this_01;
                        LAB_00137c00:if (*(code**)( lVar18 + 0x58 ) == TType::getQualifier) goto LAB_00137c0d;
                        pTVar16 = (TType*)( **(code**)( lVar18 + 0x58 ) )(this_01);
                     }

                     TVar4 = pTVar16[0xb];
                     if (*(code**)( *(long*)pTVar11 + 0x50 ) == TType::getQualifier) {
                        pTVar16 = pTVar11 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)pTVar11 + 0x50 ) )(pTVar11);
                     }

                     pTVar16[0xb] = ( TType )(( byte )(( (byte)TVar4 >> 5 & 1 ) << 5) | (byte)pTVar16[0xb] & 0xdf);
                     if (*(code**)( *(long*)this_01 + 0x58 ) == TType::getQualifier) {
                        pTVar16 = this_01 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)this_01 + 0x58 ) )(this_01);
                     }

                     TVar4 = pTVar16[0xd];
                     if (*(code**)( *(long*)pTVar11 + 0x50 ) == TType::getQualifier) {
                        pTVar16 = pTVar11 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)pTVar11 + 0x50 ) )(pTVar11);
                     }

                     pTVar16[0xd] = ( TType )(( byte )(( (byte)TVar4 >> 5 & 1 ) << 5) | (byte)pTVar16[0xd] & 0xdf);
                     if (*(code**)( *(long*)this_01 + 0x58 ) == TType::getQualifier) {
                        pTVar16 = this_01 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)this_01 + 0x58 ) )(this_01);
                     }

                     TVar4 = pTVar16[0xb];
                     if (*(code**)( *(long*)pTVar11 + 0x50 ) == TType::getQualifier) {
                        pTVar16 = pTVar11 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)pTVar11 + 0x50 ) )(pTVar11);
                     }

                     pTVar16[0xb] = ( TType )(( byte )(( (byte)TVar4 >> 4 & 1 ) << 4) | (byte)pTVar16[0xb] & 0xef);
                     if (*(code**)( *(long*)this_01 + 0x58 ) == TType::getQualifier) {
                        pTVar16 = this_01 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)this_01 + 0x58 ) )(this_01);
                     }

                     TVar4 = pTVar16[0xc];
                     if (*(code**)( *(long*)pTVar11 + 0x50 ) == TType::getQualifier) {
                        pTVar16 = pTVar11 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)pTVar11 + 0x50 ) )(pTVar11);
                     }

                     pTVar16[0xc] = ( TType )(( byte )(( (byte)TVar4 >> 4 & 1 ) << 4) | (byte)pTVar16[0xc] & 0xef);
                     if (*(code**)( *(long*)this_01 + 0x58 ) == TType::getQualifier) {
                        pTVar16 = this_01 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)this_01 + 0x58 ) )(this_01);
                     }

                     TVar4 = pTVar16[0xb];
                     if (*(code**)( *(long*)pTVar11 + 0x50 ) == TType::getQualifier) {
                        pTVar16 = pTVar11 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)pTVar11 + 0x50 ) )(pTVar11);
                     }

                     pTVar16[0xb] = ( TType )(( byte )(( (byte)TVar4 >> 6 & 1 ) << 6) | (byte)pTVar16[0xb] & 0xbf);
                     if (*(code**)( *(long*)this_01 + 0x58 ) == TType::getQualifier) {
                        pTVar16 = this_01 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)this_01 + 0x58 ) )(this_01);
                     }

                     TVar4 = pTVar16[0xb];
                     if (*(code**)( *(long*)pTVar11 + 0x50 ) == TType::getQualifier) {
                        pTVar16 = pTVar11 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)pTVar11 + 0x50 ) )(pTVar11);
                     }

                     pTVar16[0xb] = ( TType )((byte)pTVar16[0xb] & 0x7f | (byte)TVar4 & 0x80);
                     if (*(code**)( *(long*)this_01 + 0x58 ) == TType::getQualifier) {
                        pTVar16 = this_01 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)this_01 + 0x58 ) )(this_01);
                     }

                     TVar4 = pTVar16[0xc];
                     if (*(code**)( *(long*)pTVar11 + 0x50 ) == TType::getQualifier) {
                        pTVar16 = pTVar11 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)pTVar11 + 0x50 ) )(pTVar11);
                     }

                     pTVar16[0xc] = ( TType )(( byte )(( (byte)TVar4 >> 5 & 1 ) << 5) | (byte)pTVar16[0xc] & 0xdf);
                     if (*(code**)( *(long*)this_01 + 0x58 ) == TType::getQualifier) {
                        pTVar16 = this_01 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)this_01 + 0x58 ) )(this_01);
                     }

                     uVar1 = *(ushort*)( pTVar16 + 0x26 );
                     if (*(code**)( *(long*)pTVar11 + 0x50 ) == TType::getQualifier) {
                        pTVar16 = pTVar11 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)pTVar11 + 0x50 ) )(pTVar11);
                     }

                     *(ushort*)( pTVar16 + 0x26 ) = ( uVar1 >> 2 & 0x1fff ) << 2 | *(ushort*)( pTVar16 + 0x26 ) & 0x8003;
                     if (*(code**)( *(long*)this_01 + 0x58 ) == TType::getQualifier) {
                        pTVar16 = this_01 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)this_01 + 0x58 ) )(this_01);
                     }

                     TVar4 = pTVar16[0x24];
                     if (*(code**)( *(long*)pTVar11 + 0x50 ) == TType::getQualifier) {
                        pTVar16 = pTVar11 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)pTVar11 + 0x50 ) )(pTVar11);
                     }

                     pTVar16[0x24] = ( TType )((byte)pTVar16[0x24] & 0xf0 | (byte)TVar4 & 0xf);
                     if (*(code**)( *(long*)this_01 + 0x58 ) == TType::getQualifier) {
                        pTVar16 = this_01 + 0x10;
                     }
 else {
                        pTVar16 = (TType*)( **(code**)( *(long*)this_01 + 0x58 ) )(this_01);
                     }

                     uVar8 = ( uint )(( ushort )(*(uint*)( pTVar16 + 0x24 ) >> 4) & 0x3fff);
                     if (*(code**)( *(long*)pTVar11 + 0x50 ) == TType::getQualifier) {
                        *(uint*)( pTVar11 + 0x34 ) = *(uint*)( pTVar11 + 0x34 ) & 0xfffc000f | uVar8 << 4;
                        LAB_00137ee5:pTVar16 = pTVar11 + 0x10;
                     }
 else {
                        lVar18 = ( **(code**)( *(long*)pTVar11 + 0x50 ) )(pTVar11);
                        UNRECOVERED_JUMPTABLE = *(code**)( *(long*)pTVar11 + 0x50 );
                        *(uint*)( lVar18 + 0x24 ) = uVar8 << 4 | *(uint*)( lVar18 + 0x24 ) & 0xfffc000f;
                        if (UNRECOVERED_JUMPTABLE == TType::getQualifier) goto LAB_00137ee5;
                        pTVar16 = (TType*)( *UNRECOVERED_JUMPTABLE )(pTVar11);
                     }

                     if (( *(ushort*)( pTVar16 + 0x26 ) & 0x7ffc ) == 0x3c) {
                        lVar18 = *(long*)pTVar11;
                     }
 else {
                        TVar25 = this[0x534];
                        if (*(code**)( *plVar26 + 0x50 ) == TType::getQualifier) {
                           plVar15 = plVar26 + 2;
                        }
 else {
                           plVar15 = (long*)( **(code**)( *plVar26 + 0x50 ) )(plVar26);
                        }

                        *(byte*)( (long)plVar15 + 0x24 ) = *(byte*)( (long)plVar15 + 0x24 ) & 0xf0 | (byte)TVar25 & 0xf;
                        lVar18 = *(long*)pTVar11;
                        TVar25 = this[0x534];
                        if (*(code**)( lVar18 + 0x50 ) == TType::getQualifier) {
                           pTVar16 = pTVar11 + 0x10;
                        }
 else {
                           pTVar16 = (TType*)( **(code**)( lVar18 + 0x50 ) )(pTVar11);
                           lVar18 = *(long*)pTVar11;
                        }

                        pTVar16[0x24] = ( TType )((byte)pTVar16[0x24] & 0xf0 | (byte)TVar25 & 0xf);
                     }

                     if (*(code**)( lVar18 + 0xf8 ) == TType::isUnsizedArray) {
                        if (*(code**)( lVar18 + 0xe8 ) == TType::isArray) {
                           lVar18 = *(long*)( pTVar11 + 0x60 );
                           if (lVar18 != 0) {
                              LAB_00137fb0:if (**(int**)( *(long*)( lVar18 + 8 ) + 8 ) == 0) goto LAB_00137fc4;
                           }

                        }
 else {
                           cVar5 = ( **(code**)( lVar18 + 0xe8 ) )(pTVar11);
                           if (cVar5 != '\0') {
                              lVar18 = *(long*)( pTVar11 + 0x60 );
                              goto LAB_00137fb0;
                           }

                        }

                     }
 else {
                        cVar5 = ( **(code**)( lVar18 + 0xf8 ) )(pTVar11);
                        if (cVar5 == '\0') goto LAB_00138048;
                        LAB_00137fc4:UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this_01 + 0xf0 );
                        if (UNRECOVERED_JUMPTABLE == TType::isSizedArray) {
                           UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this_01 + 0xe8 );
                           if (UNRECOVERED_JUMPTABLE == TType::isArray) {
                              lVar18 = *(long*)( this_01 + 0x60 );
                              if (lVar18 != 0) {
                                 LAB_00137ffd:if (**(int**)( *(long*)( lVar18 + 8 ) + 8 ) != 0) goto LAB_0013800d;
                              }

                           }
 else {
                              cVar5 = ( *UNRECOVERED_JUMPTABLE )(this_01);
                              if (cVar5 != '\0') {
                                 lVar18 = *(long*)( this_01 + 0x60 );
                                 goto LAB_00137ffd;
                              }

                           }

                        }
 else {
                           cVar5 = ( *UNRECOVERED_JUMPTABLE )(this_01);
                           if (cVar5 != '\0') {
                              LAB_0013800d:if (*(code**)( *(long*)this_01 + 0x78 ) == TType::getOuterArraySize) {
                                 uVar9 = **(undefined4**)( *(long*)( *(long*)( this_01 + 0x60 ) + 8 ) + 8 );
                              }
 else {
                                 uVar9 = ( **(code**)( *(long*)this_01 + 0x78 ) )(this_01);
                              }

                              lVar18 = *(long*)( pTVar11 + 0x60 );
                              **(undefined4**)( *(long*)( lVar18 + 8 ) + 8 ) = uVar9;
                              *(undefined1*)( lVar18 + 0x14 ) = 0;
                           }

                        }

                     }

                     LAB_00138048:plVar15 = plVar17 + 4;
                     local_80 = local_80 + 1;
                     layoutTypeCheck(this, param_1, pTVar11);
                     lVar18 = plVar26[0xd];
                     goto LAB_0013806d;
                  }

               }

               plVar15 = plVar15 + 4;
            }
 while ( *(long**)( param_2 + 0x10 ) != plVar15 );
         }

         plVar15 = plVar17 + 4;
         if (param_4 == (basic_string*)0x0) {
            plVar17 = (long*)*plVar17;
            if (*(code**)( *plVar17 + 0x10 ) == TType::hideMember) {
               *(ushort*)( plVar17 + 1 ) = *(ushort*)( plVar17 + 1 ) & 0xf000 | 0x100;
            }
 else {
               ( **(code**)( *plVar17 + 0x10 ) )();
            }

            lVar18 = plVar26[0xd];
         }
 else {
            lVar14 = plVar26[0xd];
            plVar22 = *(long**)( lVar14 + 0x10 );
            lVar18 = lVar14;
            if (plVar15 != plVar22) {
               sVar12 = (long)plVar22 - (long)plVar15;
               if ((long)sVar12 < 0x21) {
                  if (sVar12 == 0x20) {
                     *plVar17 = plVar17[4];
                     for (int i = 0; i < 3; i++) {
                        plVar17[( i + 1 )] = plVar17[( i + 5 )];
                     }

                  }

               }
 else {
                  memmove(plVar17, plVar15, sVar12);
                  plVar22 = *(long**)( lVar14 + 0x10 );
                  lVar18 = plVar26[0xd];
               }

            }

            *(long**)( lVar14 + 0x10 ) = plVar22 + -4;
            plVar15 = plVar17;
         }

         LAB_0013806d:plVar17 = plVar15;
      }
 while ( plVar15 != *(long**)( lVar18 + 0x10 ) );
   }

   if (0 < *(int*)( this + 0x28 )) {
      TVar25 = this[0x533];
      if (*(code**)( *plVar26 + 0x50 ) == TType::getQualifier) {
         plVar17 = plVar26 + 2;
      }
 else {
         plVar17 = (long*)( **(code**)( *plVar26 + 0x50 ) )(plVar26);
      }

      *(TParseContext*)( (long)plVar17 + 0x23 ) = TVar25;
   }

   if (local_80 < ( ulong )(*(long*)( param_2 + 0x10 ) - *(long*)( param_2 + 8 ) >> 5)) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "block redeclaration has extra members", *(undefined8*)( param_3 + 8 ), &_LC1);
   }

   lVar18 = *plVar26;
   bVar29 = param_5 != (TArraySizes*)0x0;
   if (*(code**)( lVar18 + 0xe8 ) == TType::isArray) {
      lVar14 = plVar26[0xc];
      bVar30 = lVar14 != 0;
      if (bVar29 == bVar30) {
         LAB_00138eaf:if (( !bVar30 ) || ( !bVar29 )) goto LAB_0013911d;
         LAB_00138ebf:if (*(code**)( lVar18 + 0xa0 ) == TType::getArraySizes) {
            lVar18 = plVar26[0xc];
         }
 else {
            lVar18 = ( **(code**)( lVar18 + 0xa0 ) )(plVar26);
         }

         lVar18 = *(long*)( lVar18 + 8 );
         lVar14 = *(long*)( param_5 + 8 );
         if (lVar18 == 0) {
            if (lVar14 == 0) goto LAB_00138f19;
            iVar6 = 0;
            LAB_00138f05:iVar7 = (int)( *(long*)( lVar14 + 0x10 ) - *(long*)( lVar14 + 8 ) >> 4 );
         }
 else {
            iVar6 = (int)( *(long*)( lVar18 + 0x10 ) - *(long*)( lVar18 + 8 ) >> 4 );
            if (lVar14 != 0) goto LAB_00138f05;
            iVar7 = 0;
         }

         if (iVar7 == iVar6) goto LAB_00138f19;
      }

      LAB_0013812e:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot change arrayness of redeclared block", *(undefined8*)( param_3 + 8 ), &_LC1);
   }
 else {
      cVar5 = ( **(code**)( lVar18 + 0xe8 ) )(plVar26);
      if (bVar29 != (bool)cVar5) goto LAB_0013812e;
      lVar18 = *plVar26;
      if (*(code**)( lVar18 + 0xe8 ) == TType::isArray) {
         lVar14 = plVar26[0xc];
         bVar30 = lVar14 != 0;
         goto LAB_00138eaf;
      }

      cVar5 = ( **(code**)( lVar18 + 0xe8 ) )(plVar26);
      if (( bVar29 ) && ( cVar5 != '\0' )) {
         lVar18 = *plVar26;
         goto LAB_00138ebf;
      }

      LAB_00138f19:lVar18 = *plVar26;
      if (*(code**)( lVar18 + 0xe8 ) == TType::isArray) {
         lVar14 = plVar26[0xc];
         LAB_0013911d:if (lVar14 != 0) goto LAB_00138f49;
      }
 else {
         cVar5 = ( **(code**)( lVar18 + 0xe8 ) )(plVar26);
         if (cVar5 != '\0') {
            lVar18 = *plVar26;
            LAB_00138f49:if (**(int**)( *(long*)( param_5 + 8 ) + 8 ) == 0) {
               if (*(code**)( lVar18 + 0xf0 ) != TType::isSizedArray) {
                  cVar5 = ( **(code**)( lVar18 + 0xf0 ) )(plVar26);
                  lVar18 = *plVar26;
                  if (cVar5 != '\0') {
                     LAB_00138f9f:if (*(code**)( lVar18 + 0x78 ) == TType::getOuterArraySize) {
                        uVar9 = **(undefined4**)( *(long*)( plVar26[0xc] + 8 ) + 8 );
                     }
 else {
                        uVar9 = ( **(code**)( lVar18 + 0x78 ) )(plVar26);
                        lVar18 = *plVar26;
                     }

                     **(undefined4**)( *(long*)( param_5 + 8 ) + 8 ) = uVar9;
                     param_5[0x14] = (TArraySizes)0x0;
                  }

                  goto LAB_00138fd4;
               }

               if (*(code**)( lVar18 + 0xe8 ) != TType::isArray) {
                  cVar5 = ( **(code**)( lVar18 + 0xe8 ) )(plVar26);
                  lVar18 = *plVar26;
                  if (( cVar5 != '\0' ) && ( **(int**)( *(long*)( plVar26[0xc] + 8 ) + 8 ) != 0 )) goto LAB_00138f9f;
                  goto LAB_00138fd4;
               }

               lVar14 = plVar26[0xc];
               if (lVar14 != 0) {
                  if (**(int**)( *(long*)( lVar14 + 8 ) + 8 ) != 0) goto LAB_00138f9f;
                  goto LAB_00138fe4;
               }

               LAB_00138ffd:if (lVar14 != 0) {
                  LAB_00139002:if (**(int**)( *(long*)( lVar14 + 8 ) + 8 ) != 0) goto LAB_00139035;
               }

               LAB_00139010:if (**(int**)( *(long*)( param_5 + 8 ) + 8 ) != 0) {
                  lVar14 = plVar26[0xc];
                  **(int**)( *(long*)( lVar14 + 8 ) + 8 ) = **(int**)( *(long*)( param_5 + 8 ) + 8 );
                  *(undefined1*)( lVar14 + 0x14 ) = 0;
               }

            }
 else {
               LAB_00138fd4:if (*(code**)( lVar18 + 0xf0 ) == TType::isSizedArray) {
                  LAB_00138fe4:if (*(code**)( lVar18 + 0xe8 ) == TType::isArray) {
                     lVar14 = plVar26[0xc];
                     goto LAB_00138ffd;
                  }

                  cVar5 = ( **(code**)( lVar18 + 0xe8 ) )(plVar26);
                  if (cVar5 == '\0') goto LAB_00139422;
                  lVar14 = plVar26[0xc];
                  lVar18 = *plVar26;
                  goto LAB_00139002;
               }

               cVar5 = ( **(code**)( lVar18 + 0xf0 ) )(plVar26);
               if (cVar5 == '\0') {
                  LAB_00139422:lVar18 = *plVar26;
                  goto LAB_00139010;
               }

               lVar18 = *plVar26;
            }

            LAB_00139035:if (*(code**)( lVar18 + 0xf0 ) == TType::isSizedArray) {
               if (*(code**)( lVar18 + 0xe8 ) == TType::isArray) {
                  lVar18 = plVar26[0xc];
                  if (lVar18 != 0) {
                     LAB_00139067:if (**(int**)( *(long*)( lVar18 + 8 ) + 8 ) != 0) goto LAB_00139079;
                  }

               }
 else {
                  cVar5 = ( **(code**)( lVar18 + 0xe8 ) )(plVar26);
                  if (cVar5 != '\0') {
                     lVar18 = plVar26[0xc];
                     goto LAB_00139067;
                  }

               }

            }
 else {
               cVar5 = ( **(code**)( lVar18 + 0xf0 ) )(plVar26);
               if (cVar5 != '\0') {
                  LAB_00139079:if (*(code**)( *plVar26 + 0xa0 ) == TType::getArraySizes) {
                     lVar18 = plVar26[0xc];
                  }
 else {
                     lVar18 = ( **(code**)( *plVar26 + 0xa0 ) )(plVar26);
                  }

                  cVar5 = TSmallArrayVector::operator ==(*(TSmallArrayVector**)( lVar18 + 8 ), *(TSmallArrayVector**)( param_5 + 8 ));
                  if (cVar5 == '\0') {
                     ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot change array size of redeclared block", *(undefined8*)( param_3 + 8 ), &_LC1);
                  }

               }

            }

         }

      }

   }

   TSymbolTable::insert(*(TSymbolTable**)( this + 0xe8 ), pTVar10);
   layoutObjectCheck(this, param_1, pTVar10);
   pTVar11 = (TType*)( **(code**)( *(long*)pTVar10 + 0x60 ) )(pTVar10);
   cVar5 = isIoResizeArray(this, pTVar11);
   if (cVar5 == '\0') {
      plVar26 = (long*)( **(code**)( *(long*)pTVar10 + 0x60 ) )(pTVar10);
      if (*(code**)( *plVar26 + 0xe8 ) == TType::isArray) {
         if (plVar26[0xc] != 0) {
            LAB_001381ff:pTVar11 = (TType*)( **(code**)( *(long*)pTVar10 + 0x68 ) )(pTVar10);
            fixIoArraySize(this, param_1, pTVar11);
         }

      }
 else {
         cVar5 = ( **(code**)( *plVar26 + 0xe8 ) )(plVar26);
         if (cVar5 != '\0') goto LAB_001381ff;
      }

   }
 else {
      puVar3 = *(undefined8**)( this + 0x7608 );
      if (puVar3 == *(undefined8**)( this + 0x7610 )) {
         std::vector<glslang::TSymbol*,glslang::pool_allocator<glslang::TSymbol*>>::_M_realloc_insert<glslang::TSymbol*const&>((vector<glslang::TSymbol*,glslang::pool_allocator<glslang::TSymbol*>>*)( this + 0x75f8 ), puVar3, &local_60);
      }
 else {
         *puVar3 = pTVar10;
         *(undefined8**)( this + 0x7608 ) = puVar3 + 1;
      }

      checkIoArraysConsistency(this, param_1, true);
   }

   if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      /* WARNING: Could not recover jumptable at 0x001381f4. Too many branches */
      /* WARNING: Treating indirect jump as call */
      ( **(code**)( *(long*)this + 600 ) )(this, pTVar10);
      return;
   }

   LAB_00139520:/* WARNING: Subroutine does not return */__stack_chk_fail();
}
/* glslang::TParseContext::handleLengthMethod(glslang::TSourceLoc const&, glslang::TFunction*,
   TIntermNode*) */long glslang::TParseContext::handleLengthMethod(TParseContext *this, TSourceLoc *param_1, TFunction *param_2, TIntermNode *param_3) {
   ulong uVar1;
   char cVar2;
   bool bVar3;
   byte bVar4;
   int iVar5;
   int iVar6;
   uint uVar7;
   long lVar8;
   long *plVar9;
   TIntermTyped *pTVar10;
   long lVar11;
   TType *pTVar12;
   code *pcVar13;
   basic_string *pbVar14;
   TQualifier *pTVar15;
   undefined8 uVar16;
   TSourceLoc *pTVar17;
   char *pcVar18;
   long in_FS_OFFSET;
   undefined **local_d8;
   uint local_d0;
   undefined8 local_c8;
   ulong local_c0;
   byte local_b8;
   undefined8 local_b4;
   undefined1 uStack_ac;
   uint7 local_ab;
   undefined4 uStack_a4;
   undefined4 local_a0;
   undefined4 uStack_9c;
   undefined1 local_98;
   undefined8 local_94;
   undefined4 local_8c;
   undefined8 local_88;
   undefined2 local_80;
   undefined1 local_78[16];
   undefined1 local_68[16];
   uint local_58;
   undefined1 local_50[16];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(code**)( *(long*)param_2 + 0x120 ) == TFunction::getParamCount) {
      iVar5 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
   }
 else {
      iVar5 = ( **(code**)( *(long*)param_2 + 0x120 ) )(param_2);
   }

   if (iVar5 < 1) {
      plVar9 = (long*)( **(code**)( *(long*)param_3 + 0x18 ) )(param_3);
      if (*(code**)( *plVar9 + 0xf0 ) == TIntermTyped::getType) {
         pTVar12 = (TType*)( plVar9 + 4 );
      }
 else {
         pTVar12 = (TType*)( **(code**)( *plVar9 + 0xf0 ) )();
      }

      lVar8 = *(long*)pTVar12;
      if (*(code**)( lVar8 + 0xe8 ) == TType::isArray) {
         if (*(long*)( pTVar12 + 0x60 ) == 0) {
            LAB_00139720:if (*(code**)( lVar8 + 0xe0 ) == TType::isMatrix) {
               if ((byte)pTVar12[9] < 0x10) goto LAB_00139950;
               LAB_00139742:pcVar13 = *(code**)( lVar8 + 0x68 );
               if (pcVar13 != TType::getMatrixCols) goto LAB_00139bb0;
               pTVar17 = (TSourceLoc*)( ulong )((byte)pTVar12[9] >> 4);
            }
 else {
               cVar2 = ( **(code**)( lVar8 + 0xe0 ) )(pTVar12);
               lVar8 = *(long*)pTVar12;
               if (cVar2 != '\0') goto LAB_00139742;
               LAB_00139950:if (*(code**)( lVar8 + 0xd8 ) != TType::isVector) {
                  bVar4 = ( **(code**)( lVar8 + 0xd8 ) )(pTVar12);
                  LAB_00139b63:if (bVar4 != 0) {
                     lVar8 = *(long*)pTVar12;
                     goto LAB_00139977;
                  }

                  if (( ( (byte)pTVar12[10] & 0x20 ) == 0 ) && ( ( (byte)pTVar12[10] & 0x40 ) == 0 )) {
                     ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, ".length()", "unexpected use of .length()", &_LC1);
                     goto LAB_001395ec;
                  }

                  LAB_001399f0:local_d8 = &PTR__TType_00167f00;
                  local_58 = local_58 & 0x9fc00000;
                  local_b8 = local_b8 & 0xf0;
                  local_d0 = local_d0 & 0xf8000000 | 0x108;
                  local_98 = 0;
                  local_94 = 0xfffff800;
                  local_80 = 0;
                  local_8c = 0xffffffff;
                  local_c8 = 0;
                  local_50 = (undefined1[16])0x0;
                  local_78 = (undefined1[16])0x0;
                  uStack_9c = 0;
                  local_ab = local_ab & 0xffc000 | 0xffffffff001fcf;
                  local_68 = (undefined1[16])0x0;
                  uStack_ac = 0xff;
                  local_b4 = 0xffffffffffffffff;
                  uVar1 = CONCAT44(local_a0, uStack_a4) & 0xfe07ff00ffffffff | 0x1ffffff7fffffff;
                  uStack_a4 = (undefined4)uVar1;
                  local_a0 = ( undefined4 )(uVar1 >> 0x20);
                  local_88 = 0;
                  local_c0 = local_c0 & 0x8000000400000000;
                  lVar11 = glslang::TIntermediate::addBuiltInFunctionCall(*(undefined8*)( this + 0x38 ), param_1, 600, 1, param_3, &local_d8);
                  goto LAB_001396e5;
               }

               if (( (byte)pTVar12[9] & 0xf ) < 2) {
                  bVar4 = (byte)pTVar12[10] >> 4 & 1;
                  goto LAB_00139b63;
               }

               LAB_00139977:pcVar13 = *(code**)( lVar8 + 0x60 );
               if (pcVar13 != TType::getVectorSize) goto LAB_00139bb0;
               pTVar17 = (TSourceLoc*)( ulong )((byte)pTVar12[9] & 0xf);
            }

            goto LAB_00139763;
         }

         pcVar13 = *(code**)( lVar8 + 0xf8 );
         if (pcVar13 == TType::isUnsizedArray) {
            LAB_00139697:lVar11 = *(long*)( pTVar12 + 0x60 );
            if (lVar11 == 0) goto LAB_001396b5;
            LAB_001396a0:if (**(int**)( *(long*)( lVar11 + 8 ) + 8 ) != 0) goto LAB_001396b2;
         }
 else {
            LAB_00139790:cVar2 = ( *pcVar13 )(pTVar12);
            if (cVar2 == '\0') goto LAB_001396b2;
         }

         lVar8 = ( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
         if (( lVar8 == 0 ) || ( cVar2 = isIoResizeArray(this, pTVar12) ),cVar2 == '\0') {
            plVar9 = (long*)( **(code**)( *(long*)param_3 + 0x18 ) )(param_3);
            if (plVar9 != (long*)0x0) {
               if (*(code**)( *plVar9 + 0x108 ) == TIntermTyped::getQualifier) {
                  plVar9 = plVar9 + 6;
               }
 else {
                  plVar9 = (long*)( **(code**)( *plVar9 + 0x108 ) )(plVar9);
               }

               if (( *(ushort*)( plVar9 + 1 ) & 0xff80 ) == 0x2380) {
                  glslang::TParseVersions::requireProfile((TSourceLoc*)this, (int)param_1, &DAT_00000008);
                  iVar6 = *(int*)( this + 0x708 ) + 0x1f;
                  iVar5 = *(int*)( this + 0x708 ) + 0x3e;
                  if (-1 < iVar6) {
                     iVar5 = iVar6;
                  }

                  uVar7 = iVar5 >> 5;
                  goto LAB_001398c3;
               }

            }

            LAB_001398cb:lVar8 = ( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
            if (( lVar8 == 0 ) || ( cVar2 = isIoResizeArray(this, pTVar12) ),cVar2 == '\0') {
               pTVar10 = (TIntermTyped*)( **(code**)( *(long*)param_3 + 0x18 ) )(param_3);
               cVar2 = isRuntimeLength(this, pTVar10);
               if (cVar2 != '\0') goto LAB_001399f0;
               pcVar13 = *(code**)( *(long*)this + 0x158 );
               if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                  lVar8 = *(long*)( param_2 + 8 );
               }
 else {
                  lVar8 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
               }

               uVar16 = *(undefined8*)( lVar8 + 8 );
               pcVar18 = "array must be declared with a size before using this method";
            }
 else {
               pcVar13 = *(code**)( *(long*)this + 0x158 );
               if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                  lVar8 = *(long*)( param_2 + 8 );
               }
 else {
                  lVar8 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
               }

               uVar16 = *(undefined8*)( lVar8 + 8 );
               pcVar18 = "array must first be sized by a redeclaration or layout qualifier";
            }

            ( *pcVar13 )(this, param_1, &_LC1, uVar16, pcVar18);
            goto LAB_001395ec;
         }

         plVar9 = (long*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
         if (*(code**)( *plVar9 + 400 ) == TIntermSymbol::getName_abi_cxx11_) {
            pbVar14 = (basic_string*)( plVar9 + 0x19 );
         }
 else {
            pbVar14 = (basic_string*)( **(code**)( *plVar9 + 400 ) )();
         }

         lVar8 = *(long*)( pbVar14 + 0x10 );
         if (lVar8 == 5) {
            if (( **(int**)( pbVar14 + 8 ) != 0x695f6c67 ) || ( (char)( *(int**)( pbVar14 + 8 ) )[1] != 'n' )) goto LAB_00139819;
         }
 else if (lVar8 == 6) {
            if (( **(int**)( pbVar14 + 8 ) != 0x6f5f6c67 ) || ( (short)( *(int**)( pbVar14 + 8 ) )[1] != 0x7475 )) {
               LAB_00139819:bVar3 = std::operator ==(pbVar14, "gl_MeshPrimitivesNV");
               if (!bVar3) goto LAB_001398cb;
            }

         }
 else if (( ( lVar8 != 0x11 ) || ( plVar9 = *(long**)( pbVar14 + 8 ) * plVar9 != 0x566873654d5f6c67 || plVar9[1] != 0x4e73656369747265 ) ) || ( (char)plVar9[2] != 'V' )) goto LAB_00139819;
         if (*(code**)( *(long*)pTVar12 + 0x58 ) == TType::getQualifier) {
            pTVar15 = (TQualifier*)( pTVar12 + 0x10 );
         }
 else {
            pTVar15 = (TQualifier*)( **(code**)( *(long*)pTVar12 + 0x58 ) )(pTVar12);
         }

         uVar7 = getIoArrayImplicitSize(this, pTVar15, (basic_string*)0x0);
         LAB_001398c3:pTVar17 = (TSourceLoc*)(ulong)uVar7;
         if (uVar7 == 0) goto LAB_001398cb;
      }
 else {
         cVar2 = ( **(code**)( lVar8 + 0xe8 ) )(pTVar12);
         lVar8 = *(long*)pTVar12;
         if (cVar2 == '\0') goto LAB_00139720;
         pcVar13 = *(code**)( lVar8 + 0xf8 );
         if (pcVar13 != TType::isUnsizedArray) goto LAB_00139790;
         if (*(code**)( lVar8 + 0xe8 ) == TType::isArray) goto LAB_00139697;
         cVar2 = ( **(code**)( lVar8 + 0xe8 ) )(pTVar12);
         if (cVar2 != '\0') {
            lVar11 = *(long*)( pTVar12 + 0x60 );
            goto LAB_001396a0;
         }

         LAB_001396b2:lVar8 = *(long*)pTVar12;
         LAB_001396b5:if (*(code**)( lVar8 + 0x80 ) != TType::getOuterArrayNode) {
            lVar8 = ( **(code**)( lVar8 + 0x80 ) )(pTVar12);
            if (lVar8 == 0) {
               lVar8 = *(long*)pTVar12;
               goto LAB_00139bd0;
            }

            if (*(code**)( *(long*)pTVar12 + 0x80 ) != TType::getOuterArrayNode) {
               if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                  /* WARNING: Could not recover jumptable at 0x00139c40. Too many branches */
                  /* WARNING: Treating indirect jump as call */
                  lVar8 = ( **(code**)( *(long*)pTVar12 + 0x80 ) )(pTVar12);
                  return lVar8;
               }

               goto LAB_00139d00;
            }

            lVar11 = *(long*)( *(long*)( *(long*)( *(long*)( pTVar12 + 0x60 ) + 8 ) + 8 ) + 8 );
            LAB_001396e5:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
               return lVar11;
            }

            goto LAB_00139d00;
         }

         lVar11 = *(long*)( *(long*)( *(long*)( *(long*)( pTVar12 + 0x60 ) + 8 ) + 8 ) + 8 );
         if (lVar11 != 0) goto LAB_001396e5;
         LAB_00139bd0:pcVar13 = *(code**)( lVar8 + 0x78 );
         if (pcVar13 == TType::getOuterArraySize) {
            pTVar17 = (TSourceLoc*)( ulong ) * *(uint**)( *(long*)( *(long*)( pTVar12 + 0x60 ) + 8 ) + 8 );
            goto LAB_00139763;
         }

         LAB_00139bb0:uVar7 = ( *pcVar13 )(pTVar12);
         pTVar17 = (TSourceLoc*)(ulong)uVar7;
         LAB_00139763:if ((int)pTVar17 == 0) goto LAB_001395ec;
      }

   }
 else {
      pcVar13 = *(code**)( *(long*)this + 0x158 );
      if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
         lVar8 = *(long*)( param_2 + 8 );
      }
 else {
         lVar8 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
      }

      ( *pcVar13 )(this, param_1, "method does not accept any arguments", *(undefined8*)( lVar8 + 8 ), &_LC1);
      LAB_001395ec:pTVar17 = (TSourceLoc*)0x1;
   }

   if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      lVar8 = glslang::TIntermediate::addConstantUnion((int)*(undefined8*)( this + 0x38 ), pTVar17, SUB81(param_1, 0));
      return lVar8;
   }

   LAB_00139d00:/* WARNING: Subroutine does not return */__stack_chk_fail();
}
/* glslang::TParseContext::addSwitch(glslang::TSourceLoc const&, glslang::TIntermTyped*,
   glslang::TIntermAggregate*) */TIntermTyped * __thiscall
glslang::TParseContext::addSwitch
          (TParseContext *this,TSourceLoc *param_1,TIntermTyped *param_2,TIntermAggregate *param_3){
   vector<TIntermNode*,glslang::pool_allocator<TIntermNode*>> *this_00;
   long *plVar1;
   undefined8 uVar2;
   TIntermNode *pTVar3;
   undefined8 uVar4;
   char cVar5;
   byte bVar6;
   int iVar7;
   uint uVar8;
   ulong uVar9;
   long *plVar10;
   long lVar11;
   long lVar12;
   TIntermTyped *pTVar13;
   size_t __n;
   ulong uVar14;
   undefined8 *puVar15;
   undefined8 *__dest;
   long lVar16;
   undefined8 *puVar17;
   long in_FS_OFFSET;
   TIntermNode *local_48;
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   glslang::TParseVersions::profileRequires((TSourceLoc*)this, (int)param_1, 8, (char*)0x12c, (char*)0x0);
   glslang::TParseVersions::profileRequires((TSourceLoc*)this, (int)param_1, 1, (char*)0x82, (char*)0x0);
   wrapupSwitchSubsequence(this, param_3, (TIntermNode*)0x0);
   if (param_2 == (TIntermTyped*)0x0) {
      LAB_00139dc9:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "condition must be a scalar integer expression", "switch", &_LC1);
   }
 else {
      lVar11 = *(long*)param_2;
      if (*(code**)( lVar11 + 0x100 ) == TIntermTyped::getBasicType) {
         uVar8 = (uint)(byte)param_2[0x28];
         if (param_2[0x28] != (TIntermTyped)0x8) {
            LAB_00139dc0:if (uVar8 != 9) goto LAB_00139dc9;
            goto LAB_0013a160;
         }

      }
 else {
         iVar7 = ( **(code**)( lVar11 + 0x100 ) )(param_2);
         if (iVar7 != 8) {
            if (*(code**)( *(long*)param_2 + 0x100 ) == TIntermTyped::getBasicType) {
               uVar8 = (uint)(byte)param_2[0x28];
            }
 else {
               uVar8 = ( **(code**)( *(long*)param_2 + 0x100 ) )(param_2);
            }

            goto LAB_00139dc0;
         }

         LAB_0013a160:lVar11 = *(long*)param_2;
      }

      if (*(code**)( lVar11 + 0xf0 ) == TIntermTyped::getType) {
         pTVar13 = param_2 + 0x20;
      }
 else {
         pTVar13 = (TIntermTyped*)( **(code**)( lVar11 + 0xf0 ) )(param_2);
      }

      if (*(code**)( *(long*)pTVar13 + 0xe8 ) != TType::isArray) {
         cVar5 = ( **(code**)( *(long*)pTVar13 + 0xe8 ) )();
         if (cVar5 == '\0') goto LAB_0013a1a4;
         goto LAB_00139dc9;
      }

      if (*(long*)( pTVar13 + 0x60 ) != 0) goto LAB_00139dc9;
      LAB_0013a1a4:pTVar13 = param_2 + 0x20;
      if (*(code**)( *(long*)param_2 + 0xf0 ) != TIntermTyped::getType) {
         pTVar13 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
      }

      if (*(code**)( *(long*)pTVar13 + 0xe0 ) != TType::isMatrix) {
         cVar5 = ( **(code**)( *(long*)pTVar13 + 0xe0 ) )();
         if (cVar5 == '\0') goto LAB_0013a1e0;
         goto LAB_00139dc9;
      }

      if (0xf < (byte)pTVar13[9]) goto LAB_00139dc9;
      LAB_0013a1e0:pTVar13 = param_2 + 0x20;
      if (*(code**)( *(long*)param_2 + 0xf0 ) != TIntermTyped::getType) {
         pTVar13 = (TIntermTyped*)( **(code**)( *(long*)param_2 + 0xf0 ) )(param_2);
      }

      if (*(code**)( *(long*)pTVar13 + 0xd8 ) == TType::isVector) {
         if (1 < ( (byte)pTVar13[9] & 0xf )) goto LAB_00139dc9;
         bVar6 = (byte)pTVar13[10] >> 4 & 1;
      }
 else {
         bVar6 = ( **(code**)( *(long*)pTVar13 + 0xd8 ) )();
      }

      if (bVar6 != 0) goto LAB_00139dc9;
   }

   this_00 = *(vector<TIntermNode*,glslang::pool_allocator<TIntermNode*>>**)( *(long*)( this + 0x148 ) + 0x10 );
   if (*(long*)( this_00 + 8 ) == *(long*)( this_00 + 0x10 )) goto LAB_0013a137;
   if (param_3 == (TIntermAggregate*)0x0) {
      if (*(int*)( this + 0xc ) == 8) {
         if (( 0x12 < *(int*)( this + 0x18 ) - 0x12dU ) && ( ( (byte)this[0xd0] & 1 ) == 0 )) goto LAB_0013a25f;
         LAB_0013a370:( **(code**)( *(long*)this + 0x160 ) )(this, param_1, "last case/default label not followed by statements", "switch", &_LC1);
      }
 else {
         if (*(int*)( this + 0x18 ) - 0x1afU < 0x1d) goto LAB_0013a370;
         LAB_0013a25f:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "last case/default label not followed by statements", "switch", &_LC1);
      }

      pTVar3 = *(TIntermNode**)( this + 0x38 );
      glslang::TIntermediate::addBranch(pTVar3, 0x1d6, param_1);
      local_48 = (TIntermNode*)glslang::TIntermediate::makeAggregate(pTVar3);
      if (*(code**)( *(long*)local_48 + 0x188 ) == TIntermAggregate::setOperator) {
         *(undefined4*)( local_48 + 0xb8 ) = 1;
      }
 else {
         ( **(code**)( *(long*)local_48 + 0x188 ) )(local_48, 1);
      }

      std::vector<TIntermNode*,glslang::pool_allocator<TIntermNode*>>::emplace_back<TIntermNode*>(this_00, &local_48);
   }

   uVar9 = glslang::GetThreadPoolAllocator();
   plVar10 = (long*)glslang::TPoolAllocator::allocate(uVar9);
   plVar10[2] = 0;
   plVar10[1] = 0;
   *(undefined4*)( plVar10 + 3 ) = 0;
   plVar10[4] = (long)&PTR__TType_00167f00;
   *(ushort*)( (long)plVar10 + 0x4c ) = *(ushort*)( (long)plVar10 + 0x4c ) | 0xfff;
   *(byte*)( plVar10 + 8 ) = *(byte*)( plVar10 + 8 ) & 0xf0;
   *(undefined2*)( plVar10 + 0xf ) = 0;
   *(uint*)( plVar10 + 5 ) = *(uint*)( plVar10 + 5 ) & 0xf8000000 | 0x101;
   plVar10[7] = plVar10[7] & 0x8000000400000000;
   *(uint*)( plVar10 + 0x14 ) = *(uint*)( plVar10 + 0x14 ) & 0x9fc00000;
   plVar10[6] = 0;
   *(undefined8*)( (long)plVar10 + 0x44 ) = 0xffffffffffffffff;
   *(ulong*)( (long)plVar10 + 0x4d ) = ( ulong )(( uint ) * (undefined8*)( (long)plVar10 + 0x4d ) & 0xffc00f) | 0xffffffffff001fc0;
   *(undefined4*)( (long)plVar10 + 0x5d ) = 0;
   *(ulong*)( (long)plVar10 + 0x55 ) = *(ulong*)( (long)plVar10 + 0x55 ) & 0xfe000000800000 | 0x1ffffff7fffff;
   plVar10[0xd] = -0x100000000;
   *(undefined4*)( (long)plVar10 + 100 ) = 0xfffff800;
   plVar10[0xe] = 0;
   plVar10[0x17] = 1;
   *plVar10 = (long)glslang::TIntermediate::addSymbol;
   *(undefined1(*) [16])( plVar10 + 0x15 ) = (undefined1[16])0x0;
   *(undefined1(*) [16])( plVar10 + 0x10 ) = (undefined1[16])0x0;
   *(undefined1(*) [16])( plVar10 + 0x12 ) = (undefined1[16])0x0;
   lVar11 = glslang::GetThreadPoolAllocator();
   plVar10[0x19] = 0;
   plVar10[0x18] = lVar11;
   plVar10[0x1a] = 0;
   plVar10[0x1b] = 0;
   lVar11 = glslang::GetThreadPoolAllocator();
   plVar10[0x1d] = 0;
   plVar10[0x1c] = lVar11;
   plVar10[0x1e] = 0;
   plVar10[0x1f] = 0;
   lVar11 = glslang::GetThreadPoolAllocator();
   *(undefined1*)( plVar10 + 0x23 ) = 0;
   plVar10[0x20] = lVar11;
   plVar10[0x21] = (long)( plVar10 + 0x23 );
   plVar10[0x22] = 0;
   plVar10[0x26] = 0;
   lVar11 = glslang::GetThreadPoolAllocator();
   *(undefined1*)( plVar10 + 0x2a ) = 0;
   plVar10[0x27] = lVar11;
   plVar10[0x28] = (long)( plVar10 + 0x2a );
   plVar10[0x29] = 0;
   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( plVar10 + 0x27 ), "");
   lVar11 = *(long*)( this + 0x148 );
   *(undefined4*)( plVar10 + 0x2c ) = 0xffffffff;
   *(undefined4*)( plVar10 + 0x2d ) = 0;
   plVar1 = *(long**)( lVar11 + 0x10 );
   if (plVar1 != plVar10 + 0x18) {
      puVar17 = (undefined8*)plVar1[2];
      puVar15 = (undefined8*)plVar1[1];
      __dest = (undefined8*)plVar10[0x19];
      uVar9 = (long)puVar17 - (long)puVar15;
      if (( ulong )(plVar10[0x1b] - (long)__dest) < uVar9) {
         lVar11 = glslang::TPoolAllocator::allocate(plVar10[0x18]);
         uVar14 = 0;
         if (puVar17 != puVar15) {
            do {
               *(undefined8*)( lVar11 + uVar14 ) = *(undefined8*)( (long)puVar15 + uVar14 );
               uVar14 = uVar14 + 8;
            }
 while ( uVar14 != uVar9 );
         }

         lVar16 = uVar9 + lVar11;
         plVar10[0x19] = lVar11;
         plVar10[0x1b] = lVar16;
      }
 else {
         lVar11 = plVar10[0x1a];
         __n = lVar11 - (long)__dest;
         if (__n < uVar9) {
            if ((long)__n < 9) {
               if (__n == 8) {
                  *__dest = *puVar15;
               }

            }
 else {
               memmove(__dest, puVar15, __n);
               lVar11 = plVar10[0x1a];
               __dest = (undefined8*)plVar10[0x19];
               puVar17 = (undefined8*)plVar1[2];
               puVar15 = (undefined8*)plVar1[1];
               __n = lVar11 - (long)__dest;
            }

            puVar15 = (undefined8*)( (long)puVar15 + __n );
            lVar16 = uVar9 + (long)__dest;
            if (puVar15 != puVar17) {
               lVar12 = 0;
               do {
                  *(undefined8*)( lVar11 + lVar12 ) = *(undefined8*)( (long)puVar15 + lVar12 );
                  lVar12 = lVar12 + 8;
               }
 while ( (long)puVar17 - (long)puVar15 != lVar12 );
               plVar10[0x1a] = lVar16;
               goto LAB_0013a0b9;
            }

         }
 else if ((long)uVar9 < 9) {
            if (uVar9 == 8) {
               *__dest = *puVar15;
            }

            lVar16 = uVar9 + (long)__dest;
         }
 else {
            memmove(__dest, puVar15, uVar9);
            lVar16 = uVar9 + plVar10[0x19];
         }

      }

      plVar10[0x1a] = lVar16;
   }

   LAB_0013a0b9:if (*(code**)( *plVar10 + 8 ) == TIntermNode::setLoc) {
      lVar11 = *(long*)( param_1 + 8 );
      plVar10[1] = *(long*)param_1;
      plVar10[2] = lVar11;
      plVar10[3] = *(long*)( param_1 + 0x10 );
   }
 else {
      ( **(code**)( *plVar10 + 8 ) )(plVar10, param_1);
   }

   uVar9 = glslang::GetThreadPoolAllocator();
   pTVar13 = (TIntermTyped*)glslang::TPoolAllocator::allocate(uVar9);
   *(undefined8*)( pTVar13 + 0x10 ) = 0;
   *(undefined4*)( pTVar13 + 0x18 ) = 0;
   *(undefined8*)( pTVar13 + 8 ) = 0;
   uVar2 = *(undefined8*)param_1;
   uVar4 = *(undefined8*)( param_1 + 8 );
   *(undefined2*)( pTVar13 + 0x30 ) = 0;
   *(undefined8*)( pTVar13 + 8 ) = uVar2;
   *(undefined8*)( pTVar13 + 0x10 ) = uVar4;
   uVar2 = *(undefined8*)( param_1 + 0x10 );
   *(code**)pTVar13 = std::__cxx11::string::_M_replace;
   *(TIntermTyped**)( pTVar13 + 0x20 ) = param_2;
   *(long**)( pTVar13 + 0x28 ) = plVar10;
   *(undefined8*)( pTVar13 + 0x18 ) = uVar2;
   param_2 = pTVar13;
   LAB_0013a137:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   return param_2;
}
/* glslang::TParseContext::handleFunctionDefinition(glslang::TSourceLoc const&, glslang::TFunction&)
    */TIntermNode * __thiscall
glslang::TParseContext::handleFunctionDefinition
          (TParseContext *this,TSourceLoc *param_1,TFunction *param_2){
   TSymbol TVar1;
   undefined4 uVar2;
   TSymbolTable *this_00;
   long lVar3;
   void *__s1;
   vector<glslang::TSymbolTableLevel*,std::allocator<glslang::TSymbolTableLevel*>> *pvVar4;
   long *plVar5;
   undefined8 *puVar6;
   TSymbolTableLevel *this_01;
   TType *pTVar7;
   TVariable *pTVar8;
   undefined8 uVar9;
   undefined8 uVar10;
   char cVar11;
   int iVar12;
   uint uVar13;
   long *plVar14;
   size_t sVar15;
   ulong uVar16;
   undefined **ppuVar17;
   undefined *puVar18;
   undefined8 uVar19;
   TSymbol *pTVar20;
   TSourceLoc *pTVar21;
   basic_string *pbVar22;
   TFunction *pTVar23;
   size_t __n;
   vector<glslang::TSymbolTableLevel*,std::allocator<glslang::TSymbolTableLevel*>> vVar24;
   char *pcVar25;
   byte bVar26;
   byte bVar27;
   byte bVar28;
   code *pcVar29;
   long lVar30;
   ulong uVar31;
   long in_FS_OFFSET;
   TIntermNode *local_150;
   undefined8 local_130;
   undefined ***local_110;
   undefined **local_108;
   undefined4 local_100;
   undefined8 local_f8;
   ulong local_f0;
   byte local_e8;
   undefined8 local_e4;
   undefined1 uStack_dc;
   uint7 local_db;
   undefined4 uStack_d4;
   undefined4 local_d0;
   undefined4 uStack_cc;
   undefined1 local_c8;
   undefined8 local_c4;
   undefined4 local_bc;
   undefined8 local_b8;
   undefined2 local_b0;
   undefined1 local_a8[16];
   undefined1 local_98[16];
   uint local_88;
   undefined1 local_80[16];
   undefined8 local_68;
   undefined1 *local_60;
   undefined8 local_58;
   undefined1 local_50[16];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(code**)( *(long*)param_2 + 0x30 ) == TFunction::getMangledName_abi_cxx11_) {
      pTVar23 = param_2 + 0xe8;
   }
 else {
      pTVar23 = (TFunction*)( **(code**)( *(long*)param_2 + 0x30 ) )(param_2);
   }

   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( this + 0x7510 ), (basic_string*)pTVar23);
   this_00 = *(TSymbolTable**)( this + 0xe8 );
   if (*(code**)( *(long*)param_2 + 0x30 ) == TFunction::getMangledName_abi_cxx11_) {
      pTVar23 = param_2 + 0xe8;
   }
 else {
      pTVar23 = (TFunction*)( **(code**)( *(long*)param_2 + 0x30 ) )(param_2);
   }

   plVar14 = (long*)TSymbolTable::find(this_00, (basic_string*)pTVar23, (bool*)0x0, (bool*)0x0, (int*)0x0);
   if (( plVar14 == (long*)0x0 ) || ( plVar14 = (long*)( **(code**)( *plVar14 + 0x38 ) )(plVar14) ),plVar14 == (long*)0x0) {
      pcVar29 = *(code**)( *(long*)this + 0x158 );
      if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
         lVar30 = *(long*)( param_2 + 8 );
      }
 else {
         lVar30 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
      }

      ( *pcVar29 )(this, param_1, "can\'t find function", *(undefined8*)( lVar30 + 8 ), &_LC1);
      LAB_0013a5c8:uVar16 = glslang::GetThreadPoolAllocator();
      plVar14 = (long*)glslang::TPoolAllocator::allocate(uVar16);
      *plVar14 = (long)&PTR__TType_00167f00;
      *(undefined8*)( (long)plVar14 + 0x44 ) = 0xfffff800;
      local_130 = _LC291;
      *(byte*)( plVar14 + 4 ) = *(byte*)( plVar14 + 4 ) & 0xf0;
      *(uint*)( plVar14 + 1 ) = CONCAT22((short)( (uint)(int)plVar14[1] >> 0x10 ), 0x100) & 0xf800ffff;
      plVar14[2] = 0;
      *(ulong*)( (long)plVar14 + 0x2d ) = *(ulong*)( (long)plVar14 + 0x2d ) & 0xffffff0000ffc07f | 0xffff001f80;
      *(uint*)( plVar14 + 0x10 ) = *(uint*)( plVar14 + 0x10 ) & 0x9fc00000;
      *(undefined2*)( plVar14 + 0xb ) = 0;
      plVar14[7] = ( ulong )((uint)plVar14[7] & 0xfe07ff00) | 0x1f800ff;
      *(undefined8*)( (long)plVar14 + 0x24 ) = local_130;
      *(ulong*)( (long)plVar14 + 0x2c ) = *(ulong*)( (long)plVar14 + 0x2c ) & 0xffffffff8000 | 0xffff000000004fff;
      *(ulong*)( (long)plVar14 + 0x34 ) = *(ulong*)( (long)plVar14 + 0x34 ) | 0x7ff007fffffff;
      plVar14[3] = plVar14[3] & 0x8000000400000000;
      *(undefined1*)( plVar14 + 8 ) = 0;
      *(undefined4*)( (long)plVar14 + 0x4c ) = 0xffffffff;
      plVar14[10] = 0;
      *(undefined1(*) [16])( plVar14 + 0x11 ) = (undefined1[16])0x0;
      *(undefined1(*) [16])( plVar14 + 0xc ) = (undefined1[16])0x0;
      *(undefined1(*) [16])( plVar14 + 0xe ) = (undefined1[16])0x0;
   }
 else {
      lVar30 = *plVar14;
      if (*(code**)( lVar30 + 0xe8 ) == TFunction::isDefined) {
         if (*(char*)( (long)plVar14 + 0x114 ) != '\0') {
            LAB_0013ae95:pcVar29 = *(code**)( *(long*)this + 0x158 );
            if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
               lVar30 = *(long*)( param_2 + 8 );
            }
 else {
               lVar30 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
            }

            ( *pcVar29 )(this, param_1, "function already has a body", *(undefined8*)( lVar30 + 8 ), &_LC1);
            goto LAB_0013aedc;
         }

      }
 else {
         cVar11 = ( **(code**)( lVar30 + 0xe8 ) )(plVar14);
         if (cVar11 != '\0') goto LAB_0013ae95;
         LAB_0013aedc:if (*(code**)( *plVar14 + 0xe8 ) == TFunction::isDefined) {
            cVar11 = *(char*)( (long)plVar14 + 0x114 );
         }
 else {
            cVar11 = ( **(code**)( *plVar14 + 0xe8 ) )(plVar14);
         }

         if (cVar11 != '\0') goto LAB_0013a5c8;
         lVar30 = *plVar14;
      }

      if (*(code**)( lVar30 + 0xe0 ) == TFunction::setDefined) {
         *(undefined1*)( (long)plVar14 + 0x114 ) = 1;
      }
 else {
         ( **(code**)( lVar30 + 0xe0 ) )(plVar14);
         lVar30 = *plVar14;
      }

      if (*(code**)( lVar30 + 0x60 ) == TFunction::getType) {
         plVar14 = plVar14 + 9;
         local_130 = _LC291;
      }
 else {
         plVar14 = (long*)( **(code**)( lVar30 + 0x60 ) )(plVar14);
         local_130 = _LC291;
      }

   }

   *(long**)( this + 0x128 ) = plVar14;
   lVar30 = *(long*)param_2;
   this[0x130] = (TParseContext)0x0;
   if (*(code**)( lVar30 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
      lVar30 = *(long*)( param_2 + 8 );
   }
 else {
      lVar30 = ( **(code**)( lVar30 + 0x18 ) )(param_2);
   }

   lVar3 = *(long*)( this + 0x38 );
   uVar16 = *(ulong*)( lVar30 + 0x10 );
   __s1 = *(void**)( lVar30 + 8 );
   pcVar25 = *(char**)( lVar3 + 8 );
   sVar15 = strlen(pcVar25);
   __n = sVar15;
   if (uVar16 <= sVar15) {
      __n = uVar16;
   }

   if (( ( ( __n == 0 ) || ( iVar12 = memcmp(__s1, pcVar25, __n) ),iVar12 == 0 ) ) && ( lVar30 = lVar30 < 0x80000000 )) {
      if (*(code**)( *(long*)param_2 + 0x30 ) == TFunction::getMangledName_abi_cxx11_) {
         pTVar23 = param_2 + 0xe8;
      }
 else {
         pTVar23 = (TFunction*)( **(code**)( *(long*)param_2 + 0x30 ) )(param_2);
      }

      pcVar25 = *(char**)( pTVar23 + 8 );
      strlen(pcVar25);
      std::__cxx11::string::_M_replace(lVar3 + 0x28, 0, *(char**)( lVar3 + 0x30 ), (ulong)pcVar25);
      lVar30 = *(long*)param_2;
      *(int*)( *(long*)( this + 0x38 ) + 0x260 ) = *(int*)( *(long*)( this + 0x38 ) + 0x260 ) + 1;
      pcVar29 = *(code**)( lVar30 + 0x120 );
      this[0x500] = (TParseContext)0x1;
      if (pcVar29 == TFunction::getParamCount) {
         iVar12 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
      }
 else {
         iVar12 = ( *pcVar29 )(param_2);
         lVar30 = *(long*)param_2;
      }

      if (0 < iVar12) {
         pcVar29 = *(code**)( *(long*)this + 0x158 );
         if (*(code**)( lVar30 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            lVar30 = *(long*)( param_2 + 8 );
         }
 else {
            lVar30 = ( **(code**)( lVar30 + 0x18 ) )(param_2);
         }

         ( *pcVar29 )(this, param_1, "function cannot take any parameter(s)", *(undefined8*)( lVar30 + 8 ), &_LC1);
         lVar30 = *(long*)param_2;
      }

      if (*(code**)( lVar30 + 0x60 ) == TFunction::getType) {
         pTVar23 = param_2 + 0x48;
      }
 else {
         pTVar23 = (TFunction*)( **(code**)( lVar30 + 0x60 ) )(param_2);
      }

      if (*(code**)( *(long*)pTVar23 + 0x38 ) == TType::getBasicType) {
         uVar13 = (uint)(byte)pTVar23[8];
      }
 else {
         uVar13 = ( **(code**)( *(long*)pTVar23 + 0x38 ) )();
      }

      if (uVar13 != 0) {
         pcVar29 = *(code**)( *(long*)this + 0x158 );
         if (*(code**)( *(long*)param_2 + 0x60 ) == TFunction::getType) {
            pTVar23 = param_2 + 0x48;
         }
 else {
            pTVar23 = (TFunction*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
         }

         if (pTVar23[8] == (TFunction)0xe) {
            TSampler::getString_abi_cxx11_();
         }
 else {
            local_68 = glslang::GetThreadPoolAllocator();
            switch (pTVar23[8]) {
               case (TFunction)0x0:
          lVar30 = 4;
          pcVar25 = "void";
          break;
               case (TFunction)0x1:
          lVar30 = 5;
          pcVar25 = "float";
          break;
               case (TFunction)0x2:
          lVar30 = 6;
          pcVar25 = "double";
          break;
               case (TFunction)0x3:
          lVar30 = 9;
          pcVar25 = "float16_t";
          break;
               case (TFunction)0x4:
          lVar30 = 6;
          pcVar25 = "int8_t";
          break;
               case (TFunction)0x5:
          lVar30 = 7;
          pcVar25 = "uint8_t";
          break;
               case (TFunction)0x6:
          lVar30 = 7;
          pcVar25 = "int16_t";
          break;
               case (TFunction)0x7:
          lVar30 = 8;
          pcVar25 = "uint16_t";
          break;
               case (TFunction)0x8:
          lVar30 = 3;
          pcVar25 = "int";
          break;
               case (TFunction)0x9:
          lVar30 = 4;
          pcVar25 = "uint";
          break;
               case (TFunction)0xa:
          lVar30 = 7;
          pcVar25 = "int64_t";
          break;
               case (TFunction)0xb:
          lVar30 = 8;
          pcVar25 = "uint64_t";
          break;
               case (TFunction)0xc:
          lVar30 = 4;
          pcVar25 = "bool";
          break;
               case (TFunction)0xd:
          lVar30 = 0xb;
          pcVar25 = "atomic_uint";
          break;
               case (TFunction)0xe:
          lVar30 = 0xd;
          pcVar25 = "sampler/image";
          break;
               case (TFunction)0xf:
          lVar30 = 9;
          pcVar25 = "structure";
          break;
               case (TFunction)0x10:
          lVar30 = 5;
          pcVar25 = "block";
          break;
               case (TFunction)0x11:
          lVar30 = 0x17;
          pcVar25 = "accelerationStructureNV";
          break;
               case (TFunction)0x12:
          lVar30 = 9;
          pcVar25 = "reference";
          break;
               case (TFunction)0x13:
          lVar30 = 0xb;
          pcVar25 = "rayQueryEXT";
          break;
               default:
          lVar30 = 0xc;
          pcVar25 = "unknown type";
          break;
               case (TFunction)0x15:
          lVar30 = 7;
          pcVar25 = "coopmat";
          break;
               case (TFunction)0x16:
          lVar30 = 10;
          pcVar25 = "spirv_type";
          break;
               case (TFunction)0x17:
          lVar30 = 6;
          pcVar25 = "string";
            }

            local_60 = local_50;
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, pcVar25, pcVar25 + lVar30);
         }

         ( *pcVar29 )(this, param_1, &_LC1, local_60, "entry point cannot return a value");
      }

      if (*(int*)( param_2 + 0x150 ) != 0) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "main function cannot be exported", &_LC1, &_LC1);
      }

   }
 else {
      this[0x500] = (TParseContext)0x0;
   }

   pvVar4 = *(vector<glslang::TSymbolTableLevel*,std::allocator<glslang::TSymbolTableLevel*>>**)( this + 0xe8 );
   uVar16 = glslang::GetThreadPoolAllocator();
   ppuVar17 = (undefined**)glslang::TPoolAllocator::allocate(uVar16);
   puVar18 = (undefined*)glslang::GetThreadPoolAllocator();
   *(undefined4*)( ppuVar17 + 2 ) = 0;
   *ppuVar17 = puVar18;
   ppuVar17[3] = (undefined*)0x0;
   ppuVar17[4] = (undefined*)( ppuVar17 + 2 );
   ppuVar17[5] = (undefined*)( ppuVar17 + 2 );
   ppuVar17[6] = (undefined*)0x0;
   ppuVar17[7] = (undefined*)0x0;
   puVar18 = (undefined*)glslang::GetThreadPoolAllocator();
   ppuVar17[9] = (undefined*)0x0;
   plVar14 = *(long**)( pvVar4 + 8 );
   ppuVar17[8] = puVar18;
   ppuVar17[10] = (undefined*)0x0;
   ppuVar17[0xb] = (undefined*)0x0;
   *(undefined4*)( ppuVar17 + 0xc ) = 0;
   *(undefined1*)( (long)ppuVar17 + 100 ) = 0;
   local_108 = ppuVar17;
   if (plVar14 == *(long**)( pvVar4 + 0x10 )) {
      std::vector<glslang::TSymbolTableLevel*,std::allocator<glslang::TSymbolTableLevel*>>::_M_realloc_insert<glslang::TSymbolTableLevel*>(pvVar4);
      plVar14 = *(long**)( pvVar4 + 8 );
   }
 else {
      *plVar14 = (long)ppuVar17;
      plVar14 = plVar14 + 1;
      *(long**)( pvVar4 + 8 ) = plVar14;
   }

   local_110 = &local_108;
   uVar13 = (int)( (long)plVar14 - *(long*)pvVar4 >> 3 ) - 1;
   vVar24 = (vector<glslang::TSymbolTableLevel*,std::allocator<glslang::TSymbolTableLevel*>>)0x7f;
   if (uVar13 < 0x80) {
      vVar24 = SUB41(uVar13, 0);
   }

   uVar31 = 0;
   pvVar4[0x1f] = vVar24;
   uVar16 = glslang::GetThreadPoolAllocator();
   local_150 = (TIntermNode*)glslang::TPoolAllocator::allocate(uVar16);
   *(undefined8*)( local_150 + 0x10 ) = 0;
   *(undefined8*)( local_150 + 8 ) = 0;
   *(undefined4*)( local_150 + 0x18 ) = 0;
   local_150[0x40] = ( TIntermNode )((byte)local_150[0x40] & 0xf0);
   *(undefined***)( local_150 + 0x20 ) = &PTR__TType_00167f00;
   *(ushort*)( local_150 + 0x4c ) = *(ushort*)( local_150 + 0x4c ) | 0xfff;
   *(undefined2*)( local_150 + 0x78 ) = 0;
   *(undefined8*)( local_150 + 0x30 ) = 0;
   *(uint*)( local_150 + 0x28 ) = *(uint*)( local_150 + 0x28 ) & 0xf8000000 | 0x101;
   *(ulong*)( local_150 + 0x38 ) = *(ulong*)( local_150 + 0x38 ) & 0x8000000400000000;
   *(uint*)( local_150 + 0xa0 ) = *(uint*)( local_150 + 0xa0 ) & 0x9fc00000;
   *(undefined8*)( local_150 + 0x44 ) = local_130;
   *(undefined4*)( local_150 + 0x5d ) = 0;
   *(undefined4*)( local_150 + 100 ) = 0xfffff800;
   *(undefined8*)( local_150 + 0x70 ) = 0;
   *(ulong*)( local_150 + 0x4d ) = ( ulong )(( uint ) * (undefined8*)( local_150 + 0x4d ) & 0xffc00f) | 0xffffffffff001fc0;
   *(undefined1(*) [16])( local_150 + 0xa8 ) = (undefined1[16])0x0;
   *(ulong*)( local_150 + 0x55 ) = *(ulong*)( local_150 + 0x55 ) & 0xfe000000800000 | 0x1ffffff7fffff;
   *(undefined8*)( local_150 + 0x68 ) = 0xffffffff00000000;
   *(undefined8*)( local_150 + 0xb8 ) = 0;
   *(code**)local_150 = glslang::TIntermediate::addSymbol;
   *(undefined1(*) [16])( local_150 + 0x80 ) = (undefined1[16])0x0;
   *(undefined1(*) [16])( local_150 + 0x90 ) = (undefined1[16])0x0;
   uVar19 = glslang::GetThreadPoolAllocator();
   *(undefined8*)( local_150 + 200 ) = 0;
   *(undefined8*)( local_150 + 0xc0 ) = uVar19;
   *(undefined8*)( local_150 + 0xd0 ) = 0;
   *(undefined8*)( local_150 + 0xd8 ) = 0;
   uVar19 = glslang::GetThreadPoolAllocator();
   *(undefined8*)( local_150 + 0xe8 ) = 0;
   *(undefined8*)( local_150 + 0xe0 ) = uVar19;
   *(undefined8*)( local_150 + 0xf0 ) = 0;
   *(undefined8*)( local_150 + 0xf8 ) = 0;
   uVar19 = glslang::GetThreadPoolAllocator();
   local_150[0x118] = (TIntermNode)0x0;
   *(undefined8*)( local_150 + 0x100 ) = uVar19;
   *(TIntermNode**)( local_150 + 0x108 ) = local_150 + 0x118;
   *(undefined8*)( local_150 + 0x110 ) = 0;
   local_150[0x128] = (TIntermNode)0x0;
   *(undefined8*)( local_150 + 0x130 ) = 0;
   uVar19 = glslang::GetThreadPoolAllocator();
   local_150[0x150] = (TIntermNode)0x0;
   *(undefined8*)( local_150 + 0x138 ) = uVar19;
   *(TIntermNode**)( local_150 + 0x140 ) = local_150 + 0x150;
   *(undefined8*)( local_150 + 0x148 ) = 0;
   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( local_150 + 0x138 ), "");
   *(undefined4*)( local_150 + 0x160 ) = 0xffffffff;
   *(undefined4*)( local_150 + 0x168 ) = 0;
   do {
      if (*(code**)( *(long*)param_2 + 0x120 ) == TFunction::getParamCount) {
         iVar12 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
      }
 else {
         iVar12 = ( **(code**)( *(long*)param_2 + 0x120 ) )(param_2);
      }

      if (iVar12 <= (int)uVar31) {
         uVar19 = *(undefined8*)( this + 0x38 );
         *(undefined4*)( local_150 + 0x168 ) = *(undefined4*)( param_2 + 0x150 );
         local_80 = (undefined1[16])0x0;
         local_108 = &PTR__TType_00167f00;
         local_a8 = (undefined1[16])0x0;
         local_98 = (undefined1[16])0x0;
         local_100 = CONCAT22(local_100._2_2_, 0x100) & 0xf800ffff;
         local_e8 = local_e8 & 0xf0;
         local_c4 = 0xfffff800;
         local_b0 = 0;
         local_88 = local_88 & 0x9fc00000;
         local_e4 = local_130;
         local_f8 = 0;
         local_c8 = 0;
         local_bc = 0xffffffff;
         local_b8 = 0;
         uStack_cc = 0;
         local_db = local_db & 0xffc000 | 0xffffffff001fcf;
         uStack_dc = 0xff;
         uVar16 = CONCAT44(local_d0, uStack_d4) & 0xfe07ff00ffffffff | 0x1ffffff7fffffff;
         uStack_d4 = (undefined4)uVar16;
         local_d0 = ( undefined4 )(uVar16 >> 0x20);
         local_f0 = local_f0 & 0x8000000400000000;
         glslang::TIntermediate::setAggregateOperator(uVar19, local_150, 6, local_110, param_1);
         this[0x131] = (TParseContext)0x0;
         *(undefined8*)( this + 0x110 ) = 0;
         *(undefined4*)( this + 0x120 ) = 0;
         if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
            /* WARNING: Subroutine does not return */
            __stack_chk_fail();
         }

         return local_150;
      }

      if (*(code**)( *(long*)param_2 + 0x138 ) == TFunction::operator []) {
         plVar14 = (long*)( *(long*)( param_2 + 0x30 ) + uVar31 * 0x18 );
      }
 else {
         plVar14 = (long*)( **(code**)( *(long*)param_2 + 0x138 ) )(param_2, uVar31 & 0xffffffff);
      }

      if (*plVar14 == 0) {
         pTVar7 = *(TType**)( this + 0x38 );
         pTVar21 = (TSourceLoc*)glslang::TIntermediate::addSymbol(pTVar7, (TSourceLoc*)plVar14[1]);
         local_150 = (TIntermNode*)glslang::TIntermediate::growAggregate((TIntermNode*)pTVar7, local_150, pTVar21);
      }
 else {
         uVar16 = glslang::GetThreadPoolAllocator();
         pTVar20 = (TSymbol*)glslang::TPoolAllocator::allocate(uVar16);
         pbVar22 = (basic_string*)*plVar14;
         lVar30 = plVar14[1];
         *(undefined8*)( pTVar20 + 0x10 ) = 0;
         *(basic_string**)( pTVar20 + 8 ) = pbVar22;
         *(undefined8*)( pTVar20 + 0x18 ) = 0;
         pTVar20[0x20] = (TSymbol)0x1;
         *(code**)pTVar20 = std::_Hash_bytes;
         pTVar20[0x48] = ( TSymbol )((byte)pTVar20[0x48] & 0xf0);
         *(undefined***)( pTVar20 + 0x28 ) = &PTR__TType_00167f00;
         *(uint*)( pTVar20 + 0xa8 ) = *(uint*)( pTVar20 + 0xa8 ) & 0x9fc00000;
         *(undefined8*)( pTVar20 + 0x38 ) = 0;
         pTVar20[0x68] = (TSymbol)0x0;
         *(uint*)( pTVar20 + 0x30 ) = CONCAT22((short)( ( uint ) * (undefined4*)( pTVar20 + 0x30 ) >> 0x10 ), 0x100) & 0xf800ffff;
         *(undefined4*)( pTVar20 + 0x6c ) = 0xfffff800;
         *(undefined8*)( pTVar20 + 0x4c ) = local_130;
         *(undefined1(*) [16])( pTVar20 + 0xb0 ) = (undefined1[16])0x0;
         *(ulong*)( pTVar20 + 0x55 ) = *(ulong*)( pTVar20 + 0x55 ) & 0xffffff0000ffc07f | 0xffff001f80;
         *(undefined1(*) [16])( pTVar20 + 0x88 ) = (undefined1[16])0x0;
         *(ulong*)( pTVar20 + 0x60 ) = CONCAT71(( uint7 )(( ulong ) * (undefined8*)( pTVar20 + 0x60 ) >> 8) & 0xffffffff, 0xff);
         *(undefined1(*) [16])( pTVar20 + 0x98 ) = (undefined1[16])0x0;
         *(ulong*)( pTVar20 + 0x54 ) = *(ulong*)( pTVar20 + 0x54 ) & 0xffffffff8000 | 0xffff000000004fff;
         *(ulong*)( pTVar20 + 0x5c ) = *(ulong*)( pTVar20 + 0x5c ) | 0x1ffff007fffffff;
         pTVar20[100] = (TSymbol)0x0;
         *(undefined8*)( pTVar20 + 0x70 ) = 0xffffffff00000000;
         *(undefined8*)( pTVar20 + 0x78 ) = 0;
         *(ulong*)( pTVar20 + 0x40 ) = *(ulong*)( pTVar20 + 0x40 ) & 0x8000000400000000;
         *(undefined2*)( pTVar20 + 0x80 ) = 0;
         uVar19 = *(undefined8*)( lVar30 + 0x10 );
         uVar9 = *(undefined8*)( lVar30 + 0x18 );
         TVar1 = *(TSymbol*)( lVar30 + 8 );
         *(undefined***)( pTVar20 + 200 ) = &PTR__TConstUnionArray_001680e8;
         uVar2 = *(undefined4*)( lVar30 + 0x80 );
         *(undefined8*)( pTVar20 + 0x38 ) = uVar19;
         *(undefined8*)( pTVar20 + 0x40 ) = uVar9;
         uVar19 = *(undefined8*)( lVar30 + 0x20 );
         uVar9 = *(undefined8*)( lVar30 + 0x28 );
         pTVar20[0x30] = TVar1;
         *(undefined8*)( pTVar20 + 0x48 ) = uVar19;
         *(undefined8*)( pTVar20 + 0x50 ) = uVar9;
         uVar19 = *(undefined8*)( lVar30 + 0x30 );
         uVar9 = *(undefined8*)( lVar30 + 0x38 );
         *(undefined4*)( pTVar20 + 0xa8 ) = uVar2;
         *(undefined8*)( pTVar20 + 0x58 ) = uVar19;
         *(undefined8*)( pTVar20 + 0x60 ) = uVar9;
         uVar19 = *(undefined8*)( lVar30 + 0x40 );
         uVar9 = *(undefined8*)( lVar30 + 0x48 );
         pTVar20[0xc0] = (TSymbol)0x0;
         *(undefined8*)( pTVar20 + 0x68 ) = uVar19;
         *(undefined8*)( pTVar20 + 0x70 ) = uVar9;
         uVar19 = *(undefined8*)( lVar30 + 0x50 );
         uVar9 = *(undefined8*)( lVar30 + 0x58 );
         *(undefined8*)( pTVar20 + 0xd0 ) = 0;
         *(undefined8*)( pTVar20 + 0x78 ) = uVar19;
         *(undefined8*)( pTVar20 + 0x80 ) = uVar9;
         bVar26 = *(byte*)( lVar30 + 9 );
         *(undefined8*)( pTVar20 + 0xd8 ) = 0;
         *(undefined8*)( pTVar20 + 0xe0 ) = 0;
         bVar26 = bVar26 & 0xf;
         *(undefined4*)( pTVar20 + 0xe8 ) = 0xffffffff;
         pTVar20[0x31] = ( TSymbol )((byte)pTVar20[0x31] & 0xf0 | bVar26);
         pTVar20[0x31] = ( TSymbol )(bVar26 | *(byte*)( lVar30 + 9 ) & 0xf0);
         TVar1 = pTVar20[0x32];
         bVar27 = *(byte*)( lVar30 + 10 ) & 0xf;
         pTVar20[0x32] = ( TSymbol )((byte)TVar1 & 0xf0 | bVar27);
         bVar28 = *(byte*)( lVar30 + 10 ) & 0x10;
         pTVar20[0x32] = ( TSymbol )((byte)TVar1 & 0xe0 | bVar27 | bVar28);
         uVar9 = *(undefined8*)( lVar30 + 0x70 );
         uVar10 = *(undefined8*)( lVar30 + 0x78 );
         uVar19 = *(undefined8*)( lVar30 + 0x68 );
         *(undefined8*)( pTVar20 + 0x88 ) = *(undefined8*)( lVar30 + 0x60 );
         *(undefined8*)( pTVar20 + 0x90 ) = uVar19;
         *(undefined8*)( pTVar20 + 0x98 ) = uVar9;
         *(undefined8*)( pTVar20 + 0xa0 ) = uVar10;
         uVar19 = *(undefined8*)( lVar30 + 0x90 );
         *(undefined8*)( pTVar20 + 0xb0 ) = *(undefined8*)( lVar30 + 0x88 );
         *(undefined8*)( pTVar20 + 0xb8 ) = uVar19;
         bVar26 = *(byte*)( lVar30 + 10 ) & 0x20;
         pTVar20[0x32] = ( TSymbol )((byte)TVar1 & 0xc0 | bVar27 | bVar28 | bVar26);
         pTVar20[0x32] = ( TSymbol )((byte)TVar1 & 0x80 | bVar27 | bVar28 | bVar26 | *(byte*)( lVar30 + 10 ) & 0x40);
         *(ushort*)( pTVar20 + 0x32 ) = *(ushort*)( pTVar20 + 0x32 ) & 0xfc7f | *(ushort*)( lVar30 + 10 ) & 0x380;
         pTVar20[0x33] = ( TSymbol )((byte)pTVar20[0x33] & 0xfb | *(byte*)( lVar30 + 0xb ) & 4);
         plVar5 = *(long**)( this + 0xe8 );
         puVar6 = (undefined8*)*plVar5;
         lVar30 = plVar5[1];
         lVar3 = plVar5[3];
         cVar11 = *(char*)( (long)plVar5 + 0x21 );
         plVar5[3] = lVar3 + 1;
         *(long*)( pTVar20 + 0x10 ) = lVar3 + 1;
         iVar12 = (int)( lVar30 - (long)puVar6 >> 3 );
         if (( ( cVar11 == '\0' ) && ( cVar11 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)puVar6[iVar12 + -1], pbVar22) ),cVar11 != '\0' )) {
            pcVar29 = *(code**)( *(long*)this + 0x158 );
         }
 else {
            this_01 = (TSymbolTableLevel*)puVar6[iVar12 + -1];
            local_68 = glslang::GetThreadPoolAllocator();
            local_60 = local_50;
            local_50[0] = 0;
            local_58 = 0;
            cVar11 = TSymbolTableLevel::insert(this_01, pTVar20, *(bool*)( (long)plVar5 + 0x21 ), (basic_string*)&local_68);
            if (cVar11 != '\0') {
               pTVar8 = *(TVariable**)( this + 0x38 );
               *plVar14 = 0;
               pTVar21 = (TSourceLoc*)glslang::TIntermediate::addSymbol(pTVar8, (TSourceLoc*)pTVar20);
               local_150 = (TIntermNode*)glslang::TIntermediate::growAggregate((TIntermNode*)pTVar8, local_150, pTVar21);
               goto LAB_0013ade7;
            }

            pcVar29 = *(code**)( *(long*)this + 0x158 );
            if (*(code**)( *(long*)pTVar20 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
               pbVar22 = *(basic_string**)( pTVar20 + 8 );
            }
 else {
               pbVar22 = (basic_string*)( **(code**)( *(long*)pTVar20 + 0x18 ) )(pTVar20);
            }

         }

         ( *pcVar29 )(this, param_1, "redefinition", *(undefined8*)( pbVar22 + 8 ), &_LC1);
      }

      LAB_0013ade7:uVar31 = uVar31 + 1;
   }
 while ( true );
}
/* std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, glslang::AstRefType> >
   std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> >, std::pair<std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const, glslang::AstRefType>,
   std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, glslang::AstRefType> >,
   std::less<std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, glslang::AstRefType> >
   >::_M_emplace_hint_unique<std::piecewise_construct_t const&,
   std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   > const&>, std::tuple<> >(std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const, glslang::AstRefType> >,
   std::piecewise_construct_t const&, std::tuple<std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const&>&&, std::tuple<>&&) [clone
   .isra.0] */_Rb_tree_node_base *std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>::_M_emplace_hint_unique<std::piecewise_construct_t_const&,std::tuple<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const&>,std::tuple<>>(_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>> *param_1, undefined8 param_2, long *param_3) {
   _Rb_tree_node_base *__src;
   ulong uVar1;
   int iVar2;
   _Rb_tree_node_base *p_Var3;
   ulong uVar4;
   _Rb_tree_node_base *p_Var5;
   ulong __n;
   long lVar6;
   bool bVar7;
   undefined1 auVar8[16];
   p_Var3 = (_Rb_tree_node_base*)operator_new(0x50);
   lVar6 = *param_3;
   uVar4 = glslang::GetThreadPoolAllocator();
   p_Var5 = p_Var3 + 0x38;
   *(_Rb_tree_node_base**)( p_Var3 + 0x28 ) = p_Var5;
   __src = *(_Rb_tree_node_base**)( lVar6 + 8 );
   uVar1 = *(ulong*)( lVar6 + 0x10 );
   *(ulong*)( p_Var3 + 0x20 ) = uVar4;
   if (uVar1 < 0x10) {
      if (uVar1 == 1) {
         p_Var3[0x38] = *__src;
      }
 else if (uVar1 != 0) goto LAB_0013b9d0;
   }
 else {
      if ((long)uVar1 < 0) {
         /* WARNING: Subroutine does not return */
         std::__throw_length_error("basic_string::_M_create");
      }

      p_Var5 = (_Rb_tree_node_base*)glslang::TPoolAllocator::allocate(uVar4);
      *(ulong*)( p_Var3 + 0x38 ) = uVar1;
      *(_Rb_tree_node_base**)( p_Var3 + 0x28 ) = p_Var5;
      LAB_0013b9d0:memcpy(p_Var5, __src, uVar1);
      p_Var5 = *(_Rb_tree_node_base**)( p_Var3 + 0x28 );
   }

   *(ulong*)( p_Var3 + 0x30 ) = uVar1;
   p_Var5[uVar1] = (_Rb_tree_node_base)0x0;
   *(undefined4*)( p_Var3 + 0x48 ) = 0;
   auVar8 = _M_get_insert_hint_unique_pos(param_1, param_2, p_Var3 + 0x20);
   p_Var5 = auVar8._8_8_;
   if (p_Var5 == (_Rb_tree_node_base*)0x0) {
      operator_delete(p_Var3, 0x50);
      return auVar8._0_8_;
   }

   bVar7 = true;
   if (( auVar8._0_8_ != (_Rb_tree_node_base*)0x0 ) || ( p_Var5 == (_Rb_tree_node_base*)( param_1 + 8 ) )) goto LAB_0013b952;
   uVar1 = *(ulong*)( p_Var3 + 0x30 );
   uVar4 = *(ulong*)( p_Var5 + 0x30 );
   __n = uVar4;
   if (uVar1 <= uVar4) {
      __n = uVar1;
   }

   if (( __n == 0 ) || ( iVar2 = memcmp(*(void**)( p_Var3 + 0x28 ), *(void**)( p_Var5 + 0x28 ), __n) ),iVar2 == 0) {
      lVar6 = uVar1 - uVar4;
      bVar7 = false;
      if (0x7fffffff < lVar6) goto LAB_0013b952;
      if (lVar6 < -0x80000000) {
         bVar7 = true;
         goto LAB_0013b952;
      }

      iVar2 = (int)lVar6;
   }

   bVar7 = SUB41((uint)iVar2 >> 0x1f, 0);
   LAB_0013b952:std::_Rb_tree_insert_and_rebalance(bVar7, p_Var3, p_Var5, (_Rb_tree_node_base*)( param_1 + 8 ));
   *(long*)( param_1 + 0x28 ) = *(long*)( param_1 + 0x28 ) + 1;
   return p_Var3;
}
/* glslang::TParseContext::setLayoutQualifier(glslang::TSourceLoc const&, glslang::TPublicType&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >&) */void glslang::TParseContext::setLayoutQualifier(TParseContext *this, TSourceLoc *param_1, TPublicType *param_2, basic_string *param_3) {
   int *piVar1;
   long lVar2;
   bool bVar3;
   char cVar4;
   int iVar5;
   char *pcVar6;
   size_t sVar7;
   undefined4 *puVar8;
   char *pcVar9;
   ulong __n;
   uint uVar10;
   char *pcVar11;
   ulong uVar12;
   int iVar13;
   code *UNRECOVERED_JUMPTABLE;
   undefined4 local_40;
   pcVar6 = *(char**)( param_3 + 8 );
   pcVar11 = pcVar6 + *(long*)( param_3 + 0x10 );
   iVar13 = (int)param_1;
   if (pcVar6 == pcVar11) {
      __n = 0;
   }
 else {
      do {
         pcVar9 = pcVar6 + 1;
         iVar5 = tolower((int)*pcVar6);
         *pcVar6 = (char)iVar5;
         pcVar6 = pcVar9;
      }
 while ( pcVar9 != pcVar11 );
      __n = *(ulong*)( param_3 + 0x10 );
      if (__n == 0xc) {
         if (( **(long**)( param_3 + 8 ) == 0x6d5f6e6d756c6f63 ) && ( (int)( *(long**)( param_3 + 8 ) )[1] == 0x726f6a61 )) {
            param_2[0x17] = ( TPublicType )((byte)param_2[0x17] & 0x8f | 0x20);
            return;
         }

      }
 else if (__n == 9) {
         if (( **(long**)( param_3 + 8 ) == 0x6f6a616d5f776f72 ) && ( (char)( *(long**)( param_3 + 8 ) )[1] == 'r' )) {
            param_2[0x17] = ( TPublicType )((byte)param_2[0x17] & 0x8f | 0x10);
            return;
         }

      }
 else if (__n == 6) {
         piVar1 = *(int**)( param_3 + 8 );
         if (( *piVar1 == 0x6b636170 ) && ( (short)piVar1[1] == 0x6465 )) {
            if (*(int*)( this + 0x20 ) != 0) {
               if (this[0x30] != (TParseContext)0x0) {
                  return;
               }

               ( **(code**)( *(long*)this + 0x130 ) )(this, param_1, "packed");
            }

            param_2[0x18] = ( TPublicType )((byte)param_2[0x18] & 0xf0 | 4);
            return;
         }

         if (( *piVar1 == 0x72616873 ) && ( (short)piVar1[1] == 0x6465 )) {
            if (*(int*)( this + 0x20 ) != 0) {
               if (this[0x30] != (TParseContext)0x0) {
                  return;
               }

               ( **(code**)( *(long*)this + 0x130 ) )(this, param_1, "shared");
            }

            param_2[0x18] = ( TPublicType )((byte)param_2[0x18] & 0xf0 | 1);
            return;
         }

         if (( *piVar1 == 0x31647473 ) && ( (short)piVar1[1] == 0x3034 )) {
            param_2[0x18] = ( TPublicType )((byte)param_2[0x18] & 0xf0 | 2);
            return;
         }

         if (( *piVar1 == 0x34647473 ) && ( (short)piVar1[1] == 0x3033 )) {
            glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar13, (char*)0xe);
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 6, (char*)0x1ae, "GL_ARB_shader_storage_buffer_object");
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 8, (char*)0x136, (char*)0x0);
            param_2[0x18] = ( TPublicType )((byte)param_2[0x18] & 0xf0 | 3);
            return;
         }

         if (( *piVar1 == 0x6c616373 ) && ( (short)piVar1[1] == 0x7261 )) {
            ( **(code**)( *(long*)this + 0x140 ) )(this, param_1, "scalar");
            ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_EXT_scalar_block_layout, "scalar block layout");
            param_2[0x18] = ( TPublicType )((byte)param_2[0x18] & 0xf0 | 5);
            return;
         }

      }

   }

   uVar12 = 1;
   do {
      pcVar6 = (char*)TQualifier::getLayoutFormatString(uVar12);
      sVar7 = strlen(pcVar6);
      if (( sVar7 == __n ) && ( ( __n == 0 || ( iVar5 = memcmp(*(void**)( param_3 + 8 ), pcVar6, __n) ),iVar5 == 0 ) )) {
         if (( 0x1fff03f03fff80U >> ( uVar12 & 0x3f ) & 1 ) != 0) {
            glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar13, (char*)0x7);
         }

         glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 7, (char*)0x1a4, "GL_ARB_shader_image_load_store");
         glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 8, (char*)0x136, "GL_ARB_shader_image_load_store");
         param_2[0x34] = SUB81(uVar12, 0);
         return;
      }

      uVar10 = (int)uVar12 + 1;
      uVar12 = (ulong)uVar10;
   }
 while ( uVar10 != 0x35 );
   bVar3 = std::operator ==(param_3, "push_constant");
   if (bVar3) {
      ( **(code**)( *(long*)this + 0x140 ) )(this, param_1, "push_constant");
      param_2[0x35] = (TPublicType)0x1;
      return;
   }

   bVar3 = std::operator ==(param_3, "buffer_reference");
   if (bVar3) {
      ( **(code**)( *(long*)this + 0x140 ) )(this, param_1, "buffer_reference");
      ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_EXT_buffer_reference, "buffer_reference");
      lVar2 = *(long*)( this + 0x38 );
      param_2[0x36] = (TPublicType)0x1;
      *(undefined1*)( lVar2 + 0x271 ) = 1;
      *(undefined1*)( lVar2 + 0x510 ) = 1;
      return;
   }

   bVar3 = std::operator ==(param_3, "bindless_sampler");
   if (bVar3) {
      ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_ARB_bindless_texture, "bindless_sampler");
      lVar2 = *(long*)( this + 0x38 );
      param_2[0x50] = (TPublicType)0x1;
      puVar8 = (undefined4*)std::map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>::operator []((map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>*)( lVar2 + 0x528 ), (basic_string*)( this + 0x7510 ));
      *puVar8 = 2;
      return;
   }

   bVar3 = std::operator ==(param_3, "bindless_image");
   if (bVar3) {
      ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_ARB_bindless_texture, "bindless_image");
      lVar2 = *(long*)( this + 0x38 );
      param_2[0x51] = (TPublicType)0x1;
      puVar8 = (undefined4*)std::map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>::operator []((map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>*)( lVar2 + 0x558 ), (basic_string*)( this + 0x7510 ));
      *puVar8 = 2;
      return;
   }

   bVar3 = std::operator ==(param_3, "bound_sampler");
   if (bVar3) {
      ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_ARB_bindless_texture, "bound_sampler");
      param_2[0x50] = (TPublicType)0x0;
      return;
   }

   bVar3 = std::operator ==(param_3, "bound_image");
   if (bVar3) {
      ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_ARB_bindless_texture, "bound_image");
      param_2[0x51] = (TPublicType)0x0;
      return;
   }

   uVar10 = *(uint*)( this + 0x1c );
   if (( uVar10 - 2 < 2 ) || ( uVar10 == 0xd )) {
      bVar3 = std::operator ==(param_3, "triangles");
      if (bVar3) {
         *(undefined4*)( param_2 + 0x58 ) = 5;
         return;
      }

      if (( uVar10 == 3 ) || ( uVar10 == 0xd )) {
         bVar3 = std::operator ==(param_3, "points");
         if (bVar3) {
            *(undefined4*)( param_2 + 0x58 ) = 1;
            return;
         }

         bVar3 = std::operator ==(param_3, "lines");
         if (bVar3) {
            *(undefined4*)( param_2 + 0x58 ) = 2;
            return;
         }

         if (uVar10 == 3) {
            bVar3 = std::operator ==(param_3, "line_strip");
            if (bVar3) {
               *(undefined4*)( param_2 + 0x58 ) = 4;
               return;
            }

            bVar3 = std::operator ==(param_3, "lines_adjacency");
            if (bVar3) {
               *(undefined4*)( param_2 + 0x58 ) = 3;
               return;
            }

            bVar3 = std::operator ==(param_3, "triangles_adjacency");
            if (bVar3) {
               *(undefined4*)( param_2 + 0x58 ) = 6;
               return;
            }

            bVar3 = std::operator ==(param_3, "triangle_strip");
            if (bVar3) {
               *(undefined4*)( param_2 + 0x58 ) = 7;
               return;
            }

            bVar3 = std::operator ==(param_3, "passthrough");
            if (bVar3) {
               ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_SPV_NV_geometry_shader_passthrough, "geometry shader passthrough");
               lVar2 = *(long*)( this + 0x38 );
               param_2[0x37] = (TPublicType)0x1;
               *(undefined1*)( lVar2 + 0x362 ) = 1;
               return;
            }

            goto LAB_0013c3a3;
         }

      }
 else {
         bVar3 = std::operator ==(param_3, "quads");
         if (bVar3) {
            *(undefined4*)( param_2 + 0x58 ) = 8;
            return;
         }

         bVar3 = std::operator ==(param_3, "isolines");
         if (bVar3) {
            *(undefined4*)( param_2 + 0x58 ) = 9;
            return;
         }

         bVar3 = std::operator ==(param_3, "equal_spacing");
         if (bVar3) {
            *(undefined4*)( param_2 + 0x68 ) = 1;
            return;
         }

         bVar3 = std::operator ==(param_3, "fractional_even_spacing");
         if (bVar3) {
            *(undefined4*)( param_2 + 0x68 ) = 2;
            return;
         }

         bVar3 = std::operator ==(param_3, "fractional_odd_spacing");
         if (bVar3) {
            *(undefined4*)( param_2 + 0x68 ) = 3;
            return;
         }

         bVar3 = std::operator ==(param_3, "cw");
         if (bVar3) {
            *(undefined4*)( param_2 + 0x6c ) = 1;
            return;
         }

         bVar3 = std::operator ==(param_3, "ccw");
         if (bVar3) {
            *(undefined4*)( param_2 + 0x6c ) = 2;
            return;
         }

         bVar3 = std::operator ==(param_3, "point_mode");
         if (bVar3) {
            param_2[0x70] = (TPublicType)0x1;
            return;
         }

      }

      if (3 < uVar10) goto LAB_0013be8c;
   }
 else {
      if (uVar10 == 4) {
         bVar3 = std::operator ==(param_3, "origin_upper_left");
         if (bVar3) {
            glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar13, (char*)0x7);
            if (*(int*)( this + 0xc ) == 1) {
               glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 6, (char*)0x8c, "GL_ARB_fragment_coord_conventions");
            }

            param_2[0x5d] = (TPublicType)0x1;
            return;
         }

         bVar3 = std::operator ==(param_3, "pixel_center_integer");
         if (bVar3) {
            glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar13, (char*)0x7);
            if (*(int*)( this + 0xc ) == 1) {
               glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 6, (char*)0x8c, "GL_ARB_fragment_coord_conventions");
            }

            param_2[0x5c] = (TPublicType)0x1;
            return;
         }

         bVar3 = std::operator ==(param_3, "early_fragment_tests");
         if (bVar3) {
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 7, (char*)0x1a4, "GL_ARB_shader_image_load_store");
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 8, (char*)0x136, (char*)0x0);
            param_2[0x90] = (TPublicType)0x1;
            return;
         }

         bVar3 = std::operator ==(param_3, "early_and_late_fragment_tests_amd");
         if (bVar3) {
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 7, (char*)0x1a4, "GL_AMD_shader_early_and_late_fragment_tests");
            glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 8, (char*)0x136, (char*)0x0);
            param_2[0x92] = (TPublicType)0x1;
            return;
         }

         bVar3 = std::operator ==(param_3, "post_depth_coverage");
         if (bVar3) {
            ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 2, post_depth_coverageEXTs, "post depth coverage");
            cVar4 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_ARB_post_depth_coverage");
            if (cVar4 != '\0') {
               param_2[0x90] = (TPublicType)0x1;
            }

            param_2[0x91] = (TPublicType)0x1;
            return;
         }

         bVar3 = std::operator ==(param_3, "non_coherent_color_attachment_readext");
         if (bVar3) {
            ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_EXT_shader_tile_image, "non_coherent_color_attachment_readEXT");
            param_2[0x93] = (TPublicType)0x1;
            return;
         }

         bVar3 = std::operator ==(param_3, "non_coherent_depth_attachment_readext");
         if (bVar3) {
            ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_EXT_shader_tile_image, "non_coherent_depth_attachment_readEXT");
            param_2[0x94] = (TPublicType)0x1;
            return;
         }

         bVar3 = std::operator ==(param_3, "non_coherent_stencil_attachment_readext");
         if (bVar3) {
            ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_EXT_shader_tile_image, "non_coherent_stencil_attachment_readEXT");
            param_2[0x95] = (TPublicType)0x1;
            return;
         }

         bVar3 = std::operator ==(param_3, "depth_any");
         if (bVar3) {
            local_40 = 1;
         }
 else {
            bVar3 = std::operator ==(param_3, "depth_greater");
            if (bVar3) {
               local_40 = 2;
            }
 else {
               bVar3 = std::operator ==(param_3, "depth_less");
               if (bVar3) {
                  local_40 = 3;
               }
 else {
                  bVar3 = std::operator ==(param_3, "depth_unchanged");
                  local_40 = 4;
                  if (!bVar3) {
                     iVar5 = 1;
                     LAB_0013c2a0:do {
                        switch (iVar5) {
                           case 2:
                  pcVar6 = "stencil_ref_greater_front_amd";
                  goto LAB_0013c5f2;
                           case 3:
                  pcVar6 = "stencil_ref_less_front_amd";
                  break;
                           case 4:
                  pcVar6 = "stencil_ref_unchanged_back_amd";
                  break;
                           case 5:
                  pcVar6 = "stencil_ref_greater_back_amd";
                  break;
                           case 6:
                  pcVar6 = "stencil_ref_less_back_amd";
LAB_0013c5f2:
                  bVar3 = std::operator==(param_3,pcVar6);
                  if (bVar3) {
LAB_0013c5a1:
                    glslang::TParseVersions::requireProfile((TSourceLoc *)this,iVar13,(char *)0x6);
                    glslang::TParseVersions::profileRequires
                              ((TSourceLoc *)this,iVar13,6,(char *)0x1a4,(char *)0x0);
                    *(int *)(param_2 + 0x9c) = iVar5;
                    return;
                  }
                  if (iVar5 == 6) {
                    iVar5 = 1;
                    do {
                      switch(iVar5) {
                      case 2:
                        pcVar6 = "pixel_interlock_unordered";
                        break;
                      case 3:
                        pcVar6 = "sample_interlock_ordered";
                        break;
                      case 4:
                        pcVar6 = "sample_interlock_unordered";
                        break;
                      case 5:
                        pcVar6 = "shading_rate_interlock_ordered";
                        break;
                      case 6:
                        pcVar6 = "shading_rate_interlock_unordered";
                        break;
                      default:
                        pcVar6 = "pixel_interlock_ordered";
                      }
                      bVar3 = std::operator==(param_3,pcVar6);
                      if (bVar3) {
                        glslang::TParseVersions::requireProfile
                                  ((TSourceLoc *)this,iVar13,(char *)0x6);
                        glslang::TParseVersions::profileRequires
                                  ((TSourceLoc *)this,iVar13,6,(char *)0x1c2,(char *)0x0);
                        (**(code **)(*(long *)this + 0x28))
                                  (this,param_1,1,&E_GL_ARB_fragment_shader_interlock,pcVar6);
                        if (iVar5 - 5U < 2) {
                          (**(code **)(*(long *)this + 0x28))
                                    (this,param_1,1,&E_GL_NV_shading_rate_image,pcVar6);
                        }
                        *(int *)(param_2 + 0xa8) = iVar5;
                        return;
                      }
                      iVar5 = iVar5 + 1;
                    } while (iVar5 != 7);
                    iVar5 = std::__cxx11::
                            basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>
                            ::compare(*(ulong *)(param_3 + 8),__n,(char *)0x0);
                    if (iVar5 == 0) {
                      iVar5 = 0;
                      do {
                        pcVar6 = (char *)TQualifier::getBlendEquationString(iVar5);
                        bVar3 = std::operator==(param_3,pcVar6);
                        if (bVar3) {
                          glslang::TParseVersions::profileRequires
                                    ((TSourceLoc *)this,iVar13,8,(char *)0x140,
                                     "GL_KHR_blend_equation_advanced");
                          glslang::TParseVersions::profileRequires
                                    ((TSourceLoc *)this,iVar13,-9,(char *)0x0,
                                     "GL_KHR_blend_equation_advanced");
                          *(uint *)(*(long *)(this + 0x38) + 0x33c) =
                               *(uint *)(*(long *)(this + 0x38) + 0x33c) | 1 << ((byte)iVar5 & 0x1f)
                          ;
                          param_2[0xa0] = (TPublicType)0x1;
                          return;
                        }
                        iVar5 = iVar5 + 1;
                      } while (iVar5 != 0x10);
                      pcVar6 = "blend_support";
                      pcVar11 = "unknown blend equation";
                      UNRECOVERED_JUMPTABLE = *(code **)(*(long *)this + 0x158);
                      goto LAB_0013bed8;
                    }
                    bVar3 = std::operator==(param_3,"override_coverage");
                    if (bVar3) {
                      (**(code **)(*(long *)this + 0x28))
                                (this,param_1,1,&E_GL_NV_sample_mask_override_coverage,
                                 "sample mask override coverage");
                      param_2[0xac] = (TPublicType)0x1;
                      return;
                    }
                    bVar3 = std::operator==(param_3,"full_quads");
                    if (bVar3) {
                      glslang::TParseVersions::requireProfile((TSourceLoc *)this,iVar13,(char *)0xe)
                      ;
                      glslang::TParseVersions::profileRequires
                                ((TSourceLoc *)this,iVar13,6,(char *)0x8c,
                                 "GL_EXT_shader_quad_control");
                      glslang::TParseVersions::profileRequires
                                ((TSourceLoc *)this,iVar13,8,(char *)0x136,
                                 "GL_EXT_shader_quad_control");
                      param_2[0x41] = (TPublicType)0x1;
                      return;
                    }
                    goto LAB_0013be8c;
                  }
                  iVar5 = 3;
                  goto LAB_0013c2a0;
                           default:
                  pcVar6 = "stencil_ref_unchanged_front_amd";
                        }

                        bVar3 = std::operator ==(param_3, pcVar6);
                        if (bVar3) goto LAB_0013c5a1;
                        iVar5 = iVar5 + 1;
                     }
 while ( true );
                  }

               }

            }

         }

         glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar13, (char*)0x6);
         glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 6, (char*)0x1a4, (char*)0x0);
         *(undefined4*)( param_2 + 0x98 ) = local_40;
         return;
      }

      if (3 < uVar10) {
         if (uVar10 - 6 < 6) {
            bVar3 = std::operator ==(param_3, "shaderrecordnv");
            if (bVar3) {
               ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_NV_ray_tracing, "shader record NV");
            }
 else {
               bVar3 = std::operator ==(param_3, "shaderrecordext");
               if (!bVar3) {
                  bVar3 = std::operator ==(param_3, "hitobjectshaderrecordnv");
                  if (bVar3) {
                     ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_NV_shader_invocation_reorder, "hitobject shader record NV");
                     param_2[0x43] = (TPublicType)0x1;
                     return;
                  }

                  goto LAB_0013be8c;
               }

               ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_EXT_ray_tracing, "shader record EXT");
            }

            param_2[0x40] = (TPublicType)0x1;
            return;
         }

         if (( uVar10 == 5 ) && ( iVar5 = std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::compare(*(ulong*)( param_3 + 8 ), __n, (char*)0x0) ),iVar5 == 0) {
            ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_NV_compute_shader_derivatives, "compute shader derivatives");
            bVar3 = std::operator ==(param_3, "derivative_group_quadsnv");
            if (bVar3) {
               param_2[0xad] = (TPublicType)0x1;
               return;
            }

            bVar3 = std::operator ==(param_3, "derivative_group_linearnv");
            if (bVar3) {
               param_2[0xae] = (TPublicType)0x1;
               return;
            }

         }

         goto LAB_0013be8c;
      }

   }

   LAB_0013c3a3:bVar3 = std::operator ==(param_3, "viewport_relative");
   if (bVar3) {
      ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_NV_viewport_array2, "view port array2");
      param_2[0x38] = (TPublicType)0x1;
      return;
   }

   LAB_0013be8c:bVar3 = std::operator ==(param_3, "primitive_culling");
   if (bVar3) {
      ( **(code**)( *(long*)this + 0x28 ) )(this, param_1, 1, &E_GL_EXT_ray_flags_primitive_culling, "primitive culling");
      param_2[0xb4] = (TPublicType)0x1;
   }
 else {
      bVar3 = std::operator ==(param_3, "quad_derivatives");
      if (!bVar3) {
         pcVar6 = *(char**)( param_3 + 8 );
         pcVar11 = "unrecognized layout identifier, or qualifier requires assignment (e.g., binding = 4)";
         UNRECOVERED_JUMPTABLE = *(code**)( *(long*)this + 0x158 );
         LAB_0013bed8:/* WARNING: Could not recover jumptable at 0x0013beee. Too many branches *//* WARNING: Treating indirect jump as call */( *UNRECOVERED_JUMPTABLE )(this, param_1, pcVar11, pcVar6, &_LC1, UNRECOVERED_JUMPTABLE);
         return;
      }

      glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar13, (char*)0xe);
      glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 6, (char*)0x8c, "GL_EXT_shader_quad_control");
      glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar13, 8, (char*)0x136, "GL_EXT_shader_quad_control");
      param_2[0x42] = (TPublicType)0x1;
   }

   return;
}
/* glslang::TParseContext::handleConstructorCall(glslang::TSourceLoc const&, glslang::TPublicType
   const&) */undefined8 * __thiscall
glslang::TParseContext::handleConstructorCall
          (TParseContext *this,TSourceLoc *param_1,TPublicType *param_2){
   undefined8 *puVar1;
   basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *this_00;
   void *__s2;
   TType *pTVar2;
   char cVar3;
   int iVar4;
   ulong uVar5;
   undefined8 *puVar6;
   undefined8 uVar7;
   undefined8 uVar8;
   TType *pTVar9;
   ulong uVar10;
   long lVar11;
   char *pcVar12;
   ulong uVar13;
   TType *pTVar14;
   undefined8 *puVar15;
   TType *pTVar16;
   TType *pTVar17;
   long in_FS_OFFSET;
   bool bVar18;
   TParseContext *local_110;
   TType local_108[8];
   undefined4 local_100;
   undefined8 local_f8;
   ulong uStack_f0;
   uint local_e8;
   undefined4 uStack_e4;
   undefined4 uStack_e0;
   uint uStack_dc;
   ulong local_d8;
   ulong uStack_d0;
   uint local_c8;
   undefined4 uStack_c4;
   undefined4 uStack_c0;
   undefined4 uStack_bc;
   undefined8 local_b8;
   undefined2 uStack_b0;
   undefined6 uStack_ae;
   undefined1 local_a8[16];
   undefined1 local_98[16];
   undefined4 local_88;
   undefined1 local_80[16];
   undefined8 local_68;
   char *local_60;
   ulong local_58;
   char local_50[16];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   TType::TType(local_108, param_2);
   uStack_f0 = uStack_f0 & 0xfffffffff1ffffff;
   if (local_a8._0_8_ != 0) {
      glslang::TParseVersions::profileRequires((TSourceLoc*)this, (int)param_1, 1, (char*)0x78, "GL_3DL_array_objects");
      glslang::TParseVersions::profileRequires((TSourceLoc*)this, (int)param_1, 8, (char*)0x12c, (char*)0x0);
   }

   if (( ( (char)local_100 != '\x0e' ) || ( ( local_88 & 0x80000 ) == 0 ) ) || ( ( byte )(local_88._1_1_ - 7U) < 2 )) {
      pTVar16 = *(TType**)( this + 0x38 );
      goto LAB_0013ccd1;
   }

   cVar3 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_ARB_bindless_texture");
   pTVar16 = *(TType**)( this + 0x38 );
   if (cVar3 == '\0') goto LAB_0013ccd1;
   pTVar17 = pTVar16 + 0x560;
   if (*(TType**)( pTVar16 + 0x568 ) == (TType*)0x0) {
      LAB_0013d39a:local_110 = this + 0x7510;
      pTVar9 = (TType*)std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>::_M_emplace_hint_unique<std::piecewise_construct_t_const&,std::tuple<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const&>,std::tuple<>>(pTVar16 + 0x558, pTVar17, &local_110);
      pTVar16 = *(TType**)( this + 0x38 );
   }
 else {
      __s2 = *(void**)( this + 0x7518 );
      uVar5 = *(ulong*)( this + 0x7520 );
      pTVar2 = *(TType**)( pTVar16 + 0x568 );
      pTVar9 = pTVar17;
      do {
         while (true) {
            pTVar14 = pTVar2;
            uVar13 = *(ulong*)( pTVar14 + 0x30 );
            uVar10 = uVar5;
            if (uVar13 <= uVar5) {
               uVar10 = uVar13;
            }

            if (( uVar10 != 0 ) && ( iVar4 = memcmp(*(void**)( pTVar14 + 0x28 ), __s2, uVar10) ),iVar4 != 0) break;
            lVar11 = uVar13 - uVar5;
            if (lVar11 < 0x80000000) {
               if (-0x80000001 < lVar11) {
                  iVar4 = (int)lVar11;
                  break;
               }

               goto LAB_0013d2d8;
            }

            LAB_0013d329:pTVar2 = *(TType**)( pTVar14 + 0x10 );
            pTVar9 = pTVar14;
            if (*(TType**)( pTVar14 + 0x10 ) == (TType*)0x0) goto LAB_0013d335;
         }
;
         if (-1 < iVar4) goto LAB_0013d329;
         LAB_0013d2d8:pTVar2 = *(TType**)( pTVar14 + 0x18 );
      }
 while ( *(TType**)( pTVar14 + 0x18 ) != (TType*)0x0 );
      LAB_0013d335:bVar18 = pTVar17 == pTVar9;
      pTVar17 = pTVar9;
      if (bVar18) goto LAB_0013d39a;
      uVar13 = *(ulong*)( pTVar9 + 0x30 );
      uVar10 = uVar5;
      if (uVar13 <= uVar5) {
         uVar10 = uVar13;
      }

      if (( uVar10 == 0 ) || ( iVar4 = memcmp(__s2, *(void**)( pTVar9 + 0x28 ), uVar10) ),iVar4 == 0) {
         lVar11 = uVar5 - uVar13;
         if (lVar11 < 0x80000000) {
            if (lVar11 < -0x80000000) goto LAB_0013d39a;
            iVar4 = (int)lVar11;
            goto LAB_0013d396;
         }

      }
 else {
         LAB_0013d396:if (iVar4 < 0) goto LAB_0013d39a;
      }

   }

   *(undefined4*)( pTVar9 + 0x48 ) = 1;
   LAB_0013ccd1:iVar4 = glslang::TIntermediate::mapTypeToConstructorOp(pTVar16);
   if (iVar4 == 0) {
      if (( *(char*)( *(long*)( this + 0x38 ) + 0x26f ) == '\0' ) || ( (char)local_100 != '\x0e' )) {
         switch ((char)local_100) {
            case '\0':
        pcVar12 = "void";
        break;
            case '\x01':
        pcVar12 = "float";
        break;
            case '\x02':
        pcVar12 = "double";
        break;
            case '\x03':
        pcVar12 = "float16_t";
        break;
            case '\x04':
        pcVar12 = "int8_t";
        break;
            case '\x05':
        pcVar12 = "uint8_t";
        break;
            case '\x06':
        pcVar12 = "int16_t";
        break;
            case '\a':
        pcVar12 = "uint16_t";
        break;
            case '\b':
        pcVar12 = "int";
        break;
            case '\t':
        pcVar12 = "uint";
        break;
            case '\n':
        pcVar12 = "int64_t";
        break;
            case '\v':
        pcVar12 = "uint64_t";
        break;
            case '\f':
        pcVar12 = "bool";
        break;
            case '\r':
        pcVar12 = "atomic_uint";
        break;
            case '\x0e':
        pcVar12 = "sampler/image";
        break;
            case '\x0f':
        pcVar12 = "structure";
        break;
            case '\x10':
        pcVar12 = "block";
        break;
            case '\x11':
        pcVar12 = "accelerationStructureNV";
        break;
            case '\x12':
        pcVar12 = "reference";
        break;
            case '\x13':
        pcVar12 = "rayQueryEXT";
        break;
            default:
        pcVar12 = "unknown type";
        break;
            case '\x15':
        pcVar12 = "coopmat";
        break;
            case '\x16':
        pcVar12 = "spirv_type";
        break;
            case '\x17':
        pcVar12 = "string";
         }

         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot construct this type", pcVar12, &_LC1);
      }
 else {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "function not supported in this version; use texture() instead", "texture*D*", &_LC1);
      }

      uStack_f0 = uStack_f0 & 0x8000000400000000;
      local_100 = CONCAT31(local_100._1_3_, 1);
      iVar4 = 0x1e4;
      local_e8 = local_e8 & 0xfffffff0;
      uStack_dc = uStack_dc & 0xffc00000 | 0x1fcfff;
      uStack_e4 = (undefined4)_LC291;
      uStack_e0 = ( undefined4 )((ulong)_LC291 >> 0x20);
      local_d8 = local_d8 | 0x7fffffffffffffff;
      local_88 = local_88 & 0x9fc00000;
      local_f8 = 0;
      uStack_d0 = ( ulong )((uint)uStack_d0 & 0xfe000000) | 0x1ffffff;
      local_c8 = local_c8 & 0xffffff00;
      uStack_c4 = 0xfffff800;
      uStack_c0 = 0;
      uStack_bc = 0xffffffff;
      uStack_b0 = 0;
      local_100 = CONCAT22((short)( ( local_100 & 0xf80000ff ) >> 0x10 ), CONCAT11(1, (char)( local_100 & 0xf80000ff )));
      local_a8 = (undefined1[16])0x0;
      local_b8 = 0;
      local_98 = (undefined1[16])0x0;
      local_80 = (undefined1[16])0x0;
   }

   uVar8 = _LC291;
   local_68 = glslang::GetThreadPoolAllocator();
   local_60 = local_50;
   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, &_LC1, &_LC1);
   uVar5 = glslang::GetThreadPoolAllocator();
   puVar6 = (undefined8*)glslang::TPoolAllocator::allocate(uVar5);
   puVar6[2] = 0;
   puVar6[3] = 0;
   puVar1 = puVar6 + 0x20;
   *(undefined1*)( puVar6 + 4 ) = 1;
   *puVar6 = &TIntermSwitch::vtable;
   puVar6[1] = &local_68;
   uVar7 = glslang::GetThreadPoolAllocator();
   pcVar12 = local_60;
   *(undefined8*)( (long)puVar6 + 0x6c ) = uVar8;
   puVar6[5] = uVar7;
   puVar6[9] = &PTR__TType_00167f00;
   *(undefined1(*) [16])( puVar6 + 0x1a ) = (undefined1[16])0x0;
   *(byte*)( puVar6 + 0xd ) = *(byte*)( puVar6 + 0xd ) & 0xf0;
   *(undefined1(*) [16])( puVar6 + 0x15 ) = (undefined1[16])0x0;
   *(uint*)( puVar6 + 10 ) = CONCAT22((short)( ( uint ) * (undefined4*)( puVar6 + 10 ) >> 0x10 ), 0x100) & 0xf800ffff;
   *(undefined1(*) [16])( puVar6 + 0x17 ) = (undefined1[16])0x0;
   *(ulong*)( (long)puVar6 + 0x75 ) = *(ulong*)( (long)puVar6 + 0x75 ) & 0xffffff0000ffc07f | 0xffff001f80;
   puVar6[6] = 0;
   puVar6[0x10] = CONCAT71(( uint7 )((ulong)puVar6[0x10] >> 8) & 0xffffffff, 0xff);
   *(undefined8*)( (long)puVar6 + 0x8c ) = 0xfffff800;
   *(undefined2*)( puVar6 + 0x14 ) = 0;
   puVar6[7] = 0;
   *(ulong*)( (long)puVar6 + 0x74 ) = *(ulong*)( (long)puVar6 + 0x74 ) & 0xffffffff8000 | 0xffff000000004fff;
   *(ulong*)( (long)puVar6 + 0x7c ) = *(ulong*)( (long)puVar6 + 0x7c ) | 0x1ffff007fffffff;
   puVar6[0xc] = puVar6[0xc] & 0x8000000400000000;
   this_00 = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( puVar6 + 0x1d );
   *(uint*)( puVar6 + 0x19 ) = *(uint*)( puVar6 + 0x19 ) & 0x9fc00000;
   puVar6[8] = 0;
   puVar6[0xb] = 0;
   *(undefined1*)( puVar6 + 0x11 ) = 0;
   *(undefined1*)( (long)puVar6 + 0x84 ) = 0;
   *(undefined4*)( (long)puVar6 + 0x94 ) = 0xffffffff;
   puVar6[0x13] = 0;
   local_110 = (TParseContext*)CONCAT71(local_110._1_7_, 0x28);
   uVar8 = glslang::GetThreadPoolAllocator();
   puVar6[0x1e] = puVar1;
   puVar6[0x1d] = uVar8;
   puVar6[0x1f] = 0;
   *(undefined1*)( puVar6 + 0x20 ) = 0;
   std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::reserve(this_00, local_58 + 1);
   uVar5 = puVar6[0x1f];
   if (local_58 <= 0x7fffffffffffffff - uVar5) {
      puVar15 = (undefined8*)puVar6[0x1e];
      uVar13 = local_58 + uVar5;
      if (puVar1 == puVar15) {
         uVar10 = 0xf;
      }
 else {
         uVar10 = puVar6[0x20];
      }

      if (uVar10 < uVar13) {
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(this_00, uVar5, 0, pcVar12, local_58);
         puVar15 = (undefined8*)puVar6[0x1e];
      }
 else if (local_58 != 0) {
         if (local_58 == 1) {
            *(char*)( (long)puVar15 + uVar5 ) = *pcVar12;
            puVar15 = (undefined8*)puVar6[0x1e];
         }
 else {
            memcpy((char*)( (long)puVar15 + uVar5 ), pcVar12, local_58);
            puVar15 = (undefined8*)puVar6[0x1e];
         }

      }

      puVar6[0x1f] = uVar13;
      *(undefined1*)( (long)puVar15 + uVar13 ) = 0;
      uVar5 = puVar6[0x1f];
      if (uVar5 != 0x7fffffffffffffff) {
         if (puVar1 == (undefined8*)puVar6[0x1e]) {
            uVar13 = 0xf;
         }
 else {
            uVar13 = puVar6[0x20];
         }

         if (uVar13 < uVar5 + 1) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(this_00, uVar5, 0, (char*)&local_110, 1);
         }
 else {
            *(undefined1*)( (long)puVar6[0x1e] + uVar5 ) = local_110._0_1_;
         }

         puVar6[0x1f] = uVar5 + 1;
         *(undefined1*)( puVar6[0x1e] + 1 + uVar5 ) = 0;
         *(int*)( puVar6 + 0x22 ) = iVar4;
         *(undefined8*)( (long)puVar6 + 0x114 ) = 0;
         uVar8 = glslang::GetThreadPoolAllocator();
         *(undefined1*)( puVar6 + 0x27 ) = 0;
         puVar6[0x24] = uVar8;
         puVar6[0x25] = puVar6 + 0x27;
         puVar6[0x26] = 0;
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( puVar6 + 0x24 ), "");
         *(undefined4*)( puVar6 + 0x29 ) = 0xffffffff;
         *(undefined4*)( puVar6 + 0x2a ) = 0;
         puVar6[0xb] = local_f8;
         puVar6[0xc] = uStack_f0;
         *(uint*)( puVar6 + 0x19 ) = local_88;
         puVar6[0xd] = CONCAT44(uStack_e4, local_e8);
         puVar6[0xe] = CONCAT44(uStack_dc, uStack_e0);
         puVar6[0xf] = local_d8;
         puVar6[0x10] = uStack_d0;
         puVar6[0x11] = CONCAT44(uStack_c4, local_c8);
         puVar6[0x12] = CONCAT44(uStack_bc, uStack_c0);
         *(uint*)( puVar6 + 10 ) = *(uint*)( puVar6 + 10 ) & 0xffe00000 | local_100 & 0x1fffff;
         puVar6[0x13] = local_b8;
         puVar6[0x14] = CONCAT62(uStack_ae, uStack_b0);
         puVar6[0x15] = local_a8._0_8_;
         puVar6[0x17] = local_98._0_8_;
         puVar6[0x18] = local_98._8_8_;
         puVar6[0x16] = local_a8._8_8_;
         puVar6[0x1a] = local_80._0_8_;
         puVar6[0x1b] = local_80._8_8_;
         *(ushort*)( (long)puVar6 + 0x52 ) = *(ushort*)( (long)puVar6 + 0x52 ) & 0xf81f | local_100._2_2_ & 0x7e0;
         *(uint*)( puVar6 + 0x1c ) = ( uint )((ushort)uStack_f0 >> 7);
         if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return puVar6;
         }

         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

   }

   /* WARNING: Subroutine does not return */
   std::__throw_length_error("basic_string::append");
}
/* glslang::TParseContext::updateBindlessQualifier(glslang::TType&) */void glslang::TParseContext::updateBindlessQualifier(TParseContext *this, TType *param_1) {
   long *plVar1;
   void *pvVar2;
   ulong uVar3;
   char cVar4;
   int iVar5;
   long lVar6;
   long lVar7;
   code *pcVar8;
   TType *pTVar9;
   long lVar10;
   long lVar11;
   ulong uVar12;
   ulong uVar13;
   long lVar14;
   long in_FS_OFFSET;
   bool bVar15;
   TParseContext *local_48;
   long local_40;
   lVar11 = *(long*)param_1;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(code**)( lVar11 + 0x1b8 ) == TType::containsSampler) {
      if (*(code**)( lVar11 + 0x168 ) == TType::isTexture) {
         if (param_1[8] == (TType)0xe) {
            if (*(code**)( lVar11 + 0x40 ) == TType::getSampler) {
               pTVar9 = param_1 + 0x80;
            }
 else {
               pTVar9 = (TType*)( **(code**)( lVar11 + 0x40 ) )(param_1);
               lVar11 = *(long*)param_1;
            }

            if (( ( (byte)pTVar9[2] & 0x20 ) != 0 ) || ( ( (byte)pTVar9[2] & 8 ) != 0 )) goto LAB_0013d6f7;
         }
 else {
            pcVar8 = *(code**)( lVar11 + 0x158 );
            if (pcVar8 == TType::isImage) goto LAB_0013d686;
            LAB_0013d9b0:cVar4 = ( *pcVar8 )(param_1);
            lVar11 = *(long*)param_1;
            if (cVar4 == '\0') goto LAB_0013d686;
         }

      }
 else {
         cVar4 = ( **(code**)( lVar11 + 0x168 ) )(param_1);
         lVar11 = *(long*)param_1;
         if (cVar4 == '\0') {
            LAB_0013d6f7:pcVar8 = *(code**)( lVar11 + 0x158 );
            if (pcVar8 != TType::isImage) goto LAB_0013d9b0;
            if (param_1[8] == (TType)0xe) {
               if (*(code**)( lVar11 + 0x40 ) == TType::getSampler) {
                  pTVar9 = param_1 + 0x80;
               }
 else {
                  pTVar9 = (TType*)( **(code**)( lVar11 + 0x40 ) )(param_1);
                  lVar11 = *(long*)param_1;
               }

               if (( ( (byte)pTVar9[2] & 8 ) != 0 ) && ( 1 < ( byte )((char)pTVar9[1] - 7U) )) goto LAB_0013d767;
            }

            LAB_0013d686:if (*(code**)( lVar11 + 0x128 ) == TType::isStruct) {
               if (1 < ( byte )((char)param_1[8] - 0xfU)) goto LAB_0013d6ad;
            }
 else {
               cVar4 = ( **(code**)( lVar11 + 0x128 ) )(param_1);
               if (cVar4 == '\0') goto LAB_0013d6ad;
            }

            lVar11 = *(long*)( *(long*)( param_1 + 0x68 ) + 0x10 );
            lVar7 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSampler()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsSampler ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_1 + 0x68 ) + 8 ),lVar11 ));
            if (lVar11 == lVar7) goto LAB_0013d6ad;
            lVar11 = *(long*)param_1;
         }

      }

   }
 else {
      cVar4 = ( **(code**)( lVar11 + 0x1b8 ) )(param_1);
      if (cVar4 == '\0') goto LAB_0013d6ad;
      lVar11 = *(long*)param_1;
   }

   LAB_0013d767:if (*(code**)( lVar11 + 0x128 ) == TType::isStruct) {
      if (1 < ( byte )((char)param_1[8] - 0xfU)) {
         LAB_0013d7dc:if (*(code**)( lVar11 + 0x48 ) == TType::getSampler) {
            pTVar9 = param_1 + 0x80;
         }
 else {
            pTVar9 = (TType*)( **(code**)( lVar11 + 0x48 ) )(param_1);
         }

         lVar11 = *(long*)( this + 0x38 );
         if (( ( (byte)pTVar9[2] & 8 ) != 0 ) && ( 1 < ( byte )((char)pTVar9[1] - 7U) )) {
            lVar7 = lVar11 + 0x560;
            lVar14 = lVar7;
            if (*(long*)( lVar11 + 0x568 ) == 0) {
               LAB_0013da82:local_48 = this + 0x7510;
               lVar14 = std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>::_M_emplace_hint_unique<std::piecewise_construct_t_const&,std::tuple<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const&>,std::tuple<>>(lVar11 + 0x558, lVar14, &local_48);
            }
 else {
               pvVar2 = *(void**)( this + 0x7518 );
               uVar12 = *(ulong*)( this + 0x7520 );
               lVar6 = *(long*)( lVar11 + 0x568 );
               do {
                  uVar3 = *(ulong*)( lVar6 + 0x30 );
                  uVar13 = uVar12;
                  if (uVar3 <= uVar12) {
                     uVar13 = uVar3;
                  }

                  if (( uVar13 == 0 ) || ( iVar5 = memcmp(*(void**)( lVar6 + 0x28 ), pvVar2, uVar13) ),iVar5 == 0) {
                     lVar10 = uVar3 - uVar12;
                     if (0x7fffffff < lVar10) goto LAB_0013da57;
                     if (-0x80000001 < lVar10) {
                        iVar5 = (int)lVar10;
                        goto LAB_0013da53;
                     }

                     LAB_0013da00:lVar10 = *(long*)( lVar6 + 0x18 );
                  }
 else {
                     LAB_0013da53:if (iVar5 < 0) goto LAB_0013da00;
                     LAB_0013da57:lVar10 = *(long*)( lVar6 + 0x10 );
                     lVar14 = lVar6;
                  }

                  lVar6 = lVar10;
               }
 while ( lVar10 != 0 );
               if (lVar7 == lVar14) goto LAB_0013da82;
               uVar3 = *(ulong*)( lVar14 + 0x30 );
               uVar13 = uVar12;
               if (uVar3 <= uVar12) {
                  uVar13 = uVar3;
               }

               if (( uVar13 == 0 ) || ( iVar5 = memcmp(pvVar2, *(void**)( lVar14 + 0x28 ), uVar13) ),iVar5 == 0) {
                  lVar7 = uVar12 - uVar3;
                  if (lVar7 < 0x80000000) {
                     if (lVar7 < -0x80000000) goto LAB_0013da82;
                     iVar5 = (int)lVar7;
                     goto LAB_0013db2b;
                  }

               }
 else {
                  LAB_0013db2b:if (iVar5 < 0) goto LAB_0013da82;
               }

            }

            lVar11 = *(long*)param_1;
            *(undefined4*)( lVar14 + 0x48 ) = 2;
            if (*(code**)( lVar11 + 0x50 ) == TType::getQualifier) {
               pTVar9 = param_1 + 0x10;
            }
 else {
               pTVar9 = (TType*)( **(code**)( lVar11 + 0x50 ) )(param_1);
            }

            pTVar9[0x49] = (TType)0x1;
            goto LAB_0013d6ad;
         }

         lVar7 = lVar11 + 0x530;
         if (*(long*)( lVar11 + 0x538 ) == 0) {
            LAB_0013d8fa:local_48 = this + 0x7510;
            lVar6 = std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>::_M_emplace_hint_unique<std::piecewise_construct_t_const&,std::tuple<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const&>,std::tuple<>>(lVar11 + 0x528, lVar7, &local_48);
         }
 else {
            pvVar2 = *(void**)( this + 0x7518 );
            uVar12 = *(ulong*)( this + 0x7520 );
            lVar6 = lVar7;
            lVar14 = *(long*)( lVar11 + 0x538 );
            do {
               while (true) {
                  uVar3 = *(ulong*)( lVar14 + 0x30 );
                  uVar13 = uVar12;
                  if (uVar3 <= uVar12) {
                     uVar13 = uVar3;
                  }

                  if (( uVar13 != 0 ) && ( iVar5 = memcmp(*(void**)( lVar14 + 0x28 ), pvVar2, uVar13) ),iVar5 != 0) break;
                  lVar10 = uVar3 - uVar12;
                  if (lVar10 < 0x80000000) {
                     if (-0x80000001 < lVar10) {
                        iVar5 = (int)lVar10;
                        break;
                     }

                     goto LAB_0013d850;
                  }

                  LAB_0013d8a3:plVar1 = (long*)( lVar14 + 0x10 );
                  lVar6 = lVar14;
                  lVar14 = *plVar1;
                  if (*plVar1 == 0) goto LAB_0013d8af;
               }
;
               if (-1 < iVar5) goto LAB_0013d8a3;
               LAB_0013d850:lVar14 = *(long*)( lVar14 + 0x18 );
            }
 while ( lVar14 != 0 );
            LAB_0013d8af:bVar15 = lVar7 == lVar6;
            lVar7 = lVar6;
            if (bVar15) goto LAB_0013d8fa;
            uVar3 = *(ulong*)( lVar6 + 0x30 );
            uVar13 = uVar12;
            if (uVar3 <= uVar12) {
               uVar13 = uVar3;
            }

            if (( uVar13 == 0 ) || ( iVar5 = memcmp(pvVar2, *(void**)( lVar6 + 0x28 ), uVar13) ),iVar5 == 0) {
               lVar14 = uVar12 - uVar3;
               if (lVar14 < 0x80000000) {
                  if (lVar14 < -0x80000000) goto LAB_0013d8fa;
                  iVar5 = (int)lVar14;
                  goto LAB_0013d8f6;
               }

            }
 else {
               LAB_0013d8f6:if (iVar5 < 0) goto LAB_0013d8fa;
            }

         }

         lVar11 = *(long*)param_1;
         *(undefined4*)( lVar6 + 0x48 ) = 2;
         if (*(code**)( lVar11 + 0x50 ) == TType::getQualifier) {
            pTVar9 = param_1 + 0x10;
         }
 else {
            pTVar9 = (TType*)( **(code**)( lVar11 + 0x50 ) )(param_1);
         }

         pTVar9[0x48] = (TType)0x1;
         goto LAB_0013d6ad;
      }

   }
 else {
      cVar4 = ( **(code**)( lVar11 + 0x128 ) )(param_1);
      if (cVar4 == '\0') {
         lVar11 = *(long*)param_1;
         goto LAB_0013d7dc;
      }

   }

   lVar11 = *(long*)( param_1 + 0x68 );
   lVar7 = *(long*)( lVar11 + 8 );
   if (lVar7 != *(long*)( lVar11 + 0x10 )) {
      uVar12 = 0;
      do {
         updateBindlessQualifier(this, *(TType**)( lVar7 + uVar12 * 0x20 ));
         lVar7 = *(long*)( lVar11 + 8 );
         uVar12 = ( ulong )((int)uVar12 + 1);
      }
 while ( uVar12 < ( ulong )(*(long*)( lVar11 + 0x10 ) - lVar7 >> 5) );
   }

   LAB_0013d6ad:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   return;
}
/* glslang::TParseContext::samplerCheck(glslang::TSourceLoc const&, glslang::TType const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const&,
   glslang::TIntermTyped*) */void glslang::TParseContext::samplerCheck(TSourceLoc *param_1, TType *param_2, basic_string *param_3, TIntermTyped *param_4) {
   basic_string bVar1;
   ulong uVar2;
   undefined8 uVar3;
   char cVar4;
   int iVar5;
   uint uVar6;
   code *pcVar7;
   long lVar8;
   undefined4 *puVar9;
   size_t sVar10;
   long lVar11;
   undefined **ppuVar12;
   ulong uVar13;
   basic_string *pbVar14;
   char *pcVar15;
   long lVar16;
   void *__s2;
   ulong uVar17;
   long lVar18;
   long in_FS_OFFSET;
   long local_88;
   TSourceLoc *local_70;
   undefined8 local_68;
   undefined1 *local_60;
   undefined1 local_50[16];
   long local_40;
   lVar16 = *(long*)param_3;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   if (*(code**)( lVar16 + 0x38 ) == TType::getBasicType) {
      uVar6 = (uint)(byte)param_3[8];
   }
 else {
      uVar6 = ( **(code**)( lVar16 + 0x38 ) )(param_3);
      lVar16 = *(long*)param_3;
   }

   if (uVar6 == 0xe) {
      if (*(code**)( lVar16 + 0x40 ) == TType::getSampler) {
         if (( (byte)param_3[0x83] & 0x20 ) == 0) goto LAB_0013dbeb;
         LAB_0013dd96:ppuVar12 = &E_GL_OES_EGL_image_external;
         if (299 < *(int*)( param_1 + 0x18 )) {
            ppuVar12 = &E_GL_OES_EGL_image_external_essl3;
         }

         ( **(code**)( *(long*)param_1 + 0x28 ) )(param_1, param_2, 1, ppuVar12, "samplerExternalOES");
      }
 else {
         lVar16 = ( **(code**)( lVar16 + 0x40 ) )(param_3);
         if (( *(byte*)( lVar16 + 3 ) & 0x20 ) != 0) goto LAB_0013dd96;
      }

      pcVar7 = *(code**)( *(long*)param_3 + 0x40 );
      if (pcVar7 != TType::getSampler) goto LAB_0013ddd9;
      LAB_0013dbeb:pbVar14 = param_3 + 0x80;
   }
 else {
      pcVar7 = *(code**)( lVar16 + 0x40 );
      if (pcVar7 == TType::getSampler) goto LAB_0013dbeb;
      LAB_0013ddd9:pbVar14 = (basic_string*)( *pcVar7 )(param_3);
   }

   if (( (byte)pbVar14[3] & 0x40 ) != 0) {
      ( **(code**)( *(long*)param_1 + 0x28 ) )(param_1, param_2, 1, &E_GL_EXT_YUV_target, "__samplerExternal2DY2YEXT");
   }

   if (*(code**)( *(long*)param_3 + 0x58 ) == TType::getQualifier) {
      pbVar14 = param_3 + 0x10;
   }
 else {
      pbVar14 = (basic_string*)( **(code**)( *(long*)param_3 + 0x58 ) )(param_3);
   }

   if (( (byte)pbVar14[8] & 0x7f ) == 5) goto LAB_0013dc60;
   if (*(code**)( *(long*)param_3 + 0x38 ) != TType::getBasicType) {
      iVar5 = ( **(code**)( *(long*)param_3 + 0x38 ) )(param_3);
      if (iVar5 == 0xf) goto LAB_0013de1e;
      LAB_0013df10:if (*(code**)( *(long*)param_3 + 0x38 ) == TType::getBasicType) {
         uVar6 = (uint)(byte)param_3[8];
      }
 else {
         uVar6 = ( **(code**)( *(long*)param_3 + 0x38 ) )(param_3);
      }

      LAB_0013dc5b:if (uVar6 != 0xe) goto LAB_0013dc60;
      if (*(code**)( *(long*)param_3 + 0x58 ) == TType::getQualifier) {
         pbVar14 = param_3 + 0x10;
      }
 else {
         pbVar14 = (basic_string*)( **(code**)( *(long*)param_3 + 0x58 ) )(param_3);
      }

      if (( (byte)pbVar14[8] & 0x7f ) == 5) goto LAB_0013dc60;
      cVar4 = ( **(code**)( *(long*)param_1 + 0x40 ) )(param_1, "GL_ARB_bindless_texture");
      if (cVar4 != '\0') {
         if (*(code**)( *(long*)param_3 + 0x40 ) == TType::getSampler) {
            pbVar14 = param_3 + 0x80;
         }
 else {
            pbVar14 = (basic_string*)( **(code**)( *(long*)param_3 + 0x40 ) )(param_3);
         }

         local_88 = *(long*)( param_1 + 0x38 );
         if (( ( (byte)pbVar14[2] & 8 ) == 0 ) || ( ( byte )((char)pbVar14[1] - 7U) < 2 )) {
            lVar16 = local_88 + 0x530;
            lVar8 = lVar16;
            if (*(long*)( local_88 + 0x538 ) != 0) {
               __s2 = *(void**)( param_1 + 0x7518 );
               uVar17 = *(ulong*)( param_1 + 0x7520 );
               lVar18 = *(long*)( local_88 + 0x538 );
               do {
                  uVar2 = *(ulong*)( lVar18 + 0x30 );
                  uVar13 = uVar17;
                  if (uVar2 <= uVar17) {
                     uVar13 = uVar2;
                  }

                  if (( uVar13 == 0 ) || ( iVar5 = memcmp(*(void**)( lVar18 + 0x28 ), __s2, uVar13) ),iVar5 == 0) {
                     lVar11 = uVar2 - uVar17;
                     if (lVar11 < 0x80000000) {
                        if (-0x80000001 < lVar11) {
                           iVar5 = (int)lVar11;
                           goto LAB_0013dd71;
                        }

                        goto LAB_0013dd20;
                     }

                     LAB_0013dd75:lVar11 = *(long*)( lVar18 + 0x10 );
                     lVar8 = lVar18;
                  }
 else {
                     LAB_0013dd71:if (-1 < iVar5) goto LAB_0013dd75;
                     LAB_0013dd20:lVar11 = *(long*)( lVar18 + 0x18 );
                  }

                  lVar18 = lVar11;
               }
 while ( lVar11 != 0 );
               if (lVar8 != lVar16) goto LAB_0013dfea;
            }

            goto LAB_0013e045;
         }

         LAB_0013e08f:puVar9 = (undefined4*)std::map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>::operator []((map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>*)( local_88 + 0x558 ), (basic_string*)( param_1 + 0x7510 ));
         *puVar9 = 0;
         goto LAB_0013dc60;
      }

      lVar16 = *(long*)param_3;
      if (*(code**)( lVar16 + 0x40 ) == TType::getSampler) {
         pbVar14 = param_3 + 0x80;
      }
 else {
         pbVar14 = (basic_string*)( **(code**)( lVar16 + 0x40 ) )(param_3);
         lVar16 = *(long*)param_3;
      }

      if (pbVar14[1] == (basic_string)0x8) {
         if (*(code**)( lVar16 + 0x58 ) == TType::getQualifier) {
            if (( (byte)param_3[0x18] & 0x7f ) == 0x1f) goto LAB_0013dc60;
         }
 else {
            lVar16 = ( **(code**)( lVar16 + 0x58 ) )(param_3);
            if (( *(byte*)( lVar16 + 8 ) & 0x7f ) == 0x1f) {
               lVar16 = *(long*)param_3;
               goto LAB_0013df56;
            }

         }

         pcVar7 = *(code**)( *(long*)param_1 + 0x158 );
         uVar3 = *(undefined8*)( param_4 + 8 );
         TType::getBasicTypeString_abi_cxx11_();
         ( *pcVar7 )(param_1, param_2, "can only be used in tileImageEXT variables or function parameters:", local_60, uVar3);
      }
 else {
         LAB_0013df56:if (*(code**)( lVar16 + 0x58 ) == TType::getQualifier) {
            bVar1 = param_3[0x18];
         }
 else {
            lVar16 = ( **(code**)( lVar16 + 0x58 ) )(param_3);
            bVar1 = *(basic_string*)( lVar16 + 8 );
         }

         if (( (byte)bVar1 & 0x7f ) != 0x1f) {
            pcVar7 = *(code**)( *(long*)param_1 + 0x158 );
            uVar3 = *(undefined8*)( param_4 + 8 );
            if (param_3[8] == (basic_string)0xe) {
               TSampler::getString_abi_cxx11_();
            }
 else {
               local_68 = glslang::GetThreadPoolAllocator();
               switch (param_3[8]) {
                  case (basic_string)0x0:
            pcVar15 = "void";
            break;
                  case (basic_string)0x1:
            pcVar15 = "float";
            break;
                  case (basic_string)0x2:
            pcVar15 = "double";
            break;
                  case (basic_string)0x3:
            pcVar15 = "float16_t";
            break;
                  case (basic_string)0x4:
            pcVar15 = "int8_t";
            break;
                  case (basic_string)0x5:
            pcVar15 = "uint8_t";
            break;
                  case (basic_string)0x6:
            pcVar15 = "int16_t";
            break;
                  case (basic_string)0x7:
            pcVar15 = "uint16_t";
            break;
                  case (basic_string)0x8:
            pcVar15 = "int";
            break;
                  case (basic_string)0x9:
            pcVar15 = "uint";
            break;
                  case (basic_string)0xa:
            pcVar15 = "int64_t";
            break;
                  case (basic_string)0xb:
            pcVar15 = "uint64_t";
            break;
                  case (basic_string)0xc:
            pcVar15 = "bool";
            break;
                  case (basic_string)0xd:
            pcVar15 = "atomic_uint";
            break;
                  case (basic_string)0xe:
            pcVar15 = "sampler/image";
            break;
                  case (basic_string)0xf:
            pcVar15 = "structure";
            break;
                  case (basic_string)0x10:
            pcVar15 = "block";
            break;
                  case (basic_string)0x11:
            pcVar15 = "accelerationStructureNV";
            break;
                  case (basic_string)0x12:
            pcVar15 = "reference";
            break;
                  case (basic_string)0x13:
            pcVar15 = "rayQueryEXT";
            break;
                  default:
            pcVar15 = "unknown type";
            break;
                  case (basic_string)0x15:
            pcVar15 = "coopmat";
            break;
                  case (basic_string)0x16:
            pcVar15 = "spirv_type";
            break;
                  case (basic_string)0x17:
            pcVar15 = "string";
               }

               local_60 = local_50;
               sVar10 = strlen(pcVar15);
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, pcVar15, pcVar15 + sVar10);
            }

            ( *pcVar7 )(param_1, param_2, "sampler/image types can only be used in uniform variables or function parameters:", local_60, uVar3);
         }

      }

      goto LAB_0013dc60;
   }

   uVar6 = (uint)(byte)param_3[8];
   if (param_3[8] != (basic_string)0xf) goto LAB_0013dc5b;
   LAB_0013de1e:cVar4 = containsFieldWithBasicType((TParseContext*)param_1, param_3, 0xe);
   if (cVar4 == '\0') goto LAB_0013df10;
   cVar4 = ( **(code**)( *(long*)param_1 + 0x40 ) )(param_1, "GL_ARB_bindless_texture");
   if (cVar4 == '\0') {
      pcVar7 = *(code**)( *(long*)param_1 + 0x158 );
      uVar3 = *(undefined8*)( param_4 + 8 );
      if (param_3[8] == (basic_string)0xe) {
         TSampler::getString_abi_cxx11_();
      }
 else {
         local_68 = glslang::GetThreadPoolAllocator();
         switch (param_3[8]) {
            case (basic_string)0x0:
        pcVar15 = "void";
        break;
            case (basic_string)0x1:
        pcVar15 = "float";
        break;
            case (basic_string)0x2:
        pcVar15 = "double";
        break;
            case (basic_string)0x3:
        pcVar15 = "float16_t";
        break;
            case (basic_string)0x4:
        pcVar15 = "int8_t";
        break;
            case (basic_string)0x5:
        pcVar15 = "uint8_t";
        break;
            case (basic_string)0x6:
        pcVar15 = "int16_t";
        break;
            case (basic_string)0x7:
        pcVar15 = "uint16_t";
        break;
            case (basic_string)0x8:
        pcVar15 = "int";
        break;
            case (basic_string)0x9:
        pcVar15 = "uint";
        break;
            case (basic_string)0xa:
        pcVar15 = "int64_t";
        break;
            case (basic_string)0xb:
        pcVar15 = "uint64_t";
        break;
            case (basic_string)0xc:
        pcVar15 = "bool";
        break;
            case (basic_string)0xd:
        pcVar15 = "atomic_uint";
        break;
            case (basic_string)0xe:
        pcVar15 = "sampler/image";
        break;
            case (basic_string)0xf:
        pcVar15 = "structure";
        break;
            case (basic_string)0x10:
        pcVar15 = "block";
        break;
            case (basic_string)0x11:
        pcVar15 = "accelerationStructureNV";
        break;
            case (basic_string)0x12:
        pcVar15 = "reference";
        break;
            case (basic_string)0x13:
        pcVar15 = "rayQueryEXT";
        break;
            default:
        pcVar15 = "unknown type";
        break;
            case (basic_string)0x15:
        pcVar15 = "coopmat";
        break;
            case (basic_string)0x16:
        pcVar15 = "spirv_type";
        break;
            case (basic_string)0x17:
        pcVar15 = "string";
         }

         local_60 = local_50;
         sVar10 = strlen(pcVar15);
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, pcVar15, pcVar15 + sVar10);
      }

      ( *pcVar7 )(param_1, param_2, "non-uniform struct contains a sampler or image:", local_60, uVar3);
      goto LAB_0013dc60;
   }

   if (*(code**)( *(long*)param_3 + 0x40 ) == TType::getSampler) {
      pbVar14 = param_3 + 0x80;
   }
 else {
      pbVar14 = (basic_string*)( **(code**)( *(long*)param_3 + 0x40 ) )(param_3);
   }

   local_88 = *(long*)( param_1 + 0x38 );
   if (( ( (byte)pbVar14[2] & 8 ) != 0 ) && ( 1 < ( byte )((char)pbVar14[1] - 7U) )) goto LAB_0013e08f;
   lVar16 = local_88 + 0x530;
   lVar8 = lVar16;
   if (*(long*)( local_88 + 0x538 ) == 0) {
      LAB_0013e045:local_70 = param_1 + 0x7510;
      lVar8 = std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>::_M_emplace_hint_unique<std::piecewise_construct_t_const&,std::tuple<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const&>,std::tuple<>>(local_88 + 0x528, lVar8, &local_70);
   }
 else {
      __s2 = *(void**)( param_1 + 0x7518 );
      uVar17 = *(ulong*)( param_1 + 0x7520 );
      lVar18 = *(long*)( local_88 + 0x538 );
      do {
         uVar2 = *(ulong*)( lVar18 + 0x30 );
         uVar13 = uVar17;
         if (uVar2 <= uVar17) {
            uVar13 = uVar2;
         }

         if (( uVar13 == 0 ) || ( iVar5 = memcmp(*(void**)( lVar18 + 0x28 ), __s2, uVar13) ),iVar5 == 0) {
            lVar11 = uVar2 - uVar17;
            if (lVar11 < 0x80000000) {
               if (-0x80000001 < lVar11) {
                  iVar5 = (int)lVar11;
                  goto LAB_0013df01;
               }

               goto LAB_0013deb0;
            }

            LAB_0013df05:lVar11 = *(long*)( lVar18 + 0x10 );
            lVar8 = lVar18;
         }
 else {
            LAB_0013df01:if (-1 < iVar5) goto LAB_0013df05;
            LAB_0013deb0:lVar11 = *(long*)( lVar18 + 0x18 );
         }

         lVar18 = lVar11;
      }
 while ( lVar11 != 0 );
      if (lVar16 == lVar8) goto LAB_0013e045;
      LAB_0013dfea:uVar2 = *(ulong*)( lVar8 + 0x30 );
      uVar13 = uVar17;
      if (uVar2 <= uVar17) {
         uVar13 = uVar2;
      }

      if (( uVar13 == 0 ) || ( iVar5 = memcmp(__s2, *(void**)( lVar8 + 0x28 ), uVar13) ),iVar5 == 0) {
         lVar16 = uVar17 - uVar2;
         if (lVar16 < 0x80000000) {
            if (lVar16 < -0x80000000) goto LAB_0013e045;
            iVar5 = (int)lVar16;
            goto LAB_0013e028;
         }

      }
 else {
         LAB_0013e028:if (iVar5 < 0) goto LAB_0013e045;
      }

   }

   *(undefined4*)( lVar8 + 0x48 ) = 0;
   LAB_0013dc60:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
      return;
   }

   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
/* glslang::TParseContext::declareVariable(glslang::TSourceLoc const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >&,
   glslang::TPublicType const&, glslang::TArraySizes*, glslang::TIntermTyped*) */undefined8 glslang::TParseContext::declareVariable(TParseContext *this, TSourceLoc *param_1, basic_string *param_2, TPublicType *param_3, TArraySizes *param_4, TIntermTyped *param_5) {
   undefined4 uVar1;
   code *pcVar2;
   byte bVar3;
   char cVar4;
   uint uVar5;
   TSymbol *pTVar6;
   TVariable *pTVar7;
   undefined8 uVar8;
   TArraySizes *pTVar9;
   vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>> *this_00;
   long *plVar10;
   TType *pTVar11;
   long lVar12;
   uint *puVar13;
   ulong uVar14;
   undefined8 *puVar15;
   undefined8 uVar16;
   long lVar17;
   uint uVar18;
   char *pcVar19;
   long in_FS_OFFSET;
   TType local_1a8[8];
   char local_1a0;
   byte local_19e;
   TQualifier local_198[8];
   ushort local_190;
   TParseContext local_175;
   byte local_174;
   TArraySizes *local_148;
   long local_140;
   long local_130;
   TSymbol *local_108;
   char local_100;
   ushort local_f0;
   long local_a8;
   long local_a0;
   long *local_68;
   long local_60;
   long local_58[3];
   long local_40;
   local_40 = *(long*)( in_FS_OFFSET + 0x28 );
   TType::TType(local_1a8, param_3);
   lVar17 = *(long*)( param_3 + 0xc0 );
   local_148 = param_4;
   if (lVar17 != 0) {
      if (param_4 == (TArraySizes*)0x0) {
         uVar14 = glslang::GetThreadPoolAllocator();
         pTVar9 = (TArraySizes*)glslang::TPoolAllocator::allocate(uVar14);
         *(undefined4*)( pTVar9 + 0x10 ) = 0;
         *(undefined***)pTVar9 = &PTR__TSmallArrayVector_00167ee0;
         uVar1 = *(undefined4*)( lVar17 + 0x10 );
         *(undefined2*)( pTVar9 + 0x14 ) = 1;
         *(undefined8*)( pTVar9 + 8 ) = 0;
         lVar12 = *(long*)( lVar17 + 8 );
         *(undefined4*)( pTVar9 + 0x10 ) = uVar1;
         pTVar9[0x15] = *(TArraySizes*)( lVar17 + 0x15 );
         local_148 = pTVar9;
         if (lVar12 == 0) {
            *(undefined8*)( pTVar9 + 8 ) = 0;
         }
 else {
            uVar14 = glslang::GetThreadPoolAllocator();
            this_00 = (vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>*)glslang::TPoolAllocator::allocate(uVar14);
            uVar8 = glslang::GetThreadPoolAllocator();
            *(undefined8*)this_00 = uVar8;
            for (int i = 0; i < 3; i++) {
               *(undefined8*)( this_00 + ( 8*i + 8 ) ) = 0;
            }

            *(vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>**)( pTVar9 + 8 ) = this_00;
            std::vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>::operator =(this_00, *(vector**)( lVar17 + 8 ));
         }

         pTVar9[0x14] = *(TArraySizes*)( lVar17 + 0x14 );
      }
 else {
         puVar15 = *(undefined8**)( param_4 + 8 );
         if (puVar15 == (undefined8*)0x0) {
            uVar14 = glslang::GetThreadPoolAllocator();
            puVar15 = (undefined8*)glslang::TPoolAllocator::allocate(uVar14);
            uVar16 = glslang::GetThreadPoolAllocator();
            puVar15[1] = 0;
            uVar8 = 0;
            *puVar15 = uVar16;
            puVar15[2] = 0;
            puVar15[3] = 0;
            *(undefined8**)( param_4 + 8 ) = puVar15;
         }
 else {
            uVar8 = puVar15[2];
         }

         std::vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>::_M_range_insert<__gnu_cxx::__normal_iterator<glslang::TArraySize*,std::vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>>>(puVar15, uVar8, *(undefined8*)( *(long*)( lVar17 + 8 ) + 8 ), *(undefined8*)( *(long*)( lVar17 + 8 ) + 0x10 ));
      }

   }

   arrayOfArrayVersionCheck(this, param_1, local_148);
   if (param_5 == (TIntermTyped*)0x0) {
      LAB_0013e83f:if (( local_19e & 0x40 ) == 0) goto LAB_0013e84c;
      LAB_0013eb5a:lVar17 = *(long*)( this + 0x38 );
      *(undefined1*)( lVar17 + 0x304 ) = 1;
      local_68 = local_58;
      std::__cxx11::string::_M_construct<char_const*>(&local_68, "use-vulkan-memory-model");
      plVar10 = *(long**)( lVar17 + 0x7d8 );
      if (plVar10 == *(long**)( lVar17 + 0x7e0 )) {
         std::vector<std::__cxx11::string,std::allocator<std::__cxx11::string>>::_M_realloc_insert<std::__cxx11::string>((vector<std::__cxx11::string,std::allocator<std::__cxx11::string>>*)( lVar17 + 2000 ), plVar10, &local_68);
         if (local_68 != local_58) {
            operator_delete(local_68, local_58[0] + 1);
         }

      }
 else {
         *plVar10 = (long)( plVar10 + 2 );
         if (local_68 == local_58) {
            uVar14 = local_60 + 1;
            uVar5 = (uint)uVar14;
            if (uVar5 < 8) {
               if (( uVar14 & 4 ) == 0) {
                  if (( uVar5 != 0 ) && ( *(char*)( plVar10 + 2 ) = (char)*local_68(uVar14 & 2) != 0 )) {
                     *(undefined2*)( (long)plVar10 + ( uVar14 & 0xffffffff ) + 0xe ) = *(undefined2*)( (long)local_68 + ( ( uVar14 & 0xffffffff ) - 2 ) );
                  }

               }
 else {
                  *(int*)( plVar10 + 2 ) = (int)*local_68;
                  *(undefined4*)( (long)plVar10 + ( uVar14 & 0xffffffff ) + 0xc ) = *(undefined4*)( (long)local_68 + ( ( uVar14 & 0xffffffff ) - 4 ) );
               }

            }
 else {
               plVar10[2] = *local_68;
               *(undefined8*)( (long)plVar10 + ( uVar14 & 0xffffffff ) + 8 ) = *(undefined8*)( (long)local_68 + ( ( uVar14 & 0xffffffff ) - 8 ) );
               lVar12 = (long)( plVar10 + 2 ) - ( ( ulong )(plVar10 + 3) & 0xfffffffffffffff8 );
               uVar5 = uVar5 + (int)lVar12 & 0xfffffff8;
               if (7 < uVar5) {
                  uVar18 = 0;
                  do {
                     uVar14 = (ulong)uVar18;
                     uVar18 = uVar18 + 8;
                     *(undefined8*)( ( ( ulong )(plVar10 + 3) & 0xfffffffffffffff8 ) + uVar14 ) = *(undefined8*)( (long)local_68 + ( uVar14 - lVar12 ) );
                  }
 while ( uVar18 < uVar5 );
               }

            }

         }
 else {
            *plVar10 = (long)local_68;
            plVar10[2] = local_58[0];
         }

         plVar10[1] = local_60;
         *(long*)( lVar17 + 0x7d8 ) = *(long*)( lVar17 + 0x7d8 ) + 0x20;
      }

      *(undefined1*)( *(long*)( this + 0x38 ) + 0x271 ) = 1;
      puVar13 = *(uint**)( param_3 + 0xe8 );
      if (( ( ( puVar13 == (uint*)0x0 ) || ( *(long*)( puVar13 + 2 ) == 0 ) ) || ( lVar17 = *(long*)( *(long*)( puVar13 + 2 ) + 8 ) ),lVar17 == 0 )) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "unexpected number type parameters", *(undefined8*)( param_2 + 8 ), &_LC1);
         puVar13 = *(uint**)( param_3 + 0xe8 );
         if (puVar13 != (uint*)0x0) goto LAB_0013f1aa;
      }
 else {
         LAB_0013f1aa:uVar5 = *puVar13;
         if (2 < uVar5 - 1) {
            if (uVar5 < 0xb) {
               if (( ( 0x550UL >> ( (ulong)uVar5 & 0x3f ) & 1 ) == 0 ) && ( ( 0xaa0UL >> ( (ulong)uVar5 & 0x3f ) & 1 ) == 0 )) {
                  LAB_0013f1df:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "expected 8, 16, 32, or 64 bit signed or unsigned integer or 16, 32, or 64 bit float type", *(undefined8*)( param_2 + 8 ), &_LC1);
               }

            }
 else if (( 0xb < uVar5 ) && ( uVar5 != 0x16 )) goto LAB_0013f1df;
         }

      }

   }
 else {
      if (local_1a0 != '\x13') {
         if (local_1a0 == '\x14') {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "hit objects cannot be initialized using initializers", &_LC1026, *(undefined8*)( param_2 + 8 ));
         }

         goto LAB_0013e83f;
      }

      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "ray queries can only be initialized by using the rayQueryInitializeEXT intrinsic:", &_LC1026, *(undefined8*)( param_2 + 8 ));
      if (( local_19e & 0x40 ) != 0) goto LAB_0013eb5a;
      LAB_0013e84c:if (( local_19e & 0x20 ) == 0) {
         if (( ( *(long*)( param_3 + 0xe8 ) != 0 ) && ( lVar17 = *(long*)( *(long*)( *(long*)( param_3 + 0xe8 ) + 8 ) + 8 ) ),lVar17 != 0 )) &&( (int)( *(long*)( lVar17 + 0x10 ) - *(long*)( lVar17 + 8 ) >> 4 ) != 0 )(**(code**)( *(long*)this + 0x158 ))(this, param_1, "unexpected type parameters", *(undefined8*)( param_2 + 8 ), &_LC1);
      }

   }

   else{lVar17 = *(long*)( this + 0x38 );
   *(undefined1*)( lVar17 + 0x304 ) = 1;
   local_68 = local_58;
   std::__cxx11::string::_M_construct<char_const*>(&local_68, "use-vulkan-memory-model");
   puVar15 = *(undefined8**)( lVar17 + 0x7d8 );
   if (puVar15 == *(undefined8**)( lVar17 + 0x7e0 )) {
      std::vector<std::__cxx11::string,std::allocator<std::__cxx11::string>>::_M_realloc_insert<std::__cxx11::string>((vector<std::__cxx11::string,std::allocator<std::__cxx11::string>>*)( lVar17 + 2000 ), puVar15, &local_68);
      if (local_68 != local_58) {
         operator_delete(local_68, local_58[0] + 1);
      }

   }
 else {
      *puVar15 = puVar15 + 2;
      if (local_68 == local_58) {
         uVar14 = local_60 + 1;
         uVar5 = (uint)uVar14;
         if (uVar5 < 8) {
            if (( uVar14 & 4 ) == 0) {
               if (( uVar5 != 0 ) && ( *(char*)( puVar15 + 2 ) = (char)*local_68(uVar14 & 2) != 0 )) {
                  *(undefined2*)( (long)puVar15 + ( uVar14 & 0xffffffff ) + 0xe ) = *(undefined2*)( (long)local_68 + ( ( uVar14 & 0xffffffff ) - 2 ) );
               }

            }
 else {
               *(int*)( puVar15 + 2 ) = (int)*local_68;
               *(undefined4*)( (long)puVar15 + ( uVar14 & 0xffffffff ) + 0xc ) = *(undefined4*)( (long)local_68 + ( ( uVar14 & 0xffffffff ) - 4 ) );
            }

         }
 else {
            puVar15[2] = *local_68;
            *(undefined8*)( (long)puVar15 + ( uVar14 & 0xffffffff ) + 8 ) = *(undefined8*)( (long)local_68 + ( ( uVar14 & 0xffffffff ) - 8 ) );
            lVar12 = (long)( puVar15 + 2 ) - ( ( ulong )(puVar15 + 3) & 0xfffffffffffffff8 );
            uVar5 = uVar5 + (int)lVar12 & 0xfffffff8;
            if (7 < uVar5) {
               uVar18 = 0;
               do {
                  uVar14 = (ulong)uVar18;
                  uVar18 = uVar18 + 8;
                  *(undefined8*)( ( ( ulong )(puVar15 + 3) & 0xfffffffffffffff8 ) + uVar14 ) = *(undefined8*)( (long)local_68 + ( uVar14 - lVar12 ) );
               }
 while ( uVar18 < uVar5 );
            }

         }

      }
 else {
         *puVar15 = local_68;
         puVar15[2] = local_58[0];
      }

      puVar15[1] = local_60;
      *(long*)( lVar17 + 0x7d8 ) = *(long*)( lVar17 + 0x7d8 ) + 0x20;
   }

   *(undefined1*)( *(long*)( this + 0x38 ) + 0x271 ) = 1;
   lVar17 = *(long*)( param_3 + 0xe8 );
   if (( ( lVar17 == 0 ) || ( lVar12 = *(long*)( *(long*)( lVar17 + 8 ) + 8 ) ),lVar12 == 0 )) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "expected four type parameters", *(undefined8*)( param_2 + 8 ), &_LC1);
      lVar17 = *(long*)( param_3 + 0xe8 );
      if (lVar17 == 0) goto LAB_0013e888;
   }

   uVar14 = ( ulong ) * (uint*)param_3;
   if (*(uint*)param_3 - 1 < 3) {
      uVar5 = **(int**)( *(long*)( *(long*)( lVar17 + 8 ) + 8 ) + 8 ) - 0x10;
      if (( 0x30 < uVar5 ) || ( ( 0x1000000010001U >> ( (ulong)uVar5 & 0x3f ) & 1 ) == 0 )) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "expected 16, 32, or 64 bits for first type parameter", *(undefined8*)( param_2 + 8 ), &_LC1);
         uVar14 = ( ulong ) * (uint*)param_3;
         goto LAB_0013f5b9;
      }

      LAB_0013ed43:if (( 0xaa0UL >> ( uVar14 & 0x3f ) & 1 ) == 0) goto LAB_0013e888;
   }
 else {
      LAB_0013f5b9:if ((uint)uVar14 < 0xb) {
         if (( 0x550UL >> ( uVar14 & 0x3f ) & 1 ) == 0) goto LAB_0013ed43;
      }
 else if (0xb < (uint)uVar14) goto LAB_0013e888;
   }

   uVar5 = **(uint**)( *(long*)( *(long*)( *(long*)( param_3 + 0xe8 ) + 8 ) + 8 ) + 8 );
   if (( 0x20 < uVar5 ) || ( ( 0x100010100U >> ( (ulong)uVar5 & 0x3f ) & 1 ) == 0 )) {
      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "expected 8, 16, or 32 bits for first type parameter", *(undefined8*)( param_2 + 8 ), &_LC1);
   }

}
}LAB_0013e888:if (local_1a0 == '\0') {
   ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "illegal use of type \'void\'", *(undefined8*)( param_2 + 8 ), &_LC1);
}
 else {
   if (param_5 == (TIntermTyped*)0x0) {
      nonInitConstCheck(this, param_1, param_2, local_1a8);
   }
 else {
      ( **(code**)( *(long*)this + 0x208 ) )(this, param_1, "initializer");
   }

   samplerCheck((TSourceLoc*)this, (TType*)param_1, (basic_string*)local_1a8, (TIntermTyped*)param_2);
   transparentOpaqueCheck(this, param_1, local_1a8, param_2);
   atomicUintCheck(this, param_1, local_1a8, param_2);
   accStructCheck(this, param_1, local_1a8, param_2);
   checkAndResizeMeshViewDim(this, param_1, local_1a8, false);
   bVar3 = (byte)local_190 & 0x7f;
   if (bVar3 == 2) {
      if (local_1a0 == '\x12') {
         LAB_0013f6d2:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "variables with reference type can\'t have qualifier \'const\'", "qualifier", &_LC1);
         LAB_0013f6f9:bVar3 = (byte)local_190 & 0x7f;
         goto LAB_0013e925;
      }

      if (( byte )(local_1a0 - 0xfU) < 2) {
         lVar17 = *(long*)( local_140 + 0x10 );
         lVar12 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( local_140 + 8 ),lVar17,0x12 ));
         if (lVar17 != lVar12) goto LAB_0013f6d2;
         goto LAB_0013f6f9;
      }

      if (local_1a0 != '\x03') goto LAB_0013f541;
      LAB_0013f287:( **(code**)( *(long*)this + 0xa8 ) )(this, param_1, "qualifier");
      LAB_0013f2a4:if (local_1a0 == '\x06') {
         LAB_0013f2df:( **(code**)( *(long*)this + 0xc0 ) )(this, param_1, "qualifier");
         LAB_0013f2fc:if (local_1a0 == '\x04') goto LAB_0013f337;
         if (( byte )(local_1a0 - 0xfU) < 2) {
            lVar17 = *(long*)( local_140 + 0x10 );
            lVar12 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( local_140 + 8 ),lVar17,4 ));
            if (( ( lVar17 != lVar12 ) || ( local_1a0 == '\x05' ) ) || ( ( ( byte )(local_1a0 - 0xfU) < 2 && ( lVar17 = *(long*)( local_140 + 0x10 ) ),lVar12 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( local_140 + 8 ),lVar17,5 ), lVar17 != lVar12) ) )) goto LAB_0013f337;
         }
 else {
            LAB_0013f559:if (local_1a0 == '\x05') goto LAB_0013f337;
         }

      }
 else {
         if (( byte )(local_1a0 - 0xfU) < 2) {
            lVar17 = *(long*)( local_140 + 0x10 );
            lVar12 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( local_140 + 8 ),lVar17,6 ));
            if (( lVar17 != lVar12 ) || ( local_1a0 == '\a' )) goto LAB_0013f2df;
            if (1 < ( byte )(local_1a0 - 0xfU)) goto LAB_0013f551;
            lVar17 = *(long*)( local_140 + 0x10 );
            lVar12 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( local_140 + 8 ),lVar17,7 ));
            if (lVar17 != lVar12) goto LAB_0013f2df;
            goto LAB_0013f2fc;
         }

         LAB_0013f549:if (local_1a0 == '\a') goto LAB_0013f2df;
         LAB_0013f551:if (local_1a0 != '\x04') goto LAB_0013f559;
         LAB_0013f337:( **(code**)( *(long*)this + 0xd8 ) )(this, param_1, "qualifier");
      }

      if (( (byte)local_190 & 0x7f ) == 0xf) {
         *(int*)( *(long*)( this + 0x38 ) + 0x378 ) = *(int*)( *(long*)( this + 0x38 ) + 0x378 ) + 1;
      }
 else if (( ( (byte)local_190 & 0x7f ) == 7 ) && ( ( ( ( local_19e & 0x20 ) != 0 || ( ( local_19e & 0x40 ) != 0 ) ) || ( ( ( byte )(local_1a0 - 0xfU) < 2 && ( lVar17 = *(long*)( local_140 + 0x10 ) ),lVar12 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsCoopMat()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsCoopMat ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( local_140 + 8 ),lVar17 ), lVar17 != lVar12) ) ) ) )) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "qualifier", "Cooperative matrix types must not be used in shared memory", &_LC1);
      }

   }
 else {
      LAB_0013e925:if (1 < ( byte )(bVar3 - 5)) {
         if (local_1a0 == '\x03') goto LAB_0013f287;
         if (( byte )(local_1a0 - 0xfU) < 2) {
            lVar17 = *(long*)( local_140 + 0x10 );
            lVar12 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( local_140 + 8 ),lVar17,3 ));
            if (lVar17 != lVar12) goto LAB_0013f287;
            goto LAB_0013f2a4;
         }

         LAB_0013f541:if (local_1a0 != '\x06') goto LAB_0013f549;
         goto LAB_0013f2df;
      }

   }

   if (*(int*)( this + 0xc ) == 8) {
      if (( ( ( byte )((byte)local_190 & 0x7f) < 0x1c ) && ( ( 0xe300008UL >> ( ( ulong )((byte)local_190 & 0x7f) & 0x3f ) & 1 ) != 0 ) ) && ( local_1a0 == '\x0f' )) {
         cVar4 = TQualifier::isArrayedIo(local_198, *(undefined4*)( this + 0x1c ));
         if (cVar4 == '\0') {
            if (local_148 == (TArraySizes*)0x0) {
               lVar17 = *(long*)( local_140 + 0x10 );
               lVar12 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( local_140 + 8 ),lVar17 ));
               if (( lVar17 == lVar12 ) || ( 0x7f < local_190 )) goto LAB_0013f08f;
               if (( byte )(local_1a0 - 0xfU) < 2) goto LAB_0013fa25;
               LAB_0013f05e:lVar17 = *(long*)this;
               pcVar19 = "A structure containing an array is not allowed as input in ES";
               uVar8 = *(undefined8*)( local_130 + 8 );
               LAB_0013f07b:( **(code**)( lVar17 + 0x158 ) )(this, param_1, pcVar19, uVar8, &_LC1);
               goto LAB_0013f08f;
            }

            if (local_190 < 0x80) {
               LAB_0013fa25:lVar17 = *(long*)( local_140 + 0x10 );
               lVar12 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBuiltIn()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBuiltIn ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( local_140 + 8 ),lVar17 ));
               if (lVar17 != lVar12) goto LAB_0013f08f;
               goto LAB_0013f05e;
            }

         }
 else {
            TType::TType((TType*)&local_108, local_1a8, 0, false);
            if (local_a8 == 0) {
               if (( ( ( byte )(local_100 - 0xfU) < 2 ) && ( lVar17 = *(long*)( local_a0 + 0x10 ) ),lVar12 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( local_a0 + 8 ),lVar17 ), lVar17 != lVar12) ) && ( local_f0 < 0x80 )) {
                  LAB_0013fac9:lVar17 = *(long*)( local_a0 + 0x10 );
                  lVar12 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBuiltIn()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBuiltIn ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( local_a0 + 8 ),lVar17 ));
                  if (lVar17 == lVar12) goto LAB_0013fa6d;
               }

            }
 else if (local_f0 < 0x80) {
               if (( byte )(local_100 - 0xfU) < 2) goto LAB_0013fac9;
               LAB_0013fa6d:lVar17 = *(long*)this;
               pcVar19 = "A per vertex structure containing an array is not allowed as input in ES";
               uVar8 = *(undefined8*)( local_130 + 8 );
               goto LAB_0013f07b;
            }

            LAB_0013f08f:if (1 < ( byte )(local_1a0 - 0xfU)) goto LAB_0013e93f;
         }

         lVar17 = *(long*)( local_140 + 0x10 );
         lVar12 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsStructure()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsStructure ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( local_140 + 8 ),lVar17,local_1a8 ));
         if (lVar17 != lVar12) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "A structure containing an struct is not allowed as input in ES", *(undefined8*)( local_130 + 8 ), &_LC1);
         }

      }

   }

   LAB_0013e93f:lVar17 = *(long*)( param_2 + 0x10 );
   if (lVar17 == 0xc) {
      plVar10 = *(long**)( param_2 + 8 );
      if (( ( *plVar10 != 0x43676172465f6c67 ) || ( (int)plVar10[1] != 0x64726f6f ) ) && ( ( param_3[0x5d] != (TPublicType)0x0 || ( param_3[0x5c] != (TPublicType)0x0 ) ) )) goto LAB_0013e95c;
      LAB_0013ee25:if (( ( *plVar10 != 0x44676172465f6c67 ) || ( (int)plVar10[1] != 0x68747065 ) ) && ( *(int*)( param_3 + 0x98 ) != 0 )) goto LAB_0013ee48;
      LAB_0013e9ab:if (*(int*)( param_3 + 0x9c ) != 0) {
         ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply depth layout to gl_FragStencilRefARB", "layout qualifier", &_LC1);
      }

   }
 else {
      if (( param_3[0x5d] != (TPublicType)0x0 ) || ( param_3[0x5c] != (TPublicType)0x0 )) {
         LAB_0013e95c:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply origin_upper_left and pixel_center_origin to gl_FragCoord", "layout qualifier", &_LC1);
         lVar17 = *(long*)( param_2 + 0x10 );
         if (lVar17 == 0xc) {
            plVar10 = *(long**)( param_2 + 8 );
            goto LAB_0013ee25;
         }

      }

      if (*(int*)( param_3 + 0x98 ) != 0) {
         LAB_0013ee48:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only apply depth layout to gl_FragDepth", "layout qualifier", &_LC1);
         lVar17 = *(long*)( param_2 + 0x10 );
      }

      if (( ( lVar17 != 0x14 ) || ( plVar10 = *(long**)( param_2 + 8 ) * plVar10 != 0x53676172465f6c67 || plVar10[1] != 0x65526c69636e6574 ) ) || ( (int)plVar10[2] != 0x42524166 )) goto LAB_0013e9ab;
   }

   pTVar6 = (TSymbol*)redeclareBuiltinVariable(this, param_1, param_2, local_198, (TShaderQualifiers*)( param_3 + 0x58 ));
   local_108 = pTVar6;
   if (pTVar6 == (TSymbol*)0x0) {
      if (3 < (int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 )) {
         reservedErrorCheck(this, param_1, param_2);
      }

      if (( ( *(int*)( this + 0x28 ) < 1 ) || ( this[0x30] == (TParseContext)0x0 ) ) || ( cVar4 = vkRelaxedRemapUniformVariable(this, param_1, param_2, param_3, param_4, param_5, local_1a8) ),cVar4 == '\0') {
         if (( (byte)local_190 & 0x7f ) == 4) goto LAB_0013eec0;
         if (local_148 != (TArraySizes*)0x0) goto LAB_0013ea28;
         LAB_0013f46d:pTVar6 = (TSymbol*)declareNonArray(this, param_1, param_2, local_1a8);
         local_108 = pTVar6;
         if (pTVar6 != (TSymbol*)0x0) goto LAB_0013ef5a;
      }

   }
 else if (( (byte)local_190 & 0x7f ) == 4) {
      LAB_0013eec0:if (( local_175 == (TParseContext)0xff ) && ( *(int*)( this + 0x1c ) == 3 )) {
         local_175 = this[0x7493];
      }

      if (( ~local_174 & 0xf ) == 0) {
         local_174 = local_174 & 0xf0 | (byte)this[0x7494] & 0xf;
      }

      if (local_148 == (TArraySizes*)0x0) {
         if (pTVar6 == (TSymbol*)0x0) goto LAB_0013f46d;
         goto LAB_0013eefe;
      }

      LAB_0013ea28:if (this[0x1c1] == (TParseContext)0x0) {
         arraySizesCheck(this, param_1, local_198, local_148, param_5, false);
      }

      cVar4 = arrayQualifierError(this, param_1, local_198);
      if (( cVar4 == '\0' ) && ( cVar4 = arrayError(this, param_1, local_1a8) ),cVar4 == '\0') {
         declareArray(this, param_1, param_2, local_1a8, &local_108);
         pTVar6 = local_108;
      }

      if (param_5 == (TIntermTyped*)0x0) {
         if (pTVar6 != (TSymbol*)0x0) {
            LAB_0013f101:uVar8 = 0;
            goto LAB_0013eadc;
         }

      }
 else {
         glslang::TParseVersions::profileRequires((TSourceLoc*)this, (int)param_1, 1, (char*)0x78, "GL_3DL_array_objects");
         glslang::TParseVersions::profileRequires((TSourceLoc*)this, (int)param_1, 8, (char*)0x12c, (char*)0x0);
         if (pTVar6 != (TSymbol*)0x0) goto LAB_0013eab4;
      }

   }
 else {
      if (local_148 != (TArraySizes*)0x0) goto LAB_0013ea28;
      LAB_0013eefe:pTVar11 = (TType*)( **(code**)( *(long*)pTVar6 + 0x60 ) )(pTVar6);
      cVar4 = TType::operator ==(local_1a8, pTVar11);
      if (cVar4 == '\0') {
         pcVar2 = *(code**)( *(long*)this + 0x158 );
         if (*(code**)( *(long*)pTVar6 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            lVar17 = *(long*)( pTVar6 + 8 );
         }
 else {
            lVar17 = ( **(code**)( *(long*)pTVar6 + 0x18 ) )(pTVar6);
         }

         ( *pcVar2 )(this, param_1, "cannot change the type of", "redeclaration", *(undefined8*)( lVar17 + 8 ));
      }

      LAB_0013ef5a:if (param_5 == (TIntermTyped*)0x0) goto LAB_0013f101;
      LAB_0013eab4:pTVar7 = (TVariable*)( **(code**)( *(long*)pTVar6 + 0x48 ) )(pTVar6);
      if (pTVar7 != (TVariable*)0x0) {
         uVar8 = executeInitializer(this, param_1, param_5, pTVar7);
         LAB_0013eadc:layoutObjectCheck(this, param_1, pTVar6);
         fixOffset(this, param_1, pTVar6);
         goto LAB_0013eaf8;
      }

      ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "initializer requires a variable, not a member", *(undefined8*)( param_2 + 8 ), &_LC1);
   }

}
uVar8 = 0;LAB_0013eaf8:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
   /* WARNING: Subroutine does not return */
   __stack_chk_fail();
}
return uVar8;}/* void 
   glslang::ForEachOpaque<glslang::TParseContext::vkRelaxedRemapUniformMembers(glslang::TSourceLoc
   const&, glslang::TPublicType const&, glslang::TType const&, std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const&)::{lambda(glslang::TType const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >
   const&)#1}>(glslang::TType const&, std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const&,
   glslang::TParseContext::vkRelaxedRemapUniformMembers(glslang::TSourceLoc const&,
   glslang::TPublicType const&, glslang::TType const&, std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const&)::{lambda(glslang::TType const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >
   const&)#1})::{lambda(glslang::TType const&, std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const&, bool,
   auto:1&)#1}::TEMPNAMEPLACEHOLDERVALUE(glslang::TType const&, std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const&, bool, {lambda(glslang::TType
   const&, std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >
   const&, bool, auto:1&)#1}&) const */void glslang::ForEachOpaque {
   lambda(glslang::TType_const&,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const&)
   #1
   ::
{lambda(glslang::TType_const&,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const&,bool,auto:1&)
   #1
   ::operator ()(_lambda_glslang__TType_const__std____cxx11__basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> const__bool_auto_1___1_*this, TType *param_1, basic_string *param_2, bool param_3, _lambda_glslang__TType_const__std____cxx11__basic_string<char,std::char_traits<char>,glslang::std::allocator<char>_> _const__bool_auto_1___1_*param_4) {
      undefined4 *__s;
      ulong uVar1;
      int *piVar2;
      undefined4 uVar3;
      undefined1 *puVar4;
      vector *pvVar5;
      char *pcVar6;
      long *plVar7;
      code *pcVar8;
      char cVar9;
      TType TVar10;
      TType TVar11;
      uint uVar12;
      undefined4 *puVar13;
      int *piVar14;
      size_t sVar15;
      vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>> *this_00;
      undefined8 uVar16;
      basic_string *pbVar17;
      long lVar18;
      long lVar19;
      TType *pTVar20;
      undefined8 *puVar21;
      ulong uVar22;
      int iVar23;
      long *plVar24;
      long *plVar25;
      ulong uVar26;
      ulong uVar27;
      TPublicType *pTVar28;
      ulong uVar29;
      int iVar30;
      ulong uVar31;
      long in_FS_OFFSET;
      byte bVar32;
      undefined4 *local_1e8;
      undefined8 local_1d8;
      undefined1 auStack_1d0[16];
      ulong local_1b8;
      ulong *local_1b0;
      ulong local_1a8;
      ulong local_1a0[3];
      undefined8 local_188;
      char *local_180;
      ulong local_178;
      char local_170[24];
      undefined8 local_158;
      ulong *local_150;
      ulong uStack_148;
      ulong local_140;
      long lStack_138;
      long local_130;
      long lStack_128;
      long local_120;
      long lStack_118;
      long local_110;
      long lStack_108;
      undefined8 local_100;
      undefined8 uStack_f8;
      undefined8 local_f0;
      undefined8 uStack_e8;
      undefined8 local_e0;
      undefined8 uStack_d8;
      undefined8 local_d0;
      undefined8 uStack_c8;
      undefined8 local_c0;
      undefined8 uStack_b8;
      undefined8 local_b0;
      undefined8 uStack_a8;
      byte local_a0;
      byte local_9f;
      undefined1 local_98[16];
      undefined8 local_88;
      undefined8 uStack_80;
      undefined8 local_78;
      undefined8 *local_70;
      undefined8 local_68;
      char local_58[24];
      long local_40;
      bVar32 = 0;
      local_40 = *(long*)( in_FS_OFFSET + 0x28 );
      lVar19 = *(long*)param_1;
      if (!param_3) {
         if (*(code**)( lVar19 + 0xe8 ) == TType::isArray) {
            if (*(long*)( param_1 + 0x60 ) != 0) {
               LAB_0013fb92:if (*(code**)( lVar19 + 0x98 ) == TType::getArraySizes) {
                  lVar19 = *(long*)( param_1 + 0x60 );
               }
 else {
                  lVar19 = ( **(code**)( lVar19 + 0x98 ) )(param_1);
               }

               lVar19 = *(long*)( lVar19 + 8 );
               if (lVar19 != 0) {
                  uVar29 = (ulong)(int)( *(long*)( lVar19 + 0x10 ) - *(long*)( lVar19 + 8 ) >> 4 );
                  if (uVar29 >> 0x3d != 0) {
                     /* WARNING: Subroutine does not return */
                     std::__throw_length_error("cannot create std::vector larger than max_size()");
                  }

                  if (uVar29 != 0) {
                     uVar27 = uVar29 * 4;
                     puVar13 = (undefined4*)operator_new(uVar27);
                     *puVar13 = 0;
                     __s = puVar13 + 1;
                     if (uVar29 == 1) {
                        uVar27 = 4;
                        uVar29 = 1;
                        local_1e8 = __s;
                     }
 else {
                        local_1e8 = puVar13 + uVar29;
                        uVar29 = 1;
                        if (local_1e8 != __s) {
                           memset(__s, 0, uVar27 - 4);
                           uVar29 = (long)uVar27 >> 2;
                        }

                     }

                     goto LAB_0013fc2c;
                  }

               }

               local_1e8 = (undefined4*)0x0;
               uVar29 = 0;
               uVar27 = 0;
               puVar13 = (undefined4*)0x0;
               LAB_0013fc2c:lVar19 = *(long*)param_1;
               iVar30 = 0;
               do {
                  if (*(code**)( lVar19 + 0x98 ) == TType::getArraySizes) {
                     lVar19 = *(long*)( param_1 + 0x60 );
                  }
 else {
                     lVar19 = ( **(code**)( lVar19 + 0x98 ) )(param_1);
                  }

                  lVar19 = *(long*)( lVar19 + 8 );
                  if (lVar19 == 0) {
                     LAB_00140778:iVar23 = 1;
                  }
 else {
                     piVar14 = *(int**)( lVar19 + 8 );
                     iVar23 = (int)( *(long*)( lVar19 + 0x10 ) - (long)piVar14 >> 4 );
                     if (iVar23 < 1) goto LAB_00140778;
                     piVar2 = piVar14 + ( ulong )(iVar23 - 1) * 4 + 4;
                     iVar23 = 1;
                     do {
                        iVar23 = iVar23 * *piVar14;
                        piVar14 = piVar14 + 4;
                     }
 while ( piVar2 != piVar14 );
                  }

                  if (iVar23 <= iVar30) {
                     if (puVar13 == (undefined4*)0x0) goto LAB_00140257;
                     if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                        operator_delete(puVar13, uVar27);
                        return;
                     }

                     goto LAB_00140932;
                  }

                  local_1b8 = glslang::GetThreadPoolAllocator();
                  uVar26 = *(ulong*)( param_2 + 0x10 );
                  puVar4 = *(undefined1**)( param_2 + 8 );
                  local_1b0 = local_1a0;
                  if (uVar26 < 0x10) {
                     if (uVar26 == 1) {
                        local_1a0[0] = CONCAT71(local_1a0[0]._1_7_, *puVar4);
                     }
 else if (uVar26 != 0) goto LAB_0014063f;
                  }
 else {
                     if ((long)uVar26 < 0) goto LAB_00140943;
                     local_1b0 = (ulong*)glslang::TPoolAllocator::allocate(local_1b8);
                     local_1a0[0] = uVar26;
                     LAB_0014063f:memcpy(local_1b0, puVar4, uVar26);
                  }

                  uVar31 = 0;
                  *(undefined1*)( (long)local_1b0 + uVar26 ) = 0;
                  local_1a8 = uVar26;
                  if (local_1e8 != puVar13) {
                     do {
                        uVar26 = local_1a8;
                        uVar3 = puVar13[uVar31];
                        if (local_1a8 == 0x7fffffffffffffff) goto LAB_0014091a;
                        uVar1 = local_1a8 + 1;
                        uVar22 = local_1a0[0];
                        if (local_1b0 == local_1a0) {
                           uVar22 = 0xf;
                        }

                        if (uVar22 < uVar1) {
                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_1b8, local_1a8, 0, "[", 1);
                        }
 else {
                           *(undefined1*)( (long)local_1b0 + local_1a8 ) = 0x5b;
                        }

                        *(undefined1*)( (long)local_1b0 + uVar26 + 1 ) = 0;
                        local_1a8 = uVar1;
                        __snprintf_chk(local_58, 0x10, 2, 0x10, &_LC524, uVar3);
                        local_188 = glslang::GetThreadPoolAllocator();
                        local_180 = local_170;
                        sVar15 = strlen(local_58);
                        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_188, local_58, local_58 + sVar15);
                        if (0x7fffffffffffffff - local_1a8 < local_178) goto LAB_0014091a;
                        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_append((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_1b8, local_180, local_178);
                        uVar26 = local_1a8;
                        if (local_1a8 == 0x7fffffffffffffff) goto LAB_0014091a;
                        uVar1 = local_1a8 + 1;
                        uVar22 = local_1a0[0];
                        if (local_1b0 == local_1a0) {
                           uVar22 = 0xf;
                        }

                        if (uVar22 < uVar1) {
                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_1b8, local_1a8, 0, "]", 1);
                        }
 else {
                           *(undefined1*)( (long)local_1b0 + local_1a8 ) = 0x5d;
                        }

                        uVar31 = uVar31 + 1;
                        *(undefined1*)( (long)local_1b0 + uVar26 + 1 ) = 0;
                        local_1a8 = uVar1;
                     }
 while ( uVar31 < uVar29 );
                  }

                  operator()((_lambda_glslang__TType_const__std____cxx11__basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const__bool_auto_1___1_
                      *)
                  param_4,param_1,(basic_string*)&local_1b8,true,param_4;
                  if (uVar29 == 0) {
                     lVar19 = *(long*)param_1;
                  }
 else {
                     uVar26 = 0;
                     lVar19 = *(long*)param_1;
                     do {
                        iVar23 = puVar13[uVar26];
                        pcVar8 = *(code**)( lVar19 + 0x98 );
                        puVar13[uVar26] = iVar23 + 1;
                        if (pcVar8 == TType::getArraySizes) {
                           lVar18 = *(long*)( param_1 + 0x60 );
                        }
 else {
                           lVar18 = ( *pcVar8 )(param_1);
                           lVar19 = *(long*)param_1;
                        }

                        if (iVar23 + 1 < *(int*)( uVar26 * 0x10 + *(long*)( *(long*)( lVar18 + 8 ) + 8 ) )) break;
                        puVar13[uVar26] = 0;
                        uVar26 = uVar26 + 1;
                     }
 while ( uVar26 != uVar29 );
                  }

                  iVar30 = iVar30 + 1;
               }
 while ( true );
            }

         }
 else {
            cVar9 = ( **(code**)( lVar19 + 0xe8 ) )(param_1);
            if (cVar9 != '\0') {
               lVar19 = *(long*)param_1;
               goto LAB_0013fb92;
            }

            lVar19 = *(long*)param_1;
         }

      }

      if (*(code**)( lVar19 + 0x128 ) == TType::isStruct) {
         if (( byte )((char)param_1[8] - 0xfU) < 2) {
            LAB_00140290:if (*(code**)( lVar19 + 0x1b0 ) == TType::containsOpaque) {
               if (*(code**)( lVar19 + 0x140 ) == TType::isOpaque) {
                  if (( 0x14 < (byte)param_1[8] ) || ( ( 0x1a6000UL >> ( (ulong)(byte)param_1[8] & 0x3f ) & 1 ) == 0 )) {
                     LAB_001404ae:if (*(code**)( lVar19 + 0x128 ) == TType::isStruct) {
                        if (1 < ( byte )((char)param_1[8] - 0xfU)) goto LAB_0013fede;
                        LAB_001404ce:lVar19 = *(long*)( *(long*)( param_1 + 0x68 ) + 0x10 );
                        lVar18 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_1 + 0x68 ) + 8 ),lVar19 ));
                        if (lVar19 != lVar18) goto LAB_001402da;
                     }
 else {
                        cVar9 = ( **(code**)( lVar19 + 0x128 ) )(param_1);
                        if (cVar9 != '\0') goto LAB_001404ce;
                     }

                     lVar19 = *(long*)param_1;
                     goto LAB_0013fede;
                  }

               }
 else {
                  cVar9 = ( **(code**)( lVar19 + 0x140 ) )(param_1);
                  if (cVar9 == '\0') {
                     lVar19 = *(long*)param_1;
                     goto LAB_001404ae;
                  }

               }

               LAB_001402da:plVar24 = *(long**)( *(long*)( param_1 + 0x68 ) + 8 );
               plVar7 = *(long**)( *(long*)( param_1 + 0x68 ) + 0x10 );
               if (plVar7 != plVar24) {
                  do {
                     local_158 = glslang::GetThreadPoolAllocator();
                     uVar29 = *(ulong*)( param_2 + 0x10 );
                     puVar4 = *(undefined1**)( param_2 + 8 );
                     local_150 = &local_140;
                     if (uVar29 < 0x10) {
                        if (uVar29 == 1) {
                           local_140 = CONCAT71(local_140._1_7_, *puVar4);
                        }
 else if (uVar29 != 0) goto LAB_001406f2;
                     }
 else {
                        if ((long)uVar29 < 0) {
                           LAB_00140943:/* WARNING: Subroutine does not return */std::__throw_length_error("basic_string::_M_create");
                        }

                        local_150 = (ulong*)glslang::TPoolAllocator::allocate(local_158);
                        local_140 = uVar29;
                        LAB_001406f2:memcpy(local_150, puVar4, uVar29);
                     }

                     *(undefined1*)( (long)local_150 + uVar29 ) = 0;
                     uStack_148 = uVar29;
                     if (uVar29 == 0x7fffffffffffffff) {
                        LAB_0014091a:/* WARNING: Subroutine does not return */std::__throw_length_error("basic_string::append");
                     }

                     uVar27 = uVar29 + 1;
                     uVar26 = local_140;
                     if (local_150 == &local_140) {
                        uVar26 = 0xf;
                     }

                     if (uVar26 < uVar27) {
                        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_158, uVar29, 0, ".", 1);
                     }
 else {
                        *(undefined1*)( (long)local_150 + uVar29 ) = 0x2e;
                     }

                     *(undefined1*)( (long)local_150 + uVar29 + 1 ) = 0;
                     pcVar8 = *(code**)( *(long*)*plVar24 + 0x30 );
                     uStack_148 = uVar27;
                     if (pcVar8 == TType::getFieldName_abi_cxx11_) {
                        lVar19 = ( (long*)*plVar24 )[0xe];
                     }
 else {
                        lVar19 = ( *pcVar8 )();
                     }

                     uVar29 = *(ulong*)( lVar19 + 0x10 );
                     pcVar6 = *(char**)( lVar19 + 8 );
                     if (0x7fffffffffffffff - uStack_148 < uVar29) goto LAB_0014091a;
                     uVar27 = uVar29 + uStack_148;
                     uVar26 = local_140;
                     if (local_150 == &local_140) {
                        uVar26 = 0xf;
                     }

                     if (uVar26 < uVar27) {
                        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_158, uStack_148, 0, pcVar6, uVar29);
                     }
 else if (uVar29 != 0) {
                        if (uVar29 == 1) {
                           *(char*)( (long)local_150 + uStack_148 ) = *pcVar6;
                        }
 else {
                           memcpy((char*)( (long)local_150 + uStack_148 ), pcVar6, uVar29);
                        }

                     }

                     plVar25 = plVar24 + 4;
                     *(undefined1*)( (long)local_150 + uVar27 ) = 0;
                     uStack_148 = uVar27;
                     operator()((_lambda_glslang__TType_const__std____cxx11__basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const__bool_auto_1___1_
                        *)
                     param_4,(TType*)*plVar24,(basic_string*)&local_158,false,param_4;
                     plVar24 = plVar25;
                  }
 while ( plVar7 != plVar25 );
               }

               goto LAB_00140257;
            }

            cVar9 = ( **(code**)( lVar19 + 0x1b0 ) )(param_1);
            if (cVar9 != '\0') goto LAB_001402da;
            lVar19 = *(long*)param_1;
         }

      }
 else {
         cVar9 = ( **(code**)( lVar19 + 0x128 ) )(param_1);
         lVar19 = *(long*)param_1;
         if (cVar9 != '\0') goto LAB_00140290;
      }

      LAB_0013fede:if (*(code**)( lVar19 + 0x140 ) == TType::isOpaque) {
         if (( 0x14 < (byte)param_1[8] ) || ( ( 0x1a6000UL >> ( (ulong)(byte)param_1[8] & 0x3f ) & 1 ) == 0 )) goto LAB_00140257;
      }
 else {
         cVar9 = ( **(code**)( lVar19 + 0x140 ) )(param_1);
         if (cVar9 == '\0') goto LAB_00140257;
         lVar19 = *(long*)param_1;
      }

      plVar24 = *(long**)this;
      if (*(code**)( lVar19 + 0x98 ) == TType::getArraySizes) {
         lVar18 = *(long*)( param_1 + 0x60 );
         if (lVar18 != 0) {
            LAB_0013ff2d:if (*(long*)( lVar18 + 8 ) != 0) {
               uVar29 = glslang::GetThreadPoolAllocator();
               this_00 = (vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>*)glslang::TPoolAllocator::allocate(uVar29);
               uVar16 = glslang::GetThreadPoolAllocator();
               *(undefined8*)( this_00 + 8 ) = 0;
               pvVar5 = *(vector**)( lVar18 + 8 );
               *(undefined8*)this_00 = uVar16;
               *(undefined8*)( this_00 + 0x10 ) = 0;
               *(undefined8*)( this_00 + 0x18 ) = 0;
               std::vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>::operator =(this_00, pvVar5);
            }

            goto LAB_0013ff78;
         }

      }
 else {
         lVar19 = ( **(code**)( lVar19 + 0x98 ) )(param_1);
         if (lVar19 != 0) {
            if (*(code**)( *(long*)param_1 + 0x98 ) == TType::getArraySizes) {
               lVar18 = *(long*)( param_1 + 0x60 );
            }
 else {
               lVar18 = ( **(code**)( *(long*)param_1 + 0x98 ) )(param_1);
            }

            goto LAB_0013ff2d;
         }

         LAB_0013ff78:lVar19 = *(long*)param_1;
      }

      local_1d8 = 0;
      auStack_1d0 = (undefined1[16])0x0;
      if (*(code**)( lVar19 + 0xb0 ) == TType::getTypeParameters) {
         puVar21 = *(undefined8**)( param_1 + 0x88 );
         if (puVar21 != (undefined8*)0x0) {
            LAB_0013ffb0:local_1d8 = *puVar21;
            auStack_1d0 = *(undefined1(*) [16])( puVar21 + 1 );
         }

      }
 else {
         lVar18 = ( **(code**)( lVar19 + 0xb0 ) )(param_1);
         lVar19 = *(long*)param_1;
         if (lVar18 != 0) {
            if (*(code**)( lVar19 + 0xb0 ) == TType::getTypeParameters) {
               puVar21 = *(undefined8**)( param_1 + 0x88 );
            }
 else {
               puVar21 = (undefined8*)( **(code**)( lVar19 + 0xb0 ) )(param_1);
               lVar19 = *(long*)param_1;
            }

            goto LAB_0013ffb0;
         }

      }

      pTVar28 = (TPublicType*)&local_158;
      for (lVar18 = 0x1f; lVar18 != 0; lVar18 = lVar18 + -1) {
         *(undefined8*)pTVar28 = 0;
         pTVar28 = pTVar28 + (ulong)bVar32 * -0x10 + 8;
      }

      if (*(code**)( lVar19 + 0x38 ) == TType::getBasicType) {
         uVar12 = (uint)(byte)param_1[8];
      }
 else {
         uVar12 = ( **(code**)( lVar19 + 0x38 ) )(param_1);
         lVar19 = *(long*)param_1;
      }

      local_158 = CONCAT44(local_158._4_4_, uVar12);
      if (*(code**)( lVar19 + 0x40 ) == TType::getSampler) {
         pTVar20 = param_1 + 0x80;
      }
 else {
         pTVar20 = (TType*)( **(code**)( lVar19 + 0x40 ) )(param_1);
         lVar19 = *(long*)param_1;
      }

      local_158 = CONCAT44(*(undefined4*)pTVar20, (undefined4)local_158);
      if (*(code**)( lVar19 + 0x58 ) == TType::getQualifier) {
         pTVar20 = param_1 + 0x10;
      }
 else {
         pTVar20 = (TType*)( **(code**)( lVar19 + 0x58 ) )(param_1);
         lVar19 = *(long*)param_1;
      }

      local_150 = *(ulong**)pTVar20;
      uStack_148 = *(ulong*)( pTVar20 + 8 );
      local_140 = *(ulong*)( pTVar20 + 0x10 );
      lStack_138 = *(long*)( pTVar20 + 0x18 );
      local_130 = *(long*)( pTVar20 + 0x20 );
      lStack_128 = *(long*)( pTVar20 + 0x28 );
      local_120 = *(long*)( pTVar20 + 0x30 );
      lStack_118 = *(long*)( pTVar20 + 0x38 );
      local_110 = *(long*)( pTVar20 + 0x40 );
      lStack_108 = *(long*)( pTVar20 + 0x48 );
      if (*(code**)( lVar19 + 0x60 ) == TType::getVectorSize) {
         TVar11 = param_1[9];
      }
 else {
         TVar11 = ( TType )(**(code**)( lVar19 + 0x60 ))(param_1);
         lVar19 = *(long*)param_1;
      }

      local_a0 = local_a0 & 0xf0 | (byte)TVar11 & 0xf;
      if (*(code**)( lVar19 + 0x68 ) == TType::getMatrixCols) {
         uVar12 = ( uint )((byte)param_1[9] >> 4);
      }
 else {
         uVar12 = ( **(code**)( lVar19 + 0x68 ) )(param_1);
         lVar19 = *(long*)param_1;
         uVar12 = uVar12 & 0xf;
      }

      local_a0 = local_a0 & 0xf | ( byte )(uVar12 << 4);
      if (*(code**)( lVar19 + 0x70 ) == TType::getMatrixRows) {
         TVar11 = param_1[10];
         TVar10 = TVar11;
      }
 else {
         TVar10 = ( TType )(**(code**)( lVar19 + 0x70 ))(param_1);
         lVar19 = *(long*)param_1;
         TVar11 = param_1[10];
      }

      local_98 = (undefined1[16])0x0;
      local_9f = (byte)TVar11 >> 1 & 0x10 | (byte)TVar10 & 0xf | (byte)TVar11 >> 1 & 0x20 | local_9f & 0xc0;
      puVar21 = (undefined8*)plVar24[1];
      local_88 = *puVar21;
      uStack_80 = puVar21[1];
      local_78 = puVar21[2];
      if (*(code**)( lVar19 + 0xb0 ) == TType::getTypeParameters) {
         local_70 = *(undefined8**)( param_1 + 0x88 );
      }
 else {
         local_70 = (undefined8*)( **(code**)( lVar19 + 0xb0 ) )(param_1);
      }

      local_68 = 0;
      if (local_70 != (undefined8*)0x0) {
         local_70 = &local_1d8;
      }

      lVar19 = *plVar24;
      local_100 = *(undefined8*)( lVar19 + 0x58 );
      uStack_f8 = *(undefined8*)( lVar19 + 0x60 );
      local_f0 = *(undefined8*)( lVar19 + 0x68 );
      uStack_e8 = *(undefined8*)( lVar19 + 0x70 );
      local_e0 = *(undefined8*)( lVar19 + 0x78 );
      uStack_d8 = *(undefined8*)( lVar19 + 0x80 );
      uStack_148 = CONCAT71(uStack_148._1_7_, (byte)uStack_148 & 0x80 | *(byte*)( lVar19 + 0x10 ) & 0x7f);
      local_d0 = *(undefined8*)( lVar19 + 0x88 );
      uStack_c8 = *(undefined8*)( lVar19 + 0x90 );
      local_c0 = *(undefined8*)( lVar19 + 0x98 );
      uStack_b8 = *(undefined8*)( lVar19 + 0xa0 );
      local_b0 = *(undefined8*)( lVar19 + 0xa8 );
      uStack_a8 = *(undefined8*)( lVar19 + 0xb0 );
      pcVar6 = *(char**)( param_2 + 8 );
      uVar29 = glslang::GetThreadPoolAllocator();
      pbVar17 = (basic_string*)glslang::TPoolAllocator::allocate(uVar29);
      uVar16 = glslang::GetThreadPoolAllocator();
      *(undefined8*)pbVar17 = uVar16;
      *(basic_string**)( pbVar17 + 8 ) = pbVar17 + 0x18;
      if (pcVar6 == (char*)0x0) {
         /* WARNING: Subroutine does not return */
         std::__throw_logic_error("basic_string: construction from null is not valid");
      }

      sVar15 = strlen(pcVar6);
      std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(pbVar17, pcVar6, pcVar6 + sVar15);
      TParseContext::declareVariable((TParseContext*)plVar24[2], (TSourceLoc*)plVar24[1], pbVar17, (TPublicType*)&local_158, (TArraySizes*)0x0, (TIntermTyped*)0x0);
      LAB_00140257:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
         return;
      }

      LAB_00140932:/* WARNING: Subroutine does not return */__stack_chk_fail();
   }

   /* glslang::TParseContext::vkRelaxedRemapUniformMembers(glslang::TSourceLoc const&,
   glslang::TPublicType const&, glslang::TType const&, std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const&) */
   void glslang::TParseContext::vkRelaxedRemapUniformMembers(TParseContext *this, TSourceLoc *param_1, TPublicType *param_2, TType *param_3, basic_string *param_4) {
      char cVar1;
      long lVar2;
      long lVar3;
      long in_FS_OFFSET;
      TPublicType **local_60;
      TPublicType *local_58;
      TSourceLoc *local_50;
      TParseContext *local_48;
      long local_40;
      local_40 = *(long*)( in_FS_OFFSET + 0x28 );
      lVar2 = *(long*)param_3;
      if (*(code**)( lVar2 + 0x128 ) == TType::isStruct) {
         if (1 < ( byte )((char)param_3[8] - 0xfU)) goto LAB_00140a31;
      }
 else {
         cVar1 = ( **(code**)( lVar2 + 0x128 ) )(param_3);
         if (cVar1 == '\0') goto LAB_00140a31;
         lVar2 = *(long*)param_3;
      }

      if (*(code**)( lVar2 + 0x1b0 ) == TType::containsOpaque) {
         if (*(code**)( lVar2 + 0x140 ) == TType::isOpaque) {
            if (( 0x14 < (byte)param_3[8] ) || ( ( 0x1a6000UL >> ( (ulong)(byte)param_3[8] & 0x3f ) & 1 ) == 0 )) {
               LAB_00140a64:if (*(code**)( lVar2 + 0x128 ) == TType::isStruct) {
                  if (1 < ( byte )((char)param_3[8] - 0xfU)) goto LAB_00140a31;
               }
 else {
                  cVar1 = ( **(code**)( lVar2 + 0x128 ) )(param_3);
                  if (cVar1 == '\0') goto LAB_00140a31;
               }

               lVar2 = *(long*)( *(long*)( param_3 + 0x68 ) + 0x10 );
               lVar3 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_3 + 0x68 ) + 8 ),lVar2 ));
               if (lVar2 == lVar3) goto LAB_00140a31;
            }

         }
 else {
            cVar1 = ( **(code**)( lVar2 + 0x140 ) )(param_3);
            if (cVar1 == '\0') {
               lVar2 = *(long*)param_3;
               goto LAB_00140a64;
            }

         }

      }
 else {
         cVar1 = ( **(code**)( lVar2 + 0x1b0 ) )(param_3);
         if (cVar1 == '\0') goto LAB_00140a31;
      }

      local_60 = &local_58;
      local_58 = param_2;
      local_50 = param_1;
      local_48 = this;
      ForEachOpaque<glslang::TParseContext::vkRelaxedRemapUniformMembers(glslang::TSourceLoc_const&,glslang::TPublicType_const&,glslang::TType_const&,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const&)::{
         lambda(glslang::TType_const&,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const&)
         #1
         ::
  {lambda(glslang::TType_const&,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const&,bool,auto:1&)
         #1
         ::operator ()((_lambda_glslang__TType_const__std____cxx11__basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const__bool_auto_1___1_*)&local_60, param_3, param_4, false, (_lambda_glslang__TType_const__std____cxx11__basic_string<char,std::char_traits<char>,glslang::std::allocator<char>_>_const__bool_auto_1___1_*)&local_60);
         LAB_00140a31:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
            /* WARNING: Subroutine does not return */
            __stack_chk_fail();
         }

         return;
      }

      /* glslang::TParseContext::vkRelaxedRemapUniformVariable(glslang::TSourceLoc const&,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >&,
   glslang::TPublicType const&, glslang::TArraySizes*, glslang::TIntermTyped*, glslang::TType&) */
      undefined8 glslang::TParseContext::vkRelaxedRemapUniformVariable(TParseContext *this, TSourceLoc *param_1, basic_string *param_2, TPublicType *param_3, TArraySizes *param_4, TIntermTyped *param_5, TType *param_6) {
         long lVar1;
         code *pcVar2;
         char cVar3;
         TType TVar4;
         uint uVar5;
         long lVar6;
         undefined8 uVar7;
         TParseContext *pTVar8;
         TQualifier *pTVar9;
         TSymbol *pTVar10;
         long lVar11;
         TArraySizes *pTVar12;
         TType *pTVar13;
         TParseContext *pTVar14;
         TParseContext *pTVar15;
         TParseContext *pTVar16;
         TQualifier *pTVar17;
         long in_FS_OFFSET;
         bool bVar18;
         uint local_4c;
         uint *local_48;
         long local_40;
         local_40 = *(long*)( in_FS_OFFSET + 0x28 );
         vkRelaxedRemapUniformMembers(this, param_1, param_3, param_6, param_2);
         if (( this[0x1c1] == (TParseContext)0x0 ) && ( (int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 ) == 4 )) {
            if (*(code**)( *(long*)param_6 + 0x50 ) == TType::getQualifier) {
               pTVar13 = param_6 + 0x10;
            }
 else {
               pTVar13 = (TType*)( **(code**)( *(long*)param_6 + 0x50 ) )(param_6);
            }

            if (( (byte)pTVar13[8] & 0x7f ) == 5) {
               lVar6 = *(long*)param_6;
               if (*(code**)( lVar6 + 0x1c8 ) == TType::containsNonOpaque) {
                  TVar4 = param_6[8];
                  if (( 0xc < (byte)TVar4 ) && ( TVar4 != (TType)0x12 )) {
                     if (*(code**)( lVar6 + 0x128 ) == TType::isStruct) {
                        if (( byte )((char)TVar4 - 0xfU) < 2) {
                           LAB_00141070:lVar1 = *(long*)( *(long*)( param_6 + 0x68 ) + 0x10 );
                           lVar11 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsNonOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsNonOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( param_6 + 0x68 ) + 8 ),lVar1 ));
                           lVar6 = *(long*)param_6;
                           if (lVar1 != lVar11) goto LAB_00140c50;
                        }

                     }
 else {
                        cVar3 = ( **(code**)( lVar6 + 0x128 ) )(param_6);
                        if (cVar3 != '\0') goto LAB_00141070;
                        lVar6 = *(long*)param_6;
                     }

                     LAB_00140bd9:if (*(code**)( lVar6 + 0x38 ) == TType::getBasicType) {
                        uVar5 = (uint)(byte)param_6[8];
                     }
 else {
                        uVar5 = ( **(code**)( lVar6 + 0x38 ) )(param_6);
                        lVar6 = *(long*)param_6;
                     }

                     if (uVar5 != 0xd) {
                        if (*(code**)( lVar6 + 0x1b8 ) == TType::containsSampler) {
                           cVar3 = TType::contains<glslang::TType::containsSampler()const::_lambda(glslang::TType_const*)_1_>();
                        }
 else {
                           cVar3 = ( **(code**)( lVar6 + 0x1b8 ) )(param_6);
                        }

                        if (cVar3 != '\0') {
                           lVar6 = *(long*)param_6;
                           if (*(code**)( lVar6 + 0x128 ) == TType::isStruct) {
                              if (( byte )((char)param_6[8] - 0xfU) < 2) goto LAB_00140c50;
                           }
 else {
                              cVar3 = ( **(code**)( lVar6 + 0x128 ) )(param_6);
                              if (cVar3 != '\0') {
                                 lVar6 = *(long*)param_6;
                                 goto LAB_00140c50;
                              }

                           }

                        }

                        goto LAB_00140b51;
                     }

                  }

               }
 else {
                  cVar3 = ( **(code**)( lVar6 + 0x1c8 ) )(param_6);
                  lVar6 = *(long*)param_6;
                  if (cVar3 == '\0') goto LAB_00140bd9;
               }

               LAB_00140c50:if (*(code**)( lVar6 + 0x50 ) == TType::getQualifier) {
                  pTVar13 = param_6 + 0x10;
               }
 else {
                  pTVar13 = (TType*)( **(code**)( lVar6 + 0x50 ) )(param_6);
               }

               if (( ~*(ushort *)(pTVar13 + 0x1c) & 0xfff ) != 0) {
                  ( **(code**)( *(long*)this + 0x160 ) )(this, param_1, "ignoring layout qualifier for uniform", *(undefined8*)( param_2 + 8 ));
                  if (*(code**)( *(long*)param_6 + 0x50 ) == TType::getQualifier) {
                     pTVar13 = param_6 + 0x10;
                  }
 else {
                     pTVar13 = (TType*)( **(code**)( *(long*)param_6 + 0x50 ) )(param_6);
                  }

                  *(ushort*)( pTVar13 + 0x1c ) = *(ushort*)( pTVar13 + 0x1c ) | 0xfff;
               }

               if (param_5 != (TIntermTyped*)0x0) {
                  ( **(code**)( *(long*)this + 0x160 ) )(this, param_1, "Ignoring initializer for uniform", *(undefined8*)( param_2 + 8 ));
               }

               lVar6 = *(long*)param_6;
               if (*(code**)( lVar6 + 0xe8 ) == TType::isArray) {
                  if (*(long*)( param_6 + 0x60 ) != 0) {
                     LAB_00140e11:if (*(code**)( lVar6 + 0xa0 ) == TType::getArraySizes) {
                        pTVar12 = *(TArraySizes**)( param_6 + 0x60 );
                     }
 else {
                        pTVar12 = (TArraySizes*)( **(code**)( lVar6 + 0xa0 ) )(param_6);
                        lVar6 = *(long*)param_6;
                     }

                     if (*(code**)( lVar6 + 0x50 ) == TType::getQualifier) {
                        pTVar17 = (TQualifier*)( param_6 + 0x10 );
                        if (this[0x1c1] == (TParseContext)0x0) {
                           LAB_00140e46:arraySizesCheck(this, param_1, pTVar17, pTVar12, (TIntermTyped*)0x0, false);
                           goto LAB_00140e5a;
                        }

                        LAB_00140e6b:pTVar17 = (TQualifier*)( param_6 + 0x10 );
                     }
 else {
                        pTVar17 = (TQualifier*)( **(code**)( lVar6 + 0x50 ) )(param_6);
                        if (this[0x1c1] == (TParseContext)0x0) goto LAB_00140e46;
                        LAB_00140e5a:if (*(code**)( *(long*)param_6 + 0x50 ) == TType::getQualifier) goto LAB_00140e6b;
                        pTVar17 = (TQualifier*)( **(code**)( *(long*)param_6 + 0x50 ) )(param_6);
                     }

                     cVar3 = arrayQualifierError(this, param_1, pTVar17);
                     if (( cVar3 != '\0' ) || ( cVar3 = arrayError(this, param_1, param_6) ),cVar3 != '\0') {
                        ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "array param error", *(undefined8*)( param_2 + 8 ));
                     }

                  }

               }
 else {
                  cVar3 = ( **(code**)( lVar6 + 0xe8 ) )(param_6);
                  if (cVar3 != '\0') {
                     lVar6 = *(long*)param_6;
                     goto LAB_00140e11;
                  }

               }

               layoutTypeCheck(this, param_1, param_6);
               local_4c = 0xffff;
               if (param_6[8] == (TType)0xd) {
                  param_6[8] = (TType)0x9;
                  if (*(code**)( *(long*)param_6 + 0x50 ) == TType::getQualifier) {
                     param_6[0x18] = ( TType )((byte)param_6[0x18] & 0x80 | 6);
                     LAB_00140ee5:TVar4 = ( TType )((byte)param_6[0x1e] | 4);
                     param_6[0x1e] = TVar4;
                     LAB_00140ef1:param_6[0x1e] = ( TType )((byte)TVar4 | 2);
                     LAB_00140ef8:local_4c = ( uint ) * (ushort*)( param_6 + 0x30 );
                     LAB_00140f01:*(undefined2*)( param_6 + 0x30 ) = 0xffff;
                     LAB_00140f0b:pTVar13 = param_6 + 0x10;
                  }
 else {
                     lVar6 = ( **(code**)( *(long*)param_6 + 0x50 ) )(param_6);
                     pcVar2 = *(code**)( *(long*)param_6 + 0x50 );
                     *(byte*)( lVar6 + 8 ) = *(byte*)( lVar6 + 8 ) & 0x80 | 6;
                     if (pcVar2 == TType::getQualifier) goto LAB_00140ee5;
                     lVar6 = ( *pcVar2 )(param_6);
                     pcVar2 = *(code**)( *(long*)param_6 + 0x50 );
                     *(byte*)( lVar6 + 0xe ) = *(byte*)( lVar6 + 0xe ) | 4;
                     if (pcVar2 == TType::getQualifier) {
                        TVar4 = param_6[0x1e];
                        goto LAB_00140ef1;
                     }

                     lVar6 = ( *pcVar2 )(param_6);
                     pcVar2 = *(code**)( *(long*)param_6 + 0x50 );
                     *(byte*)( lVar6 + 0xe ) = *(byte*)( lVar6 + 0xe ) | 2;
                     if (pcVar2 == TType::getQualifier) goto LAB_00140ef8;
                     lVar6 = ( *pcVar2 )(param_6);
                     local_4c = ( uint ) * (ushort*)( lVar6 + 0x20 );
                     if (*(code**)( *(long*)param_6 + 0x50 ) == TType::getQualifier) goto LAB_00140f01;
                     lVar6 = ( **(code**)( *(long*)param_6 + 0x50 ) )(param_6);
                     pcVar2 = *(code**)( *(long*)param_6 + 0x50 );
                     *(undefined2*)( lVar6 + 0x20 ) = 0xffff;
                     if (pcVar2 == TType::getQualifier) goto LAB_00140f0b;
                     pTVar13 = (TType*)( *pcVar2 )(param_6);
                  }

                  pTVar13[0xc] = ( TType )((byte)pTVar13[0xc] & 0xfb);
                  ( **(code**)( *(long*)this + 0x1f8 ) )(this, local_4c, param_1, param_6, param_2, 0);
                  pTVar15 = *(TParseContext**)( this + 0x4a0 );
                  pTVar16 = this + 0x498;
                  pTVar8 = pTVar16;
                  if (pTVar15 == (TParseContext*)0x0) {
                     LAB_00140f7a:local_48 = &local_4c;
                     pTVar8 = (TParseContext*)std::_Rb_tree<int,std::pair<int_const,glslang::TVariable*>,std::_Select1st<std::pair<int_const,glslang::TVariable*>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVariable*>>>::_M_emplace_hint_unique<std::piecewise_construct_t_const&,std::tuple<int_const&>,std::tuple<>>(this + 0x488, pTVar16, &local_48);
                  }
 else {
                     do {
                        pTVar14 = *(TParseContext**)( pTVar15 + 0x18 );
                        if ((int)local_4c <= *(int*)( pTVar15 + 0x20 )) {
                           pTVar14 = *(TParseContext**)( pTVar15 + 0x10 );
                           pTVar8 = pTVar15;
                        }

                        pTVar15 = pTVar14;
                     }
 while ( pTVar14 != (TParseContext*)0x0 );
                     bVar18 = pTVar16 == pTVar8;
                     pTVar16 = pTVar8;
                     if (( bVar18 ) || ( (int)local_4c < *(int*)( pTVar8 + 0x20 ) )) goto LAB_00140f7a;
                  }

                  pTVar10 = *(TSymbol**)( pTVar8 + 0x28 );
                  if (pTVar10 == (TSymbol*)0x0) goto LAB_00140d1e;
               }
 else {
                  LAB_00140d1e:( **(code**)( *(long*)this + 0x1f0 ) )(this, param_1, param_6);
                  pTVar10 = *(TSymbol**)( this + 0x470 );
               }

               layoutObjectCheck(this, param_1, pTVar10);
               lVar6 = TSymbolTable::find(*(TSymbolTable**)( this + 0xe8 ), param_2, (bool*)0x0, (bool*)0x0, (int*)0x0);
               if (lVar6 == 0) {
                  if (*(TSymbol**)( this + 0x470 ) == pTVar10) {
                     ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "error adding uniform to default uniform block", *(undefined8*)( param_2 + 8 ), &_LC1);
                     uVar7 = 0;
                  }
 else {
                     ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "error adding atomic counter to atomic counter block");
                     uVar7 = 0;
                  }

               }
 else {
                  if (*(code**)( *(long*)param_6 + 0x50 ) == TType::getQualifier) {
                     pTVar17 = (TQualifier*)( param_6 + 0x10 );
                  }
 else {
                     pTVar17 = (TQualifier*)( **(code**)( *(long*)param_6 + 0x50 ) )(param_6);
                  }

                  if (*(code**)( *(long*)pTVar10 + 0x68 ) == TVariable::getWritableType) {
                     pTVar10 = pTVar10 + 0x28;
                  }
 else {
                     pTVar10 = (TSymbol*)( **(code**)( *(long*)pTVar10 + 0x68 ) )(pTVar10);
                  }

                  if (*(code**)( *(long*)pTVar10 + 0x50 ) == TType::getQualifier) {
                     pTVar9 = (TQualifier*)( pTVar10 + 0x10 );
                  }
 else {
                     pTVar9 = (TQualifier*)( **(code**)( *(long*)pTVar10 + 0x50 ) )();
                  }

                  mergeObjectLayoutQualifiers(this, pTVar9, pTVar17, true);
                  uVar7 = 1;
               }

               goto LAB_00140dc3;
            }

         }

         LAB_00140b51:uVar7 = 0;
         LAB_00140dc3:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
            /* WARNING: Subroutine does not return */
            __stack_chk_fail();
         }

         return uVar7;
      }

      /* glslang::TParseContext::constructorTextureSamplerError(glslang::TSourceLoc const&,
   glslang::TFunction const&) */
      undefined8 glslang::TParseContext::constructorTextureSamplerError(TParseContext *this, TSourceLoc *param_1, TFunction *param_2) {
         TFunction TVar1;
         TFunction TVar2;
         byte bVar3;
         undefined4 uVar4;
         code *pcVar5;
         void *pvVar6;
         ulong uVar7;
         ulong uVar8;
         undefined1 *puVar9;
         char cVar10;
         uint uVar11;
         undefined8 uVar12;
         long lVar13;
         TFunction *pTVar14;
         long *plVar15;
         long lVar16;
         int iVar17;
         long lVar18;
         ulong uVar19;
         char *pcVar20;
         long lVar21;
         long lVar22;
         long in_FS_OFFSET;
         bool bVar23;
         short local_a0;
         byte local_98;
         TParseContext *local_70;
         undefined8 local_68;
         undefined1 *local_60;
         undefined1 local_50[16];
         long local_40;
         local_40 = *(long*)( in_FS_OFFSET + 0x28 );
         if (*(code**)( *(long*)param_2 + 0x60 ) == TFunction::getType) {
            pTVar14 = param_2 + 0x48;
         }
 else {
            pTVar14 = (TFunction*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
         }

         if (pTVar14[8] == (TFunction)0xe) {
            TSampler::getString_abi_cxx11_();
         }
 else {
            local_68 = glslang::GetThreadPoolAllocator();
            switch (pTVar14[8]) {
               case (TFunction)0x0:
      lVar18 = 4;
      pcVar20 = "void";
      break;
               case (TFunction)0x1:
      lVar18 = 5;
      pcVar20 = "float";
      break;
               case (TFunction)0x2:
      lVar18 = 6;
      pcVar20 = "double";
      break;
               case (TFunction)0x3:
      lVar18 = 9;
      pcVar20 = "float16_t";
      break;
               case (TFunction)0x4:
      lVar18 = 6;
      pcVar20 = "int8_t";
      break;
               case (TFunction)0x5:
      lVar18 = 7;
      pcVar20 = "uint8_t";
      break;
               case (TFunction)0x6:
      lVar18 = 7;
      pcVar20 = "int16_t";
      break;
               case (TFunction)0x7:
      lVar18 = 8;
      pcVar20 = "uint16_t";
      break;
               case (TFunction)0x8:
      lVar18 = 3;
      pcVar20 = "int";
      break;
               case (TFunction)0x9:
      lVar18 = 4;
      pcVar20 = "uint";
      break;
               case (TFunction)0xa:
      lVar18 = 7;
      pcVar20 = "int64_t";
      break;
               case (TFunction)0xb:
      lVar18 = 8;
      pcVar20 = "uint64_t";
      break;
               case (TFunction)0xc:
      lVar18 = 4;
      pcVar20 = "bool";
      break;
               case (TFunction)0xd:
      lVar18 = 0xb;
      pcVar20 = "atomic_uint";
      break;
               case (TFunction)0xe:
      lVar18 = 0xd;
      pcVar20 = "sampler/image";
      break;
               case (TFunction)0xf:
      lVar18 = 9;
      pcVar20 = "structure";
      break;
               case (TFunction)0x10:
      lVar18 = 5;
      pcVar20 = "block";
      break;
               case (TFunction)0x11:
      lVar18 = 0x17;
      pcVar20 = "accelerationStructureNV";
      break;
               case (TFunction)0x12:
      lVar18 = 9;
      pcVar20 = "reference";
      break;
               case (TFunction)0x13:
      lVar18 = 0xb;
      pcVar20 = "rayQueryEXT";
      break;
               default:
      lVar18 = 0xc;
      pcVar20 = "unknown type";
      break;
               case (TFunction)0x15:
      lVar18 = 7;
      pcVar20 = "coopmat";
      break;
               case (TFunction)0x16:
      lVar18 = 10;
      pcVar20 = "spirv_type";
      break;
               case (TFunction)0x17:
      lVar18 = 6;
      pcVar20 = "string";
            }

            local_60 = local_50;
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, pcVar20, pcVar20 + lVar18);
         }

         puVar9 = local_60;
         lVar18 = *(long*)param_2;
         if (*(code**)( lVar18 + 0x120 ) == TFunction::getParamCount) {
            iVar17 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
            if (iVar17 != 1) goto LAB_001412b9;
            LAB_00141313:if (*(code**)( lVar18 + 0x140 ) == TFunction::operator []) {
               lVar18 = *(long*)( param_2 + 0x30 );
            }
 else {
               lVar18 = ( **(code**)( lVar18 + 0x140 ) )(param_2, 0);
            }

            plVar15 = *(long**)( lVar18 + 8 );
            if (*(code**)( *plVar15 + 0x38 ) == TType::getBasicType) {
               uVar11 = ( uint ) * (byte*)( plVar15 + 1 );
            }
 else {
               uVar11 = ( **(code**)( *plVar15 + 0x38 ) )(plVar15);
            }

            if (1 < uVar11 - 8) {
               cVar10 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_ARB_bindless_texture");
               LAB_0014136a:if (cVar10 == '\0') {
                  ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "sampler-constructor requires the extension GL_ARB_bindless_texture enabled");
               }
 else {
                  ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "sampler-constructor requires the input to be ivec2 or uvec2", puVar9, &_LC1);
               }

               goto LAB_001412e6;
            }

            if (*(code**)( *plVar15 + 0x60 ) == TType::getVectorSize) {
               uVar11 = *(byte*)( (long)plVar15 + 9 ) & 0xf;
            }
 else {
               uVar11 = ( **(code**)( *plVar15 + 0x60 ) )(plVar15);
            }

            cVar10 = ( **(code**)( *(long*)this + 0x40 ) )(this, "GL_ARB_bindless_texture");
            if (( uVar11 != 2 ) || ( cVar10 == '\0' )) goto LAB_0014136a;
            if (*(code**)( *plVar15 + 0x48 ) == TType::getSampler) {
               plVar15 = plVar15 + 0x10;
            }
 else {
               plVar15 = (long*)( **(code**)( *plVar15 + 0x48 ) )(plVar15);
            }

            lVar18 = *(long*)( this + 0x38 );
            if (( ( *plVar15 & 0x80000 ) != 0 ) && ( 1 < ( byte )(*(char*)( (long)plVar15 + 1 ) - 7U) )) {
               lVar22 = lVar18 + 0x560;
               if (*(long*)( lVar18 + 0x568 ) == 0) {
                  LAB_00141cc4:local_70 = this + 0x7510;
                  lVar13 = std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>::_M_emplace_hint_unique<std::piecewise_construct_t_const&,std::tuple<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const&>,std::tuple<>>(lVar18 + 0x558, lVar22, &local_70);
               }
 else {
                  pvVar6 = *(void**)( this + 0x7518 );
                  uVar7 = *(ulong*)( this + 0x7520 );
                  lVar16 = *(long*)( lVar18 + 0x568 );
                  lVar13 = lVar22;
                  do {
                     uVar8 = *(ulong*)( lVar16 + 0x30 );
                     uVar19 = uVar7;
                     if (uVar8 <= uVar7) {
                        uVar19 = uVar8;
                     }

                     if (( uVar19 == 0 ) || ( iVar17 = memcmp(*(void**)( lVar16 + 0x28 ), pvVar6, uVar19) ),iVar17 == 0) {
                        lVar21 = uVar8 - uVar7;
                        if (lVar21 < 0x80000000) {
                           if (-0x80000001 < lVar21) {
                              iVar17 = (int)lVar21;
                              goto LAB_0014190f;
                           }

                           goto LAB_001418c0;
                        }

                        LAB_00141913:lVar21 = *(long*)( lVar16 + 0x10 );
                        lVar13 = lVar16;
                     }
 else {
                        LAB_0014190f:if (-1 < iVar17) goto LAB_00141913;
                        LAB_001418c0:lVar21 = *(long*)( lVar16 + 0x18 );
                     }

                     lVar16 = lVar21;
                  }
 while ( lVar21 != 0 );
                  bVar23 = lVar22 == lVar13;
                  lVar22 = lVar13;
                  if (bVar23) goto LAB_00141cc4;
                  uVar8 = *(ulong*)( lVar13 + 0x30 );
                  uVar19 = uVar7;
                  if (uVar8 <= uVar7) {
                     uVar19 = uVar8;
                  }

                  if (( uVar19 == 0 ) || ( iVar17 = memcmp(pvVar6, *(void**)( lVar13 + 0x28 ), uVar19) ),iVar17 == 0) {
                     lVar16 = uVar7 - uVar8;
                     if (lVar16 < 0x80000000) {
                        if (lVar16 < -0x80000000) goto LAB_00141cc4;
                        iVar17 = (int)lVar16;
                        goto LAB_00141cc0;
                     }

                  }
 else {
                     LAB_00141cc0:if (iVar17 < 0) goto LAB_00141cc4;
                  }

               }

               *(undefined4*)( lVar13 + 0x48 ) = 1;
               uVar12 = 0;
               goto LAB_001412eb;
            }

            lVar22 = lVar18 + 0x530;
            if (*(long*)( lVar18 + 0x538 ) == 0) {
               LAB_0014180b:local_70 = this + 0x7510;
               lVar13 = std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>::_M_emplace_hint_unique<std::piecewise_construct_t_const&,std::tuple<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const&>,std::tuple<>>(lVar18 + 0x528, lVar22, &local_70);
            }
 else {
               pvVar6 = *(void**)( this + 0x7518 );
               uVar7 = *(ulong*)( this + 0x7520 );
               lVar16 = *(long*)( lVar18 + 0x538 );
               lVar13 = lVar22;
               do {
                  while (true) {
                     lVar21 = lVar16;
                     uVar8 = *(ulong*)( lVar21 + 0x30 );
                     uVar19 = uVar7;
                     if (uVar8 <= uVar7) {
                        uVar19 = uVar8;
                     }

                     if (( uVar19 != 0 ) && ( iVar17 = memcmp(*(void**)( lVar21 + 0x28 ), pvVar6, uVar19) ),iVar17 != 0) break;
                     lVar16 = uVar8 - uVar7;
                     if (lVar16 < 0x80000000) {
                        if (-0x80000001 < lVar16) {
                           iVar17 = (int)lVar16;
                           break;
                        }

                        goto LAB_00141740;
                     }

                     LAB_0014178c:lVar16 = *(long*)( lVar21 + 0x10 );
                     lVar13 = lVar21;
                     if (*(long*)( lVar21 + 0x10 ) == 0) goto LAB_00141798;
                  }
;
                  if (-1 < iVar17) goto LAB_0014178c;
                  LAB_00141740:lVar16 = *(long*)( lVar21 + 0x18 );
               }
 while ( *(long*)( lVar21 + 0x18 ) != 0 );
               LAB_00141798:bVar23 = lVar13 == lVar22;
               lVar22 = lVar13;
               if (bVar23) goto LAB_0014180b;
               uVar8 = *(ulong*)( lVar13 + 0x30 );
               uVar19 = uVar7;
               if (uVar8 <= uVar7) {
                  uVar19 = uVar8;
               }

               if (( uVar19 == 0 ) || ( iVar17 = memcmp(pvVar6, *(void**)( lVar13 + 0x28 ), uVar19) ),iVar17 == 0) {
                  lVar16 = uVar7 - uVar8;
                  if (lVar16 < 0x80000000) {
                     if (lVar16 < -0x80000000) goto LAB_0014180b;
                     iVar17 = (int)lVar16;
                     goto LAB_001417ee;
                  }

               }
 else {
                  LAB_001417ee:if (iVar17 < 0) goto LAB_0014180b;
               }

            }

            *(undefined4*)( lVar13 + 0x48 ) = 1;
            LAB_001417fa:uVar12 = 0;
            goto LAB_001412eb;
         }

         iVar17 = ( **(code**)( lVar18 + 0x120 ) )(param_2);
         if (iVar17 == 1) {
            lVar18 = *(long*)param_2;
            goto LAB_00141313;
         }

         if (*(code**)( *(long*)param_2 + 0x120 ) == TFunction::getParamCount) {
            iVar17 = (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555;
         }
 else {
            iVar17 = ( **(code**)( *(long*)param_2 + 0x120 ) )(param_2);
         }

         LAB_001412b9:if (iVar17 == 2) {
            if (*(code**)( *(long*)param_2 + 0x60 ) == TFunction::getType) {
               pTVar14 = param_2 + 0x48;
            }
 else {
               pTVar14 = (TFunction*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
            }

            if (*(code**)( *(long*)pTVar14 + 0xe8 ) == TType::isArray) {
               if (*(long*)( pTVar14 + 0x60 ) != 0) {
                  LAB_001415a2:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "sampler-constructor cannot make an array of samplers", puVar9, &_LC1);
                  goto LAB_001412e6;
               }

            }
 else {
               cVar10 = ( **(code**)( *(long*)pTVar14 + 0xe8 ) )();
               if (cVar10 != '\0') goto LAB_001415a2;
            }

            if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
               lVar18 = *(long*)( param_2 + 0x30 );
            }
 else {
               lVar18 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
            }

            pcVar5 = *(code**)( **(long**)( lVar18 + 8 ) + 0x38 );
            if (pcVar5 == TType::getBasicType) {
               uVar11 = ( uint ) * (byte*)( *(long**)( lVar18 + 8 ) + 1 );
            }
 else {
               uVar11 = ( *pcVar5 )();
            }

            if (uVar11 == 0xe) {
               if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                  lVar18 = *(long*)( param_2 + 0x30 );
               }
 else {
                  lVar18 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
               }

               pcVar5 = *(code**)( **(long**)( lVar18 + 8 ) + 0x48 );
               if (pcVar5 == TType::getSampler) {
                  plVar15 = *(long**)( lVar18 + 8 ) + 0x10;
               }
 else {
                  plVar15 = (long*)( *pcVar5 )();
               }

               if (( ( *plVar15 & 0x200000 ) == 0 ) && ( ( *plVar15 & 0x80000 ) == 0 )) {
                  if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                     lVar18 = *(long*)( param_2 + 0x30 );
                  }
 else {
                     lVar18 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
                  }

                  pcVar5 = *(code**)( **(long**)( lVar18 + 8 ) + 0xe8 );
                  if (pcVar5 == TType::isArray) {
                     if (( *(long**)( lVar18 + 8 ) )[0xc] == 0) {
                        LAB_001414a2:pTVar14 = param_2 + 0x48;
                        if (*(code**)( *(long*)param_2 + 0x60 ) != TFunction::getType) {
                           pTVar14 = (TFunction*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
                        }

                        if (*(code**)( *(long*)pTVar14 + 0x40 ) == TType::getSampler) {
                           pTVar14 = pTVar14 + 0x80;
                        }
 else {
                           pTVar14 = (TFunction*)( **(code**)( *(long*)pTVar14 + 0x40 ) )();
                        }

                        TVar1 = pTVar14[2];
                        uVar4 = *(undefined4*)pTVar14;
                        TVar2 = pTVar14[3];
                        local_98 = (byte)TVar2 >> 5 & 1;
                        if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                           lVar18 = *(long*)( param_2 + 0x30 );
                        }
 else {
                           lVar18 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 0);
                        }

                        pcVar5 = *(code**)( **(long**)( lVar18 + 8 ) + 0x48 );
                        if (pcVar5 == TType::getSampler) {
                           plVar15 = *(long**)( lVar18 + 8 ) + 0x10;
                        }
 else {
                           plVar15 = (long*)( *pcVar5 )();
                        }

                        local_a0 = (short)uVar4;
                        if (( ( ( ( (short)*plVar15 == local_a0 ) && ( ( ( ( byte )((uint)uVar4 >> 0x10) & 0xed ^ *(byte*)( (long)plVar15 + 2 ) ) & 3 ) == 0 ) ) && ( bVar3 = *(byte*)( (long)plVar15 + 2 )((byte)TVar1 >> 2 & 1) == ( bVar3 >> 2 & 1 ) ) ) && ( ( ( bVar3 >> 3 & 1 ) == ( (byte)TVar1 >> 3 & 1 ) && ( ( bVar3 & 0x10 ) == 0 ) ) ) ) && ( ( ( (byte)TVar1 >> 5 & 1 ) == ( bVar3 >> 5 & 1 ) && ( ( ( *(byte*)( (long)plVar15 + 3 ) >> 5 & 1 ) == local_98 && ( ( *(byte*)( (long)plVar15 + 3 ) >> 6 & 1 ) == ( (byte)TVar2 >> 6 & 1 ) ) ) ) ) )) {
                           if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                              lVar18 = *(long*)( param_2 + 0x30 ) + 0x18;
                           }
 else {
                              lVar18 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 1);
                           }

                           pcVar5 = *(code**)( **(long**)( lVar18 + 8 ) + 0x38 );
                           if (pcVar5 == TType::getBasicType) {
                              uVar11 = ( uint ) * (byte*)( *(long**)( lVar18 + 8 ) + 1 );
                           }
 else {
                              uVar11 = ( *pcVar5 )();
                           }

                           if (uVar11 == 0xe) {
                              if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                                 lVar18 = *(long*)( param_2 + 0x30 ) + 0x18;
                              }
 else {
                                 lVar18 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 1);
                              }

                              pcVar5 = *(code**)( **(long**)( lVar18 + 8 ) + 0x48 );
                              if (pcVar5 == TType::getSampler) {
                                 plVar15 = *(long**)( lVar18 + 8 ) + 0x10;
                              }
 else {
                                 plVar15 = (long*)( *pcVar5 )();
                              }

                              if (( *plVar15 & 0x200000 ) != 0) {
                                 if (*(code**)( *(long*)param_2 + 0x140 ) == TFunction::operator []) {
                                    lVar18 = *(long*)( param_2 + 0x30 ) + 0x18;
                                 }
 else {
                                    lVar18 = ( **(code**)( *(long*)param_2 + 0x140 ) )(param_2, 1);
                                 }

                                 pcVar5 = *(code**)( **(long**)( lVar18 + 8 ) + 0xe8 );
                                 if (pcVar5 == TType::isArray) {
                                    if (( *(long**)( lVar18 + 8 ) )[0xc] == 0) goto LAB_001417fa;
                                 }
 else {
                                    cVar10 = ( *pcVar5 )();
                                    if (cVar10 == '\0') {
                                       uVar12 = 0;
                                       goto LAB_001412eb;
                                    }

                                 }

                              }

                           }

                           ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "sampler-constructor second argument must be a scalar sampler or samplerShadow", puVar9, &_LC1);
                        }
 else {
                           ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "sampler-constructor first argument must be a *texture* type matching the dimensionality and sampled type of the constructor", puVar9, &_LC1);
                        }

                        goto LAB_001412e6;
                     }

                  }
 else {
                     cVar10 = ( *pcVar5 )();
                     if (cVar10 == '\0') goto LAB_001414a2;
                  }

               }

            }

            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "sampler-constructor first argument must be a scalar *texture* type", puVar9, &_LC1);
         }
 else {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "sampler-constructor requires two arguments", puVar9, &_LC1);
         }

         LAB_001412e6:uVar12 = 1;
         LAB_001412eb:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return uVar12;
         }

         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      /* glslang::TParseContext::constructorError(glslang::TSourceLoc const&, TIntermNode*,
   glslang::TFunction&, glslang::TOperator, glslang::TType&) */
      undefined8 glslang::TParseContext::constructorError(TParseContext *this, TSourceLoc *param_1, long *param_2, TFunction *param_3, uint param_5, TType *param_6) {
         TFunction TVar1;
         undefined4 uVar2;
         bool bVar3;
         bool bVar4;
         bool bVar5;
         bool bVar6;
         bool bVar7;
         bool bVar8;
         bool bVar9;
         TType TVar10;
         char cVar11;
         byte bVar12;
         int iVar13;
         long lVar14;
         undefined8 uVar15;
         int *piVar16;
         code *pcVar17;
         long *plVar18;
         long lVar19;
         int *piVar20;
         TFunction *pTVar21;
         long *plVar22;
         TType *pTVar23;
         undefined4 *puVar24;
         uint uVar25;
         uint uVar26;
         int iVar27;
         ulong uVar28;
         ulong uVar29;
         long lVar30;
         undefined8 *puVar31;
         long lVar32;
         bool bVar33;
         long in_FS_OFFSET;
         byte local_129;
         int local_124;
         undefined8 local_f8;
         undefined1 *local_f0;
         ulong local_e8;
         undefined1 local_e0;
         undefined6 uStack_df;
         undefined4 uStack_d9;
         undefined1 local_d5;
         undefined8 local_c8;
         undefined1 *local_c0;
         undefined1 local_b0[24];
         undefined8 local_98;
         undefined1 *local_90;
         undefined1 local_80[24];
         undefined1 local_68[8];
         char *local_60;
         ulong local_58;
         long local_40;
         local_40 = *(long*)( in_FS_OFFSET + 0x28 );
         if (param_5 == 0x243) {
            if (( param_2 != (long*)0x0 ) && ( lVar30 = lVar30 != 0 )) {
               plVar18 = (long*)( **(code**)( *param_2 + 0x18 ) )(param_2);
               if (*(code**)( *plVar18 + 0xf0 ) == TIntermTyped::getType) {
                  plVar18 = plVar18 + 4;
               }
 else {
                  plVar18 = (long*)( **(code**)( *plVar18 + 0xf0 ) )();
               }

               lVar30 = plVar18[3];
               TVar10 = *(TType*)( plVar18 + 1 );
               lVar19 = plVar18[0x10];
               *(long*)( param_6 + 0x10 ) = plVar18[2];
               *(long*)( param_6 + 0x18 ) = lVar30;
               lVar30 = plVar18[4];
               lVar14 = plVar18[5];
               *(int*)( param_6 + 0x80 ) = (int)lVar19;
               *(long*)( param_6 + 0x20 ) = lVar30;
               *(long*)( param_6 + 0x28 ) = lVar14;
               lVar30 = plVar18[6];
               lVar14 = plVar18[7];
               param_6[8] = TVar10;
               *(long*)( param_6 + 0x30 ) = lVar30;
               *(long*)( param_6 + 0x38 ) = lVar14;
               lVar30 = plVar18[9];
               *(long*)( param_6 + 0x40 ) = plVar18[8];
               *(long*)( param_6 + 0x48 ) = lVar30;
               lVar30 = plVar18[0xb];
               *(long*)( param_6 + 0x50 ) = plVar18[10];
               *(long*)( param_6 + 0x58 ) = lVar30;
               bVar12 = *(byte*)( (long)plVar18 + 9 ) & 0xf;
               param_6[9] = ( TType )((byte)param_6[9] & 0xf0 | bVar12);
               param_6[9] = ( TType )(bVar12 | *(byte*)( (long)plVar18 + 9 ) & 0xf0);
               TVar10 = param_6[10];
               bVar12 = *(byte*)( (long)plVar18 + 10 ) & 0xf;
               param_6[10] = ( TType )((byte)TVar10 & 0xf0 | bVar12);
               TVar10 = ( TType )((byte)TVar10 & 0xe0 | bVar12 | *(byte*)( (long)plVar18 + 10 ) & 0x10);
               param_6[10] = TVar10;
               lVar14 = plVar18[0xe];
               lVar19 = plVar18[0xf];
               *(long*)( param_6 + 0x60 ) = plVar18[0xc];
               lVar30 = *(long*)param_6;
               *(long*)( param_6 + 0x70 ) = lVar14;
               *(long*)( param_6 + 0x78 ) = lVar19;
               if (*(code**)( lVar30 + 0x128 ) != TType::isStruct) {
                  ( **(code**)( lVar30 + 0x128 ) )(param_6);
                  lVar30 = *(long*)param_6;
                  TVar10 = param_6[10];
               }

               *(long*)( param_6 + 0x68 ) = plVar18[0xd];
               lVar14 = plVar18[0x12];
               *(long*)( param_6 + 0x88 ) = plVar18[0x11];
               *(long*)( param_6 + 0x90 ) = lVar14;
               bVar12 = *(byte*)( (long)plVar18 + 10 ) & 0x20;
               param_6[10] = ( TType )((byte)TVar10 & 0xdf | bVar12);
               param_6[10] = ( TType )((byte)TVar10 & 0x9f | bVar12 | *(byte*)( (long)plVar18 + 10 ) & 0x40);
               *(ushort*)( param_6 + 10 ) = *(ushort*)( param_6 + 10 ) & 0xfc7f | *(ushort*)( (long)plVar18 + 10 ) & 0x380;
               param_6[0xb] = ( TType )((byte)param_6[0xb] & 0xfb | *(byte*)( (long)plVar18 + 0xb ) & 4);
               if (*(code**)( lVar30 + 0x50 ) == TType::getQualifier) {
                  pTVar23 = param_6 + 0x10;
                  pcVar17 = TType::getQualifier;
               }
 else {
                  pTVar23 = (TType*)( **(code**)( lVar30 + 0x50 ) )(param_6);
                  pcVar17 = *(code**)( *(long*)param_6 + 0x50 );
               }

               pTVar23[0x10] = ( TType )((byte)pTVar23[0x10] & 0xf0);
               *(undefined8*)( pTVar23 + 0x14 ) = 0xffffffffffffffff;
               pTVar23[0x30] = (TType)0x0;
               *(undefined4*)( pTVar23 + 0x34 ) = 0xfffff800;
               *(uint*)( pTVar23 + 0x1c ) = *(uint*)( pTVar23 + 0x1c ) & 0xffc00000 | 0x1fcfff;
               *(ulong*)( pTVar23 + 0x20 ) = *(ulong*)( pTVar23 + 0x20 ) | 0x7fffffffffffffff;
               *(long*)( pTVar23 + 0x38 ) = -0x100000000;
               *(long*)( pTVar23 + 0x40 ) = 0;
               *(long*)pTVar23 = 0;
               *(ulong*)( pTVar23 + 0x28 ) = ( ulong )(( uint ) * (long*)( pTVar23 + 0x28 ) & 0xfe000000) | 0x1ffffff;
               *(undefined2*)( pTVar23 + 0x48 ) = 0;
               *(ulong*)( pTVar23 + 8 ) = *(ulong*)( pTVar23 + 8 ) & 0x800000141fff0000;
               if (pcVar17 == TType::getQualifier) {
                  pTVar23 = param_6 + 0x10;
               }
 else {
                  pTVar23 = (TType*)( *pcVar17 )(param_6);
               }

               pTVar23[0xc] = ( TType )((byte)pTVar23[0xc] | 2);
            }

         }
 else {
            if (*(code**)( *(long*)param_3 + 0x60 ) == TFunction::getType) {
               pTVar21 = param_3 + 0x48;
            }
 else {
               pTVar21 = (TFunction*)( **(code**)( *(long*)param_3 + 0x60 ) )(param_3);
            }

            lVar30 = *(long*)( pTVar21 + 0x18 );
            TVar1 = pTVar21[8];
            uVar2 = *(undefined4*)( pTVar21 + 0x80 );
            *(long*)( param_6 + 0x10 ) = *(long*)( pTVar21 + 0x10 );
            *(long*)( param_6 + 0x18 ) = lVar30;
            lVar30 = *(long*)( pTVar21 + 0x20 );
            lVar14 = *(long*)( pTVar21 + 0x28 );
            *(undefined4*)( param_6 + 0x80 ) = uVar2;
            *(long*)( param_6 + 0x20 ) = lVar30;
            *(long*)( param_6 + 0x28 ) = lVar14;
            lVar30 = *(long*)( pTVar21 + 0x30 );
            lVar14 = *(long*)( pTVar21 + 0x38 );
            *(TFunction*)( param_6 + 8 ) = TVar1;
            *(long*)( param_6 + 0x30 ) = lVar30;
            *(long*)( param_6 + 0x38 ) = lVar14;
            lVar30 = *(long*)( pTVar21 + 0x48 );
            *(long*)( param_6 + 0x40 ) = *(long*)( pTVar21 + 0x40 );
            *(long*)( param_6 + 0x48 ) = lVar30;
            lVar30 = *(long*)( pTVar21 + 0x58 );
            *(long*)( param_6 + 0x50 ) = *(long*)( pTVar21 + 0x50 );
            *(long*)( param_6 + 0x58 ) = lVar30;
            TVar1 = pTVar21[9];
            param_6[9] = ( TType )((byte)param_6[9] & 0xf0 | (byte)TVar1 & 0xf);
            param_6[9] = ( TType )((byte)TVar1 & 0xf | (byte)pTVar21[9] & 0xf0);
            TVar10 = param_6[10];
            TVar1 = pTVar21[10];
            param_6[10] = ( TType )((byte)TVar10 & 0xf0 | (byte)TVar1 & 0xf);
            TVar10 = ( TType )((byte)TVar10 & 0xe0 | (byte)TVar1 & 0xf | (byte)pTVar21[10] & 0x10);
            param_6[10] = TVar10;
            lVar30 = *(long*)( pTVar21 + 0x70 );
            lVar14 = *(long*)( pTVar21 + 0x78 );
            *(long*)( param_6 + 0x60 ) = *(long*)( pTVar21 + 0x60 );
            *(long*)( param_6 + 0x70 ) = lVar30;
            *(long*)( param_6 + 0x78 ) = lVar14;
            if (*(code**)( *(long*)param_6 + 0x128 ) != TType::isStruct) {
               ( **(code**)( *(long*)param_6 + 0x128 ) )(param_6);
               TVar10 = param_6[10];
            }

            *(long*)( param_6 + 0x68 ) = *(long*)( pTVar21 + 0x68 );
            lVar30 = *(long*)( pTVar21 + 0x90 );
            *(long*)( param_6 + 0x88 ) = *(long*)( pTVar21 + 0x88 );
            *(long*)( param_6 + 0x90 ) = lVar30;
            TVar1 = pTVar21[10];
            param_6[10] = ( TType )((byte)TVar10 & 0xdf | (byte)TVar1 & 0x20);
            param_6[10] = ( TType )((byte)TVar10 & 0x9f | (byte)TVar1 & 0x20 | (byte)pTVar21[10] & 0x40);
            *(ushort*)( param_6 + 10 ) = *(ushort*)( param_6 + 10 ) & 0xfc7f | *(ushort*)( pTVar21 + 10 ) & 0x380;
            param_6[0xb] = ( TType )((byte)param_6[0xb] & 0xfb | (byte)pTVar21[0xb] & 4);
         }

         local_f8 = glslang::GetThreadPoolAllocator();
         local_e8 = 0;
         local_e0 = 0;
         local_f0 = &local_e0;
         if (*(char*)( *(long*)( this + 0x38 ) + 0x26f ) == '\0') {
            local_d5 = 0;
            local_e0 = 99;
            uStack_df = 0x757274736e6f;
            uStack_d9 = 0x726f7463;
            local_e8 = 0xb;
         }
 else {
            local_98 = glslang::GetThreadPoolAllocator();
            local_90 = local_80;
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
            local_c8 = glslang::GetThreadPoolAllocator();
            local_c0 = local_b0;
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_c8, &_LC1, &_LC1);
            TType::getCompleteString(local_68, param_6, 1, 0, 0, 1, &local_c8, &local_98);
            if (0x7fffffffffffffff - local_e8 < local_58) {
               LAB_00144395:/* WARNING: Subroutine does not return */std::__throw_length_error("basic_string::append");
            }

            uVar28 = local_58 + local_e8;
            if (local_f0 == &local_e0) {
               uVar29 = 0xf;
            }
 else {
               uVar29 = CONCAT17((undefined1)uStack_d9, CONCAT61(uStack_df, local_e0));
            }

            if (uVar29 < uVar28) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_f8, local_e8, 0, local_60, local_58);
            }
 else if (local_58 != 0) {
               if (local_58 == 1) {
                  local_f0[local_e8] = *local_60;
               }
 else {
                  memcpy(local_f0 + local_e8, local_60, local_58);
               }

            }

            local_f0[uVar28] = 0;
            local_e8 = uVar28;
            if (0x7fffffffffffffff - uVar28 < 0xc) goto LAB_00144395;
            if (local_f0 == &local_e0) {
               uVar29 = 0xf;
            }
 else {
               uVar29 = CONCAT17((undefined1)uStack_d9, CONCAT61(uStack_df, local_e0));
            }

            if (uVar29 < uVar28 + 0xc) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_f8, uVar28, 0, " constructor", 0xc);
            }
 else {
               *(undefined8*)( local_f0 + uVar28 ) = 0x757274736e6f6320;
               *(undefined4*)( (long)( local_f0 + uVar28 ) + 8 ) = 0x726f7463;
            }

            local_f0[uVar28 + 0xc] = 0;
            local_e8 = uVar28 + 0xc;
         }

         if (param_5 != 0x242) {
            bVar33 = false;
            if (param_5 < 0x243) {
               if (param_5 < 0x219) {
                  bVar33 = true;
                  if (param_5 < 0x210) {
                     bVar33 = param_5 - 0x1e9 < 9;
                  }

               }
 else {
                  bVar33 = param_5 - 0x238 < 9;
               }

            }

            uVar28 = 0;
            lVar30 = 0;
            bVar9 = false;
            bVar8 = false;
            bVar4 = false;
            bVar3 = false;
            bVar6 = false;
            bVar5 = false;
            local_129 = 0;
            bVar7 = true;
            local_124 = 0;
            do {
               if (*(code**)( *(long*)param_3 + 0x120 ) == TFunction::getParamCount) {
                  if ((int)( *(long*)( param_3 + 0x38 ) - *(long*)( param_3 + 0x30 ) >> 3 ) * -0x55555555 <= (int)uVar28) {
                     LAB_00142ae0:lVar30 = *(long*)param_6;
                     if (param_5 != 0x243) {
                        if (param_5 < 0x204) {
                           if (param_5 < 0x1fe) {
                              if (param_5 < 0x1e1) {
                                 if (0x1de < param_5) goto LAB_00143a04;
                                 if (param_5 - 0x1dd < 2) goto LAB_00142b3c;
                                 if (!bVar7) goto LAB_00142f98;
                                 if (local_129 == 0) goto LAB_00143de1;
                                 goto LAB_00143af5;
                              }

                              if (param_5 - 0x1f8 < 6) {
                                 LAB_00142b3c:if (*(code**)( lVar30 + 0xe8 ) == TType::isArray) {
                                    if (*(long*)( param_6 + 0x60 ) != 0) {
                                       LAB_00142b5a:( **(code**)( *(long*)this + 0xd8 ) )(this, param_1, local_f0, "8-bit arrays not supported");
                                       goto LAB_00142b81;
                                    }

                                 }
 else {
                                    cVar11 = ( **(code**)( lVar30 + 0xe8 ) )(param_6);
                                    if (cVar11 != '\0') goto LAB_00142b5a;
                                    LAB_00142b81:lVar30 = *(long*)param_6;
                                 }

                                 if (*(code**)( lVar30 + 0xd8 ) == TType::isVector) {
                                    if (( (byte)param_6[9] & 0xf ) < 2) {
                                       bVar12 = (byte)param_6[10] >> 4 & 1;
                                       goto LAB_00143da6;
                                    }

                                    LAB_00142bab:if (*(code**)( *(long*)param_3 + 0x120 ) == TFunction::getParamCount) {
                                       iVar13 = (int)( *(long*)( param_3 + 0x38 ) - *(long*)( param_3 + 0x30 ) >> 3 ) * -0x55555555;
                                    }
 else {
                                       iVar13 = ( **(code**)( *(long*)param_3 + 0x120 ) )(param_3);
                                    }

                                    if (iVar13 != 1) {
                                       ( **(code**)( *(long*)this + 0xd8 ) )(this, param_1, local_f0, "8-bit vectors only take vector types");
                                    }

                                 }
 else {
                                    bVar12 = ( **(code**)( lVar30 + 0xd8 ) )(param_6);
                                    LAB_00143da6:if (bVar12 != 0) goto LAB_00142bab;
                                 }

                                 goto LAB_00143acb;
                              }

                              if (!bVar7) goto LAB_00142f98;
                              if (local_129 == 0) goto LAB_00143de1;
                              if (0x1e8 < param_5) goto LAB_00143f2c;
                              if (param_5 < 0x1e6) goto LAB_00143af5;
                              if (bVar9) goto LAB_00142efc;
                              LAB_00143b13:if (*(code**)( lVar30 + 0xe8 ) == TType::isArray) {
                                 if (*(long*)( param_6 + 0x60 ) == 0) {
                                    LAB_00143b35:if (*(code**)( lVar30 + 0x50 ) == TType::getQualifier) {
                                       pTVar23 = param_6 + 0x10;
                                    }
 else {
                                       pTVar23 = (TType*)( **(code**)( lVar30 + 0x50 ) )(param_6);
                                       lVar30 = *(long*)param_6;
                                    }

                                    *(ulong*)( pTVar23 + 8 ) = *(ulong*)( pTVar23 + 8 ) & 0xfffffffeffffff80 | 0x100000002;
                                    goto LAB_00142f98;
                                 }

                              }
 else {
                                 cVar11 = ( **(code**)( lVar30 + 0xe8 ) )(param_6);
                                 lVar30 = *(long*)param_6;
                                 if (cVar11 == '\0') goto LAB_00143b35;
                              }

                           }
 else {
                              LAB_00143a04:if (*(code**)( lVar30 + 0xe8 ) == TType::isArray) {
                                 if (*(long*)( param_6 + 0x60 ) != 0) {
                                    LAB_00143a22:( **(code**)( *(long*)this + 0xc0 ) )(this, param_1, local_f0, "16-bit arrays not supported");
                                    goto LAB_00143a49;
                                 }

                              }
 else {
                                 cVar11 = ( **(code**)( lVar30 + 0xe8 ) )(param_6);
                                 if (cVar11 != '\0') goto LAB_00143a22;
                                 LAB_00143a49:lVar30 = *(long*)param_6;
                              }

                              if (*(code**)( lVar30 + 0xd8 ) == TType::isVector) {
                                 if (( (byte)param_6[9] & 0xf ) < 2) {
                                    bVar12 = (byte)param_6[10] >> 4 & 1;
                                    goto LAB_00143dbe;
                                 }

                                 LAB_00143a73:if (*(code**)( *(long*)param_3 + 0x120 ) == TFunction::getParamCount) {
                                    iVar13 = (int)( *(long*)( param_3 + 0x38 ) - *(long*)( param_3 + 0x30 ) >> 3 ) * -0x55555555;
                                 }
 else {
                                    iVar13 = ( **(code**)( *(long*)param_3 + 0x120 ) )(param_3);
                                 }

                                 if (iVar13 != 1) {
                                    ( **(code**)( *(long*)this + 0xc0 ) )(this, param_1, local_f0, "16-bit vectors only take vector types");
                                 }

                              }
 else {
                                 bVar12 = ( **(code**)( lVar30 + 0xd8 ) )(param_6);
                                 LAB_00143dbe:if (bVar12 != 0) goto LAB_00143a73;
                              }

                              LAB_00143acb:lVar30 = *(long*)param_6;
                              if (!bVar7) goto LAB_00142f98;
                              if (local_129 == 0) goto LAB_00143de1;
                              if (0x1e8 < param_5) goto LAB_00143f2c;
                              LAB_00143af5:if (param_5 - 0x1db < 9) {
                                 LAB_00143b08:if (!bVar8) goto LAB_00143b13;
                              }

                           }

                        }
 else if (param_5 - 0x234 < 4) {
                           if (*(code**)( lVar30 + 0xe8 ) == TType::isArray) {
                              if (*(long*)( param_6 + 0x60 ) != 0) {
                                 LAB_00142e7c:( **(code**)( *(long*)this + 0xa8 ) )(this, param_1, local_f0, "16-bit arrays not supported");
                                 goto LAB_00142ea3;
                              }

                           }
 else {
                              cVar11 = ( **(code**)( lVar30 + 0xe8 ) )(param_6);
                              if (cVar11 != '\0') goto LAB_00142e7c;
                              LAB_00142ea3:lVar30 = *(long*)param_6;
                           }

                           if (*(code**)( lVar30 + 0xd8 ) == TType::isVector) {
                              if (( (byte)param_6[9] & 0xf ) < 2) {
                                 bVar12 = (byte)param_6[10] >> 4 & 1;
                                 goto LAB_00142ed8;
                              }

                              LAB_00143cec:if (*(code**)( *(long*)param_3 + 0x120 ) == TFunction::getParamCount) {
                                 iVar13 = (int)( *(long*)( param_3 + 0x38 ) - *(long*)( param_3 + 0x30 ) >> 3 ) * -0x55555555;
                              }
 else {
                                 iVar13 = ( **(code**)( *(long*)param_3 + 0x120 ) )(param_3);
                              }

                              if (iVar13 == 1) goto LAB_00142ee0;
                              ( **(code**)( *(long*)this + 0xa8 ) )(this, param_1, local_f0, "16-bit vectors only take vector types");
                              if (!bVar7) {
                                 lVar30 = *(long*)param_6;
                                 goto LAB_00142f98;
                              }

                              lVar30 = *(long*)param_6;
                           }
 else {
                              bVar12 = ( **(code**)( lVar30 + 0xd8 ) )(param_6);
                              LAB_00142ed8:if (bVar12 != 0) goto LAB_00143cec;
                              LAB_00142ee0:lVar30 = *(long*)param_6;
                              if (!bVar7) goto LAB_00142f98;
                           }

                           if (local_129 == 0) {
                              LAB_00143de1:pTVar23 = param_6 + 0x10;
                              if (*(code**)( lVar30 + 0x50 ) != TType::getQualifier) {
                                 pTVar23 = (TType*)( **(code**)( lVar30 + 0x50 ) )(param_6);
                                 lVar30 = *(long*)param_6;
                              }

                              pTVar23[8] = ( TType )((byte)pTVar23[8] & 0x80 | 2);
                              goto LAB_00142f98;
                           }

                        }
 else {
                           if (!bVar7) goto LAB_00142f98;
                           if (local_129 == 0) goto LAB_00143de1;
                           LAB_00143f2c:if (param_5 - 0x1f5 < 0x1b) goto LAB_00143b08;
                        }

                        LAB_00142efc:if (*(code**)( lVar30 + 0x50 ) == TType::getQualifier) {
                           pTVar23 = param_6 + 0x10;
                        }
 else {
                           pTVar23 = (TType*)( **(code**)( lVar30 + 0x50 ) )(param_6);
                           lVar30 = *(long*)param_6;
                        }

                        pTVar23[0x10] = ( TType )((byte)pTVar23[0x10] & 0xf0);
                        *(long*)( pTVar23 + 0x38 ) = -0x100000000;
                        *(undefined8*)( pTVar23 + 0x14 ) = 0xffffffffffffffff;
                        pTVar23[0x30] = (TType)0x0;
                        *(uint*)( pTVar23 + 0x1c ) = *(uint*)( pTVar23 + 0x1c ) & 0xffc00000 | 0x1fcfff;
                        *(ulong*)( pTVar23 + 0x20 ) = *(ulong*)( pTVar23 + 0x20 ) | 0x7fffffffffffffff;
                        *(undefined4*)( pTVar23 + 0x34 ) = 0xfffff800;
                        *(long*)( pTVar23 + 0x40 ) = 0;
                        *(undefined2*)( pTVar23 + 0x48 ) = 0;
                        *(ulong*)( pTVar23 + 0x28 ) = ( ulong )(( uint ) * (long*)( pTVar23 + 0x28 ) & 0xfe000000) | 0x1ffffff;
                        *(ulong*)( pTVar23 + 8 ) = *(ulong*)( pTVar23 + 8 ) & 0x800000141fff0000;
                        *(long*)pTVar23 = 0;
                     }

                     LAB_00142f98:if (*(code**)( lVar30 + 0xe8 ) == TType::isArray) {
                        if (*(long*)( param_6 + 0x60 ) == 0) goto LAB_001430f2;
                     }
 else {
                        cVar11 = ( **(code**)( lVar30 + 0xe8 ) )(param_6);
                        if (cVar11 == '\0') goto LAB_001430f2;
                     }

                     if (*(code**)( *(long*)param_3 + 0x120 ) == TFunction::getParamCount) {
                        iVar13 = (int)( *(long*)( param_3 + 0x38 ) - *(long*)( param_3 + 0x30 ) >> 3 ) * -0x55555555;
                     }
 else {
                        iVar13 = ( **(code**)( *(long*)param_3 + 0x120 ) )(param_3);
                     }

                     if (iVar13 == 0) {
                        ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "array constructor must have at least one argument", local_f0, &_LC1);
                        goto LAB_001424e3;
                     }

                     lVar30 = *(long*)param_6;
                     if (*(code**)( lVar30 + 0xf8 ) == TType::isUnsizedArray) {
                        if (*(code**)( lVar30 + 0xe8 ) == TType::isArray) {
                           lVar14 = *(long*)( param_6 + 0x60 );
                           if (lVar14 != 0) goto LAB_0014352f;
                           goto LAB_0014302c;
                        }

                        cVar11 = ( **(code**)( lVar30 + 0xe8 ) )(param_6);
                        if (cVar11 == '\0') goto LAB_001438a2;
                        lVar14 = *(long*)( param_6 + 0x60 );
                        LAB_0014352f:if (**(int**)( *(long*)( lVar14 + 8 ) + 8 ) != 0) goto LAB_001438a2;
                        LAB_00143543:if (*(code**)( *(long*)param_3 + 0x120 ) == TFunction::getParamCount) {
                           iVar13 = (int)( *(long*)( param_3 + 0x38 ) - *(long*)( param_3 + 0x30 ) >> 3 ) * -0x55555555;
                        }
 else {
                           iVar13 = ( **(code**)( *(long*)param_3 + 0x120 ) )(param_3);
                        }

                        lVar30 = *(long*)( param_6 + 0x60 );
                        **(int**)( *(long*)( lVar30 + 8 ) + 8 ) = iVar13;
                        lVar14 = *(long*)( lVar30 + 8 );
                        *(undefined1*)( lVar30 + 0x14 ) = 0;
                        LAB_00143589:if (1 < (int)( *(long*)( lVar14 + 0x10 ) - *(long*)( lVar14 + 8 ) >> 4 )) {
                           if (*(code**)( *(long*)param_6 + 0xa0 ) != TType::getArraySizes) {
                              lVar30 = ( **(code**)( *(long*)param_6 + 0xa0 ) )(param_6);
                           }

                           if (*(code**)( *(long*)param_3 + 0x138 ) == TFunction::operator []) {
                              lVar14 = *(long*)( param_3 + 0x30 );
                           }
 else {
                              lVar14 = ( **(code**)( *(long*)param_3 + 0x138 ) )(param_3, 0);
                           }

                           pcVar17 = *(code**)( **(long**)( lVar14 + 8 ) + 0xe8 );
                           if (pcVar17 == TType::isArray) {
                              if (( *(long**)( lVar14 + 8 ) )[0xc] != 0) {
                                 LAB_001435ff:lVar14 = *(long*)( lVar30 + 8 );
                                 if (lVar14 == 0) {
                                    iVar13 = 0;
                                 }
 else {
                                    iVar13 = (int)( *(long*)( lVar14 + 0x10 ) - *(long*)( lVar14 + 8 ) >> 4 );
                                 }

                                 if (*(code**)( *(long*)param_3 + 0x138 ) == TFunction::operator []) {
                                    lVar14 = *(long*)( param_3 + 0x30 );
                                 }
 else {
                                    lVar14 = ( **(code**)( *(long*)param_3 + 0x138 ) )(param_3, 0);
                                 }

                                 pcVar17 = *(code**)( **(long**)( lVar14 + 8 ) + 0xa0 );
                                 if (pcVar17 == TType::getArraySizes) {
                                    lVar14 = ( *(long**)( lVar14 + 8 ) )[0xc];
                                 }
 else {
                                    lVar14 = ( *pcVar17 )();
                                 }

                                 lVar14 = *(long*)( lVar14 + 8 );
                                 if (lVar14 == 0) {
                                    iVar27 = 1;
                                 }
 else {
                                    iVar27 = (int)( *(long*)( lVar14 + 0x10 ) - *(long*)( lVar14 + 8 ) >> 4 ) + 1;
                                 }

                                 if (iVar13 == iVar27) {
                                    lVar14 = *(long*)( lVar30 + 8 );
                                    if (lVar14 == 0) goto LAB_001430f2;
                                    lVar19 = *(long*)( lVar14 + 0x10 );
                                    piVar16 = *(int**)( lVar14 + 8 );
                                    iVar13 = 1;
                                    piVar20 = piVar16;
                                    goto LAB_001436a3;
                                 }

                              }

                           }
 else {
                              cVar11 = ( *pcVar17 )();
                              if (cVar11 != '\0') goto LAB_001435ff;
                           }

                           ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "array constructor argument not correct type to construct array element", local_f0, &_LC1);
                           goto LAB_001424e3;
                        }

                     }
 else {
                        cVar11 = ( **(code**)( lVar30 + 0xf8 ) )(param_6);
                        if (cVar11 != '\0') goto LAB_00143543;
                        LAB_001438a2:lVar30 = *(long*)param_6;
                        LAB_0014302c:if (*(code**)( lVar30 + 0x78 ) == TType::getOuterArraySize) {
                           iVar13 = **(int**)( *(long*)( *(long*)( param_6 + 0x60 ) + 8 ) + 8 );
                        }
 else {
                           iVar13 = ( **(code**)( lVar30 + 0x78 ) )(param_6);
                        }

                        if (*(code**)( *(long*)param_3 + 0x120 ) == TFunction::getParamCount) {
                           iVar27 = (int)( *(long*)( param_3 + 0x38 ) - *(long*)( param_3 + 0x30 ) >> 3 ) * -0x55555555;
                        }
 else {
                           iVar27 = ( **(code**)( *(long*)param_3 + 0x120 ) )(param_3);
                        }

                        if (iVar13 != iVar27) {
                           ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "array constructor needs one argument per array element", local_f0, &_LC1);
                           goto LAB_001424e3;
                        }

                        lVar30 = *(long*)( param_6 + 0x60 );
                        if (( lVar30 != 0 ) && ( lVar14 = lVar14 != 0 )) goto LAB_00143589;
                     }

                     if (( !bVar4 ) || ( param_5 == 0x241 )) goto LAB_0014310a;
                     goto LAB_001430af;
                  }

               }
 else {
                  iVar13 = ( **(code**)( *(long*)param_3 + 0x120 ) )(param_3);
                  if (iVar13 <= (int)uVar28) goto LAB_00142ae0;
               }

               if (*(code**)( *(long*)param_3 + 0x138 ) == TFunction::operator []) {
                  lVar14 = *(long*)( param_3 + 0x30 ) + lVar30;
               }
 else {
                  lVar14 = ( **(code**)( *(long*)param_3 + 0x138 ) )(param_3, uVar28 & 0xffffffff);
               }

               pcVar17 = *(code**)( **(long**)( lVar14 + 8 ) + 0xe8 );
               if (pcVar17 == TType::isArray) {
                  if (( *(long**)( lVar14 + 8 ) )[0xc] != 0) {
                     pcVar17 = *(code**)( *(long*)param_3 + 0x138 );
                     if (pcVar17 == TFunction::operator []) goto LAB_00142465;
                     LAB_00142c2d:lVar14 = ( *pcVar17 )(param_3, uVar28 & 0xffffffff);
                     LAB_0014246c:plVar18 = *(long**)( lVar14 + 8 );
                     pcVar17 = *(code**)( *plVar18 + 0xf8 );
                     if (pcVar17 == TType::isUnsizedArray) {
                        pcVar17 = *(code**)( *plVar18 + 0xe8 );
                        if (pcVar17 == TType::isArray) {
                           lVar14 = plVar18[0xc];
                           if (lVar14 != 0) {
                              LAB_001424aa:if (**(int**)( *(long*)( lVar14 + 8 ) + 8 ) == 0) goto LAB_001424ba;
                           }

                        }
 else {
                           cVar11 = ( *pcVar17 )(plVar18);
                           if (cVar11 != '\0') {
                              lVar14 = plVar18[0xc];
                              goto LAB_001424aa;
                           }

                        }

                     }
 else {
                        cVar11 = ( *pcVar17 )(plVar18);
                        if (cVar11 != '\0') goto LAB_001424ba;
                     }

                     bVar4 = true;
                  }

               }
 else {
                  cVar11 = ( *pcVar17 )();
                  if (cVar11 != '\0') {
                     pcVar17 = *(code**)( *(long*)param_3 + 0x138 );
                     if (pcVar17 != TFunction::operator []) goto LAB_00142c2d;
                     LAB_00142465:lVar14 = *(long*)( param_3 + 0x30 ) + lVar30;
                     goto LAB_0014246c;
                  }

               }

               if (bVar33) {
                  if (*(code**)( *(long*)param_3 + 0x138 ) == TFunction::operator []) {
                     lVar14 = *(long*)( param_3 + 0x30 ) + lVar30;
                  }
 else {
                     lVar14 = ( **(code**)( *(long*)param_3 + 0x138 ) )(param_3, uVar28 & 0xffffffff);
                  }

                  pcVar17 = *(code**)( **(long**)( lVar14 + 8 ) + 0xe0 );
                  if (pcVar17 == TType::isMatrix) {
                     if (0xf < *(byte*)( (long)*(long**)( lVar14 + 8 ) + 9 )) {
                        LAB_0014256b:bVar3 = bVar33;
                     }

                  }
 else {
                     cVar11 = ( *pcVar17 )();
                     if (cVar11 != '\0') goto LAB_0014256b;
                  }

               }

               if (bVar5) {
                  bVar6 = bVar5;
               }

               if (*(code**)( *(long*)param_3 + 0x138 ) == TFunction::operator []) {
                  lVar14 = *(long*)( param_3 + 0x30 ) + lVar30;
               }
 else {
                  lVar14 = ( **(code**)( *(long*)param_3 + 0x138 ) )(param_3, uVar28 & 0xffffffff);
               }

               plVar18 = *(long**)( lVar14 + 8 );
               if (*(code**)( *plVar18 + 0x38 ) == TType::getBasicType) {
                  uVar25 = ( uint ) * (byte*)( plVar18 + 1 );
                  if (*(byte*)( plVar18 + 1 ) == 0xf) goto LAB_00142900;
                  LAB_001425cf:if (uVar25 == 0x10) goto LAB_00142900;
                  if (*(byte*)( (long)plVar18 + 9 ) < 0x10) {
                     uVar25 = *(byte*)( (long)plVar18 + 9 ) & 0xf;
                  }
 else {
                     uVar25 = ( uint )(*(byte*)( (long)plVar18 + 9 ) >> 4) * ( *(byte*)( (long)plVar18 + 10 ) & 0xf );
                  }

               }
 else {
                  iVar13 = ( **(code**)( *plVar18 + 0x38 ) )(plVar18);
                  if (iVar13 != 0xf) {
                     if (*(code**)( *plVar18 + 0x38 ) == TType::getBasicType) {
                        uVar25 = ( uint ) * (byte*)( plVar18 + 1 );
                     }
 else {
                        uVar25 = ( **(code**)( *plVar18 + 0x38 ) )(plVar18);
                     }

                     goto LAB_001425cf;
                  }

                  LAB_00142900:uVar25 = 0;
                  puVar31 = *(undefined8**)( plVar18[0xd] + 8 );
                  if (*(undefined8**)( plVar18[0xd] + 0x10 ) != puVar31) {
                     do {
                        pTVar23 = (TType*)*puVar31;
                        puVar31 = puVar31 + 4;
                        iVar13 = TType::computeNumComponents(pTVar23);
                        uVar25 = uVar25 + iVar13;
                     }
 while ( *(undefined8**)( plVar18[0xd] + 0x10 ) != puVar31 );
                  }

               }

               if (( plVar18[0xc] != 0 ) && ( lVar14 = lVar14 != 0 )) {
                  piVar16 = *(int**)( lVar14 + 8 );
                  iVar13 = (int)( *(long*)( lVar14 + 0x10 ) - (long)piVar16 >> 4 );
                  if (iVar13 < 1) {
                     iVar27 = 1;
                  }
 else {
                     piVar20 = piVar16 + 4;
                     iVar27 = 1;
                     if (( (int)( piVar20 + ( ulong )(iVar13 - 1) * 4 ) - (int)piVar16 & 0x10U ) == 0) goto LAB_00142658;
                     iVar27 = *piVar16;
                     for (piVar16 = piVar20; piVar16 != piVar20 + ( ulong )(iVar13 - 1) * 4; piVar16 = piVar16 + 8) {
                        LAB_00142658:iVar27 = iVar27 * *piVar16 * piVar16[4];
                     }

                  }

                  uVar25 = uVar25 * iVar27;
               }

               local_124 = local_124 + uVar25;
               if (param_5 == 0x241) {
                  LAB_001426a1:pcVar17 = *(code**)( *(long*)param_3 + 0x138 );
                  if (pcVar17 == TFunction::operator []) goto LAB_001426b4;
                  LAB_00142abc:lVar14 = ( *pcVar17 )(param_3, uVar28 & 0xffffffff);
               }
 else {
                  lVar14 = *(long*)param_6;
                  if (*(code**)( lVar14 + 0xe8 ) == TType::isArray) {
                     if (*(long*)( param_6 + 0x60 ) != 0) goto LAB_001426a1;
                  }
 else {
                     cVar11 = ( **(code**)( lVar14 + 0xe8 ) )(param_6);
                     if (cVar11 != '\0') goto LAB_001426a1;
                     lVar14 = *(long*)param_6;
                  }

                  if (*(code**)( lVar14 + 0x38 ) == TType::getBasicType) {
                     uVar25 = (uint)(byte)param_6[8];
                     if (param_6[8] == (TType)0xf) goto LAB_00142d30;
                     LAB_001429fa:if (uVar25 == 0x10) goto LAB_00142d30;
                     if ((byte)param_6[9] < 0x10) {
                        uVar26 = (byte)param_6[9] & 0xf;
                     }
 else {
                        uVar26 = ( uint )((byte)param_6[9] >> 4) * ( (byte)param_6[10] & 0xf );
                     }

                  }
 else {
                     iVar13 = ( **(code**)( lVar14 + 0x38 ) )(param_6);
                     if (iVar13 != 0xf) {
                        if (*(code**)( *(long*)param_6 + 0x38 ) == TType::getBasicType) {
                           uVar25 = (uint)(byte)param_6[8];
                        }
 else {
                           uVar25 = ( **(code**)( *(long*)param_6 + 0x38 ) )(param_6);
                        }

                        goto LAB_001429fa;
                     }

                     LAB_00142d30:uVar26 = 0;
                     puVar31 = *(undefined8**)( *(long*)( param_6 + 0x68 ) + 8 );
                     uVar25 = 0;
                     if (puVar31 != *(undefined8**)( *(long*)( param_6 + 0x68 ) + 0x10 )) {
                        do {
                           pTVar23 = (TType*)*puVar31;
                           puVar31 = puVar31 + 4;
                           iVar13 = TType::computeNumComponents(pTVar23);
                           uVar26 = uVar25 + iVar13;
                           uVar25 = uVar26;
                        }
 while ( *(undefined8**)( *(long*)( param_6 + 0x68 ) + 0x10 ) != puVar31 );
                     }

                  }

                  if (( *(long*)( param_6 + 0x60 ) != 0 ) && ( lVar14 = lVar14 != 0 )) {
                     piVar16 = *(int**)( lVar14 + 8 );
                     iVar13 = (int)( *(long*)( lVar14 + 0x10 ) - (long)piVar16 >> 4 );
                     if (iVar13 < 1) {
                        iVar27 = 1;
                     }
 else {
                        piVar20 = piVar16 + 4;
                        iVar27 = 1;
                        if (( (int)( piVar20 + ( ulong )(iVar13 - 1) * 4 ) - (int)piVar16 & 0x10U ) == 0) goto LAB_00142a80;
                        iVar27 = *piVar16;
                        for (piVar16 = piVar20; piVar16 != piVar20 + ( ulong )(iVar13 - 1) * 4; piVar16 = piVar16 + 8) {
                           LAB_00142a80:iVar27 = iVar27 * *piVar16 * piVar16[4];
                        }

                     }

                     uVar26 = uVar26 * iVar27;
                  }

                  if ((int)uVar26 <= local_124) {
                     bVar5 = true;
                  }

                  pcVar17 = *(code**)( *(long*)param_3 + 0x138 );
                  if (pcVar17 != TFunction::operator []) goto LAB_00142abc;
                  LAB_001426b4:lVar14 = *(long*)( param_3 + 0x30 ) + lVar30;
               }

               pcVar17 = *(code**)( **(long**)( lVar14 + 8 ) + 0x50 );
               if (pcVar17 == TType::getQualifier) {
                  plVar18 = *(long**)( lVar14 + 8 ) + 2;
               }
 else {
                  plVar18 = (long*)( *pcVar17 )();
               }

               if (( ( *(byte*)( plVar18 + 1 ) & 0x7f ) != 2 ) && ( ( *(byte*)( (long)plVar18 + 0xc ) & 1 ) == 0 )) {
                  bVar7 = false;
               }

               if (*(code**)( *(long*)param_3 + 0x138 ) == TFunction::operator []) {
                  lVar14 = *(long*)( param_3 + 0x30 ) + lVar30;
               }
 else {
                  lVar14 = ( **(code**)( *(long*)param_3 + 0x138 ) )(param_3, uVar28 & 0xffffffff);
               }

               pcVar17 = *(code**)( **(long**)( lVar14 + 8 ) + 0x50 );
               if (pcVar17 == TType::getQualifier) {
                  plVar18 = *(long**)( lVar14 + 8 ) + 2;
               }
 else {
                  plVar18 = (long*)( *pcVar17 )();
               }

               if (( *(byte*)( (long)plVar18 + 0xc ) & 1 ) != 0) {
                  local_129 = *(byte*)( (long)plVar18 + 0xc ) & 1;
               }

               if (*(code**)( *(long*)param_3 + 0x138 ) == TFunction::operator []) {
                  lVar14 = *(long*)( param_3 + 0x30 ) + lVar30;
               }
 else {
                  lVar14 = ( **(code**)( *(long*)param_3 + 0x138 ) )(param_3, uVar28 & 0xffffffff);
               }

               pcVar17 = *(code**)( **(long**)( lVar14 + 8 ) + 0x130 );
               if (pcVar17 == TType::isFloatingDomain) {
                  if (( byte )((char)( *(long**)( lVar14 + 8 ) )[1] - 1U) < 3) {
                     LAB_00142785:bVar8 = true;
                  }

               }
 else {
                  cVar11 = ( *pcVar17 )();
                  if (cVar11 != '\0') goto LAB_00142785;
               }

               if (*(code**)( *(long*)param_3 + 0x138 ) == TFunction::operator []) {
                  lVar14 = *(long*)( param_3 + 0x30 ) + lVar30;
               }
 else {
                  lVar14 = ( **(code**)( *(long*)param_3 + 0x138 ) )(param_3, uVar28 & 0xffffffff);
               }

               pcVar17 = *(code**)( **(long**)( lVar14 + 8 ) + 0x138 );
               if (pcVar17 == TType::isIntegerDomain) {
                  bVar12 = *(byte*)( *(long**)( lVar14 + 8 ) + 1 );
                  if (bVar12 < 0xc) {
                     if (3 < bVar12) {
                        LAB_001427d2:bVar9 = true;
                     }

                  }
 else if (bVar12 == 0xd) goto LAB_001427d2;
               }
 else {
                  cVar11 = ( *pcVar17 )();
                  if (cVar11 != '\0') goto LAB_001427d2;
               }

               iVar13 = (int)uVar28;
               if (*(code**)( *(long*)param_6 + 0x128 ) == TType::isStruct) {
                  if (( byte )((char)param_6[8] - 0xfU) < 2) {
                     pcVar17 = *(code**)( *(long*)param_3 + 0x138 );
                     if (pcVar17 == TFunction::operator []) goto LAB_00142815;
                     LAB_00142cb0:lVar14 = ( *pcVar17 )(param_3, uVar28 & 0xffffffff);
                     LAB_0014281c:plVar18 = *(long**)( lVar14 + 8 );
                     pcVar17 = *(code**)( *plVar18 + 400 );
                     if (pcVar17 == TType::containsBasicType) {
                        if ((char)plVar18[1] == '\x03') goto LAB_00142967;
                        pcVar17 = *(code**)( *plVar18 + 0x128 );
                        if (pcVar17 == TType::isStruct) {
                           if (( byte )((char)plVar18[1] - 0xfU) < 2) {
                              LAB_00142d7c:lVar14 = *(long*)( plVar18[0xd] + 0x10 );
                              lVar19 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar18[0xd] + 8 ),lVar14,3 ));
                              if (lVar14 != lVar19) goto LAB_00142967;
                           }

                        }
 else {
                           cVar11 = ( *pcVar17 )();
                           if (cVar11 != '\0') goto LAB_00142d7c;
                        }

                        LAB_00142861:pcVar17 = *(code**)( *(long*)param_3 + 0x138 );
                        if (pcVar17 != TFunction::operator []) goto LAB_00142999;
                        LAB_00142874:lVar14 = *(long*)( param_3 + 0x30 ) + lVar30;
                     }
 else {
                        cVar11 = ( *pcVar17 )(plVar18, 3);
                        if (cVar11 == '\0') goto LAB_00142861;
                        LAB_00142967:( **(code**)( *(long*)this + 0xa8 ) )(this, param_1, local_f0, "can\'t construct structure containing 16-bit type");
                        pcVar17 = *(code**)( *(long*)param_3 + 0x138 );
                        if (pcVar17 == TFunction::operator []) goto LAB_00142874;
                        LAB_00142999:lVar14 = ( *pcVar17 )(param_3, uVar28 & 0xffffffff);
                     }

                     cVar11 = TType::contains16BitInt(*(TType**)( lVar14 + 8 ));
                     if (cVar11 != '\0') {
                        ( **(code**)( *(long*)this + 0xc0 ) )(this, param_1, local_f0, "can\'t construct structure containing 16-bit type");
                     }

                     iVar13 = (int)uVar28;
                     if (*(code**)( *(long*)param_3 + 0x138 ) == TFunction::operator []) {
                        lVar14 = *(long*)( param_3 + 0x30 ) + lVar30;
                     }
 else {
                        lVar14 = ( **(code**)( *(long*)param_3 + 0x138 ) )(param_3, uVar28 & 0xffffffff);
                     }

                     cVar11 = TType::contains8BitInt(*(TType**)( lVar14 + 8 ));
                     if (cVar11 != '\0') {
                        ( **(code**)( *(long*)this + 0xd8 ) )(this, param_1, local_f0, "can\'t construct structure containing 8-bit type");
                     }

                  }

               }
 else {
                  cVar11 = ( **(code**)( *(long*)param_6 + 0x128 ) )(param_6);
                  iVar13 = (int)uVar28;
                  if (cVar11 != '\0') {
                     pcVar17 = *(code**)( *(long*)param_3 + 0x138 );
                     if (pcVar17 != TFunction::operator []) goto LAB_00142cb0;
                     LAB_00142815:lVar14 = *(long*)( param_3 + 0x30 ) + lVar30;
                     goto LAB_0014281c;
                  }

               }

               uVar28 = ( ulong )(iVar13 + 1);
               lVar30 = lVar30 + 0x18;
            }
 while ( true );
         }

         uVar15 = constructorTextureSamplerError(this, param_1, param_3);
         goto LAB_001424e8;
         LAB_001436a3:piVar20 = piVar20 + 4;
         if ((int)( lVar19 - (long)piVar16 >> 4 ) <= iVar13) goto LAB_001430f2;
         if (*piVar20 == 0) {
            lVar32 = 0;
            goto LAB_001436d8;
         }

         iVar13 = iVar13 + 1;
         goto LAB_001436a3;
         LAB_001436d8:if ((int)( lVar19 - (long)piVar16 >> 4 ) <= (int)lVar32 + 1) goto LAB_001430f2;
         if (piVar16[lVar32 * 4 + 4] == 0) {
            if (*(code**)( *(long*)param_3 + 0x138 ) == TFunction::operator []) {
               lVar14 = *(long*)( param_3 + 0x30 );
            }
 else {
               lVar14 = ( **(code**)( *(long*)param_3 + 0x138 ) )(param_3, 0);
            }

            pcVar17 = *(code**)( **(long**)( lVar14 + 8 ) + 0xa0 );
            if (pcVar17 == TType::getArraySizes) {
               lVar19 = ( *(long**)( lVar14 + 8 ) )[0xc];
            }
 else {
               lVar19 = ( *pcVar17 )();
            }

            lVar14 = *(long*)( lVar30 + 8 );
            *(undefined4*)( *(long*)( lVar14 + 8 ) + 0x10 + lVar32 * 0x10 ) = *(undefined4*)( *(long*)( *(long*)( lVar19 + 8 ) + 8 ) + lVar32 * 0x10 );
         }
 else if (lVar14 == 0) goto LAB_001430f2;
         lVar19 = *(long*)( lVar14 + 0x10 );
         piVar16 = *(int**)( lVar14 + 8 );
         lVar32 = lVar32 + 1;
         goto LAB_001436d8;
         LAB_001424ba:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "array argument must be sized", local_f0, &_LC1);
         goto LAB_001424e3;
         LAB_001430f2:bVar4 = (bool)( bVar4 & param_5 != 0x241 );
         if (bVar4) {
            if (( ( *(long*)( param_6 + 0x60 ) == 0 ) || ( lVar30 = *(long*)( *(long*)( param_6 + 0x60 ) + 8 ) ),lVar30 == 0 )) {
               LAB_001430af:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "constructing non-array constituent from array argument", local_f0, &_LC1);
               goto LAB_001424e3;
            }

            bVar33 = bVar3;
            if (bVar3) goto LAB_00143111;
            if (!bVar6) goto LAB_0014314f;
            LAB_001439d6:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "too many arguments", local_f0, &_LC1);
            goto LAB_001424e3;
         }

         LAB_0014310a:bVar33 = param_5 != 0x241;
         if (bVar3) {
            LAB_00143111:if (*(code**)( *(long*)param_6 + 0xe8 ) != TType::isArray) {
               cVar11 = ( **(code**)( *(long*)param_6 + 0xe8 ) )(param_6);
               if (cVar11 == '\0') goto LAB_00143fbe;
               goto LAB_00143136;
            }

            if (*(long*)( param_6 + 0x60 ) != 0) goto LAB_00143136;
            LAB_00143fbe:glslang::TParseVersions::profileRequires((TSourceLoc*)this, (int)param_1, 1, (char*)0x78, (char*)0x0);
            if (*(code**)( *(long*)param_3 + 0x120 ) == TFunction::getParamCount) {
               iVar13 = (int)( *(long*)( param_3 + 0x38 ) - *(long*)( param_3 + 0x30 ) >> 3 ) * -0x55555555;
            }
 else {
               iVar13 = ( **(code**)( *(long*)param_3 + 0x120 ) )(param_3);
            }

            if (iVar13 != 1) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "matrix constructed from matrix can only have one argument", local_f0, &_LC1);
               uVar15 = 0;
               goto LAB_001424e8;
            }

            LAB_00143e9e:uVar15 = 0;
         }
 else {
            LAB_00143136:if (bVar6) goto LAB_001439d6;
            bVar4 = bVar33;
            if (param_5 == 0x241) {
               if (*(code**)( *(long*)param_6 + 0xe8 ) == TType::isArray) {
                  if (*(long*)( param_6 + 0x60 ) == 0) goto LAB_00143c7a;
               }
 else {
                  cVar11 = ( **(code**)( *(long*)param_6 + 0xe8 ) )(param_6);
                  if (cVar11 == '\0') {
                     LAB_00143c7a:lVar30 = *(long*)( *(long*)( param_6 + 0x68 ) + 0x10 );
                     lVar14 = *(long*)( *(long*)( param_6 + 0x68 ) + 8 );
                     if (*(code**)( *(long*)param_3 + 0x120 ) == TFunction::getParamCount) {
                        iVar13 = (int)( *(long*)( param_3 + 0x38 ) - *(long*)( param_3 + 0x30 ) >> 3 ) * -0x55555555;
                     }
 else {
                        iVar13 = ( **(code**)( *(long*)param_3 + 0x120 ) )(param_3);
                     }

                     if ((int)( lVar30 - lVar14 >> 5 ) != iVar13) {
                        ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "Number of constructor parameters does not match the number of structure fields", local_f0, &_LC1);
                        goto LAB_001424e3;
                     }

                  }

               }

               LAB_0014397f:iVar13 = TType::computeNumComponents(param_6);
               if (local_124 < iVar13) {
                  ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "not enough data provided for construction", local_f0, &_LC1);
                  goto LAB_001424e3;
               }

            }
 else {
               LAB_0014314f:bVar33 = bVar4;
               if (local_124 != 1) goto LAB_0014397f;
            }

            if (( ( (byte)param_6[10] & 0x20 ) != 0 ) || ( ( (byte)param_6[10] & 0x40 ) != 0 )) {
               if (*(code**)( *(long*)param_3 + 0x120 ) == TFunction::getParamCount) {
                  iVar13 = (int)( *(long*)( param_3 + 0x38 ) - *(long*)( param_3 + 0x30 ) >> 3 ) * -0x55555555;
               }
 else {
                  iVar13 = ( **(code**)( *(long*)param_3 + 0x120 ) )(param_3);
               }

               if (iVar13 != 1) {
                  ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "wrong number of arguments", local_f0, &_LC1);
                  goto LAB_001424e3;
               }

               if (( ( (byte)param_6[10] & 0x20 ) != 0 ) || ( ( (byte)param_6[10] & 0x40 ) != 0 )) {
                  if (*(code**)( *(long*)param_3 + 0x138 ) == TFunction::operator []) {
                     lVar30 = *(long*)( param_3 + 0x30 );
                  }
 else {
                     lVar30 = ( **(code**)( *(long*)param_3 + 0x138 ) )(param_3, 0);
                  }

                  cVar11 = ( **(code**)( **(long**)( lVar30 + 8 ) + 0xc0 ) )();
                  if (cVar11 == '\0') {
                     if (*(code**)( *(long*)param_3 + 0x138 ) == TFunction::operator []) {
                        lVar30 = *(long*)( param_3 + 0x30 );
                     }
 else {
                        lVar30 = ( **(code**)( *(long*)param_3 + 0x138 ) )(param_3, 0);
                     }

                     bVar12 = *(byte*)( *(long*)( lVar30 + 8 ) + 10 );
                     if (( ( bVar12 & 0x20 ) == 0 ) && ( ( bVar12 & 0x40 ) == 0 )) {
                        ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "Cooperative matrix constructor argument must be scalar or cooperative matrix", local_f0, &_LC1);
                        goto LAB_001424e3;
                     }

                  }

               }

            }

            plVar18 = (long*)( **(code**)( *param_2 + 0x18 ) )();
            TVar10 = param_6[10];
            uVar28 = (ulong)(byte)TVar10;
            uVar25 = ( uint )((byte)TVar10 >> 5);
            if (( ( (byte)TVar10 >> 5 & 1 ) == 0 ) && ( ( (byte)TVar10 & 0x40 ) == 0 )) {
               if (plVar18 == (long*)0x0) {
                  ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "constructor argument does not have a type", local_f0, &_LC1);
               }
 else {
                  LAB_00143e37:if (param_5 == 0x243) {
                     if (bVar33) goto LAB_00143e71;
                  }
 else if (bVar33) {
                     if (*(code**)( *plVar18 + 0x100 ) == TIntermTyped::getBasicType) {
                        uVar25 = ( uint ) * (byte*)( plVar18 + 5 );
                     }
 else {
                        uVar25 = ( **(code**)( *plVar18 + 0x100 ) )(plVar18);
                     }

                     if (uVar25 == 0xe) {
                        lVar30 = *(long*)this;
                        if (param_5 == 0x207) {
                           cVar11 = ( **(code**)( lVar30 + 0x40 ) )(this, "GL_ARB_bindless_texture");
                           if (cVar11 != '\0') {
                              param_6 = *(TType**)( this + 0x38 );
                              puVar24 = (undefined4*)std::map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>::operator []((map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>*)( param_6 + 0x528 ), (basic_string*)( this + 0x7510 ));
                              *puVar24 = 1;
                              goto LAB_00143e71;
                           }

                           lVar30 = *(long*)this;
                        }

                        ( **(code**)( lVar30 + 0x158 ) )(this, param_1, "cannot convert a sampler", local_f0, &_LC1);
                     }
 else {
                        LAB_00143e71:if ((char)plVar18[5] != '\r') goto LAB_00143e7b;
                        ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot convert an atomic_uint", local_f0, &_LC1, *(long*)this, param_6);
                     }

                     goto LAB_001424e3;
                  }

                  LAB_00143e7b:if (*(code**)( *plVar18 + 0x100 ) == TIntermTyped::getBasicType) {
                     uVar25 = ( uint ) * (byte*)( plVar18 + 5 );
                  }
 else {
                     uVar25 = ( **(code**)( *plVar18 + 0x100 ) )(plVar18);
                  }

                  if (uVar25 != 0) goto LAB_00143e9e;
                  ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "cannot convert a void", local_f0, &_LC1);
               }

            }
 else {
               if (*(code**)( *plVar18 + 0xf0 ) == TIntermTyped::getType) {
                  if (( *(byte*)( (long)plVar18 + 0x2a ) & 0x20 ) == 0) {
                     if (( *(byte*)( (long)plVar18 + 0x2a ) & 0x40 ) == 0) goto LAB_00143e37;
                     LAB_001437aa:uVar25 = ( uint )(uVar28 >> 5);
                  }

                  plVar22 = plVar18 + 4;
               }
 else {
                  lVar30 = ( **(code**)( *plVar18 + 0xf0 ) )(plVar18);
                  if (( ( *(byte*)( lVar30 + 10 ) & 0x20 ) == 0 ) && ( ( *(byte*)( lVar30 + 10 ) & 0x40 ) == 0 )) goto LAB_00143e37;
                  if (*(code**)( *plVar18 + 0xf0 ) == TIntermTyped::getType) {
                     uVar28 = (ulong)(byte)param_6[10];
                     goto LAB_001437aa;
                  }

                  plVar22 = (long*)( **(code**)( *plVar18 + 0xf0 ) )(plVar18);
                  uVar28 = (ulong)(byte)param_6[10];
                  uVar25 = ( uint )((byte)param_6[10] >> 5);
               }

               if (( ( ( ( uVar25 & 1 ) != 0 ) || ( ( uVar28 & 0x40 ) != 0 ) ) && ( ( bVar12 = *(byte*)( (long)plVar22 + 10 ) >> 6 & 1(*(byte*)( (long)plVar22 + 10 ) & 0x20) != 0 || ( bVar12 != 0 ) ) ) ) && ( ( ( (byte)uVar28 >> 6 & 1 ) == bVar12 && ( ( ( *(ushort*)( param_6 + 10 ) ^ *(ushort*)( (long)plVar22 + 10 ) ) & 0x380 ) == 0 ) ) )) {
                  uVar26 = uVar25 & 1;
                  lVar30 = *(long*)( *(long*)( *(long*)( param_6 + 0x88 ) + 8 ) + 8 );
                  if (lVar30 != 0) {
                     lVar14 = ( ulong )(uVar25 & 1) << 4;
                     for (; (int)uVar26 < (int)( *(long*)( lVar30 + 0x10 ) - *(long*)( lVar30 + 8 ) >> 4 ); uVar26 = uVar26 + 1) {
                        piVar16 = (int*)( *(long*)( lVar30 + 8 ) + lVar14 );
                        piVar20 = (int*)( *(long*)( *(long*)( *(long*)( plVar22[0x11] + 8 ) + 8 ) + 8 ) + lVar14 );
                        lVar14 = lVar14 + 0x10;
                        if (*piVar16 != *piVar20) goto LAB_0014385f;
                     }

                  }

                  goto LAB_00143e37;
               }

               LAB_0014385f:( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "Cooperative matrix type parameters mismatch", local_f0, &_LC1);
            }

            LAB_001424e3:uVar15 = 1;
         }

         LAB_001424e8:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return uVar15;
         }

         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      /* glslang::TParseContext::addQualifierToExisting(glslang::TSourceLoc const&, glslang::TQualifier,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const&)
    */
      void glslang::TParseContext::addQualifierToExisting(TParseContext *param_1, TSourceLoc *param_2, basic_string *param_3) {
         TSymbolTableLevel *this;
         basic_string *pbVar1;
         char cVar2;
         byte bVar3;
         TSymbol *pTVar4;
         long lVar5;
         long lVar6;
         long *plVar7;
         ulong uVar8;
         undefined8 *puVar9;
         undefined8 uVar10;
         size_t sVar11;
         TVariable *this_00;
         TQualifier *pTVar12;
         undefined *puVar13;
         char *pcVar14;
         int iVar15;
         code *UNRECOVERED_JUMPTABLE;
         long in_FS_OFFSET;
         undefined8 in_stack_00000008;
         int iStack0000000000000010;
         char cStack0000000000000014;
         char cStack0000000000000015;
         char cStack0000000000000016;
         ulong in_stack_00000018;
         uint uStack0000000000000020;
         byte bStack0000000000000025;
         short sStack0000000000000028;
         byte bStack000000000000002a;
         byte bStack000000000000002b;
         byte bStack000000000000002c;
         ushort uStack000000000000002e;
         uint uStack0000000000000030;
         char cStack0000000000000034;
         char cStack0000000000000035;
         char cStack0000000000000036;
         undefined8 in_stack_00000038;
         char cStack0000000000000040;
         undefined8 in_stack_00000048;
         undefined8 in_stack_00000050;
         undefined8 local_1c8;
         undefined8 local_1c0;
         undefined8 local_1b8;
         undefined8 local_1b0;
         undefined **local_1a8;
         uint local_1a0;
         undefined8 local_198;
         ulong uStack_190;
         ulong local_188;
         undefined8 uStack_180;
         undefined8 local_178;
         undefined8 uStack_170;
         undefined8 local_168;
         undefined8 uStack_160;
         undefined8 local_158;
         undefined8 uStack_150;
         undefined8 local_148;
         undefined8 *local_140;
         undefined8 local_138;
         undefined8 *local_130;
         uint local_128;
         undefined1 local_120[16];
         undefined **local_108;
         uint local_100;
         undefined8 local_f8;
         ulong local_f0;
         byte local_e8;
         undefined8 local_e4;
         uint local_dc;
         ulong local_d8;
         ulong local_d0;
         undefined1 local_c8;
         undefined4 local_c4;
         undefined8 local_c0;
         undefined8 local_b8;
         undefined2 local_b0;
         undefined8 local_a8;
         undefined8 local_a0;
         undefined8 local_98;
         undefined8 *local_90;
         uint local_88;
         undefined1 local_80[16];
         undefined8 local_68;
         undefined1 *local_60;
         undefined8 local_58;
         undefined1 local_50[16];
         long local_40;
         local_40 = *(long*)( in_FS_OFFSET + 0x28 );
         pTVar4 = (TSymbol*)TSymbolTable::find(*(TSymbolTable**)( param_1 + 0xe8 ), param_3, (bool*)0x0, (bool*)0x0, (int*)0x0);
         if (pTVar4 == (TSymbol*)0x0) {
            if (cStack0000000000000036 == '\0') {
               if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                  puVar13 = *(undefined**)( param_3 + 8 );
                  pcVar14 = "identifier not previously declared";
                  UNRECOVERED_JUMPTABLE = *(code**)( *(long*)param_1 + 0x158 );
                  goto LAB_0014445e;
               }

               goto LAB_00144bee;
            }

            local_1c8 = glslang::GetThreadPoolAllocator();
            uStack_190 = _iStack0000000000000010;
            local_188 = in_stack_00000018;
            uStack_180 = _uStack0000000000000020;
            local_198 = in_stack_00000008;
            local_178 = _sStack0000000000000028;
            uStack_170 = _uStack0000000000000030;
            local_120 = (undefined1[16])0x0;
            uStack_160 = _cStack0000000000000040;
            local_1a0 = local_1a0 & 0xf8000000 | 0x110;
            pcVar14 = *(char**)( param_3 + 8 );
            local_140 = &local_1c8;
            local_168 = in_stack_00000038;
            local_158 = in_stack_00000048;
            uStack_150 = in_stack_00000050;
            local_128 = local_128 & 0x9fc00000;
            local_1c0 = 0;
            local_1b8 = 0;
            local_1b0 = 0;
            local_1a8 = &PTR__TType_00167f00;
            local_148 = 0;
            local_138 = 0;
            uVar8 = glslang::GetThreadPoolAllocator();
            puVar9 = (undefined8*)glslang::TPoolAllocator::allocate(uVar8);
            uVar10 = glslang::GetThreadPoolAllocator();
            *puVar9 = uVar10;
            puVar9[1] = puVar9 + 3;
            if (pcVar14 == (char*)0x0) {
               LAB_00144e0a:/* WARNING: Subroutine does not return */std::__throw_logic_error("basic_string: construction from null is not valid");
            }

            sVar11 = strlen(pcVar14);
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(puVar9, pcVar14, pcVar14 + sVar11);
            local_80 = (undefined1[16])0x0;
            local_108 = &PTR__TType_00167f00;
            pcVar14 = *(char**)( param_3 + 8 );
            local_100 = local_100 & 0xf8000000 | 0x112;
            local_a8 = 0;
            local_98 = 0;
            local_130 = puVar9;
            uVar8 = glslang::GetThreadPoolAllocator();
            puVar9 = (undefined8*)glslang::TPoolAllocator::allocate(uVar8);
            uVar10 = glslang::GetThreadPoolAllocator();
            *puVar9 = uVar10;
            puVar9[1] = puVar9 + 3;
            if (pcVar14 == (char*)0x0) goto LAB_00144e0a;
            sVar11 = strlen(pcVar14);
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(puVar9, pcVar14, pcVar14 + sVar11);
            local_88 = local_88 & 0x9fc00000;
            local_e8 = local_e8 & 0xf0;
            local_dc = local_dc & 0xffc00000 | 0x1fcfff;
            local_d8 = local_d8 | 0x7fffffffffffffff;
            local_e4 = 0xffffffffffffffff;
            local_c8 = 0;
            local_d0 = ( ulong )((uint)local_d0 & 0xfe000000) | 0x1ffffff;
            local_c4 = 0xfffff800;
            local_c0 = 0xffffffff00000000;
            local_b0 = 0;
            local_b8 = 0;
            local_f0 = local_f0 & 0x8000000400000000 | ( ulong )((byte)uStack_190 & 0x7f);
            local_f8 = 0;
            local_90 = puVar9;
            local_a0 = TType::clone((TType*)&local_1a8);
            uVar8 = glslang::GetThreadPoolAllocator();
            this_00 = (TVariable*)glslang::TPoolAllocator::allocate(uVar8);
            TVariable::TVariable(this_00, param_3, (TType*)&local_108, true);
            plVar7 = *(long**)( param_1 + 0xe8 );
            lVar5 = plVar7[3];
            puVar9 = (undefined8*)*plVar7;
            lVar6 = plVar7[1];
            cVar2 = *(char*)( (long)plVar7 + 0x21 );
            plVar7[3] = lVar5 + 1;
            *(long*)( this_00 + 0x10 ) = lVar5 + 1;
            if (cVar2 == '\0') {
               iVar15 = (int)( lVar6 - (long)puVar9 >> 3 );
               cVar2 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)puVar9[iVar15 + -1], *(basic_string**)( this_00 + 8 ));
               if (cVar2 == '\0') goto LAB_00144af9;
            }
 else {
               iVar15 = (int)( lVar6 - (long)puVar9 >> 3 );
               LAB_00144af9:if (( (char)plVar7[4] != '\0' ) && ( iVar15 - 2U < 3 )) {
                  pbVar1 = *(basic_string**)( this_00 + 8 );
                  cVar2 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)*puVar9, pbVar1);
                  if (( cVar2 != '\0' ) || ( ( iVar15 != 2 && ( cVar2 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)puVar9[1], pbVar1) ),cVar2 != '\0' ) )) goto LAB_00144bbe;
               }

               this(TSymbolTableLevel * puVar9[iVar15 + -1]);
               local_68 = glslang::GetThreadPoolAllocator();
               local_60 = local_50;
               local_58 = 0;
               local_50[0] = 0;
               cVar2 = TSymbolTableLevel::insert(this, (TSymbol*)this_00, *(bool*)( (long)plVar7 + 0x21 ), (basic_string*)&local_68);
               if (cVar2 != '\0') goto LAB_00144b66;
            }

            LAB_00144bbe:( **(code**)( *(long*)param_1 + 0x158 ) )(param_1, param_2, "block name cannot redefine a non-block name", *(undefined8*)( *(long*)( param_1 + 0x508 ) + 8 ), &_LC1);
         }
 else {
            lVar5 = ( **(code**)( *(long*)pTVar4 + 0x38 ) )(pTVar4);
            if (lVar5 != 0) {
               if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                  puVar13 = *(undefined**)( param_3 + 8 );
                  pcVar14 = "cannot re-qualify a function name";
                  UNRECOVERED_JUMPTABLE = *(code**)( *(long*)param_1 + 0x158 );
                  LAB_0014445e:/* WARNING: Could not recover jumptable at 0x00144477. Too many branches *//* WARNING: Treating indirect jump as call */( *UNRECOVERED_JUMPTABLE )(param_1, param_2, pcVar14, puVar13, &_LC1, UNRECOVERED_JUMPTABLE);
                  return;
               }

               goto LAB_00144bee;
            }

            if (( ( ( ( ( ( ( _iStack0000000000000010 & 0x20000000 ) != 0 ) || ( ( _iStack0000000000000010 & 0x100000000000 ) != 0 ) ) || ( ( _iStack0000000000000010 & 0x200000000000 ) != 0 ) ) || ( ( ( cStack0000000000000014 < '\0' || ( ( _iStack0000000000000010 & 0x10000000000 ) != 0 ) ) || ( ( cStack0000000000000016 < '\0' || ( ( ( _iStack0000000000000010 & 0x40000000000000 ) != 0 || ( ( _iStack0000000000000010 & 0x20000000000000 ) != 0 ) ) ) ) ) ) ) ) || ( ( _iStack0000000000000010 & 0x10000000000000 ) != 0 ) ) || ( ( ( ( ( ( ( _iStack0000000000000010 & 0x8000000000000 ) != 0 || ( ( _iStack0000000000000010 & 0x2000000000000 ) != 0 ) ) || ( ( _iStack0000000000000010 & 0x4000000000000 ) != 0 ) ) || ( ( ( _iStack0000000000000010 & 0x400000000000 ) != 0 || ( cStack0000000000000015 < '\0' ) ) ) ) || ( ( _iStack0000000000000010 & 0x1000000000000 ) != 0 ) ) || ( ( ( ( ( _iStack0000000000000010 & 0x100000000000000 ) != 0 || ( iStack0000000000000010 < 0 ) ) || ( ( ( ( _iStack0000000000000010 & 0x40000000 ) != 0 || ( ( ( ( _iStack0000000000000010 & 0x2000000000 ) != 0 || ( ( _iStack0000000000000010 & 0x4000000000 ) != 0 ) ) || ( sStack0000000000000028 != -1 ) ) ) ) || ( ( ( ( ( uint )((ulong)_uStack0000000000000020 >> 0x20) & 0x3f8000 ) != 0x1f8000 || ( ( in_stack_00000018._4_4_ & uStack0000000000000020 ) != 0xffffffff ) ) || ( ( ~(ushort)((ulong)_uStack0000000000000020 >> 0x20) & 0xfff ) != 0 ) ) ) ) ) ) || ( ( ( bStack0000000000000025 & 0x70 ) != 0x40 || ( ( bStack000000000000002b & bStack000000000000002a ) != 0xff ) ) ) ) ) ) ) ) || ( ( ( ( ( _iStack0000000000000010 & 0x7000000000000000 ) != 0 || ( in_stack_00000018 & 0xf ) != 0 ) || cStack0000000000000034 != '\0' || ( ( ( cStack0000000000000040 != '\0' || ( cStack0000000000000035 != '\0' ) ) || ( cStack0000000000000036 != '\0' ) ) ) ) || ( ( ( ( ~bStack000000000000002c & 0xf ) != 0 || ( ( ~(uint)((ulong)_sStack0000000000000028 >> 0x20) & 0x3fff0 ) != 0 ) ) || ( ( ( ~uStack000000000000002e & 0x7ffc ) != 0 || ( ( _iStack0000000000000010 & 0xe00007f ) != 0 ) ) ) ) ) ) )) {
               if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                  puVar13 = *(undefined**)( param_3 + 8 );
                  pcVar14 = "cannot add storage, auxiliary, memory, interpolation, layout, or precision qualifier to an existing variable";
                  UNRECOVERED_JUMPTABLE = *(code**)( *(long*)param_1 + 0x158 );
                  goto LAB_0014445e;
               }

               goto LAB_00144bee;
            }

            if (*(code**)( *(long*)pTVar4 + 0xa0 ) == TSymbol::isReadOnly) {
               bVar3 = (byte)pTVar4[0x20] ^ 1;
            }
 else {
               bVar3 = ( **(code**)( *(long*)pTVar4 + 0xa0 ) )(pTVar4);
            }

            if (bVar3 != 0) {
               pTVar4 = (TSymbol*)TSymbolTable::copyUp(*(TSymbolTable**)( param_1 + 0xe8 ), pTVar4);
            }

            if (( _iStack0000000000000010 & 0x10000000 ) == 0) {
               if (( _iStack0000000000000010 & 0x1000000000 ) == 0) {
                  if (( _iStack0000000000000010 & 0x100000000 ) == 0) {
                     if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                        pcVar14 = "unknown requalification";
                        puVar13 = &_LC1;
                        UNRECOVERED_JUMPTABLE = *(code**)( *(long*)param_1 + 0x160 );
                        goto LAB_0014445e;
                     }

                     goto LAB_00144bee;
                  }

                  plVar7 = (long*)( **(code**)( *(long*)pTVar4 + 0x68 ) )(pTVar4);
                  if (*(code**)( *plVar7 + 0x50 ) == TType::getQualifier) {
                     plVar7 = plVar7 + 2;
                  }
 else {
                     plVar7 = (long*)( **(code**)( *plVar7 + 0x50 ) )(plVar7);
                  }

                  plVar7[1] = plVar7[1] & 0xfffffffeffffff80U | 0x100000002;
                  if (( ~uStack0000000000000030 & 0x7ff00 ) != 0) {
                     plVar7 = (long*)( **(code**)( *(long*)pTVar4 + 0x68 ) )(pTVar4);
                     if (*(code**)( *plVar7 + 0x50 ) == TType::getQualifier) {
                        plVar7 = plVar7 + 2;
                     }
 else {
                        plVar7 = (long*)( **(code**)( *plVar7 + 0x50 ) )(plVar7);
                     }

                     *(uint*)( plVar7 + 5 ) = *(uint*)( plVar7 + 5 ) & 0xfff800ff | ( uint )(( ushort )((ulong)_uStack0000000000000030 >> 8) & 0x7ff) << 8;
                  }

               }
 else {
                  lVar5 = *(long*)( param_1 + 0x38 );
                  lVar6 = std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>::find((_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>*)( lVar5 + 0x730 ), param_3);
                  if (lVar5 + 0x738 != lVar6) {
                     ( **(code**)( *(long*)param_1 + 0x158 ) )(param_1, param_2, "cannot change qualification after use", "precise", &_LC1);
                  }

                  plVar7 = (long*)( **(code**)( *(long*)pTVar4 + 0x68 ) )(pTVar4);
                  if (*(code**)( *plVar7 + 0x50 ) == TType::getQualifier) {
                     plVar7 = plVar7 + 2;
                  }
 else {
                     plVar7 = (long*)( **(code**)( *plVar7 + 0x50 ) )(plVar7);
                  }

                  *(byte*)( (long)plVar7 + 0xc ) = *(byte*)( (long)plVar7 + 0xc ) | 0x10;
               }

            }
 else {
               lVar5 = *(long*)( param_1 + 0x38 );
               lVar6 = std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>::find((_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>*)( lVar5 + 0x730 ), param_3);
               if (lVar5 + 0x738 != lVar6) {
                  ( **(code**)( *(long*)param_1 + 0x158 ) )(param_1, param_2, "cannot change qualification after use", "invariant", &_LC1);
               }

               plVar7 = (long*)( **(code**)( *(long*)pTVar4 + 0x68 ) )(pTVar4);
               if (*(code**)( *plVar7 + 0x50 ) == TType::getQualifier) {
                  plVar7 = plVar7 + 2;
               }
 else {
                  plVar7 = (long*)( **(code**)( *plVar7 + 0x50 ) )(plVar7);
               }

               *(byte*)( (long)plVar7 + 0xb ) = *(byte*)( (long)plVar7 + 0xb ) | 0x10;
               plVar7 = (long*)( **(code**)( *(long*)pTVar4 + 0x60 ) )(pTVar4);
               if (*(code**)( *plVar7 + 0x58 ) == TType::getQualifier) {
                  pTVar12 = (TQualifier*)( plVar7 + 2 );
               }
 else {
                  pTVar12 = (TQualifier*)( **(code**)( *plVar7 + 0x58 ) )();
               }

               if (( (byte)pTVar12[0xb] & 0x10 ) != 0) {
                  if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                     invariantCheck(param_1, param_2, pTVar12);
                     return;
                  }

                  goto LAB_00144bee;
               }

            }

         }

         LAB_00144b66:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return;
         }

         LAB_00144bee:/* WARNING: Subroutine does not return */__stack_chk_fail();
      }

      /* glslang::TParseContext::addQualifierToExisting(glslang::TSourceLoc const&, glslang::TQualifier,
   glslang::TVector<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> >*>&) */
      void glslang::TParseContext::addQualifierToExisting(undefined8 param_1, undefined8 param_2, long param_3) {
         ulong uVar1;
         long lVar2;
         lVar2 = *(long*)( param_3 + 8 );
         if (*(long*)( param_3 + 0x10 ) != lVar2) {
            uVar1 = 0;
            do {
               addQualifierToExisting(param_1, param_2, *(undefined8*)( lVar2 + uVar1 * 8 ));
               lVar2 = *(long*)( param_3 + 8 );
               uVar1 = ( ulong )((int)uVar1 + 1);
            }
 while ( uVar1 < ( ulong )(*(long*)( param_3 + 0x10 ) - lVar2 >> 3) );
         }

         return;
      }

      /* glslang::TParseContext::fixBlockUniformLayoutMatrix(glslang::TQualifier&,
   glslang::TVector<glslang::TTypeLoc>*, glslang::TVector<glslang::TTypeLoc>*) */
      void glslang::TParseContext::fixBlockUniformLayoutMatrix(TParseContext *this, TQualifier *param_1, TVector *param_2, TVector *param_3) {
         TType *pTVar1;
         char cVar2;
         int iVar3;
         code *pcVar4;
         long *plVar5;
         undefined8 uVar6;
         TType *pTVar7;
         long lVar8;
         TQualifier *pTVar9;
         uint uVar10;
         long lVar11;
         long lVar12;
         ulong uVar13;
         long *plVar14;
         lVar8 = *(long*)( param_2 + 8 );
         if (*(long*)( param_2 + 0x10 ) != lVar8) {
            uVar13 = 0;
            do {
               lVar12 = uVar13 * 0x20;
               if (( (byte)param_1[0x10] & 0xf ) == 0) {
                  LAB_00145098:lVar8 = *(long*)( param_2 + 8 );
                  plVar14 = *(long**)( lVar8 + lVar12 );
                  pcVar4 = *(code**)( *plVar14 + 0x38 );
                  if (pcVar4 == TType::getBasicType) {
                     LAB_00144f9b:if ((char)plVar14[1] != '\x0f') goto LAB_00144fa8;
                  }
 else {
                     LAB_001450b0:iVar3 = ( *pcVar4 )();
                     lVar8 = *(long*)( param_2 + 8 );
                     if (iVar3 != 0xf) goto LAB_00144fa8;
                  }

                  pTVar7 = *(TType**)( lVar8 + lVar12 );
                  pTVar9 = param_1;
                  if (*(code**)( *(long*)pTVar7 + 0x50 ) == TType::getQualifier) {
                     if (( (byte)pTVar7[0x1f] & 0x70 ) != 0) {
                        LAB_001451e8:pTVar9 = (TQualifier*)( pTVar7 + 0x10 );
                     }

                  }
 else {
                     lVar8 = ( **(code**)( *(long*)pTVar7 + 0x50 ) )();
                     pTVar7 = *(TType**)( *(long*)( param_2 + 8 ) + lVar12 );
                     if (( *(byte*)( lVar8 + 0xf ) & 0x70 ) != 0) {
                        if (*(code**)( *(long*)pTVar7 + 0x50 ) == TType::getQualifier) goto LAB_001451e8;
                        pTVar9 = (TQualifier*)( **(code**)( *(long*)pTVar7 + 0x50 ) )();
                        pTVar7 = *(TType**)( *(long*)( param_2 + 8 ) + lVar12 );
                     }

                  }

                  if (param_3 == (TVector*)0x0) {
                     pTVar7 = (TType*)TType::clone(pTVar7);
                     fixBlockUniformLayoutMatrix(this, pTVar9, *(TVector**)( *(long*)( *(long*)( param_2 + 8 ) + lVar12 ) + 0x68 ), *(TVector**)( pTVar7 + 0x68 ));
                     uVar6 = recordStructCopy(this, (map*)( this + 0x7598 ), *(TType**)( *(long*)( param_2 + 8 ) + lVar12 ), pTVar7);
                     lVar8 = *(long*)( param_2 + 8 );
                     *(undefined8*)( *(long*)( lVar8 + lVar12 ) + 0x68 ) = uVar6;
                  }
 else {
                     pTVar1 = *(TType**)( *(long*)( param_3 + 8 ) + lVar12 );
                     fixBlockUniformLayoutMatrix(this, pTVar9, *(TVector**)( pTVar7 + 0x68 ), *(TVector**)( pTVar1 + 0x68 ));
                     uVar6 = recordStructCopy(this, (map*)( this + 0x7598 ), *(TType**)( *(long*)( param_2 + 8 ) + lVar12 ), pTVar1);
                     *(undefined8*)( *(long*)( *(long*)( param_3 + 8 ) + lVar12 ) + 0x68 ) = uVar6;
                     lVar8 = *(long*)( param_2 + 8 );
                  }

               }
 else {
                  if (param_3 != (TVector*)0x0) {
                     plVar5 = *(long**)( *(long*)( param_3 + 8 ) + lVar12 );
                     lVar8 = *plVar5;
                     if (*(code**)( lVar8 + 0xe0 ) != TType::isMatrix) {
                        cVar2 = ( **(code**)( lVar8 + 0xe0 ) )(plVar5);
                        plVar5 = *(long**)( *(long*)( param_3 + 8 ) + lVar12 );
                        lVar8 = *plVar5;
                        if (cVar2 == '\0') goto LAB_00144ff0;
                        LAB_00144f65:pcVar4 = *(code**)( lVar8 + 0x50 );
                        if (pcVar4 == TType::getQualifier) goto LAB_00144f79;
                        LAB_00145029:lVar8 = ( *pcVar4 )(plVar5);
                        if (( *(byte*)( lVar8 + 0xf ) & 0x70 ) != 0) goto LAB_00145098;
                        plVar5 = *(long**)( *(long*)( param_3 + 8 ) + lVar12 );
                        uVar10 = (byte)param_1[0xf] >> 4 & 7;
                        if (*(code**)( *plVar5 + 0x50 ) == TType::getQualifier) goto LAB_0014507b;
                        plVar5 = (long*)( **(code**)( *plVar5 + 0x50 ) )(plVar5);
                        LAB_0014507f:*(byte*)( (long)plVar5 + 0xf ) = *(byte*)( (long)plVar5 + 0xf ) & 0x8f | ( byte )(uVar10 << 4);
                        goto LAB_00145098;
                     }

                     if (0xf < *(byte*)( (long)plVar5 + 9 )) goto LAB_00144f65;
                     LAB_00144ff0:if (*(code**)( lVar8 + 0x38 ) == TType::getBasicType) {
                        uVar10 = ( uint ) * (byte*)( plVar5 + 1 );
                     }
 else {
                        uVar10 = ( **(code**)( lVar8 + 0x38 ) )(plVar5);
                     }

                     if (uVar10 != 0xf) goto LAB_00145098;
                     plVar5 = *(long**)( *(long*)( param_3 + 8 ) + lVar12 );
                     pcVar4 = *(code**)( *plVar5 + 0x50 );
                     if (pcVar4 != TType::getQualifier) goto LAB_00145029;
                     LAB_00144f79:lVar8 = *(long*)( param_2 + 8 );
                     plVar14 = *(long**)( lVar8 + lVar12 );
                     lVar11 = *plVar14;
                     if (( *(byte*)( (long)plVar5 + 0x1f ) & 0x70 ) == 0) {
                        uVar10 = (byte)param_1[0xf] >> 4 & 7;
                        LAB_0014507b:plVar5 = plVar5 + 2;
                        goto LAB_0014507f;
                     }

                     LAB_00144f8e:pcVar4 = *(code**)( lVar11 + 0x38 );
                     if (pcVar4 != TType::getBasicType) goto LAB_001450b0;
                     goto LAB_00144f9b;
                  }

                  plVar5 = *(long**)( lVar8 + lVar12 );
                  if (*(code**)( *plVar5 + 0xe0 ) == TType::isMatrix) {
                     lVar8 = *(long*)( param_2 + 8 );
                     plVar14 = *(long**)( lVar8 + lVar12 );
                     lVar11 = *plVar14;
                     if (*(byte*)( (long)plVar5 + 9 ) < 0x10) goto LAB_0014517a;
                     LAB_0014519b:if (*(code**)( lVar11 + 0x50 ) == TType::getQualifier) {
                        if (( *(byte*)( (long)plVar14 + 0x1f ) & 0x70 ) != 0) goto LAB_00144f8e;
                        uVar10 = (byte)param_1[0xf] >> 4 & 7;
                        LAB_001451c4:plVar5 = plVar14 + 2;
                     }
 else {
                        lVar8 = ( **(code**)( lVar11 + 0x50 ) )();
                        if (( *(byte*)( lVar8 + 0xf ) & 0x70 ) != 0) goto LAB_00145098;
                        lVar8 = *(long*)( param_2 + 8 );
                        plVar14 = *(long**)( lVar8 + lVar12 );
                        uVar10 = (byte)param_1[0xf] >> 4 & 7;
                        lVar11 = *plVar14;
                        if (*(code**)( lVar11 + 0x50 ) == TType::getQualifier) goto LAB_001451c4;
                        plVar5 = (long*)( **(code**)( lVar11 + 0x50 ) )();
                        lVar8 = *(long*)( param_2 + 8 );
                        plVar14 = *(long**)( lVar8 + lVar12 );
                        lVar11 = *plVar14;
                     }

                     *(byte*)( (long)plVar5 + 0xf ) = *(byte*)( (long)plVar5 + 0xf ) & 0x8f | ( byte )(uVar10 << 4);
                     goto LAB_00144f8e;
                  }

                  cVar2 = ( **(code**)( *plVar5 + 0xe0 ) )(plVar5);
                  if (cVar2 != '\0') {
                     lVar8 = *(long*)( param_2 + 8 );
                     plVar14 = *(long**)( lVar8 + lVar12 );
                     lVar11 = *plVar14;
                     goto LAB_0014519b;
                  }

                  lVar8 = *(long*)( param_2 + 8 );
                  LAB_0014517a:plVar14 = *(long**)( lVar8 + lVar12 );
                  lVar11 = *plVar14;
                  if (*(code**)( lVar11 + 0x38 ) != TType::getBasicType) {
                     iVar3 = ( **(code**)( lVar11 + 0x38 ) )();
                     lVar8 = *(long*)( param_2 + 8 );
                     plVar14 = *(long**)( lVar8 + lVar12 );
                     lVar11 = *plVar14;
                     if (iVar3 == 0xf) goto LAB_0014519b;
                     goto LAB_00144f8e;
                  }

                  if ((char)plVar14[1] == '\x0f') goto LAB_0014519b;
               }

               LAB_00144fa8:uVar13 = ( ulong )((int)uVar13 + 1);
            }
 while ( uVar13 < ( ulong )(*(long*)( param_2 + 0x10 ) - lVar8 >> 5) );
         }

         return;
      }

      /* glslang::TParseContext::fixBlockUniformLayoutPacking(glslang::TQualifier&,
   glslang::TVector<glslang::TTypeLoc>*, glslang::TVector<glslang::TTypeLoc>*) */
      void glslang::TParseContext::fixBlockUniformLayoutPacking(TParseContext *this, TQualifier *param_1, TVector *param_2, TVector *param_3) {
         TQualifier TVar1;
         code *pcVar2;
         char cVar3;
         uint uVar4;
         undefined8 uVar5;
         long lVar6;
         TType *pTVar7;
         long *plVar8;
         long lVar9;
         long lVar10;
         ulong uVar11;
         long *plVar12;
         lVar6 = *(long*)( param_2 + 8 );
         if (*(long*)( param_2 + 0x10 ) != lVar6) {
            uVar11 = 0;
            do {
               lVar10 = uVar11 * 0x20;
               if (( (byte)param_1[0x10] & 0xf ) == 0) {
                  LAB_00145450:lVar6 = *(long*)( param_2 + 8 );
                  plVar12 = *(long**)( lVar6 + lVar10 );
                  lVar9 = *plVar12;
               }
 else {
                  if (param_3 != (TVector*)0x0) {
                     pcVar2 = *(code**)( **(long**)( *(long*)( param_3 + 8 ) + lVar10 ) + 0x50 );
                     if (pcVar2 == TType::getQualifier) {
                        plVar8 = *(long**)( *(long*)( param_3 + 8 ) + lVar10 ) + 2;
                     }
 else {
                        plVar8 = (long*)( *pcVar2 )();
                     }

                     if (( *(byte*)( plVar8 + 2 ) & 0xf ) == 0) {
                        plVar8 = *(long**)( *(long*)( param_3 + 8 ) + lVar10 );
                        lVar6 = *plVar8;
                        if (*(code**)( lVar6 + 0xd0 ) == TType::isScalarOrVector) {
                           if (*(code**)( lVar6 + 0xe0 ) != TType::isMatrix) {
                              cVar3 = ( **(code**)( lVar6 + 0xe0 ) )();
                              if (cVar3 == '\0') {
                                 lVar6 = *plVar8;
                                 goto LAB_001455f3;
                              }

                              goto LAB_00145638;
                           }

                           if (*(byte*)( (long)plVar8 + 9 ) < 0x10) {
                              LAB_001455f3:if (*(code**)( lVar6 + 0x128 ) == TType::isStruct) {
                                 if (1 < ( byte )((char)plVar8[1] - 0xfU)) {
                                    LAB_00145616:if (*(code**)( lVar6 + 0xe8 ) != TType::isArray) {
                                       cVar3 = ( **(code**)( lVar6 + 0xe8 ) )();
                                       goto joined_r0x001456c4;
                                    }

                                    if (plVar8[0xc] == 0) goto LAB_00145450;
                                 }

                              }
 else {
                                 cVar3 = ( **(code**)( lVar6 + 0x128 ) )();
                                 if (cVar3 == '\0') {
                                    lVar6 = *plVar8;
                                    goto LAB_00145616;
                                 }

                              }

                              goto LAB_00145638;
                           }

                        }
 else {
                           cVar3 = ( **(code**)( lVar6 + 0xd0 ) )();
                           joined_r0x001456c4:if (cVar3 != '\0') goto LAB_00145450;
                           LAB_00145638:plVar8 = *(long**)( *(long*)( param_3 + 8 ) + lVar10 );
                           lVar6 = *plVar8;
                        }

                        TVar1 = param_1[0x10];
                        if (*(code**)( lVar6 + 0x50 ) == TType::getQualifier) {
                           plVar8 = plVar8 + 2;
                        }
 else {
                           plVar8 = (long*)( **(code**)( lVar6 + 0x50 ) )();
                        }

                        *(byte*)( plVar8 + 2 ) = *(byte*)( plVar8 + 2 ) & 0xf0 | (byte)TVar1 & 0xf;
                     }

                     goto LAB_00145450;
                  }

                  pcVar2 = *(code**)( **(long**)( lVar6 + lVar10 ) + 0x50 );
                  if (pcVar2 == TType::getQualifier) {
                     plVar8 = *(long**)( lVar6 + lVar10 ) + 2;
                  }
 else {
                     plVar8 = (long*)( *pcVar2 )();
                  }

                  lVar6 = *(long*)( param_2 + 8 );
                  plVar12 = *(long**)( lVar6 + lVar10 );
                  lVar9 = *plVar12;
                  if (( *(byte*)( plVar8 + 2 ) & 0xf ) == 0) {
                     if (*(code**)( lVar9 + 0xd0 ) == TType::isScalarOrVector) {
                        if (*(code**)( lVar9 + 0xe0 ) == TType::isMatrix) {
                           if (*(byte*)( (long)plVar12 + 9 ) < 0x10) goto LAB_00145580;
                        }
 else {
                           cVar3 = ( **(code**)( lVar9 + 0xe0 ) )();
                           if (cVar3 == '\0') {
                              lVar9 = *plVar12;
                              LAB_00145580:if (*(code**)( lVar9 + 0x128 ) == TType::isStruct) {
                                 if (1 < ( byte )((char)plVar12[1] - 0xfU)) {
                                    LAB_001456fc:if (*(code**)( lVar9 + 0xe8 ) != TType::isArray) {
                                       cVar3 = ( **(code**)( lVar9 + 0xe8 ) )();
                                       lVar6 = *(long*)( param_2 + 8 );
                                       plVar12 = *(long**)( lVar6 + lVar10 );
                                       lVar9 = *plVar12;
                                       goto joined_r0x0014575e;
                                    }

                                    lVar6 = *(long*)( param_2 + 8 );
                                    plVar8 = plVar12 + 0xc;
                                    plVar12 = *(long**)( lVar6 + lVar10 );
                                    lVar9 = *plVar12;
                                    if (*plVar8 == 0) goto LAB_0014545b;
                                    goto LAB_001455b1;
                                 }

                              }
 else {
                                 cVar3 = ( **(code**)( lVar9 + 0x128 ) )();
                                 if (cVar3 == '\0') {
                                    lVar9 = *plVar12;
                                    goto LAB_001456fc;
                                 }

                              }

                           }

                           lVar6 = *(long*)( param_2 + 8 );
                           plVar12 = *(long**)( lVar6 + lVar10 );
                           lVar9 = *plVar12;
                        }

                     }
 else {
                        cVar3 = ( **(code**)( lVar9 + 0xd0 ) )();
                        lVar6 = *(long*)( param_2 + 8 );
                        plVar12 = *(long**)( lVar6 + lVar10 );
                        lVar9 = *plVar12;
                        joined_r0x0014575e:if (cVar3 != '\0') goto LAB_0014545b;
                     }

                     LAB_001455b1:TVar1 = param_1[0x10];
                     if (*(code**)( lVar9 + 0x50 ) == TType::getQualifier) {
                        plVar8 = plVar12 + 2;
                     }
 else {
                        plVar8 = (long*)( **(code**)( lVar9 + 0x50 ) )();
                        lVar6 = *(long*)( param_2 + 8 );
                        plVar12 = *(long**)( lVar6 + lVar10 );
                        lVar9 = *plVar12;
                     }

                     *(byte*)( plVar8 + 2 ) = *(byte*)( plVar8 + 2 ) & 0xf0 | (byte)TVar1 & 0xf;
                  }

               }

               LAB_0014545b:if (*(code**)( lVar9 + 0x38 ) == TType::getBasicType) {
                  uVar4 = ( uint ) * (byte*)( plVar12 + 1 );
               }
 else {
                  uVar4 = ( **(code**)( lVar9 + 0x38 ) )();
                  lVar6 = *(long*)( param_2 + 8 );
               }

               if (uVar4 == 0xf) {
                  if (param_3 == (TVector*)0x0) {
                     pTVar7 = (TType*)TType::clone(*(TType**)( lVar6 + lVar10 ));
                     fixBlockUniformLayoutPacking(this, param_1, *(TVector**)( *(long*)( *(long*)( param_2 + 8 ) + lVar10 ) + 0x68 ), *(TVector**)( pTVar7 + 0x68 ));
                     uVar5 = recordStructCopy(this, (map*)( this + 0x75c8 ), *(TType**)( *(long*)( param_2 + 8 ) + lVar10 ), pTVar7);
                     lVar6 = *(long*)( param_2 + 8 );
                     *(undefined8*)( *(long*)( lVar6 + lVar10 ) + 0x68 ) = uVar5;
                  }
 else {
                     pTVar7 = *(TType**)( *(long*)( param_3 + 8 ) + lVar10 );
                     fixBlockUniformLayoutPacking(this, param_1, *(TVector**)( *(TType**)( lVar6 + lVar10 ) + 0x68 ), *(TVector**)( pTVar7 + 0x68 ));
                     uVar5 = recordStructCopy(this, (map*)( this + 0x75c8 ), *(TType**)( *(long*)( param_2 + 8 ) + lVar10 ), pTVar7);
                     *(undefined8*)( *(long*)( *(long*)( param_3 + 8 ) + lVar10 ) + 0x68 ) = uVar5;
                     lVar6 = *(long*)( param_2 + 8 );
                  }

               }

               uVar11 = ( ulong )((int)uVar11 + 1);
            }
 while ( uVar11 < ( ulong )(*(long*)( param_2 + 0x10 ) - lVar6 >> 5) );
         }

         return;
      }

      /* glslang::TParseContext::declareBlock(glslang::TSourceLoc const&,
   glslang::TVector<glslang::TTypeLoc>&, std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const*, glslang::TArraySizes*) */
      void glslang::TParseContext::declareBlock(TParseContext *this, TSourceLoc *param_1, TVector *param_2, basic_string *param_3, TArraySizes *param_4) {
         TQualifier *pTVar1;
         TSourceLoc *pTVar2;
         TQualifier TVar3;
         TQualifier TVar4;
         TSymbolTable TVar5;
         code *pcVar6;
         long lVar7;
         code *pcVar8;
         char *pcVar9;
         TSymbolTableLevel *pTVar10;
         undefined8 *puVar11;
         undefined1 auVar12[16];
         undefined1 auVar13[16];
         TParseContext TVar14;
         char cVar15;
         int iVar16;
         uint uVar17;
         TType *pTVar18;
         basic_string *pbVar19;
         TArraySizes *pTVar20;
         TQualifier *pTVar21;
         ulong uVar22;
         undefined8 uVar23;
         size_t sVar24;
         TVariable *pTVar25;
         long *plVar26;
         long *plVar27;
         TVariable *pTVar28;
         ulong uVar29;
         long lVar30;
         TType *pTVar31;
         byte bVar32;
         undefined8 *puVar33;
         bool bVar34;
         undefined8 *puVar35;
         bool bVar36;
         long lVar37;
         TSymbolTable *pTVar38;
         long lVar39;
         long in_FS_OFFSET;
         byte local_290;
         ulong local_288;
         basic_string *local_268;
         undefined8 local_238[2];
         undefined4 local_228[2];
         long local_220;
         undefined4 *local_218;
         undefined4 *local_210;
         undefined8 local_208;
         undefined **local_1f8;
         ulong uStack_1f0;
         uint local_1e8;
         undefined4 uStack_1e4;
         undefined4 uStack_1e0;
         uint uStack_1dc;
         undefined8 local_1d8;
         ulong uStack_1d0;
         undefined8 local_1c8;
         undefined8 uStack_1c0;
         undefined8 local_1b8;
         ulong uStack_1b0;
         undefined **local_1a8;
         uint local_1a0;
         undefined8 local_198;
         undefined8 uStack_190;
         undefined8 local_188;
         undefined8 uStack_180;
         undefined8 local_178;
         undefined8 uStack_170;
         undefined8 local_168;
         undefined8 uStack_160;
         undefined8 local_158;
         undefined8 uStack_150;
         TArraySizes *local_148;
         TVector *local_140;
         undefined8 local_138;
         undefined8 *local_130;
         uint local_128;
         undefined8 local_120;
         undefined **local_108;
         ulong uStack_100;
         undefined8 local_f8;
         ulong uStack_f0;
         uint local_e8;
         undefined4 uStack_e4;
         undefined4 uStack_e0;
         uint uStack_dc;
         undefined4 uStack_d8;
         undefined4 uStack_d4;
         uint uStack_d0;
         undefined4 uStack_cc;
         uint local_c8;
         undefined4 uStack_c4;
         undefined4 uStack_c0;
         undefined4 uStack_bc;
         undefined8 local_b8;
         undefined2 local_b0;
         undefined1 local_a8[16];
         undefined1 local_98[16];
         uint local_88;
         undefined1 local_80[16];
         undefined8 local_68;
         undefined1 *local_60;
         undefined8 local_58;
         undefined1 local_50[16];
         long local_40;
         local_40 = *(long*)( in_FS_OFFSET + 0x28 );
         pTVar1 = (TQualifier*)( this + 0x510 );
         if (( 0 < *(int*)( this + 0x28 ) ) && ( this[0x30] != (TParseContext)0x0 )) {
            blockStorageRemap(this, param_1, *(basic_string**)( this + 0x508 ), pTVar1);
         }

         pTVar21 = (TQualifier*)( this + 0x510 );
         blockStageIoCheck(this, param_1, pTVar21);
         blockQualifierCheck((TSourceLoc*)this, (TQualifier*)param_1, SUB81(pTVar21, 0));
         if (param_4 != (TArraySizes*)0x0) {
            if (this[0x1c1] == (TParseContext)0x0) {
               arraySizesCheck(this, param_1, pTVar21, param_4, (TIntermTyped*)0x0, false);
            }

            arrayOfArrayVersionCheck(this, param_1, param_4);
            lVar39 = *(long*)( param_4 + 8 );
            if (( lVar39 != 0 ) && ( 1 < (int)( *(long*)( lVar39 + 0x10 ) - *(long*)( lVar39 + 8 ) >> 4 ) )) {
               glslang::TParseVersions::requireProfile((TSourceLoc*)this, (int)param_1, (char*)0xfffffff7);
            }

         }

         lVar39 = *(long*)( param_2 + 8 );
         if (*(long*)( param_2 + 0x10 ) != lVar39) {
            local_288 = 0;
            uVar17 = 0;
            do {
               lVar37 = local_288 * 0x20;
               pTVar31 = *(TType**)( lVar39 + lVar37 );
               if (*(code**)( *(long*)pTVar31 + 0x50 ) == TType::getQualifier) {
                  pTVar18 = pTVar31 + 0x10;
               }
 else {
                  pTVar18 = (TType*)( **(code**)( *(long*)pTVar31 + 0x50 ) )(pTVar31);
                  lVar39 = *(long*)( param_2 + 8 );
               }

               pTVar2 = (TSourceLoc*)( lVar39 + 8 + lVar37 );
               bVar32 = (byte)this[0x518] & 0x7f;
               if (( ( ( byte )((TQualifier*)pTVar18)[8] & 0x7e ) != 0 ) && ( ( ( byte )((TQualifier*)pTVar18)[8] & 0x7f ) != bVar32 )) {
                  pcVar6 = *(code**)( *(long*)this + 0x158 );
                  if (*(code**)( *(long*)pTVar31 + 0x30 ) != TType::getFieldName_abi_cxx11_) {
                     ( **(code**)( *(long*)pTVar31 + 0x30 ) )(pTVar31);
                  }

                  ( *pcVar6 )(this, pTVar2, "member storage qualifier cannot contradict block storage qualifier");
                  bVar32 = (byte)this[0x518] & 0x7f;
               }

               ( (TQualifier*)pTVar18 )[8] = ( TQualifier )(( byte )((TQualifier*)pTVar18)[8] & 0x80 | bVar32);
               globalQualifierFixCheck(this, pTVar2, (TQualifier*)pTVar18, false, (TPublicType*)0x0);
               if ((char)this[0x51d] < '\0') {
                  ( (TQualifier*)pTVar18 )[0xd] = ( TQualifier )(( byte )((TQualifier*)pTVar18)[0xd] | 0x80);
               }

               TVar14 = this[0x51e];
               if (( (byte)TVar14 & 1 ) != 0) {
                  ( (TQualifier*)pTVar18 )[0xe] = ( TQualifier )(( byte )((TQualifier*)pTVar18)[0xe] | 1);
                  TVar14 = this[0x51e];
               }

               if (( (byte)TVar14 & 2 ) != 0) {
                  ( (TQualifier*)pTVar18 )[0xe] = ( TQualifier )(( byte )((TQualifier*)pTVar18)[0xe] | 2);
                  TVar14 = this[0x51e];
               }

               if (( (byte)TVar14 & 4 ) != 0) {
                  ( (TQualifier*)pTVar18 )[0xe] = ( TQualifier )(( byte )((TQualifier*)pTVar18)[0xe] | 4);
               }

               if (( (byte)this[0x51d] & 0x40 ) != 0) {
                  ( (TQualifier*)pTVar18 )[0xd] = ( TQualifier )(( byte )((TQualifier*)pTVar18)[0xd] | 0x40);
               }

               TVar14 = this[0x51d];
               if (( (byte)TVar14 & 2 ) != 0) {
                  ( (TQualifier*)pTVar18 )[0xd] = ( TQualifier )(( byte )((TQualifier*)pTVar18)[0xd] | 2);
                  TVar14 = this[0x51d];
               }

               if (( (byte)TVar14 & 4 ) != 0) {
                  ( (TQualifier*)pTVar18 )[0xd] = ( TQualifier )(( byte )((TQualifier*)pTVar18)[0xd] | 4);
                  TVar14 = this[0x51d];
               }

               if (( (byte)TVar14 & 8 ) != 0) {
                  ( (TQualifier*)pTVar18 )[0xd] = ( TQualifier )(( byte )((TQualifier*)pTVar18)[0xd] | 8);
               }

               if (( (byte)this[0x518] & 0x7f ) == 0xf) {
                  ( (TQualifier*)pTVar18 )[8] = ( TQualifier )(( byte )((TQualifier*)pTVar18)[8] & 0x80 | 0xf);
               }

               if (( ( byte )((TQualifier*)pTVar18)[8] & 0x7f ) == 8) {
                  pcVar6 = *(code**)( *(long*)this + 0x158 );
                  if (*(code**)( *(long*)pTVar31 + 0x30 ) == TType::getFieldName_abi_cxx11_) {
                     lVar39 = *(long*)( pTVar31 + 0x70 );
                  }
 else {
                     lVar39 = ( **(code**)( *(long*)pTVar31 + 0x30 ) )(pTVar31);
                  }

                  ( *pcVar6 )(this, pTVar2, "member cannot have a spirv_storage_class qualifier", *(undefined8*)( lVar39 + 8 ));
               }

               if (( *(long*)( (TQualifier*)pTVar18 + 0x40 ) != 0 ) && ( *(long*)( *(long*)( (TQualifier*)pTVar18 + 0x40 ) + 0x68 ) != 0 )) {
                  pcVar6 = *(code**)( *(long*)this + 0x158 );
                  if (*(code**)( *(long*)pTVar31 + 0x30 ) == TType::getFieldName_abi_cxx11_) {
                     lVar39 = *(long*)( pTVar31 + 0x70 );
                  }
 else {
                     lVar39 = ( **(code**)( *(long*)pTVar31 + 0x30 ) )(pTVar31);
                  }

                  ( *pcVar6 )(this, pTVar2, "member cannot have a spirv_decorate_id qualifier", *(undefined8*)( lVar39 + 8 ));
               }

               if (( ( byte )(( (byte)this[0x518] & 0x7f ) - 5) < 2 ) && ( ( ( ( ( ( TVar3 = ( (TQualifier*)pTVar18 )[0xb] ),(char)TVar3 < '\0' || ( ( (byte)TVar3 & 0x40 ) != 0 ) ) || ( TVar4 = ( (TQualifier*)pTVar18 )[0xc]((byte)TVar4 & 0x20) != 0 ) ) || ( ( ( (byte)TVar4 & 0x40 ) != 0 || ( ( (byte)TVar3 & 0x20 ) != 0 ) ) ) ) || ( TVar3 = ( (TQualifier*)pTVar18 )[0xd]((byte)TVar3 & 0x10) != 0 ) ) || ( ( ( ( (byte)TVar3 & 0x20 ) != 0 || ( (char)TVar4 < '\0' ) ) || ( ( (byte)TVar3 & 1 ) != 0 ) ) ) )) {
                  pcVar6 = *(code**)( *(long*)this + 0x158 );
                  if (*(code**)( *(long*)pTVar31 + 0x30 ) == TType::getFieldName_abi_cxx11_) {
                     lVar39 = *(long*)( pTVar31 + 0x70 );
                  }
 else {
                     lVar39 = ( **(code**)( *(long*)pTVar31 + 0x30 ) )(pTVar31);
                  }

                  ( *pcVar6 )(this, pTVar2, "member of uniform or buffer block cannot have an auxiliary or interpolation qualifier", *(undefined8*)( lVar39 + 8 ));
               }

               lVar39 = *(long*)pTVar31;
               if (*(code**)( lVar39 + 0xe8 ) == TType::isArray) {
                  if (*(long*)( pTVar31 + 0x60 ) != 0) {
                     LAB_00145b45:lVar30 = *(long*)( param_2 + 0x10 );
                     lVar7 = *(long*)( param_2 + 8 );
                     if (*(code**)( lVar39 + 0xa0 ) == TType::getArraySizes) {
                        pTVar20 = *(TArraySizes**)( pTVar31 + 0x60 );
                     }
 else {
                        pTVar20 = (TArraySizes*)( **(code**)( lVar39 + 0xa0 ) )(pTVar31);
                     }

                     if (this[0x1c1] == (TParseContext)0x0) {
                        arraySizesCheck(this, pTVar2, pTVar1, pTVar20, (TIntermTyped*)0x0, ( lVar30 - lVar7 >> 5 ) - 1U == local_288);
                     }

                  }

               }
 else {
                  cVar15 = ( **(code**)( lVar39 + 0xe8 ) )(pTVar31);
                  if (cVar15 != '\0') {
                     lVar39 = *(long*)pTVar31;
                     goto LAB_00145b45;
                  }

               }

               if (( *(int*)( (TQualifier*)pTVar18 + 0x14 ) != -1 ) && ( *(int*)( this + 0x20 ) == 0 )) {
                  glslang::TParseVersions::profileRequires((TSourceLoc*)this, (int)pTVar2, -9, (char*)0x1b8, "GL_ARB_enhanced_layouts");
                  glslang::TParseVersions::profileRequires((TSourceLoc*)this, (int)pTVar2, 8, (char*)0x12c, "GL_ARB_enhanced_layouts");
               }

               lVar39 = *(long*)pTVar31;
               if (*(code**)( lVar39 + 0x1b0 ) == TType::containsOpaque) {
                  if (*(code**)( lVar39 + 0x140 ) != TType::isOpaque) {
                     cVar15 = ( **(code**)( lVar39 + 0x140 ) )(pTVar31);
                     lVar39 = *(long*)pTVar31;
                     if (cVar15 == '\0') goto LAB_00145cf0;
                     goto LAB_00145bff;
                  }

                  if (( (byte)pTVar31[8] < 0x15 ) && ( ( 0x1a6000UL >> ( (ulong)(byte)pTVar31[8] & 0x3f ) & 1 ) != 0 )) goto LAB_00145bff;
                  LAB_00145cf0:if (*(code**)( lVar39 + 0x128 ) == TType::isStruct) {
                     if (( byte )((char)pTVar31[8] - 0xfU) < 2) {
                        LAB_00145d17:lVar39 = *(long*)( *(long*)( pTVar31 + 0x68 ) + 0x10 );
                        lVar30 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( pTVar31 + 0x68 ) + 8 ),lVar39 ));
                        if (lVar39 != lVar30) goto LAB_00145d34;
                     }

                  }
 else {
                     cVar15 = ( **(code**)( lVar39 + 0x128 ) )(pTVar31);
                     if (cVar15 != '\0') goto LAB_00145d17;
                  }

               }
 else {
                  cVar15 = ( **(code**)( lVar39 + 0x1b0 ) )(pTVar31);
                  if (cVar15 == '\0') goto LAB_00145c83;
                  LAB_00145d34:lVar39 = *(long*)pTVar31;
                  LAB_00145bff:if (*(code**)( lVar39 + 0x1b8 ) == TType::containsSampler) {
                     cVar15 = TType::contains<glslang::TType::containsSampler()const::_lambda(glslang::TType_const*)_1_>();
                  }
 else {
                     cVar15 = ( **(code**)( lVar39 + 0x1b8 ) )(pTVar31);
                  }

                  lVar39 = *(long*)this;
                  if (cVar15 != '\0') {
                     cVar15 = ( **(code**)( lVar39 + 0x40 ) )(this, "GL_ARB_bindless_texture");
                     if (cVar15 != '\0') {
                        updateBindlessQualifier(this, pTVar31);
                        goto LAB_00145c83;
                     }

                     lVar39 = *(long*)this;
                  }

                  pcVar6 = *(code**)( lVar39 + 0x158 );
                  pcVar8 = *(code**)( **(long**)( *(long*)( param_2 + 8 ) + lVar37 ) + 0x30 );
                  if (pcVar8 == TType::getFieldName_abi_cxx11_) {
                     lVar39 = ( *(long**)( *(long*)( param_2 + 8 ) + lVar37 ) )[0xe];
                  }
 else {
                     lVar39 = ( *pcVar8 )();
                  }

                  ( *pcVar6 )(this, pTVar2, "member of block cannot be or contain a sampler, image, or atomic_uint type", *(undefined8*)( lVar39 + 8 ));
               }

               LAB_00145c83:if (( ( (byte)pTVar31[10] & 0x20 ) == 0 ) && ( ( (byte)pTVar31[10] & 0x40 ) == 0 )) {
                  if (*(code**)( *(long*)pTVar31 + 0x128 ) == TType::isStruct) {
                     if (( byte )((char)pTVar31[8] - 0xfU) < 2) {
                        LAB_00145fe5:lVar39 = *(long*)( *(long*)( pTVar31 + 0x68 ) + 0x10 );
                        lVar30 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsCoopMat()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsCoopMat ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( pTVar31 + 0x68 ) + 8 ),lVar39 ));
                        if (lVar39 != lVar30) goto LAB_00145c90;
                     }

                  }
 else {
                     cVar15 = ( **(code**)( *(long*)pTVar31 + 0x128 ) )(pTVar31);
                     if (cVar15 != '\0') goto LAB_00145fe5;
                  }

               }
 else {
                  LAB_00145c90:pcVar6 = *(code**)( *(long*)this + 0x158 );
                  pcVar8 = *(code**)( **(long**)( *(long*)( param_2 + 8 ) + lVar37 ) + 0x30 );
                  if (pcVar8 == TType::getFieldName_abi_cxx11_) {
                     lVar39 = ( *(long**)( *(long*)( param_2 + 8 ) + lVar37 ) )[0xe];
                  }
 else {
                     lVar39 = ( *pcVar8 )();
                  }

                  ( *pcVar6 )(this, pTVar2, "member of block cannot be or contain a cooperative matrix type", *(undefined8*)( lVar39 + 8 ));
               }

               lVar39 = *(long*)( param_2 + 8 );
               uVar17 = uVar17 + 1;
               local_288 = (ulong)uVar17;
            }
 while ( local_288 < ( ulong )(*(long*)( param_2 + 0x10 ) - lVar39 >> 5) );
         }

         if (3 < (int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 )) {
            pbVar19 = *(basic_string**)( this + 0x508 );
            uVar22 = *(ulong*)( pbVar19 + 0x10 );
            if (uVar22 != 0) {
               sVar24 = 3;
               if (uVar22 < 4) {
                  sVar24 = uVar22;
               }

               iVar16 = memcmp(*(void**)( pbVar19 + 8 ), &_LC61, sVar24);
               if (iVar16 == 0 && (int)sVar24 == 3) {
                  if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                     redeclareBuiltinBlock(this, param_1, param_2, pbVar19, param_3, param_4);
                     return;
                  }

                  goto LAB_001478ae;
               }

            }

            reservedErrorCheck(this, param_1, pbVar19);
            if (( param_3 != (basic_string*)0x0 ) && ( 3 < (int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 ) )) {
               reservedErrorCheck(this, param_1, param_3);
            }

            lVar39 = *(long*)( param_2 + 8 );
         }

         uVar22 = 0;
         if (lVar39 != *(long*)( param_2 + 0x10 )) {
            do {
               plVar26 = *(long**)( lVar39 + uVar22 * 0x20 );
               pcVar6 = *(code**)( *plVar26 + 0x30 );
               if (pcVar6 == TType::getFieldName_abi_cxx11_) {
                  pbVar19 = (basic_string*)plVar26[0xe];
               }
 else {
                  pbVar19 = (basic_string*)( *pcVar6 )();
                  lVar39 = *(long*)( param_2 + 8 );
               }

               if (3 < (int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 )) {
                  reservedErrorCheck(this, (TSourceLoc*)( lVar39 + 8 + uVar22 * 0x20 ), pbVar19);
                  lVar39 = *(long*)( param_2 + 8 );
               }

               uVar22 = ( ulong )((int)uVar22 + 1);
            }
 while ( uVar22 < ( ulong )(*(long*)( param_2 + 0x10 ) - lVar39 >> 5) );
         }

         switch ((char)this[0x518] + 0x7dU & 0x7f) {
            case 0:
    local_1f8 = *(undefined ***)(this + 0x7420);
    uStack_1f0 = *(ulong *)(this + 0x7428);
    local_1d8 = *(ulong *)(this + 0x7440);
    uStack_1d0 = *(ulong *)(this + 0x7448);
    local_1c8 = *(undefined8 *)(this + 0x7450);
    uStack_1c0 = *(undefined8 *)(this + 0x7458);
    local_1b8 = *(undefined8 *)(this + 0x7460);
    uStack_1b0 = *(ulong *)(this + 0x7468);
    local_1e8 = (uint)*(undefined8 *)(this + 0x7430);
    uStack_1e4 = (undefined4)((ulong)*(undefined8 *)(this + 0x7430) >> 0x20);
    uStack_1e0 = (undefined4)*(undefined8 *)(this + 0x7438);
    uStack_1dc = (uint)((ulong)*(undefined8 *)(this + 0x7438) >> 0x20);
    if (this[0x53d] != (TParseContext)0x0) goto LAB_001461f5;
    goto LAB_001465e8;
            case 1:
    local_1f8 = *(undefined ***)(this + 0x7470);
    uStack_1f0 = *(ulong *)(this + 0x7478);
    local_1d8 = *(ulong *)(this + 0x7490);
    uStack_1d0 = *(ulong *)(this + 0x7498);
    local_1c8 = *(undefined8 *)(this + 0x74a0);
    uStack_1c0 = *(undefined8 *)(this + 0x74a8);
    local_1b8 = *(undefined8 *)(this + 0x74b0);
    uStack_1b0 = *(ulong *)(this + 0x74b8);
    local_1e8 = (uint)*(undefined8 *)(this + 0x7480);
    uStack_1e4 = (undefined4)((ulong)*(undefined8 *)(this + 0x7480) >> 0x20);
    uStack_1e0 = (undefined4)*(undefined8 *)(this + 0x7488);
    uStack_1dc = (uint)((ulong)*(undefined8 *)(this + 0x7488) >> 0x20);
    break;
            case 2:
    local_1f8 = *(undefined ***)(this + 0x73d0);
    uStack_1f0 = *(ulong *)(this + 0x73d8);
    local_1d8 = *(ulong *)(this + 0x73f0);
    uStack_1d0 = *(ulong *)(this + 0x73f8);
    local_1c8 = *(undefined8 *)(this + 0x7400);
    uStack_1c0 = *(undefined8 *)(this + 0x7408);
    local_1b8 = *(undefined8 *)(this + 0x7410);
    uStack_1b0 = *(ulong *)(this + 0x7418);
    local_1e8 = (uint)*(undefined8 *)(this + 0x73e0);
    uStack_1e4 = (undefined4)((ulong)*(undefined8 *)(this + 0x73e0) >> 0x20);
    uStack_1e0 = (undefined4)*(undefined8 *)(this + 0x73e8);
    uStack_1dc = (uint)((ulong)*(undefined8 *)(this + 0x73e8) >> 0x20);
    break;
            case 3:
    local_1f8 = *(undefined ***)(this + 0x7380);
    uStack_1f0 = *(ulong *)(this + 0x7388);
    local_1d8 = *(ulong *)(this + 0x73a0);
    uStack_1d0 = *(ulong *)(this + 0x73a8);
    local_1c8 = *(undefined8 *)(this + 0x73b0);
    uStack_1c0 = *(undefined8 *)(this + 0x73b8);
    local_1b8 = *(undefined8 *)(this + 0x73c0);
    uStack_1b0 = *(ulong *)(this + 0x73c8);
    local_1e8 = (uint)*(undefined8 *)(this + 0x7390);
    uStack_1e4 = (undefined4)((ulong)*(undefined8 *)(this + 0x7390) >> 0x20);
    uStack_1e0 = (undefined4)*(undefined8 *)(this + 0x7398);
    uStack_1dc = (uint)((ulong)*(undefined8 *)(this + 0x7398) >> 0x20);
    break;
            case 4:
    local_1f8 = *(undefined ***)(this + 0x74c0);
    uStack_1f0 = *(ulong *)(this + 0x74c8);
    local_1d8 = *(ulong *)(this + 0x74e0);
    uStack_1d0 = *(ulong *)(this + 0x74e8);
    local_1c8 = *(undefined8 *)(this + 0x74f0);
    uStack_1c0 = *(undefined8 *)(this + 0x74f8);
    local_1b8 = *(undefined8 *)(this + 0x7500);
    uStack_1b0 = *(ulong *)(this + 0x7508);
    local_1e8 = (uint)*(undefined8 *)(this + 0x74d0);
    uStack_1e4 = (undefined4)((ulong)*(undefined8 *)(this + 0x74d0) >> 0x20);
    uStack_1e0 = (undefined4)*(undefined8 *)(this + 0x74d8);
    uStack_1dc = (uint)((ulong)*(undefined8 *)(this + 0x74d8) >> 0x20);
    break;
            default:
    local_1e8 = local_1e8 & 0xfffffff0;
    uStack_1e4 = 0xffffffff;
    uStack_1e0 = 0xffffffff;
    local_1c8._0_4_ = (uint)local_1c8 & 0xffffff00;
    uStack_1dc = uStack_1dc & 0xffc00000 | 0x1fcfff;
    uStack_1b0 = uStack_1b0 & 0xffffffffffff0000;
    local_1d8 = local_1d8 | 0x7fffffffffffffff;
    local_1c8 = CONCAT44(0xfffff800,(uint)local_1c8);
    local_1b8 = 0;
    uStack_1d0 = (ulong)((uint)uStack_1d0 & 0xfe000000) | 0x1ffffff;
    local_1f8 = (undefined **)0x0;
    uStack_1c0 = 0xffffffff00000000;
    uStack_1f0 = uStack_1f0 & 0x8000000400000000;
         }

         if (this[0x53d] == (TParseContext)0x0) {
            LAB_001465e8:if (this[0x548] == (TParseContext)0x0) goto LAB_00146210;
            if (( (byte)this[0x520] & 0xf ) == 0) goto LAB_00146602;
         }
 else {
            LAB_001461f5:if (( (byte)this[0x520] & 0xf ) == 0) {
               LAB_00146602:this[0x520] = ( TParseContext )((byte)this[0x520] & 0xf0 | 3);
            }
 else if (this[0x548] != (TParseContext)0x0) goto LAB_00146230;
            LAB_00146210:if (( ( (byte)this[0x51d] & 8 ) != 0 ) && ( ( (byte)this[0x520] & 0xf ) == 0 )) {
               this[0x520] = ( TParseContext )((byte)this[0x520] & 0xf0 | 3);
            }

         }

         LAB_00146230:mergeObjectLayoutQualifiers(this, (TQualifier*)&local_1f8, pTVar1, true);
         if (( ( *(int*)( this + 0x528 ) != -1 ) && ( ( (byte)local_1e8 & 0xe ) != 2 ) ) && ( ( (byte)local_1e8 & 0xf ) != 5 )) {
            ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be used with std140, std430, or scalar layout packing", "align");
            uStack_1e0 = 0xffffffff;
         }

         lVar39 = *(long*)( param_2 + 8 );
         bVar36 = false;
         if (*(long*)( param_2 + 0x10 ) == lVar39) {
            local_290 = 0;
            bVar34 = false;
         }
 else {
            uVar22 = 0;
            local_290 = 0;
            bVar36 = false;
            bVar34 = false;
            do {
               lVar37 = uVar22 * 0x20;
               pcVar6 = *(code**)( **(long**)( lVar39 + lVar37 ) + 0x50 );
               if (pcVar6 == TType::getQualifier) {
                  pTVar21 = (TQualifier*)( *(long**)( lVar39 + lVar37 ) + 2 );
               }
 else {
                  pTVar21 = (TQualifier*)( *pcVar6 )();
                  lVar39 = *(long*)( param_2 + 8 );
               }

               pTVar2 = (TSourceLoc*)( lVar39 + 8 + lVar37 );
               if (( pTVar21[0x23] != (TQualifier)0xff ) && ( local_1d8._3_1_ != pTVar21[0x23] )) {
                  ( **(code**)( *(long*)this + 0x158 ) )(this, pTVar2, "member cannot contradict block", "stream");
               }

               if (( ( ~(byte)pTVar21[0x24] & 0xf ) != 0 ) && ( ( ( (byte)pTVar21[0x24] ^ local_1d8._4_1_ ) & 0xf ) != 0 )) {
                  ( **(code**)( *(long*)this + 0x158 ) )(this, pTVar2, "member cannot contradict block (or what block inherited from global)", "xfb_buffer");
               }

               if (( (byte)pTVar21[0x10] & 0xf ) != 0) {
                  pcVar6 = *(code**)( *(long*)this + 0x158 );
                  pcVar8 = *(code**)( **(long**)( *(long*)( param_2 + 8 ) + lVar37 ) + 0x30 );
                  if (pcVar8 == TType::getFieldName_abi_cxx11_) {
                     lVar39 = ( *(long**)( *(long*)( param_2 + 8 ) + lVar37 ) )[0xe];
                  }
 else {
                     lVar39 = ( *pcVar8 )();
                  }

                  ( *pcVar6 )(this, pTVar2, "member of block cannot have a packing layout qualifier", *(undefined8*)( lVar39 + 8 ));
               }

               if (( ~*(ushort *)(pTVar21 + 0x1c) & 0xfff ) == 0) {
                  bVar36 = true;
                  if (*(int*)( pTVar21 + 0x18 ) != -1) goto LAB_00146338;
                  LAB_00146572:if (*(int*)( pTVar21 + 0x14 ) != -1) goto LAB_00146338;
               }
 else {
                  if (( (byte)this[0x518] & 0x7f ) - 3 < 2) {
                     iVar16 = (int)pTVar2;
                     glslang::TParseVersions::requireProfile((TSourceLoc*)this, iVar16, (char*)0xe);
                     glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar16, 6, (char*)0x1b8, "GL_ARB_enhanced_layouts");
                     glslang::TParseVersions::profileRequires((TSourceLoc*)this, iVar16, 8, 0x140, (char**)0x2, AEP_shader_io_blocks);
                     bVar34 = true;
                  }
 else {
                     ( **(code**)( *(long*)this + 0x158 ) )(this, pTVar2, "can only use in an in/out block", "location on block member");
                  }

                  if (*(int*)( pTVar21 + 0x18 ) == -1) goto LAB_00146572;
                  LAB_00146338:if (( ( (byte)local_1e8 & 0xe ) != 2 ) && ( ( (byte)local_1e8 & 0xf ) != 5 )) {
                     ( **(code**)( *(long*)this + 0x158 ) )(this, pTVar2, "can only be used with std140, std430, or scalar layout packing", "offset/align");
                  }

               }

               uVar22 = ( ulong )((int)uVar22 + 1);
               local_f8 = CONCAT44(uStack_1e4, local_1e8);
               uStack_f0 = CONCAT44(uStack_1dc, uStack_1e0);
               local_108 = local_1f8;
               uStack_100 = uStack_1f0;
               if (( (byte)pTVar21[0xd] >> 2 & 1 ) != 0) {
                  local_290 = (byte)pTVar21[0xd] >> 2 & 1;
               }

               local_e8 = (uint)local_1d8;
               uStack_e4 = ( undefined4 )(local_1d8 >> 0x20);
               uStack_e0 = (undefined4)uStack_1d0;
               uStack_dc = ( uint )(uStack_1d0 >> 0x20);
               uStack_d8 = (undefined4)local_1c8;
               uStack_d4 = ( undefined4 )((ulong)local_1c8 >> 0x20);
               uStack_d0 = (uint)uStack_1c0;
               uStack_cc = ( undefined4 )((ulong)uStack_1c0 >> 0x20);
               local_c8 = (uint)local_1b8;
               uStack_c4 = ( undefined4 )((ulong)local_1b8 >> 0x20);
               uStack_c0 = (undefined4)uStack_1b0;
               uStack_bc = ( undefined4 )(uStack_1b0 >> 0x20);
               mergeQualifiers(this, pTVar2, (TQualifier*)&local_108, pTVar21, false);
               lVar39 = *(long*)( param_2 + 8 );
               lVar37 = *(long*)( param_2 + 0x10 );
               *(undefined***)pTVar21 = local_108;
               *(ulong*)( pTVar21 + 8 ) = uStack_100;
               *(undefined8*)( pTVar21 + 0x10 ) = local_f8;
               *(ulong*)( pTVar21 + 0x18 ) = uStack_f0;
               *(ulong*)( pTVar21 + 0x20 ) = CONCAT44(uStack_e4, local_e8);
               *(ulong*)( pTVar21 + 0x28 ) = CONCAT44(uStack_dc, uStack_e0);
               *(ulong*)( pTVar21 + 0x30 ) = CONCAT44(uStack_d4, uStack_d8);
               *(ulong*)( pTVar21 + 0x38 ) = CONCAT44(uStack_cc, uStack_d0);
               *(ulong*)( pTVar21 + 0x40 ) = CONCAT44(uStack_c4, local_c8);
               *(ulong*)( pTVar21 + 0x48 ) = CONCAT44(uStack_bc, uStack_c0);
            }
 while ( uVar22 < ( ulong )(lVar37 - lVar39 >> 5) );
         }

         layoutMemberLocationArrayCheck(this, param_1, bVar34, param_4);
         if (( ( ( ( (byte)this[0x518] & 0x7f ) == 4 ) && ( ( (byte)this[0x7494] & 0xf ) != 0xf ) ) && ( ( ~(byte)this[0x534] & 0xf ) == 0 ) ) && ( ( ~*(ushort *)(this + 0x536) & 0x7ffc ) != 0 )) {
            this[0x534] = ( TParseContext )((byte)this[0x534] & 0xf0 | (byte)this[0x7494] & 0xf);
         }

         fixBlockLocations(this, param_1, pTVar1, param_2, bVar34, bVar36);
         fixXfbOffsets(this, pTVar1, param_2);
         if (( ( ( (byte)this[0x518] & 0x7f ) - 5 < 3 ) || ( ( (byte)this[0x51d] & 8 ) != 0 ) ) && ( ( ( (byte)this[0x520] & 0xe ) == 2 || ( ( (byte)this[0x520] & 0xf ) == 5 ) ) )) {
            fixBlockUniformOffsets(this, pTVar1, param_2);
         }

         uVar22 = 0;
         fixBlockUniformLayoutMatrix(this, pTVar1, param_2, (TVector*)0x0);
         fixBlockUniformLayoutPacking(this, pTVar1, param_2, (TVector*)0x0);
         lVar39 = *(long*)( param_2 + 8 );
         if (lVar39 != *(long*)( param_2 + 0x10 )) {
            do {
               puVar35 = (undefined8*)( lVar39 + uVar22 * 0x20 );
               layoutTypeCheck(this, (TSourceLoc*)( puVar35 + 1 ), (TType*)*puVar35);
               lVar39 = *(long*)( param_2 + 8 );
               uVar22 = ( ulong )((int)uVar22 + 1);
            }
 while ( uVar22 < ( ulong )(*(long*)( param_2 + 0x10 ) - lVar39 >> 5) );
            if (( local_290 != 0 ) && ( *(long*)( param_2 + 0x10 ) != lVar39 )) {
               uVar22 = 0;
               do {
                  puVar35 = (undefined8*)( lVar39 + uVar22 * 0x20 );
                  checkAndResizeMeshViewDim(this, (TSourceLoc*)( puVar35 + 1 ), (TType*)*puVar35, true);
                  lVar39 = *(long*)( param_2 + 8 );
                  uVar22 = ( ulong )((int)uVar22 + 1);
               }
 while ( uVar22 < ( ulong )(*(long*)( param_2 + 0x10 ) - lVar39 >> 5) );
            }

         }

         local_120 = mergeObjectLayoutQualifiers(this, pTVar1, (TQualifier*)&local_1f8, true);
         local_198 = *(undefined8*)( this + 0x510 );
         uStack_190 = *(undefined8*)( this + 0x518 );
         local_188 = *(undefined8*)( this + 0x520 );
         uStack_180 = *(undefined8*)( this + 0x528 );
         local_178 = *(undefined8*)( this + 0x530 );
         uStack_170 = *(undefined8*)( this + 0x538 );
         local_168 = *(undefined8*)( this + 0x540 );
         uStack_160 = *(undefined8*)( this + 0x548 );
         local_1a8 = &PTR__TType_00167f00;
         local_158 = *(undefined8*)( this + 0x550 );
         uStack_150 = *(undefined8*)( this + 0x558 );
         local_1a0 = local_1a0 & 0xf8000000 | 0x110;
         pcVar9 = *(char**)( *(long*)( this + 0x508 ) + 8 );
         local_128 = local_128 & 0x9fc00000;
         local_148 = (TArraySizes*)0x0;
         local_138 = 0;
         local_140 = param_2;
         uVar22 = glslang::GetThreadPoolAllocator();
         puVar35 = (undefined8*)glslang::TPoolAllocator::allocate(uVar22);
         uVar23 = glslang::GetThreadPoolAllocator();
         *puVar35 = uVar23;
         puVar35[1] = puVar35 + 3;
         if (pcVar9 == (char*)0x0) {
            LAB_00147896:/* WARNING: Subroutine does not return */std::__throw_logic_error("basic_string: construction from null is not valid");
         }

         sVar24 = strlen(pcVar9);
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(puVar35, pcVar9, pcVar9 + sVar24);
         pTVar20 = param_4;
         local_130 = puVar35;
         if (param_4 == (TArraySizes*)0x0) {
            pbVar19 = param_3;
            if (param_3 == (basic_string*)0x0) {
               pbVar19 = *(basic_string**)( this + 0x508 );
            }

            ioArrayCheck(this, param_1, (TType*)&local_1a8, pbVar19);
            pTVar20 = local_148;
         }

         local_148 = pTVar20;
         local_268 = param_3;
         if (this[0x53e] == (TParseContext)0x0) {
            local_80 = (undefined1[16])0x0;
            local_a8 = (undefined1[16])0x0;
            local_98 = (undefined1[16])0x0;
            uStack_100 = uStack_100 & 0xfffffffff8000000 | 0x110;
            uStack_c4 = 0xfffff800;
            uStack_c0 = 0;
            local_b0 = 0;
            local_e8 = local_e8 & 0xfffffff0;
            local_88 = local_88 & 0x9fc00000;
            local_108 = &PTR__TType_00167f00;
            local_c8 = local_c8 & 0xffffff00;
            uStack_cc = 0;
            local_f8 = 0;
            uVar22 = ( (ulong)CONCAT43(uStack_d8, uStack_dc._1_3_) & 0xffc000 | 0xffff001f80 ) << 8 | 0xffff000000004fff;
            uStack_dc = (uint)uVar22;
            uStack_d8 = ( undefined4 )(uVar22 >> 0x20);
            uVar22 = CONCAT44(uStack_d0, uStack_d4) & 0xfe07ff00ffffffff | 0x1ffffff7fffffff;
            uStack_d4 = (undefined4)uVar22;
            uStack_d0 = ( uint )(uVar22 >> 0x20);
            uStack_e4 = 0xffffffff;
            uStack_e0 = 0xffffffff;
            uStack_f0 = uStack_f0 & 0x8000000400000000 | ( ulong )((byte)uStack_190 & 0x7f);
            uStack_bc = 0xffffffff;
            local_b8 = 0;
            uVar22 = glslang::GetThreadPoolAllocator();
            pTVar25 = (TVariable*)glslang::TPoolAllocator::allocate(uVar22);
            TVariable::TVariable(pTVar25, *(basic_string**)( this + 0x508 ), (TType*)&local_108, false);
            pTVar38 = *(TSymbolTable**)( this + 0xe8 );
            lVar39 = *(long*)( pTVar38 + 0x18 );
            puVar35 = *(undefined8**)pTVar38;
            lVar37 = *(long*)( pTVar38 + 8 );
            TVar5 = pTVar38[0x21];
            *(long*)( pTVar38 + 0x18 ) = lVar39 + 1;
            *(long*)( pTVar25 + 0x10 ) = lVar39 + 1;
            if (TVar5 != (TSymbolTable)0x0) {
               iVar16 = (int)( lVar37 - (long)puVar35 >> 3 );
               LAB_001471a1:if (( pTVar38[0x20] != (TSymbolTable)0x0 ) && ( iVar16 - 2U < 3 )) {
                  pbVar19 = *(basic_string**)( pTVar25 + 8 );
                  cVar15 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)*puVar35, pbVar19);
                  if (( cVar15 != '\0' ) || ( ( iVar16 != 2 && ( cVar15 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)puVar35[1], pbVar19) ),cVar15 != '\0' ) )) goto LAB_00147378;
               }

               pTVar10 = (TSymbolTableLevel*)puVar35[iVar16 + -1];
               local_68 = glslang::GetThreadPoolAllocator();
               local_50[0] = 0;
               local_60 = local_50;
               local_58 = 0;
               cVar15 = TSymbolTableLevel::insert(pTVar10, (TSymbol*)pTVar25, (bool)pTVar38[0x21], (basic_string*)&local_68);
               if (cVar15 == '\0') {
                  pTVar38 = *(TSymbolTable**)( this + 0xe8 );
                  goto LAB_00147378;
               }

               LAB_00147212:if (param_3 == (basic_string*)0x0) {
                  uVar22 = glslang::GetThreadPoolAllocator();
                  local_268 = (basic_string*)glslang::TPoolAllocator::allocate(uVar22);
                  uVar23 = glslang::GetThreadPoolAllocator();
                  *(undefined8*)local_268 = uVar23;
                  *(basic_string**)( local_268 + 8 ) = local_268 + 0x18;
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(local_268, &_LC1, &_LC1);
               }

               goto LAB_00146d04;
            }

            iVar16 = (int)( lVar37 - (long)puVar35 >> 3 );
            cVar15 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)puVar35[iVar16 + -1], *(basic_string**)( pTVar25 + 8 ));
            if (cVar15 == '\0') goto LAB_001471a1;
            LAB_00147378:plVar26 = (long*)TSymbolTable::find(pTVar38, *(basic_string**)( this + 0x508 ), (bool*)0x0, (bool*)0x0, (int*)0x0);
            plVar27 = (long*)( **(code**)( *plVar26 + 0x60 ) )(plVar26);
            if (*(code**)( *plVar27 + 0x38 ) == TType::getBasicType) {
               uVar17 = ( uint ) * (byte*)( plVar27 + 1 );
            }
 else {
               uVar17 = ( **(code**)( *plVar27 + 0x38 ) )();
            }

            if (uVar17 == 0x10) {
               plVar26 = (long*)( **(code**)( *plVar26 + 0x60 ) )(plVar26);
               if (*(code**)( *plVar26 + 0x58 ) == TType::getQualifier) {
                  plVar26 = plVar26 + 2;
               }
 else {
                  plVar26 = (long*)( **(code**)( *plVar26 + 0x58 ) )();
               }

               if (( ( *(byte*)( plVar26 + 1 ) ^ (byte)uStack_190 ) & 0x7f ) != 0) goto LAB_00147212;
               pcVar6 = *(code**)( *(long*)this + 0x158 );
               uVar23 = GetStorageQualifierString((byte)uStack_190 & 0x7f);
               ( *pcVar6 )(this, param_1, "Cannot reuse block name within the same interface:", *(undefined8*)( *(long*)( this + 0x508 ) + 8 ), uVar23);
            }
 else {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "block name cannot redefine a non-block name", *(undefined8*)( *(long*)( this + 0x508 ) + 8 ), &_LC1);
            }

         }
 else {
            if (( (byte)this[0x518] & 0x7f ) != 6) {
               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "can only be used with buffer", "buffer_reference");
            }

            local_108 = &PTR__TType_00167f00;
            local_80 = (undefined1[16])0x0;
            pcVar9 = *(char**)( *(long*)( this + 0x508 ) + 8 );
            auVar12._8_8_ = 0;
            auVar12._0_8_ = local_a8._8_8_;
            local_a8 = auVar12 << 0x40;
            auVar13._8_8_ = 0;
            auVar13._0_8_ = local_98._8_8_;
            local_98 = auVar13 << 0x40;
            uStack_100 = uStack_100 & 0xfffffffff8000000 | 0x112;
            uVar22 = glslang::GetThreadPoolAllocator();
            puVar35 = (undefined8*)glslang::TPoolAllocator::allocate(uVar22);
            uVar23 = glslang::GetThreadPoolAllocator();
            *puVar35 = uVar23;
            puVar35[1] = puVar35 + 3;
            if (pcVar9 == (char*)0x0) goto LAB_00147896;
            sVar24 = strlen(pcVar9);
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(puVar35, pcVar9, pcVar9 + sVar24);
            local_b0 = 0;
            local_e8 = local_e8 & 0xfffffff0;
            uStack_dc = uStack_dc & 0xffc00000 | 0x1fcfff;
            local_88 = local_88 & 0x9fc00000;
            uVar22 = CONCAT44(uStack_d4, uStack_d8) | 0x7fffffffffffffff;
            uStack_d8 = (undefined4)uVar22;
            uStack_d4 = ( undefined4 )(uVar22 >> 0x20);
            local_98._8_8_ = puVar35;
            uStack_e4 = 0xffffffff;
            uStack_e0 = 0xffffffff;
            uStack_d0 = uStack_d0 & 0xfe000000 | 0x1ffffff;
            local_c8 = local_c8 & 0xffffff00;
            uStack_cc = 0;
            uStack_c0 = 0;
            uStack_bc = 0xffffffff;
            uStack_c4 = 0xfffff800;
            uStack_f0 = uStack_f0 & 0x8000000400000000 | ( ulong )((byte)uStack_190 & 0x7f);
            local_b8 = 0;
            local_f8 = 0;
            uVar23 = TType::clone((TType*)&local_1a8);
            local_a8._8_8_ = uVar23;
            uVar22 = glslang::GetThreadPoolAllocator();
            pTVar25 = (TVariable*)glslang::TPoolAllocator::allocate(uVar22);
            TVariable::TVariable(pTVar25, *(basic_string**)( this + 0x508 ), (TType*)&local_108, true);
            pTVar38 = *(TSymbolTable**)( this + 0xe8 );
            lVar39 = *(long*)( pTVar38 + 0x18 );
            puVar35 = *(undefined8**)pTVar38;
            lVar37 = *(long*)( pTVar38 + 8 );
            TVar5 = pTVar38[0x21];
            *(long*)( pTVar38 + 0x18 ) = lVar39 + 1;
            *(long*)( pTVar25 + 0x10 ) = lVar39 + 1;
            if (TVar5 == (TSymbolTable)0x0) {
               iVar16 = (int)( lVar37 - (long)puVar35 >> 3 );
               cVar15 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)puVar35[iVar16 + -1], *(basic_string**)( pTVar25 + 8 ));
               if (cVar15 == '\0') goto LAB_00146c89;
               LAB_00146f85:plVar26 = (long*)TSymbolTable::find(pTVar38, *(basic_string**)( this + 0x508 ), (bool*)0x0, (bool*)0x0, (int*)0x0);
               plVar27 = (long*)( **(code**)( *plVar26 + 0x60 ) )(plVar26);
               if (*(code**)( *plVar27 + 0x38 ) == TType::getBasicType) {
                  uVar17 = ( uint ) * (byte*)( plVar27 + 1 );
               }
 else {
                  uVar17 = ( **(code**)( *plVar27 + 0x38 ) )();
               }

               if (uVar17 == 0x12) {
                  plVar27 = (long*)( **(code**)( *plVar26 + 0x60 ) )(plVar26);
                  if (*(code**)( *plVar27 + 0xa8 ) == TType::getReferentType) {
                     lVar39 = plVar27[0xd];
                  }
 else {
                     lVar39 = ( **(code**)( *plVar27 + 0xa8 ) )(plVar27);
                  }

                  if (*(long*)( lVar39 + 0x68 ) != 0) {
                     plVar27 = (long*)( **(code**)( *plVar26 + 0x60 ) )(plVar26);
                     if (*(code**)( *plVar27 + 0xa8 ) == TType::getReferentType) {
                        lVar39 = plVar27[0xd];
                     }
 else {
                        lVar39 = ( **(code**)( *plVar27 + 0xa8 ) )();
                     }

                     if (*(long*)( *(long*)( lVar39 + 0x68 ) + 0x10 ) == *(long*)( *(long*)( lVar39 + 0x68 ) + 8 )) {
                        plVar27 = (long*)( **(code**)( *plVar26 + 0x60 ) )(plVar26);
                        if (*(code**)( *plVar27 + 0x58 ) == TType::getQualifier) {
                           plVar27 = plVar27 + 2;
                        }
 else {
                           plVar27 = (long*)( **(code**)( *plVar27 + 0x58 ) )();
                        }

                        if (( ( *(byte*)( plVar27 + 1 ) ^ (byte)uStack_190 ) & 0x7f ) == 0) {
                           plVar26 = (long*)( **(code**)( *plVar26 + 0x60 ) )(plVar26);
                           if (*(code**)( *plVar26 + 0xa8 ) == TType::getReferentType) {
                              pTVar31 = (TType*)plVar26[0xd];
                           }
 else {
                              pTVar31 = (TType*)( **(code**)( *plVar26 + 0xa8 ) )();
                           }

                           local_238[0] = glslang::GetThreadPoolAllocator();
                           local_218 = local_228;
                           local_228[0] = 0;
                           local_220 = 0;
                           local_208 = 0;
                           local_210 = local_218;
                           TType::deepCopy(pTVar31, (TType*)&local_1a8, (TMap*)local_238);
                           for (lVar39 = local_220; lVar39 != 0; lVar39 = *(long*)( lVar39 + 0x10 )) {
                              std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>*,std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector < glslang::TTypeLoc>*>>,std::less<glslang::TVector<glslang::TTypeLoc>*>,glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>> > ::_M_erase(*(_Rb_tree_node**)( lVar39 + 0x18 ));
                           }

                           goto LAB_00146cf8;
                        }

                     }

                  }

               }

               ( **(code**)( *(long*)this + 0x158 ) )(this, param_1, "block name cannot be redefined", *(undefined8*)( *(long*)( this + 0x508 ) + 8 ), &_LC1);
            }
 else {
               iVar16 = (int)( lVar37 - (long)puVar35 >> 3 );
               LAB_00146c89:if (( pTVar38[0x20] != (TSymbolTable)0x0 ) && ( iVar16 - 2U < 3 )) {
                  pbVar19 = *(basic_string**)( pTVar25 + 8 );
                  cVar15 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)*puVar35, pbVar19);
                  if (( cVar15 != '\0' ) || ( ( iVar16 != 2 && ( cVar15 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)puVar35[1], pbVar19) ),cVar15 != '\0' ) )) goto LAB_00146f85;
               }

               pTVar10 = (TSymbolTableLevel*)puVar35[iVar16 + -1];
               local_68 = glslang::GetThreadPoolAllocator();
               local_50[0] = 0;
               local_60 = local_50;
               local_58 = 0;
               cVar15 = TSymbolTableLevel::insert(pTVar10, (TSymbol*)pTVar25, (bool)pTVar38[0x21], (basic_string*)&local_68);
               if (cVar15 == '\0') {
                  pTVar38 = *(TSymbolTable**)( this + 0xe8 );
                  goto LAB_00146f85;
               }

            }

            LAB_00146cf8:if (param_3 == (basic_string*)0x0) goto LAB_00146e2a;
            LAB_00146d04:uVar22 = glslang::GetThreadPoolAllocator();
            pTVar25 = (TVariable*)glslang::TPoolAllocator::allocate(uVar22);
            TVariable::TVariable(pTVar25, local_268, (TType*)&local_1a8, false);
            plVar26 = *(long**)( this + 0xe8 );
            lVar39 = plVar26[3];
            puVar35 = (undefined8*)*plVar26;
            lVar37 = plVar26[1];
            cVar15 = *(char*)( (long)plVar26 + 0x21 );
            plVar26[3] = lVar39 + 1;
            *(long*)( pTVar25 + 0x10 ) = lVar39 + 1;
            if (cVar15 == '\0') {
               iVar16 = (int)( lVar37 - (long)puVar35 >> 3 );
               cVar15 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)puVar35[iVar16 + -1], *(basic_string**)( pTVar25 + 8 ));
               if (cVar15 == '\0') goto LAB_00146d5f;
            }
 else {
               iVar16 = (int)( lVar37 - (long)puVar35 >> 3 );
               LAB_00146d5f:if (( (char)plVar26[4] != '\0' ) && ( iVar16 - 2U < 3 )) {
                  pbVar19 = *(basic_string**)( pTVar25 + 8 );
                  cVar15 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)*puVar35, pbVar19);
                  if (( cVar15 != '\0' ) || ( ( iVar16 != 2 && ( cVar15 = TSymbolTableLevel::hasFunctionName((TSymbolTableLevel*)puVar35[1], pbVar19) ),cVar15 != '\0' ) )) goto LAB_00146ea5;
               }

               pTVar10 = (TSymbolTableLevel*)puVar35[iVar16 + -1];
               local_68 = glslang::GetThreadPoolAllocator();
               local_50[0] = 0;
               local_60 = local_50;
               local_58 = 0;
               cVar15 = TSymbolTableLevel::insert(pTVar10, (TSymbol*)pTVar25, *(bool*)( (long)plVar26 + 0x21 ), (basic_string*)&local_68);
               if (cVar15 != '\0') {
                  layoutObjectCheck(this, param_1, (TSymbol*)pTVar25);
                  cVar15 = isIoResizeArray(this, (TType*)&local_1a8);
                  if (cVar15 == '\0') {
                     if (*(code**)( *(long*)pTVar25 + 0x68 ) == TVariable::getWritableType) {
                        pTVar28 = pTVar25 + 0x28;
                     }
 else {
                        pTVar28 = (TVariable*)( **(code**)( *(long*)pTVar25 + 0x68 ) )(pTVar25);
                     }

                     fixIoArraySize(this, param_1, (TType*)pTVar28);
                  }
 else {
                     puVar35 = *(undefined8**)( this + 0x7608 );
                     if (puVar35 == *(undefined8**)( this + 0x7610 )) {
                        puVar11 = *(undefined8**)( this + 0x7600 );
                        puVar33 = (undefined8*)( (long)puVar35 - (long)puVar11 );
                        uVar22 = (long)puVar33 >> 3;
                        if (uVar22 == 0xfffffffffffffff) {
                           /* WARNING: Subroutine does not return */
                           std::__throw_length_error("vector::_M_realloc_insert");
                        }

                        if (puVar35 == puVar11) {
                           uVar29 = uVar22 + 1;
                           if (0xfffffffffffffffe < uVar22) goto LAB_00147876;
                           LAB_00147827:if (0xfffffffffffffff < uVar29) {
                              uVar29 = 0xfffffffffffffff;
                           }

                           lVar39 = uVar29 * 8;
                           LAB_00147840:lVar30 = glslang::TPoolAllocator::allocate(*(ulong*)( this + 0x75f8 ));
                           lVar39 = lVar39 + lVar30;
                           lVar37 = lVar30 + 8;
                           *(TVariable**)( lVar30 + (long)puVar33 ) = pTVar25;
                           if (puVar35 != puVar11) goto LAB_001477b8;
                        }
 else {
                           uVar29 = uVar22 * 2;
                           if (uVar29 < uVar22) {
                              LAB_00147876:lVar39 = 0x7ffffffffffffff8;
                              goto LAB_00147840;
                           }

                           if (uVar29 != 0) goto LAB_00147827;
                           *puVar33 = pTVar25;
                           lVar39 = 0;
                           lVar30 = 0;
                           LAB_001477b8:lVar37 = 0;
                           do {
                              *(undefined8*)( lVar30 + lVar37 ) = *(undefined8*)( (long)puVar11 + lVar37 );
                              lVar37 = lVar37 + 8;
                           }
 while ( lVar37 != (long)puVar35 - (long)puVar11 );
                           lVar37 = lVar30 + 8 + lVar37;
                        }

                        *(long*)( this + 0x7600 ) = lVar30;
                        *(long*)( this + 0x7608 ) = lVar37;
                        *(long*)( this + 0x7610 ) = lVar39;
                     }
 else {
                        *puVar35 = pTVar25;
                        *(undefined8**)( this + 0x7608 ) = puVar35 + 1;
                     }

                     checkIoArraysConsistency(this, param_1, true);
                  }

                  ( **(code**)( *(long*)this + 600 ) )(this, pTVar25);
                  goto LAB_00146e2a;
               }

            }

            LAB_00146ea5:pcVar6 = *(code**)( *(long*)this + 0x158 );
            if (*(long*)( local_268 + 0x10 ) == 0) {
               ( *pcVar6 )(this, param_1, "nameless block contains a member that already has a name at global scope", *(undefined8*)( *(long*)( this + 0x508 ) + 8 ), &_LC1);
            }
 else {
               if (*(code**)( *(long*)pTVar25 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                  lVar39 = *(long*)( pTVar25 + 8 );
               }
 else {
                  lVar39 = ( **(code**)( *(long*)pTVar25 + 0x18 ) )(pTVar25);
               }

               ( *pcVar6 )(this, param_1, "block instance name redefinition", *(undefined8*)( lVar39 + 8 ), &_LC1);
            }

         }

         LAB_00146e2a:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return;
         }

         LAB_001478ae:/* WARNING: Subroutine does not return */__stack_chk_fail();
      }

      /* glslang::TParseContext::vkRelaxedRemapFunctionCall(glslang::TSourceLoc const&,
   glslang::TFunction*, TIntermNode*) */
      long glslang::TParseContext::vkRelaxedRemapFunctionCall(TParseContext *this, TSourceLoc *param_1, TFunction *param_2, TIntermNode *param_3) {
         char *pcVar1;
         undefined1 auVar2[16];
         undefined1 auVar3[16];
         ulong uVar4;
         int iVar5;
         long lVar6;
         ulong uVar7;
         ulong uVar8;
         undefined8 *puVar9;
         undefined8 uVar10;
         size_t sVar11;
         TType *pTVar12;
         code *pcVar13;
         TType *pTVar14;
         TIntermNode *pTVar15;
         undefined8 uVar16;
         long *plVar17;
         TFunction *pTVar18;
         ulong uVar19;
         bool bVar20;
         long lVar21;
         long in_FS_OFFSET;
         undefined1 local_4d8[16];
         long local_4c8;
         undefined1 local_4b8[16];
         long local_4a8;
         undefined **local_498;
         uint local_490;
         ulong local_488;
         ulong local_480;
         undefined8 local_478;
         undefined8 local_470;
         undefined4 local_468;
         undefined4 uStack_464;
         undefined4 local_460;
         undefined4 uStack_45c;
         undefined1 local_458;
         undefined8 local_454;
         undefined4 local_44c;
         undefined8 local_448;
         undefined2 local_440;
         undefined1 local_438[16];
         undefined1 local_428[16];
         uint local_418;
         undefined1 local_410[16];
         undefined **local_3f8;
         uint local_3f0;
         ulong local_3e8;
         ulong local_3e0;
         undefined8 local_3d8;
         undefined8 uStack_3d0;
         undefined4 uStack_3c8;
         undefined4 uStack_3c4;
         undefined4 local_3c0;
         undefined4 uStack_3bc;
         undefined1 local_3b8;
         undefined8 local_3b4;
         undefined4 local_3ac;
         undefined8 local_3a8;
         undefined2 local_3a0;
         undefined1 local_398[16];
         undefined1 local_388[16];
         uint local_378;
         undefined1 local_370[16];
         undefined8 local_358;
         undefined1 *local_350;
         undefined1 local_340[24];
         undefined8 local_328;
         undefined1 *local_320;
         undefined1 local_310[24];
         TFunction local_2f8[40];
         vector<glslang::TParameter,glslang::pool_allocator<glslang::TParameter>> local_2d0[16];
         undefined8 *local_2c0;
         undefined8 *local_2b8;
         basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> local_210[8];
         ulong *local_208;
         ulong local_200;
         ulong local_1f8[3];
         int local_1e0;
         TFunction local_198[40];
         vector<glslang::TParameter,glslang::pool_allocator<glslang::TParameter>> local_170[16];
         undefined8 *local_160;
         undefined8 *local_158;
         basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> local_b0[8];
         ulong *local_a8;
         ulong local_a0;
         ulong local_98[3];
         int local_80;
         long local_40;
         local_40 = *(long*)( in_FS_OFFSET + 0x28 );
         if (*(code**)( *(long*)param_2 + 0xd8 ) == TFunction::getBuiltInOp) {
            iVar5 = *(int*)( param_2 + 0x110 );
         }
 else {
            iVar5 = ( **(code**)( *(long*)param_2 + 0xd8 ) )(param_2);
         }

         if (iVar5 == 0) {
            bVar20 = SUB81(param_1, 0);
            if (*(code**)( *(long*)param_2 + 0x18 ) != TSymbol::getName_abi_cxx11_) {
               lVar6 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
               if (*(long*)( lVar6 + 0x10 ) == 0x16) goto LAB_00147988;
               LAB_001479b0:if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                  lVar6 = *(long*)( param_2 + 8 );
                  lVar21 = *(long*)( lVar6 + 0x10 );
                  if (lVar21 != 0x16) goto LAB_0014793a;
                  LAB_001481f7:plVar17 = *(long**)( lVar6 + 8 );
                  if (( *plVar17 == 0x6f4363696d6f7461 && plVar17[1] == 0x6365447265746e75 ) && ( *(long*)( (long)plVar17 + 0xe ) == 0x746e656d65726365 )) {
                     local_328 = glslang::GetThreadPoolAllocator();
                     local_320 = local_310;
                     std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_328);
                     uVar16 = _LC291;
                     local_3f8 = &PTR__TType_00167f00;
                     local_3d8._0_4_ = (uint)local_3d8 & 0xfffffff0;
                     local_370 = (undefined1[16])0x0;
                     local_3f0 = local_3f0 & 0xf8000000 | 0x109;
                     local_398 = (undefined1[16])0x0;
                     local_3b4 = 0xfffff800;
                     local_388 = (undefined1[16])0x0;
                     local_3d8._4_4_ = (undefined4)_LC291;
                     uStack_3d0._0_4_ = ( undefined4 )((ulong)_LC291 >> 0x20);
                     local_3a0 = 0;
                     local_378 = local_378 & 0x9fc00000;
                     local_3e8 = 0;
                     local_3b8 = 0;
                     uStack_3bc = 0;
                     local_3ac = 0xffffffff;
                     uVar7 = ( (ulong)uStack_3d0._5_3_ & 0xffc000 | 0xffff001f80 ) << 8 | 0xffff000000004fff;
                     uStack_3d0._4_4_ = (undefined4)uVar7;
                     uStack_3c8 = ( undefined4 )(uVar7 >> 0x20);
                     uVar7 = CONCAT44(local_3c0, uStack_3c4) & 0xfe07ff00ffffffff | 0x1ffffff7fffffff;
                     uStack_3c4 = (undefined4)uVar7;
                     local_3c0 = ( undefined4 )(uVar7 >> 0x20);
                     local_3e0 = local_3e0 & 0x8000000400000000;
                     local_3a8 = 0;
                     if (*(code**)( *(long*)param_2 + 0x60 ) == TFunction::getType) {
                        pTVar18 = param_2 + 0x48;
                     }
 else {
                        pTVar18 = (TFunction*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
                     }

                     uVar7 = 0;
                     TFunction::TFunction(local_198, &local_328, pTVar18);
                     pcVar13 = *(code**)( *(long*)param_2 + 0x120 );
                     if (pcVar13 != TFunction::getParamCount) goto LAB_0014870a;
                     while ((int)uVar7 < (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555) {
                        while (true) {
                           local_4a8 = 0;
                           local_4b8 = (undefined1[16])0x0;
                           if (*(code**)( *(long*)param_2 + 0x138 ) == TFunction::operator []) {
                              plVar17 = (long*)( *(long*)( param_2 + 0x30 ) + uVar7 * 0x18 );
                           }
 else {
                              plVar17 = (long*)( **(code**)( *(long*)param_2 + 0x138 ) )(param_2, uVar7 & 0xffffffff);
                           }

                           if (*plVar17 != 0) {
                              pcVar1 = *(char**)( *plVar17 + 8 );
                              uVar8 = glslang::GetThreadPoolAllocator();
                              puVar9 = (undefined8*)glslang::TPoolAllocator::allocate(uVar8);
                              uVar10 = glslang::GetThreadPoolAllocator();
                              *puVar9 = uVar10;
                              puVar9[1] = puVar9 + 3;
                              if (pcVar1 == (char*)0x0) goto LAB_00148b74;
                              sVar11 = strlen(pcVar1);
                              std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(puVar9, pcVar1, pcVar1 + sVar11);
                              local_4b8._0_8_ = puVar9;
                           }

                           pTVar14 = (TType*)plVar17[1];
                           uVar8 = glslang::GetThreadPoolAllocator();
                           pTVar12 = (TType*)glslang::TPoolAllocator::allocate(uVar8);
                           pTVar12[0x20] = ( TType )((byte)pTVar12[0x20] & 0xf0);
                           *(undefined***)pTVar12 = &PTR__TType_00167f00;
                           *(undefined2*)( pTVar12 + 0x58 ) = 0;
                           *(undefined8*)( pTVar12 + 0x10 ) = 0;
                           pTVar12[0x40] = (TType)0x0;
                           *(uint*)( pTVar12 + 8 ) = CONCAT22((short)( ( uint ) * (undefined4*)( pTVar12 + 8 ) >> 0x10 ), 0x100) & 0xf800ffff;
                           *(undefined8*)( pTVar12 + 0x44 ) = 0xfffff800;
                           *(uint*)( pTVar12 + 0x80 ) = *(uint*)( pTVar12 + 0x80 ) & 0x9fc00000;
                           *(undefined8*)( pTVar12 + 0x24 ) = uVar16;
                           *(undefined4*)( pTVar12 + 0x4c ) = 0xffffffff;
                           *(ulong*)( pTVar12 + 0x2d ) = *(ulong*)( pTVar12 + 0x2d ) & 0xffffff0000ffc07f | 0xffff001f80;
                           *(undefined8*)( pTVar12 + 0x50 ) = 0;
                           *(undefined1(*) [16])( pTVar12 + 0x88 ) = (undefined1[16])0x0;
                           *(undefined1(*) [16])( pTVar12 + 0x60 ) = (undefined1[16])0x0;
                           *(ulong*)( pTVar12 + 0x38 ) = ( ulong )(( uint ) * (undefined8*)( pTVar12 + 0x38 ) & 0xfe07ff00) | 0x1f800ff;
                           *(undefined1(*) [16])( pTVar12 + 0x70 ) = (undefined1[16])0x0;
                           *(ulong*)( pTVar12 + 0x2c ) = *(ulong*)( pTVar12 + 0x2c ) & 0xffffffff8000 | 0xffff000000004fff;
                           *(ulong*)( pTVar12 + 0x34 ) = *(ulong*)( pTVar12 + 0x34 ) | 0x7ff007fffffff;
                           *(ulong*)( pTVar12 + 0x18 ) = *(ulong*)( pTVar12 + 0x18 ) & 0x8000000400000000;
                           local_498 = (undefined**)glslang::GetThreadPoolAllocator();
                           local_478 = &local_488;
                           local_488 = local_488 & 0xffffffff00000000;
                           local_480 = 0;
                           local_468 = 0;
                           uStack_464 = 0;
                           local_470 = local_478;
                           TType::deepCopy(pTVar12, pTVar14, (TMap*)&local_498);
                           for (uVar8 = local_480; uVar8 != 0; uVar8 = *(ulong*)( uVar8 + 0x10 )) {
                              std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>*,std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector < glslang::TTypeLoc>*>>,std::less<glslang::TVector<glslang::TTypeLoc>*>,glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>> > ::_M_erase(*(_Rb_tree_node**)( uVar8 + 0x18 ));
                           }

                           lVar6 = plVar17[2];
                           local_4b8._8_8_ = pTVar12;
                           local_4a8 = lVar6;
                           if (local_160 == local_158) {
                              std::vector<glslang::TParameter,glslang::pool_allocator<glslang::TParameter>>::_M_realloc_insert<glslang::TParameter_const&>(local_170, local_160, local_4b8);
                           }
 else {
                              *local_160 = local_4b8._0_8_;
                              local_160[1] = pTVar12;
                              local_160[2] = lVar6;
                              local_160 = local_160 + 3;
                           }

                           glslang::TType::buildMangledName((basic_string*)pTVar12);
                           uVar4 = local_a0;
                           uVar8 = local_a0 + 1;
                           uVar19 = local_98[0];
                           if (local_a8 == local_98) {
                              uVar19 = 0xf;
                           }

                           if (uVar19 < uVar8) {
                              std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(local_b0, local_a0, 0, (char*)0x0, 1);
                           }

                           *(undefined1*)( (long)local_a8 + uVar4 ) = 0x3b;
                           *(undefined1*)( (long)local_a8 + uVar4 + 1 ) = 0;
                           if (lVar6 != 0) {
                              local_80 = local_80 + 1;
                           }

                           uVar7 = uVar7 + 1;
                           pcVar13 = *(code**)( *(long*)param_2 + 0x120 );
                           local_a0 = uVar8;
                           if (pcVar13 == TFunction::getParamCount) break;
                           LAB_0014870a:iVar5 = ( *pcVar13 )(param_2);
                           if (iVar5 <= (int)uVar7) goto LAB_00148717;
                        }
;
                     }
;
                     LAB_00148717:auVar3._8_8_ = 0;
                     auVar3._0_8_ = local_4b8._8_8_;
                     local_4b8 = auVar3 << 0x40;
                     local_4a8 = 0;
                     uVar7 = glslang::GetThreadPoolAllocator();
                     pTVar14 = (TType*)glslang::TPoolAllocator::allocate(uVar7);
                     pTVar14[0x20] = ( TType )((byte)pTVar14[0x20] & 0xf0);
                     *(undefined***)pTVar14 = &PTR__TType_00167f00;
                     *(uint*)( pTVar14 + 0x80 ) = *(uint*)( pTVar14 + 0x80 ) & 0x9fc00000;
                     *(undefined8*)( pTVar14 + 0x10 ) = 0;
                     pTVar14[0x40] = (TType)0x0;
                     *(uint*)( pTVar14 + 8 ) = CONCAT22((short)( ( uint ) * (undefined4*)( pTVar14 + 8 ) >> 0x10 ), 0x100) & 0xf800ffff;
                     *(undefined8*)( pTVar14 + 0x44 ) = 0xfffff800;
                     *(undefined2*)( pTVar14 + 0x58 ) = 0;
                     *(undefined4*)( pTVar14 + 0x4c ) = 0xffffffff;
                     *(undefined8*)( pTVar14 + 0x24 ) = uVar16;
                     *(undefined8*)( pTVar14 + 0x50 ) = 0;
                     *(ulong*)( pTVar14 + 0x2d ) = *(ulong*)( pTVar14 + 0x2d ) & 0xffffff0000ffc07f | 0xffff001f80;
                     *(undefined1(*) [16])( pTVar14 + 0x88 ) = (undefined1[16])0x0;
                     *(undefined1(*) [16])( pTVar14 + 0x60 ) = (undefined1[16])0x0;
                     *(undefined1(*) [16])( pTVar14 + 0x70 ) = (undefined1[16])0x0;
                     *(ulong*)( pTVar14 + 0x38 ) = ( ulong )(( uint ) * (undefined8*)( pTVar14 + 0x38 ) & 0xfe07ff00) | 0x1f800ff;
                     *(ulong*)( pTVar14 + 0x2c ) = *(ulong*)( pTVar14 + 0x2c ) & 0xffffffff8000 | 0xffff000000004fff;
                     *(ulong*)( pTVar14 + 0x34 ) = *(ulong*)( pTVar14 + 0x34 ) | 0x7ff007fffffff;
                     *(ulong*)( pTVar14 + 0x18 ) = *(ulong*)( pTVar14 + 0x18 ) & 0x8000000400000000;
                     local_498 = (undefined**)glslang::GetThreadPoolAllocator();
                     local_478 = &local_488;
                     local_488 = local_488 & 0xffffffff00000000;
                     local_480 = 0;
                     local_468 = 0;
                     uStack_464 = 0;
                     local_470 = local_478;
                     TType::deepCopy(pTVar14, (TType*)&local_3f8, (TMap*)&local_498);
                     for (uVar7 = local_480; uVar7 != 0; uVar7 = *(ulong*)( uVar7 + 0x10 )) {
                        std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>*,std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector < glslang::TTypeLoc>*>>,std::less<glslang::TVector<glslang::TTypeLoc>*>,glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>> > ::_M_erase(*(_Rb_tree_node**)( uVar7 + 0x18 ));
                     }

                     local_4b8._8_8_ = pTVar14;
                     if (local_160 == local_158) {
                        std::vector<glslang::TParameter,glslang::pool_allocator<glslang::TParameter>>::_M_realloc_insert<glslang::TParameter_const&>(local_170, local_160, local_4b8);
                     }
 else {
                        *local_160 = local_4b8._0_8_;
                        local_160[1] = pTVar14;
                        local_160[2] = local_4a8;
                        local_160 = local_160 + 3;
                     }

                     glslang::TType::buildMangledName((basic_string*)pTVar14);
                     uVar8 = local_a0;
                     uVar7 = local_a0 + 1;
                     if (local_a8 == local_98) {
                        local_98[0] = 0xf;
                     }

                     if (local_98[0] < uVar7) {
                        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(local_b0, local_a0, 0, (char*)0x0, 1);
                     }

                     *(undefined1*)( (long)local_a8 + uVar8 ) = 0x3b;
                     *(undefined1*)( (long)local_a8 + uVar8 + 1 ) = 0;
                     pTVar15 = *(TIntermNode**)( this + 0x38 );
                     local_a0 = uVar7;
                     glslang::TIntermediate::addConstantUnion((int)pTVar15, (TSourceLoc*)0xffffffff, bVar20);
                     pTVar15 = (TIntermNode*)glslang::TIntermediate::growAggregate(pTVar15, param_3);
                     lVar6 = handleFunctionCall(this, param_1, local_198, pTVar15);
                     if (lVar6 != 0) {
                        uVar16 = glslang::TIntermediate::addConstantUnion((int)*(undefined8*)( this + 0x38 ), (TSourceLoc*)0x1, bVar20);
                        lVar6 = handleBinaryMath(this, param_1, &_LC1382, 0x9d, lVar6, uVar16);
                     }

                     glslang::TFunction::~TFunction(local_198);
                     goto LAB_00147946;
                  }

               }
 else {
                  lVar6 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
                  if (*(long*)( lVar6 + 0x10 ) == 0x16) goto LAB_001481f7;
               }

               if (*(code**)( *(long*)param_2 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                  lVar6 = *(long*)( param_2 + 8 );
                  lVar21 = *(long*)( lVar6 + 0x10 );
               }
 else {
                  lVar6 = ( **(code**)( *(long*)param_2 + 0x18 ) )(param_2);
                  lVar21 = *(long*)( lVar6 + 0x10 );
               }

               LAB_0014793a:if (( ( lVar21 == 0xd ) && ( **(long**)( lVar6 + 8 ) == 0x6f4363696d6f7461 ) ) && ( *(long*)( (long)*(long**)( lVar6 + 8 ) + 5 ) == 0x7265746e756f4363 )) {
                  lVar6 = ( **(code**)( *(long*)param_3 + 0x18 ) )(param_3);
                  if (lVar6 != 0) {
                     if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
                        /* WARNING: Could not recover jumptable at 0x00147a71. Too many branches */
                        /* WARNING: Treating indirect jump as call */
                        lVar6 = ( **(code**)( *(long*)param_3 + 0x18 ) )(param_3);
                        return lVar6;
                     }

                     goto LAB_00148b80;
                  }

               }

               goto LAB_00147944;
            }

            lVar6 = *(long*)( param_2 + 8 );
            lVar21 = *(long*)( lVar6 + 0x10 );
            if (lVar21 != 0x16) goto LAB_0014793a;
            LAB_00147988:plVar17 = *(long**)( lVar6 + 8 );
            if (( *plVar17 != 0x6f4363696d6f7461 || plVar17[1] != 0x636e497265746e75 ) || ( *(long*)( (long)plVar17 + 0xe ) != 0x746e656d6572636e )) goto LAB_001479b0;
            local_358 = glslang::GetThreadPoolAllocator();
            local_350 = local_340;
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_358, "atomicAdd");
            uVar16 = _LC291;
            local_498 = &PTR__TType_00167f00;
            local_478._0_4_ = (uint)local_478 & 0xfffffff0;
            local_410 = (undefined1[16])0x0;
            local_490 = local_490 & 0xf8000000 | 0x109;
            local_438 = (undefined1[16])0x0;
            local_454 = 0xfffff800;
            local_428 = (undefined1[16])0x0;
            local_478._4_4_ = (undefined4)_LC291;
            local_470._0_4_ = ( undefined4 )((ulong)_LC291 >> 0x20);
            local_418 = local_418 & 0x9fc00000;
            local_488 = 0;
            local_440 = 0;
            local_458 = 0;
            uStack_45c = 0;
            local_44c = 0xffffffff;
            uVar7 = ( (ulong)local_470._5_3_ & 0xffc000 | 0xffff001f80 ) << 8 | 0xffff000000004fff;
            local_470._4_4_ = (undefined4)uVar7;
            local_468 = ( undefined4 )(uVar7 >> 0x20);
            uVar7 = CONCAT44(local_460, uStack_464) & 0xfe07ff00ffffffff | 0x1ffffff7fffffff;
            uStack_464 = (undefined4)uVar7;
            local_460 = ( undefined4 )(uVar7 >> 0x20);
            local_480 = local_480 & 0x8000000400000000;
            local_448 = 0;
            if (*(code**)( *(long*)param_2 + 0x60 ) == TFunction::getType) {
               pTVar18 = param_2 + 0x48;
            }
 else {
               pTVar18 = (TFunction*)( **(code**)( *(long*)param_2 + 0x60 ) )(param_2);
            }

            uVar7 = 0;
            TFunction::TFunction(local_2f8, &local_358, pTVar18);
            pcVar13 = *(code**)( *(long*)param_2 + 0x120 );
            if (pcVar13 != TFunction::getParamCount) goto LAB_00147f63;
            LAB_00147c60:if ((int)uVar7 < (int)( *(long*)( param_2 + 0x38 ) - *(long*)( param_2 + 0x30 ) >> 3 ) * -0x55555555) {
               do {
                  local_4c8 = 0;
                  local_4d8 = (undefined1[16])0x0;
                  if (*(code**)( *(long*)param_2 + 0x138 ) == TFunction::operator []) {
                     plVar17 = (long*)( *(long*)( param_2 + 0x30 ) + uVar7 * 0x18 );
                  }
 else {
                     plVar17 = (long*)( **(code**)( *(long*)param_2 + 0x138 ) )(param_2, uVar7 & 0xffffffff);
                  }

                  if (*plVar17 != 0) {
                     pcVar1 = *(char**)( *plVar17 + 8 );
                     uVar8 = glslang::GetThreadPoolAllocator();
                     puVar9 = (undefined8*)glslang::TPoolAllocator::allocate(uVar8);
                     uVar10 = glslang::GetThreadPoolAllocator();
                     *puVar9 = uVar10;
                     puVar9[1] = puVar9 + 3;
                     if (pcVar1 == (char*)0x0) {
                        LAB_00148b74:/* WARNING: Subroutine does not return */std::__throw_logic_error("basic_string: construction from null is not valid");
                     }

                     sVar11 = strlen(pcVar1);
                     std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(puVar9, pcVar1, pcVar1 + sVar11);
                     local_4d8._0_8_ = puVar9;
                  }

                  pTVar14 = (TType*)plVar17[1];
                  uVar8 = glslang::GetThreadPoolAllocator();
                  pTVar12 = (TType*)glslang::TPoolAllocator::allocate(uVar8);
                  pTVar12[0x20] = ( TType )((byte)pTVar12[0x20] & 0xf0);
                  *(undefined***)pTVar12 = &PTR__TType_00167f00;
                  *(uint*)( pTVar12 + 0x80 ) = *(uint*)( pTVar12 + 0x80 ) & 0x9fc00000;
                  *(undefined2*)( pTVar12 + 0x58 ) = 0;
                  *(undefined8*)( pTVar12 + 0x10 ) = 0;
                  *(uint*)( pTVar12 + 8 ) = CONCAT22((short)( ( uint ) * (undefined4*)( pTVar12 + 8 ) >> 0x10 ), 0x100) & 0xf800ffff;
                  *(undefined8*)( pTVar12 + 0x44 ) = 0xfffff800;
                  pTVar12[0x40] = (TType)0x0;
                  *(undefined8*)( pTVar12 + 0x24 ) = uVar16;
                  *(undefined4*)( pTVar12 + 0x4c ) = 0xffffffff;
                  *(ulong*)( pTVar12 + 0x2d ) = *(ulong*)( pTVar12 + 0x2d ) & 0xffffff0000ffc07f | 0xffff001f80;
                  *(undefined8*)( pTVar12 + 0x50 ) = 0;
                  *(undefined1(*) [16])( pTVar12 + 0x88 ) = (undefined1[16])0x0;
                  *(undefined1(*) [16])( pTVar12 + 0x60 ) = (undefined1[16])0x0;
                  *(ulong*)( pTVar12 + 0x38 ) = ( ulong )(( uint ) * (undefined8*)( pTVar12 + 0x38 ) & 0xfe07ff00) | 0x1f800ff;
                  *(undefined1(*) [16])( pTVar12 + 0x70 ) = (undefined1[16])0x0;
                  *(ulong*)( pTVar12 + 0x2c ) = *(ulong*)( pTVar12 + 0x2c ) & 0xffffffff8000 | 0xffff000000004fff;
                  *(ulong*)( pTVar12 + 0x34 ) = *(ulong*)( pTVar12 + 0x34 ) | 0x7ff007fffffff;
                  *(ulong*)( pTVar12 + 0x18 ) = *(ulong*)( pTVar12 + 0x18 ) & 0x8000000400000000;
                  local_3f8 = (undefined**)glslang::GetThreadPoolAllocator();
                  local_3d8 = &local_3e8;
                  local_3e8 = local_3e8 & 0xffffffff00000000;
                  local_3e0 = 0;
                  uStack_3c8 = 0;
                  uStack_3c4 = 0;
                  uStack_3d0 = local_3d8;
                  TType::deepCopy(pTVar12, pTVar14, (TMap*)&local_3f8);
                  for (uVar8 = local_3e0; uVar8 != 0; uVar8 = *(ulong*)( uVar8 + 0x10 )) {
                     std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>*,std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector < glslang::TTypeLoc>*>>,std::less<glslang::TVector<glslang::TTypeLoc>*>,glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>> > ::_M_erase(*(_Rb_tree_node**)( uVar8 + 0x18 ));
                  }

                  lVar6 = plVar17[2];
                  local_4d8._8_8_ = pTVar12;
                  local_4c8 = lVar6;
                  if (local_2c0 == local_2b8) {
                     std::vector<glslang::TParameter,glslang::pool_allocator<glslang::TParameter>>::_M_realloc_insert<glslang::TParameter_const&>(local_2d0, local_2c0, local_4d8);
                  }
 else {
                     *local_2c0 = local_4d8._0_8_;
                     local_2c0[1] = pTVar12;
                     local_2c0[2] = lVar6;
                     local_2c0 = local_2c0 + 3;
                  }

                  glslang::TType::buildMangledName((basic_string*)pTVar12);
                  uVar4 = local_200;
                  uVar8 = local_200 + 1;
                  uVar19 = local_1f8[0];
                  if (local_208 == local_1f8) {
                     uVar19 = 0xf;
                  }

                  if (uVar19 < uVar8) {
                     std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(local_210, local_200, 0, (char*)0x0, 1);
                  }

                  *(undefined1*)( (long)local_208 + uVar4 ) = 0x3b;
                  *(undefined1*)( (long)local_208 + uVar4 + 1 ) = 0;
                  if (lVar6 != 0) {
                     local_1e0 = local_1e0 + 1;
                  }

                  uVar7 = uVar7 + 1;
                  pcVar13 = *(code**)( *(long*)param_2 + 0x120 );
                  local_200 = uVar8;
                  if (pcVar13 == TFunction::getParamCount) goto LAB_00147c60;
                  LAB_00147f63:iVar5 = ( *pcVar13 )(param_2);
                  if (iVar5 <= (int)uVar7) break;
               }
 while ( true );
            }

            auVar2._8_8_ = 0;
            auVar2._0_8_ = local_4b8._8_8_;
            local_4b8 = auVar2 << 0x40;
            local_4a8 = 0;
            uVar7 = glslang::GetThreadPoolAllocator();
            pTVar14 = (TType*)glslang::TPoolAllocator::allocate(uVar7);
            pTVar14[0x20] = ( TType )((byte)pTVar14[0x20] & 0xf0);
            *(undefined***)pTVar14 = &PTR__TType_00167f00;
            *(uint*)( pTVar14 + 0x80 ) = *(uint*)( pTVar14 + 0x80 ) & 0x9fc00000;
            *(undefined2*)( pTVar14 + 0x58 ) = 0;
            *(undefined8*)( pTVar14 + 0x10 ) = 0;
            *(uint*)( pTVar14 + 8 ) = CONCAT22((short)( ( uint ) * (undefined4*)( pTVar14 + 8 ) >> 0x10 ), 0x100) & 0xf800ffff;
            *(undefined8*)( pTVar14 + 0x44 ) = 0xfffff800;
            pTVar14[0x40] = (TType)0x0;
            *(undefined8*)( pTVar14 + 0x24 ) = uVar16;
            *(undefined4*)( pTVar14 + 0x4c ) = 0xffffffff;
            *(ulong*)( pTVar14 + 0x2d ) = *(ulong*)( pTVar14 + 0x2d ) & 0xffffff0000ffc07f | 0xffff001f80;
            *(undefined8*)( pTVar14 + 0x50 ) = 0;
            *(undefined1(*) [16])( pTVar14 + 0x88 ) = (undefined1[16])0x0;
            *(undefined1(*) [16])( pTVar14 + 0x60 ) = (undefined1[16])0x0;
            *(ulong*)( pTVar14 + 0x38 ) = ( ulong )(( uint ) * (undefined8*)( pTVar14 + 0x38 ) & 0xfe07ff00) | 0x1f800ff;
            *(undefined1(*) [16])( pTVar14 + 0x70 ) = (undefined1[16])0x0;
            *(ulong*)( pTVar14 + 0x2c ) = *(ulong*)( pTVar14 + 0x2c ) & 0xffffffff8000 | 0xffff000000004fff;
            *(ulong*)( pTVar14 + 0x34 ) = *(ulong*)( pTVar14 + 0x34 ) | 0x7ff007fffffff;
            *(ulong*)( pTVar14 + 0x18 ) = *(ulong*)( pTVar14 + 0x18 ) & 0x8000000400000000;
            local_3f8 = (undefined**)glslang::GetThreadPoolAllocator();
            local_3d8 = &local_3e8;
            local_3e8 = local_3e8 & 0xffffffff00000000;
            local_3e0 = 0;
            uStack_3c8 = 0;
            uStack_3c4 = 0;
            uStack_3d0 = local_3d8;
            TType::deepCopy(pTVar14, (TType*)&local_498, (TMap*)&local_3f8);
            for (uVar7 = local_3e0; uVar7 != 0; uVar7 = *(ulong*)( uVar7 + 0x10 )) {
               std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>*,std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector < glslang::TTypeLoc>*>>,std::less<glslang::TVector<glslang::TTypeLoc>*>,glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>> > ::_M_erase(*(_Rb_tree_node**)( uVar7 + 0x18 ));
            }

            local_4b8._8_8_ = pTVar14;
            if (local_2c0 == local_2b8) {
               std::vector<glslang::TParameter,glslang::pool_allocator<glslang::TParameter>>::_M_realloc_insert<glslang::TParameter_const&>(local_2d0, local_2c0, local_4b8);
            }
 else {
               *local_2c0 = local_4b8._0_8_;
               local_2c0[1] = pTVar14;
               local_2c0[2] = local_4a8;
               local_2c0 = local_2c0 + 3;
            }

            glslang::TType::buildMangledName((basic_string*)pTVar14);
            uVar8 = local_200;
            uVar7 = local_200 + 1;
            if (local_208 == local_1f8) {
               local_1f8[0] = 0xf;
            }

            if (local_1f8[0] < uVar7) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(local_210, local_200, 0, (char*)0x0, 1);
            }

            *(undefined1*)( (long)local_208 + uVar8 ) = 0x3b;
            *(undefined1*)( (long)local_208 + uVar8 + 1 ) = 0;
            pTVar15 = *(TIntermNode**)( this + 0x38 );
            local_200 = uVar7;
            glslang::TIntermediate::addConstantUnion((int)pTVar15, (TSourceLoc*)0x1, bVar20);
            pTVar15 = (TIntermNode*)glslang::TIntermediate::growAggregate(pTVar15, param_3);
            lVar6 = handleFunctionCall(this, param_1, local_2f8, pTVar15);
            glslang::TFunction::~TFunction(local_2f8);
         }
 else {
            LAB_00147944:lVar6 = 0;
         }

         LAB_00147946:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return lVar6;
         }

         LAB_00148b80:/* WARNING: Subroutine does not return */__stack_chk_fail();
      }

      /* glslang::TParseContext::handleFunctionCall(glslang::TSourceLoc const&, glslang::TFunction*,
   TIntermNode*) */
      long *__thiscallglslang::TParseContext::handleFunctionCall(TParseContext *this, TSourceLoc *param_1, TFunction *param_2, TIntermNode *param_3) {
         TInfoSink *pTVar1;
         code *pcVar2;
         uint *puVar3;
         uint *puVar4;
         long lVar5;
         TType TVar6;
         char cVar7;
         int iVar8;
         undefined4 uVar9;
         uint uVar10;
         long *plVar11;
         TFunction *pTVar12;
         long *plVar13;
         long *plVar14;
         undefined8 uVar15;
         long lVar16;
         TIntermAggregate *pTVar17;
         long lVar18;
         TType *pTVar19;
         TIntermNode *pTVar20;
         TIntermNode *pTVar21;
         ulong *puVar22;
         TFunction *pTVar23;
         byte bVar24;
         byte bVar25;
         byte bVar26;
         byte bVar27;
         int iVar28;
         code *pcVar29;
         long lVar30;
         ulong uVar31;
         uint *puVar32;
         ulong uVar33;
         TIntermNode *pTVar34;
         ulong uVar35;
         long in_FS_OFFSET;
         long *local_1b8;
         TIntermNode *local_170;
         undefined **local_168;
         uint local_160;
         undefined8 local_158;
         ulong local_150;
         byte local_148;
         undefined8 local_144;
         undefined1 uStack_13c;
         uint7 local_13b;
         undefined4 uStack_134;
         undefined4 local_130;
         undefined4 uStack_12c;
         undefined1 local_128;
         undefined8 local_124;
         undefined4 local_11c;
         undefined8 local_118;
         undefined2 local_110;
         undefined1 local_108[16];
         undefined1 local_f8[16];
         uint local_e8;
         undefined1 local_e0[16];
         undefined8 local_c8;
         undefined1 *local_c0;
         undefined1 local_b0[24];
         undefined8 local_98;
         undefined1 *local_90;
         undefined1 local_80[24];
         undefined8 local_68;
         undefined1 *local_60;
         undefined1 local_50[16];
         long local_40;
         local_40 = *(long*)( in_FS_OFFSET + 0x28 );
         local_170 = param_3;
         if (( ( *(int*)( this + 0x28 ) != 0 ) && ( this[0x30] != (TParseContext)0x0 ) ) && ( plVar11 = (long*)vkRelaxedRemapFunctionCall(this, param_1, param_2, param_3) ),plVar11 != (long*)0x0) goto LAB_00148d88;
         if (*(code**)( *(long*)param_2 + 0xd8 ) == TFunction::getBuiltInOp) {
            iVar28 = *(int*)( param_2 + 0x110 );
            if (iVar28 != 600) goto LAB_00148c06;
            LAB_00149a80:plVar11 = (long*)handleLengthMethod(this, param_1, param_2, local_170);
            goto LAB_00149a98;
         }

         iVar28 = ( **(code**)( *(long*)param_2 + 0xd8 ) )();
         if (iVar28 == 600) goto LAB_00149a80;
         if (*(code**)( *(long*)param_2 + 0xd8 ) == TFunction::getBuiltInOp) {
            iVar28 = *(int*)( param_2 + 0x110 );
         }
 else {
            iVar28 = ( **(code**)( *(long*)param_2 + 0xd8 ) )();
         }

         LAB_00148c06:if (iVar28 == 0) {
            local_168 = (undefined**)( (ulong)local_168 & 0xffffffffffffff00 );
            pTVar12 = (TFunction*)findFunction(this, param_1, param_2, (bool*)&local_168);
            pTVar34 = local_170;
            if (pTVar12 != (TFunction*)0x0) {
               TVar6 = local_168._0_1_;
               if (local_168._0_1_ == (TType)0x0) {
                  if (local_170 != (TIntermNode*)0x0) goto LAB_00148df9;
                  goto LAB_00149cbd;
               }

               lVar16 = *(long*)pTVar12;
               if (*(code**)( lVar16 + 0xd8 ) == TFunction::getBuiltInOp) {
                  iVar28 = *(int*)( pTVar12 + 0x110 );
                  if (iVar28 == 0x17b) goto LAB_0014a3f0;
                  LAB_0014954b:if (iVar28 == 0x17c) goto LAB_0014a3f0;
               }
 else {
                  iVar28 = ( **(code**)( lVar16 + 0xd8 ) )(pTVar12);
                  lVar16 = *(long*)pTVar12;
                  if (iVar28 != 0x17b) {
                     if (*(code**)( lVar16 + 0xd8 ) == TFunction::getBuiltInOp) {
                        iVar28 = *(int*)( pTVar12 + 0x110 );
                     }
 else {
                        iVar28 = ( **(code**)( lVar16 + 0xd8 ) )(pTVar12);
                        lVar16 = *(long*)pTVar12;
                     }

                     goto LAB_0014954b;
                  }

                  LAB_0014a3f0:pcVar2 = *(code**)( *(long*)this + 0x28 );
                  if (*(code**)( lVar16 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                     lVar16 = *(long*)( pTVar12 + 8 );
                  }
 else {
                     lVar16 = ( **(code**)( lVar16 + 0x18 ) )(pTVar12);
                  }

                  ( *pcVar2 )(this, param_1, 1, &E_GL_EXT_shader_quad_control, *(undefined8*)( lVar16 + 8 ));
                  lVar16 = *(long*)pTVar12;
               }

               if (*(code**)( lVar16 + 0x88 ) == TSymbol::getNumExtensions) {
                  lVar18 = *(long*)( pTVar12 + 0x18 );
                  if (lVar18 != 0) {
                     iVar28 = (int)( *(long*)( lVar18 + 0x10 ) - *(long*)( lVar18 + 8 ) >> 3 );
                     goto LAB_00149586;
                  }

               }
 else {
                  iVar28 = ( **(code**)( lVar16 + 0x88 ) )(pTVar12);
                  lVar16 = *(long*)pTVar12;
                  LAB_00149586:if (iVar28 != 0) {
                     pcVar2 = *(code**)( *(long*)this + 0x28 );
                     if (*(code**)( lVar16 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                        lVar18 = *(long*)( pTVar12 + 8 );
                     }
 else {
                        lVar18 = ( **(code**)( lVar16 + 0x18 ) )(pTVar12);
                        lVar16 = *(long*)pTVar12;
                     }

                     uVar15 = *(undefined8*)( lVar18 + 8 );
                     if (*(code**)( lVar16 + 0x90 ) == TSymbol::getExtensions) {
                        lVar18 = *(long*)( pTVar12 + 0x18 );
                        pcVar29 = *(code**)( lVar16 + 0x88 );
                        lVar16 = *(long*)( lVar18 + 8 );
                        lVar30 = lVar16;
                        if (pcVar29 == TSymbol::getNumExtensions) {
                           LAB_001495e0:uVar35 = *(long*)( lVar18 + 0x10 ) - lVar30 >> 3;
                        }
 else {
                           LAB_0014a561:uVar10 = ( *pcVar29 )(pTVar12);
                           uVar35 = (ulong)uVar10;
                        }

                     }
 else {
                        lVar16 = ( **(code**)( lVar16 + 0x90 ) )(pTVar12);
                        pcVar29 = *(code**)( *(long*)pTVar12 + 0x88 );
                        if (pcVar29 != TSymbol::getNumExtensions) goto LAB_0014a561;
                        lVar18 = *(long*)( pTVar12 + 0x18 );
                        if (lVar18 != 0) {
                           lVar30 = *(long*)( lVar18 + 8 );
                           goto LAB_001495e0;
                        }

                        uVar35 = 0;
                     }

                     ( *pcVar2 )(this, param_1, uVar35, lVar16, uVar15);
                     lVar16 = *(long*)pTVar12;
                  }

               }

               if (*(code**)( lVar16 + 0x60 ) == TFunction::getType) {
                  pTVar23 = pTVar12 + 0x48;
               }
 else {
                  pTVar23 = (TFunction*)( **(code**)( lVar16 + 0x60 ) )(pTVar12);
               }

               pcVar2 = *(code**)( *(long*)pTVar23 + 400 );
               if (pcVar2 == TType::containsBasicType) {
                  if (pTVar23[8] == (TFunction)0x3) goto LAB_0014a44a;
                  pcVar2 = *(code**)( *(long*)pTVar23 + 0x128 );
                  if (pcVar2 == TType::isStruct) {
                     if (( byte )((char)pTVar23[8] - 0xfU) < 2) {
                        LAB_0014a53a:lVar16 = *(long*)( *(long*)( pTVar23 + 0x68 ) + 0x10 );
                        lVar18 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( pTVar23 + 0x68 ) + 8 ),lVar16,3 ));
                        if (lVar16 != lVar18) goto LAB_0014a44a;
                     }

                  }
 else {
                     cVar7 = ( *pcVar2 )(pTVar23);
                     if (cVar7 != '\0') goto LAB_0014a53a;
                  }

               }
 else {
                  cVar7 = ( *pcVar2 )(pTVar23, 3);
                  if (cVar7 == '\0') goto LAB_0014965e;
                  LAB_0014a44a:( **(code**)( *(long*)this + 0xa8 ) )(this, param_1, "built-in function", "float16 types can only be in uniform block or buffer storage");
               }

               LAB_0014965e:if (*(code**)( *(long*)pTVar12 + 0x60 ) == TFunction::getType) {
                  pTVar23 = pTVar12 + 0x48;
               }
 else {
                  pTVar23 = (TFunction*)( **(code**)( *(long*)pTVar12 + 0x60 ) )(pTVar12);
               }

               cVar7 = TType::contains16BitInt((TType*)pTVar23);
               if (cVar7 != '\0') {
                  ( **(code**)( *(long*)this + 0xc0 ) )(this, param_1, "built-in function", "(u)int16 types can only be in uniform block or buffer storage");
               }

               if (*(code**)( *(long*)pTVar12 + 0x60 ) == TFunction::getType) {
                  pTVar23 = pTVar12 + 0x48;
               }
 else {
                  pTVar23 = (TFunction*)( **(code**)( *(long*)pTVar12 + 0x60 ) )(pTVar12);
               }

               cVar7 = TType::contains8BitInt((TType*)pTVar23);
               if (cVar7 != '\0') {
                  ( **(code**)( *(long*)this + 0xd8 ) )(this, param_1, "built-in function", "(u)int8 types can only be in uniform block or buffer storage");
               }

               lVar16 = *(long*)pTVar12;
               if (*(code**)( lVar16 + 0xd8 ) == TFunction::getBuiltInOp) {
                  iVar28 = *(int*)( pTVar12 + 0x110 );
                  if (iVar28 == 0x27a) goto LAB_0014a343;
                  LAB_00149703:if (iVar28 == 0x271) goto LAB_0014a340;
               }
 else {
                  iVar28 = ( **(code**)( lVar16 + 0xd8 ) )(pTVar12);
                  if (iVar28 != 0x27a) {
                     if (*(code**)( *(long*)pTVar12 + 0xd8 ) == TFunction::getBuiltInOp) {
                        iVar28 = *(int*)( pTVar12 + 0x110 );
                     }
 else {
                        iVar28 = ( **(code**)( *(long*)pTVar12 + 0xd8 ) )(pTVar12);
                     }

                     goto LAB_00149703;
                  }

                  LAB_0014a340:lVar16 = *(long*)pTVar12;
                  LAB_0014a343:if (*(code**)( lVar16 + 0x140 ) == TFunction::operator []) {
                     lVar16 = *(long*)( pTVar12 + 0x30 );
                  }
 else {
                     lVar16 = ( **(code**)( lVar16 + 0x140 ) )(pTVar12, 0);
                  }

                  pcVar2 = *(code**)( **(long**)( lVar16 + 8 ) + 0x48 );
                  if (pcVar2 == TType::getSampler) {
                     plVar11 = *(long**)( lVar16 + 8 ) + 0x10;
                  }
 else {
                     plVar11 = (long*)( *pcVar2 )();
                  }

                  if (( ( *plVar11 & 0x40000 ) != 0 ) && ( *(int*)( this + 0x18 ) < 0x8d )) {
                     pcVar2 = *(code**)( *(long*)this + 0x28 );
                     if (*(code**)( *(long*)pTVar12 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                        lVar16 = *(long*)( pTVar12 + 8 );
                     }
 else {
                        lVar16 = ( **(code**)( *(long*)pTVar12 + 0x18 ) )(pTVar12);
                     }

                     ( *pcVar2 )(this, param_1, 1, &E_GL_ARB_texture_multisample, *(undefined8*)( lVar16 + 8 ));
                  }

               }

               if (pTVar34 != (TIntermNode*)0x0) {
                  LAB_00148df9:uVar35 = 0;
                  plVar11 = (long*)( **(code**)( *(long*)pTVar34 + 0x30 ) )(pTVar34);
                  do {
                     if (*(code**)( *(long*)pTVar12 + 0x120 ) == TFunction::getParamCount) {
                        iVar28 = (int)( *(long*)( pTVar12 + 0x38 ) - *(long*)( pTVar12 + 0x30 ) >> 3 ) * -0x55555555;
                        if (iVar28 <= (int)uVar35) goto LAB_00149ae0;
                     }
 else {
                        iVar28 = ( **(code**)( *(long*)pTVar12 + 0x120 ) )(pTVar12);
                        if (iVar28 <= (int)uVar35) goto LAB_00149ae0;
                        if (*(code**)( *(long*)pTVar12 + 0x120 ) == TFunction::getParamCount) {
                           iVar28 = (int)( *(long*)( pTVar12 + 0x38 ) - *(long*)( pTVar12 + 0x30 ) >> 3 ) * -0x55555555;
                        }
 else {
                           iVar28 = ( **(code**)( *(long*)pTVar12 + 0x120 ) )(pTVar12);
                        }

                     }

                     pTVar20 = pTVar34;
                     if (( iVar28 != 1 ) && ( plVar11 != (long*)0x0 )) {
                        if (*(code**)( *plVar11 + 400 ) == TIntermAggregate::getSequence) {
                           plVar13 = plVar11 + 0x18;
                        }
 else {
                           plVar13 = (long*)( **(code**)( *plVar11 + 400 ) )(plVar11);
                        }

                        pTVar20 = *(TIntermNode**)( plVar13[1] + uVar35 * 8 );
                     }

                     if (*(code**)( *(long*)pTVar12 + 0x140 ) == TFunction::operator []) {
                        lVar16 = *(long*)( pTVar12 + 0x30 ) + uVar35 * 0x18;
                     }
 else {
                        lVar16 = ( **(code**)( *(long*)pTVar12 + 0x140 ) )(pTVar12, uVar35 & 0xffffffff);
                     }

                     pcVar2 = *(code**)( **(long**)( lVar16 + 8 ) + 0x50 );
                     if (pcVar2 == TType::getQualifier) {
                        local_1b8 = *(long**)( lVar16 + 8 ) + 2;
                     }
 else {
                        local_1b8 = (long*)( *pcVar2 )();
                     }

                     lVar16 = *(long*)pTVar20;
                     if (( *(byte*)( local_1b8 + 1 ) & 0x7f ) - 0x11 < 2) {
                        pcVar2 = *(code**)( *(long*)this + 0x200 );
                        uVar15 = ( **(code**)( lVar16 + 0x18 ) )(pTVar20);
                        if ((code*)**(undefined8**)pTVar34 == TIntermNode::getLoc) {
                           pTVar21 = pTVar34 + 8;
                        }
 else {
                           pTVar21 = (TIntermNode*)( *(code*)**(undefined8**)pTVar34 )(pTVar34);
                        }

                        cVar7 = ( *pcVar2 )(this, pTVar21, "assign", uVar15);
                        if (cVar7 != '\0') {
                           pcVar2 = *(code**)( *(long*)this + 0x158 );
                           if ((code*)**(undefined8**)pTVar34 == TIntermNode::getLoc) {
                              pTVar21 = pTVar34 + 8;
                           }
 else {
                              pTVar21 = (TIntermNode*)( *(code*)**(undefined8**)pTVar34 )(pTVar34);
                           }

                           ( *pcVar2 )(this, pTVar21, "Non-L-value cannot be passed for \'out\' or \'inout\' parameters.", &_LC71, &_LC1);
                        }

                        lVar16 = *(long*)pTVar20;
                     }

                     if (( *(byte*)( (long)local_1b8 + 0xf ) & 8 ) != 0) {
                        plVar13 = (long*)( **(code**)( lVar16 + 0x18 ) )(pTVar20);
                        if (*(code**)( *plVar13 + 0x108 ) == TIntermTyped::getQualifier) {
                           plVar13 = plVar13 + 6;
                        }
 else {
                           plVar13 = (long*)( **(code**)( *plVar13 + 0x108 ) )();
                        }

                        if (( ( *(byte*)( plVar13 + 1 ) & 0x7f ) != 2 ) || ( ( *(byte*)( (long)plVar13 + 0xc ) & 1 ) != 0 )) {
                           pcVar2 = *(code**)( *(long*)this + 0x158 );
                           if ((code*)**(undefined8**)pTVar34 == TIntermNode::getLoc) {
                              pTVar21 = pTVar34 + 8;
                           }
 else {
                              pTVar21 = (TIntermNode*)( *(code*)**(undefined8**)pTVar34 )(pTVar34);
                           }

                           ( *pcVar2 )(this, pTVar21, "Non front-end constant expressions cannot be passed for \'spirv_literal\' parameters.", "spirv_literal", &_LC1);
                        }

                        lVar16 = *(long*)pTVar20;
                     }

                     plVar13 = (long*)( **(code**)( lVar16 + 0x18 ) )(pTVar20);
                     if (*(code**)( *plVar13 + 0xf0 ) == TIntermTyped::getType) {
                        plVar13 = plVar13 + 4;
                     }
 else {
                        plVar13 = (long*)( **(code**)( *plVar13 + 0xf0 ) )();
                     }

                     if (*(code**)( *plVar13 + 0x58 ) == TType::getQualifier) {
                        plVar14 = plVar13 + 2;
                     }
 else {
                        plVar14 = (long*)( **(code**)( *plVar13 + 0x58 ) )(plVar13);
                     }

                     if (( *(long*)( *(long*)( this + 0x38 ) + 0x550 ) == 0 ) && ( *(long*)( *(long*)( this + 0x38 ) + 0x580 ) == 0 )) {
                        bVar24 = *(byte*)( (long)plVar14 + 0xe );
                        joined_r0x0014976c:if (( ( ( ( -1 < (char)bVar24 ) && ( ( bVar24 & 0x40 ) == 0 ) ) && ( ( bVar24 & 0x20 ) == 0 ) ) && ( ( ( ( bVar24 & 0x10 ) == 0 && ( ( bVar24 & 8 ) == 0 ) ) && ( ( ( bVar24 & 2 ) == 0 && ( ( ( bVar24 & 4 ) == 0 && ( ( *(byte*)( (long)plVar14 + 0xd ) & 0x40 ) == 0 ) ) ) ) ) ) ) ) && ( -1 < (char)*(byte*)( (long)plVar14 + 0xd ) )) {
                           cVar7 = '\0';
                           LAB_00149877:if (( ( ( bVar24 & 1 ) == 0 ) && ( ( *(byte*)( (long)plVar14 + 0xf ) & 1 ) == 0 ) ) || ( cVar7 != '\0' )) goto LAB_001493b0;
                        }

                        lVar16 = *plVar13;
                        if (*(code**)( lVar16 + 0x1b0 ) == TType::containsOpaque) {
                           if (*(code**)( lVar16 + 0x140 ) != TType::isOpaque) {
                              cVar7 = ( **(code**)( lVar16 + 0x140 ) )(plVar13);
                              if (cVar7 != '\0') goto LAB_00149a70;
                              lVar16 = *plVar13;
                              LAB_00149a28:if (*(code**)( lVar16 + 0x128 ) == TType::isStruct) {
                                 if (( byte )((char)plVar13[1] - 0xfU) < 2) goto LAB_0014a491;
                                 goto LAB_00149a4f;
                              }

                              cVar7 = ( **(code**)( lVar16 + 0x128 ) )(plVar13);
                              if (cVar7 == '\0') goto LAB_0014a331;
                              LAB_0014a491:lVar16 = *(long*)( plVar13[0xd] + 0x10 );
                              lVar18 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar13[0xd] + 8 ),lVar16 ));
                              if (lVar16 == lVar18) goto LAB_0014a331;
                              goto LAB_00149a70;
                           }

                           if (( 0x14 < *(byte*)( plVar13 + 1 ) ) || ( ( 0x1a6000UL >> ( ( ulong ) * (byte*)( plVar13 + 1 ) & 0x3f ) & 1 ) == 0 )) goto LAB_00149a28;
                        }
 else {
                           cVar7 = ( **(code**)( lVar16 + 0x1b0 ) )(plVar13);
                           if (cVar7 == '\0') {
                              LAB_0014a331:lVar16 = *plVar13;
                              LAB_00149a4f:if (*(code**)( lVar16 + 0x38 ) == TType::getBasicType) {
                                 uVar10 = ( uint ) * (byte*)( plVar13 + 1 );
                              }
 else {
                                 uVar10 = ( **(code**)( lVar16 + 0x38 ) )(plVar13);
                              }

                              if (uVar10 != 0x12) goto LAB_001493b0;
                           }

                           LAB_00149a70:bVar24 = *(byte*)( (long)plVar14 + 0xe );
                        }

                        if (( ( bVar24 & 4 ) != 0 ) && ( ( *(byte*)( (long)local_1b8 + 0xe ) & 4 ) == 0 )) {
                           pcVar2 = *(code**)( *(long*)this + 0x158 );
                           if ((code*)**(undefined8**)pTVar34 == TIntermNode::getLoc) {
                              pTVar21 = pTVar34 + 8;
                           }
 else {
                              pTVar21 = (TIntermNode*)( *(code*)**(undefined8**)pTVar34 )(pTVar34);
                           }

                           ( *pcVar2 )(this, pTVar21, "argument cannot drop memory qualifier when passed to formal parameter", "volatile", &_LC1);
                           bVar24 = *(byte*)( (long)plVar14 + 0xe );
                        }

                        if (( bVar24 & 2 ) == 0) {
                           LAB_00149134:if (( ( ( bVar24 & 8 ) != 0 ) && ( ( *(byte*)( (long)local_1b8 + 0xe ) & 8 ) == 0 ) ) && ( ( *(byte*)( (long)local_1b8 + 0xe ) & 2 ) == 0 )) {
                              pcVar2 = *(code**)( *(long*)this + 0x158 );
                              if ((code*)**(undefined8**)pTVar34 == TIntermNode::getLoc) {
                                 pTVar21 = pTVar34 + 8;
                              }
 else {
                                 pTVar21 = (TIntermNode*)( *(code*)**(undefined8**)pTVar34 )(pTVar34);
                              }

                              ( *pcVar2 )(this, pTVar21, "argument cannot drop memory qualifier when passed to formal parameter", "devicecoherent", &_LC1);
                              bVar24 = *(byte*)( (long)plVar14 + 0xe );
                           }

                        }
 else if (( ( *(byte*)( (long)local_1b8 + 0xe ) & 8 ) == 0 ) && ( ( *(byte*)( (long)local_1b8 + 0xe ) & 2 ) == 0 )) {
                           pcVar2 = *(code**)( *(long*)this + 0x158 );
                           if ((code*)**(undefined8**)pTVar34 == TIntermNode::getLoc) {
                              pTVar21 = pTVar34 + 8;
                           }
 else {
                              pTVar21 = (TIntermNode*)( *(code*)**(undefined8**)pTVar34 )(pTVar34);
                           }

                           ( *pcVar2 )(this, pTVar21, "argument cannot drop memory qualifier when passed to formal parameter", "coherent", &_LC1);
                           bVar24 = *(byte*)( (long)plVar14 + 0xe );
                           goto LAB_00149134;
                        }

                        if (( ( ( bVar24 & 0x10 ) != 0 ) && ( bVar25 = *(byte*)( (long)local_1b8 + 0xe )(bVar25 & 0x10) == 0 ) ) && ( ( ( bVar25 & 8 ) == 0 && ( ( bVar25 & 2 ) == 0 ) ) )) {
                           pcVar2 = *(code**)( *(long*)this + 0x158 );
                           if ((code*)**(undefined8**)pTVar34 == TIntermNode::getLoc) {
                              pTVar21 = pTVar34 + 8;
                           }
 else {
                              pTVar21 = (TIntermNode*)( *(code*)**(undefined8**)pTVar34 )(pTVar34);
                           }

                           ( *pcVar2 )(this, pTVar21, "argument cannot drop memory qualifier when passed to formal parameter", "queuefamilycoherent", &_LC1);
                           bVar24 = *(byte*)( (long)plVar14 + 0xe );
                        }

                        if (( ( ( bVar24 & 0x20 ) != 0 ) && ( bVar25 = *(byte*)( (long)local_1b8 + 0xe )(bVar25 & 0x20) == 0 ) ) && ( ( ( bVar25 & 0x10 ) == 0 && ( ( ( bVar25 & 8 ) == 0 && ( ( bVar25 & 2 ) == 0 ) ) ) ) )) {
                           pcVar2 = *(code**)( *(long*)this + 0x158 );
                           if ((code*)**(undefined8**)pTVar34 == TIntermNode::getLoc) {
                              pTVar21 = pTVar34 + 8;
                           }
 else {
                              pTVar21 = (TIntermNode*)( *(code*)**(undefined8**)pTVar34 )(pTVar34);
                           }

                           ( *pcVar2 )(this, pTVar21, "argument cannot drop memory qualifier when passed to formal parameter", "workgroupcoherent", &_LC1);
                           bVar24 = *(byte*)( (long)plVar14 + 0xe );
                        }

                        if (( ( ( ( ( bVar24 & 0x40 ) != 0 ) && ( bVar24 = *(byte*)( (long)local_1b8 + 0xe )(bVar24 & 0x40) == 0 ) ) && ( ( bVar24 & 0x20 ) == 0 ) ) && ( ( ( bVar24 & 0x10 ) == 0 && ( ( bVar24 & 8 ) == 0 ) ) ) ) && ( ( bVar24 & 2 ) == 0 )) {
                           pcVar2 = *(code**)( *(long*)this + 0x158 );
                           if ((code*)**(undefined8**)pTVar34 == TIntermNode::getLoc) {
                              pTVar21 = pTVar34 + 8;
                           }
 else {
                              pTVar21 = (TIntermNode*)( *(code*)**(undefined8**)pTVar34 )(pTVar34);
                           }

                           ( *pcVar2 )(this, pTVar21, "argument cannot drop memory qualifier when passed to formal parameter", "subgroupcoherent", &_LC1);
                        }

                        if (( *(char*)( (long)plVar14 + 0xd ) < '\0' ) && ( -1 < *(char*)( (long)local_1b8 + 0xd ) )) {
                           pcVar2 = *(code**)( *(long*)this + 0x158 );
                           if ((code*)**(undefined8**)pTVar34 == TIntermNode::getLoc) {
                              pTVar21 = pTVar34 + 8;
                           }
 else {
                              pTVar21 = (TIntermNode*)( *(code*)**(undefined8**)pTVar34 )(pTVar34);
                           }

                           ( *pcVar2 )(this, pTVar21, "argument cannot drop memory qualifier when passed to formal parameter", "readonly", &_LC1);
                        }

                        if (( ( *(byte*)( (long)plVar14 + 0xe ) & 1 ) != 0 ) && ( ( *(byte*)( (long)local_1b8 + 0xe ) & 1 ) == 0 )) {
                           pcVar2 = *(code**)( *(long*)this + 0x158 );
                           if ((code*)**(undefined8**)pTVar34 == TIntermNode::getLoc) {
                              pTVar21 = pTVar34 + 8;
                           }
 else {
                              pTVar21 = (TIntermNode*)( *(code*)**(undefined8**)pTVar34 )(pTVar34);
                           }

                           ( *pcVar2 )(this, pTVar21, "argument cannot drop memory qualifier when passed to formal parameter", "writeonly", &_LC1);
                        }

                     }
 else {
                        if (*(code**)( *plVar13 + 0x1b8 ) == TType::containsSampler) {
                           cVar7 = TType::contains<glslang::TType::containsSampler()const::_lambda(glslang::TType_const*)_1_>();
                        }
 else {
                           cVar7 = ( **(code**)( *plVar13 + 0x1b8 ) )(plVar13);
                        }

                        bVar24 = *(byte*)( (long)plVar14 + 0xe );
                        if (cVar7 == '\0') goto joined_r0x0014976c;
                        if (( ( ( ( ( -1 < (char)bVar24 ) && ( ( bVar24 & 0x40 ) == 0 ) ) && ( ( bVar24 & 0x20 ) == 0 ) ) && ( ( ( bVar24 & 0x10 ) == 0 && ( ( bVar24 & 8 ) == 0 ) ) ) ) && ( ( ( bVar24 & 2 ) == 0 && ( ( ( bVar24 & 4 ) == 0 && ( ( *(byte*)( (long)plVar14 + 0xd ) & 0x40 ) == 0 ) ) ) ) ) ) && ( -1 < (char)*(byte*)( (long)plVar14 + 0xd ) )) goto LAB_00149877;
                     }

                     LAB_001493b0:if (TVar6 == (TType)0x0) {
                        if (( *(char*)( (long)local_1b8 + 0x2c ) != *(char*)( (long)plVar14 + 0x2c ) ) && ( ( ( *(byte*)( (long)local_1b8 + 0xe ) & 1 ) == 0 || ( ( *(char*)( (long)local_1b8 + 0x2c ) != '\0' && ( *(char*)( (long)plVar14 + 0x2c ) != '\0' ) ) ) ) )) {
                           pcVar2 = *(code**)( *(long*)this + 0x158 );
                           if ((code*)**(undefined8**)pTVar34 == TIntermNode::getLoc) {
                              pTVar20 = pTVar34 + 8;
                           }
 else {
                              pTVar20 = (TIntermNode*)( *(code*)**(undefined8**)pTVar34 )(pTVar34);
                           }

                           ( *pcVar2 )(this, pTVar20, "image formats must match", "format", &_LC1);
                        }

                     }
 else {
                        plVar14 = (long*)( **(code**)( *(long*)pTVar20 + 0x18 ) )(pTVar20);
                        plVar13 = plVar14 + 4;
                        if (*(code**)( *plVar14 + 0xf0 ) != TIntermTyped::getType) {
                           plVar13 = (long*)( **(code**)( *plVar14 + 0xf0 ) )();
                        }

                        pcVar2 = *(code**)( *plVar13 + 400 );
                        if (pcVar2 == TType::containsBasicType) {
                           if ((char)plVar13[1] == '\x03') goto LAB_0014991a;
                           pcVar2 = *(code**)( *plVar13 + 0x128 );
                           if (pcVar2 == TType::isStruct) {
                              if (( byte )((char)plVar13[1] - 0xfU) < 2) {
                                 LAB_00149c55:lVar16 = *(long*)( plVar13[0xd] + 0x10 );
                                 lVar18 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( plVar13[0xd] + 8 ),lVar16,3 ));
                                 if (lVar16 != lVar18) goto LAB_0014991a;
                              }

                           }
 else {
                              cVar7 = ( *pcVar2 )(plVar13);
                              if (cVar7 != '\0') goto LAB_00149c55;
                           }

                        }
 else {
                           cVar7 = ( *pcVar2 )(plVar13, 3);
                           if (cVar7 == '\0') goto LAB_00149427;
                           LAB_0014991a:pTVar21 = pTVar34 + 8;
                           pcVar2 = *(code**)( *(long*)this + 0xa8 );
                           if ((code*)**(undefined8**)pTVar34 != TIntermNode::getLoc) {
                              pTVar21 = (TIntermNode*)( *(code*)**(undefined8**)pTVar34 )(pTVar34, pTVar21);
                           }

                           ( *pcVar2 )(this, pTVar21, "built-in function", "float16 types can only be in uniform block or buffer storage");
                        }

                        LAB_00149427:plVar13 = (long*)( **(code**)( *(long*)pTVar20 + 0x18 ) )(pTVar20);
                        if (*(code**)( *plVar13 + 0xf0 ) == TIntermTyped::getType) {
                           pTVar19 = (TType*)( plVar13 + 4 );
                        }
 else {
                           pTVar19 = (TType*)( **(code**)( *plVar13 + 0xf0 ) )();
                        }

                        cVar7 = TType::contains16BitInt(pTVar19);
                        if (cVar7 != '\0') {
                           pcVar2 = *(code**)( *(long*)this + 0xc0 );
                           if ((code*)**(undefined8**)pTVar34 == TIntermNode::getLoc) {
                              pTVar21 = pTVar34 + 8;
                           }
 else {
                              pTVar21 = (TIntermNode*)( *(code*)**(undefined8**)pTVar34 )(pTVar34);
                           }

                           ( *pcVar2 )(this, pTVar21, "built-in function", "(u)int16 types can only be in uniform block or buffer storage");
                        }

                        plVar13 = (long*)( **(code**)( *(long*)pTVar20 + 0x18 ) )(pTVar20);
                        if (*(code**)( *plVar13 + 0xf0 ) == TIntermTyped::getType) {
                           pTVar19 = (TType*)( plVar13 + 4 );
                        }
 else {
                           pTVar19 = (TType*)( **(code**)( *plVar13 + 0xf0 ) )();
                        }

                        cVar7 = TType::contains8BitInt(pTVar19);
                        if (cVar7 != '\0') {
                           pcVar2 = *(code**)( *(long*)this + 0xd8 );
                           if ((code*)**(undefined8**)pTVar34 == TIntermNode::getLoc) {
                              pTVar20 = pTVar34 + 8;
                           }
 else {
                              pTVar20 = (TIntermNode*)( *(code*)**(undefined8**)pTVar34 )(pTVar34);
                           }

                           ( *pcVar2 )(this, pTVar20, "built-in function", "(u)int8 types can only be in uniform block or buffer storage");
                        }

                     }

                     uVar35 = uVar35 + 1;
                  }
 while ( true );
               }

               pTVar34 = (TIntermNode*)0x0;
               goto LAB_00149b00;
            }

         }
 else {
            local_148 = local_148 & 0xf0;
            local_168 = &PTR__TType_00167f00;
            local_e0 = (undefined1[16])0x0;
            local_108 = (undefined1[16])0x0;
            local_160 = CONCAT22((short)( local_160 >> 0x10 ), 0x100) & 0xf800ffff;
            local_f8 = (undefined1[16])0x0;
            local_124 = 0xfffff800;
            local_110 = 0;
            local_e8 = local_e8 & 0x9fc00000;
            local_128 = 0;
            local_158 = 0;
            uStack_12c = 0;
            local_144 = 0xffffffffffffffff;
            local_13b = local_13b & 0xffc000 | 0xffffffff001fcf;
            uStack_13c = 0xff;
            uVar35 = CONCAT44(local_130, uStack_134) & 0xfe07ff00ffffffff | 0x1ffffff7fffffff;
            uStack_134 = (undefined4)uVar35;
            local_130 = ( undefined4 )(uVar35 >> 0x20);
            local_150 = local_150 & 0x8000000400000000;
            local_11c = 0xffffffff;
            local_118 = 0;
            if (*(code**)( *(long*)param_2 + 0xd8 ) == TFunction::getBuiltInOp) {
               uVar9 = *(undefined4*)( param_2 + 0x110 );
            }
 else {
               uVar9 = ( **(code**)( *(long*)param_2 + 0xd8 ) )(param_2);
            }

            pTVar34 = local_170;
            cVar7 = constructorError(this, param_1, local_170, param_2, uVar9, (TType*)&local_168);
            if (cVar7 == '\0') {
               plVar11 = (long*)addConstructor(this, param_1, pTVar34, (TType*)&local_168);
               if (plVar11 != (long*)0x0) goto LAB_00148d88;
               pcVar2 = *(code**)( *(long*)this + 0x158 );
               local_98 = glslang::GetThreadPoolAllocator();
               local_90 = local_80;
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1, &_LC1);
               local_c8 = glslang::GetThreadPoolAllocator();
               local_c0 = local_b0;
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_c8, &_LC1, &_LC1);
               TType::getCompleteString(&local_68, (TType*)&local_168, *(undefined1*)( *(long*)( this + 0x38 ) + 0x26f ), 1, 1, 1, &local_c8, &local_98);
               ( *pcVar2 )(this, param_1, "cannot construct with these arguments", local_60, &_LC1);
            }

         }

         LAB_00148d65:plVar11 = (long*)glslang::TIntermediate::addConstantUnion(0, *(undefined8*)( this + 0x38 ), 1, param_1, 0);
         LAB_00148d88:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return plVar11;
         }

         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
         LAB_00149ae0:addInputArgumentConversions(this, pTVar12, &local_170);
         pTVar34 = local_170;
         if (TVar6 == (TType)0x0) {
            LAB_00149cbd:if (*(code**)( *(long*)pTVar12 + 0xd8 ) == TFunction::getBuiltInOp) {
               iVar28 = *(int*)( pTVar12 + 0x110 );
            }
 else {
               iVar28 = ( **(code**)( *(long*)pTVar12 + 0xd8 ) )(pTVar12);
            }

            if (iVar28 == 7) goto LAB_0014a62e;
            lVar16 = *(long*)pTVar12;
            LAB_00149b28:uVar15 = *(undefined8*)( this + 0x38 );
            if (*(code**)( lVar16 + 0x60 ) == TFunction::getType) {
               pTVar23 = pTVar12 + 0x48;
            }
 else {
               pTVar23 = (TFunction*)( **(code**)( lVar16 + 0x60 ) )(pTVar12);
            }

            plVar11 = (long*)glslang::TIntermediate::setAggregateOperator(uVar15, pTVar34, 4, pTVar23, param_1);
            pTVar17 = (TIntermAggregate*)( **(code**)( *plVar11 + 0x30 ) )(plVar11);
            pcVar2 = *(code**)( *(long*)pTVar17 + 0x1a0 );
            if (*(code**)( *(long*)pTVar12 + 0x30 ) == TFunction::getMangledName_abi_cxx11_) {
               pTVar23 = pTVar12 + 0xe8;
            }
 else {
               pTVar23 = (TFunction*)( **(code**)( *(long*)pTVar12 + 0x30 ) )(pTVar12);
            }

            if (pcVar2 == TIntermAggregate::setName) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( pTVar17 + 0x100 ), (basic_string*)pTVar23);
            }
 else {
               ( *pcVar2 )(pTVar17);
            }

            if (TVar6 == (TType)0x0) {
               if (*(code**)( *(long*)pTVar17 + 0x1b0 ) == TIntermAggregate::setUserDefined) {
                  pTVar17[0x128] = (TIntermAggregate)0x1;
               }
 else {
                  ( **(code**)( *(long*)pTVar17 + 0x1b0 ) )(pTVar17);
               }

               if ((int)( ( *(long**)( this + 0xe8 ) )[1] - **(long**)( this + 0xe8 ) >> 3 ) < 5) {
                  glslang::TParseVersions::requireProfile((TSourceLoc*)this, (int)param_1, (char*)0xfffffff7);
                  pTVar1 = *(TInfoSink**)( this + 0x38 );
                  if (*(code**)( *(long*)pTVar12 + 0x30 ) != TFunction::getMangledName_abi_cxx11_) {
                     ( **(code**)( *(long*)pTVar12 + 0x30 ) )(pTVar12);
                  }

                  local_68 = glslang::GetThreadPoolAllocator();
                  local_60 = local_50;
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>((basic_string*)&local_68, &_LC1401);
                  glslang::TIntermediate::addToCallGraph(pTVar1, *(basic_string**)( this + 0x10 ), (basic_string*)&local_68);
               }
 else {
                  pTVar1 = *(TInfoSink**)( this + 0x38 );
                  if (*(code**)( *(long*)pTVar12 + 0x30 ) != TFunction::getMangledName_abi_cxx11_) {
                     ( **(code**)( *(long*)pTVar12 + 0x30 ) )(pTVar12);
                  }

                  glslang::TIntermediate::addToCallGraph(pTVar1, *(basic_string**)( this + 0x10 ), (basic_string*)( this + 0x7510 ));
               }

               userFunctionCallCheck(this, param_1, pTVar17);
            }
 else {
               nonOpBuiltInCheck(this, param_1, pTVar12, pTVar17);
            }

         }
 else {
            LAB_00149b00:lVar16 = *(long*)pTVar12;
            if (*(code**)( lVar16 + 0xd8 ) == TFunction::getBuiltInOp) {
               if (*(int*)( pTVar12 + 0x110 ) == 0) goto LAB_00149b28;
            }
 else {
               iVar28 = ( **(code**)( lVar16 + 0xd8 ) )(pTVar12);
               if (iVar28 == 0) goto LAB_00149cbd;
            }

            LAB_0014a62e:plVar11 = (long*)handleBuiltInFunctionCall(this, pTVar34, pTVar12);
         }

         lVar16 = ( **(code**)( *plVar11 + 0x30 ) )(plVar11);
         if (lVar16 != 0) {
            plVar13 = (long*)( **(code**)( *plVar11 + 0x30 ) )(plVar11);
            if (*(code**)( *plVar13 + 0x1c0 ) == TIntermAggregate::getQualifierList) {
               puVar22 = (ulong*)( plVar13 + 0x1c );
            }
 else {
               puVar22 = (ulong*)( **(code**)( *plVar13 + 0x1c0 ) )();
            }

            lVar16 = 0;
            iVar28 = 0;
            while (true) {
               if (*(code**)( *(long*)pTVar12 + 0x120 ) == TFunction::getParamCount) {
                  iVar8 = (int)( *(long*)( pTVar12 + 0x38 ) - *(long*)( pTVar12 + 0x30 ) >> 3 ) * -0x55555555;
               }
 else {
                  iVar8 = ( **(code**)( *(long*)pTVar12 + 0x120 ) )(pTVar12);
               }

               if (iVar8 <= iVar28) break;
               if (*(code**)( *(long*)pTVar12 + 0x140 ) == TFunction::operator []) {
                  lVar18 = *(long*)( pTVar12 + 0x30 ) + lVar16;
               }
 else {
                  lVar18 = ( **(code**)( *(long*)pTVar12 + 0x140 ) )(pTVar12, iVar28);
               }

               pcVar2 = *(code**)( **(long**)( lVar18 + 8 ) + 0x50 );
               if (pcVar2 == TType::getQualifier) {
                  plVar13 = *(long**)( lVar18 + 8 ) + 2;
               }
 else {
                  plVar13 = (long*)( *pcVar2 )();
               }

               puVar3 = (uint*)puVar22[2];
               uVar10 = *(byte*)( plVar13 + 1 ) & 0x7f;
               if (puVar3 == (uint*)puVar22[3]) {
                  puVar4 = (uint*)puVar22[1];
                  puVar32 = (uint*)( (long)puVar3 - (long)puVar4 );
                  uVar35 = (long)puVar32 >> 2;
                  if (uVar35 == 0x1fffffffffffffff) {
                     /* WARNING: Subroutine does not return */
                     std::__throw_length_error("vector::_M_realloc_insert");
                  }

                  if (puVar3 == puVar4) {
                     if (0xfffffffffffffffe < uVar35) goto LAB_0014a4f8;
                     uVar31 = 0x1fffffffffffffff;
                     if (uVar35 + 1 < 0x2000000000000000) {
                        uVar31 = uVar35 + 1;
                     }

                     lVar18 = uVar31 << 2;
                     LAB_0014a262:uVar31 = glslang::TPoolAllocator::allocate(*puVar22);
                     uVar33 = lVar18 + uVar31;
                     uVar35 = uVar31 + 4;
                     *(uint*)( uVar31 + (long)puVar32 ) = uVar10;
                     if (puVar3 != puVar4) goto LAB_0014a207;
                  }
 else {
                     uVar31 = uVar35 * 2;
                     if (uVar31 < uVar35) {
                        LAB_0014a4f8:lVar18 = 0x7ffffffffffffffc;
                        goto LAB_0014a262;
                     }

                     if (uVar31 != 0) {
                        if (0x1fffffffffffffff < uVar31) {
                           uVar31 = 0x1fffffffffffffff;
                        }

                        lVar18 = uVar31 * 4;
                        goto LAB_0014a262;
                     }

                     *puVar32 = uVar10;
                     uVar33 = 0;
                     uVar31 = 0;
                     LAB_0014a207:lVar18 = 0;
                     do {
                        *(undefined4*)( uVar31 + lVar18 ) = *(undefined4*)( (long)puVar4 + lVar18 );
                        lVar18 = lVar18 + 4;
                     }
 while ( lVar18 != (long)puVar3 - (long)puVar4 );
                     uVar35 = uVar31 + 4 + lVar18;
                  }

                  puVar22[1] = uVar31;
                  puVar22[2] = uVar35;
                  puVar22[3] = uVar33;
               }
 else {
                  *puVar3 = uVar10;
                  puVar22[2] = ( ulong )(puVar3 + 1);
               }

               iVar28 = iVar28 + 1;
               lVar16 = lVar16 + 0x18;
            }
;
            pTVar17 = (TIntermAggregate*)( **(code**)( *plVar11 + 0x30 ) )(plVar11);
            plVar11 = (long*)addOutputArgumentConversions(this, pTVar12, pTVar17);
         }

         lVar16 = *plVar11;
         plVar13 = plVar11;
         if (*(code**)( lVar16 + 0x18 ) != TIntermTyped::getAsTyped) {
            plVar13 = (long*)( **(code**)( lVar16 + 0x18 ) )();
            lVar16 = *plVar13;
         }

         if (*(code**)( lVar16 + 0xf0 ) == TIntermTyped::getType) {
            plVar13 = plVar13 + 4;
         }
 else {
            plVar13 = (long*)( **(code**)( lVar16 + 0xf0 ) )();
         }

         if (( ( *(byte*)( (long)plVar13 + 10 ) & 0x20 ) != 0 ) || ( ( *(byte*)( (long)plVar13 + 10 ) & 0x40 ) != 0 )) {
            lVar16 = *plVar11;
            plVar13 = plVar11;
            if (*(code**)( lVar16 + 0x18 ) != TIntermTyped::getAsTyped) {
               plVar13 = (long*)( **(code**)( lVar16 + 0x18 ) )();
               lVar16 = *plVar13;
            }

            if (*(code**)( lVar16 + 0xf0 ) == TIntermTyped::getType) {
               plVar13 = plVar13 + 4;
            }
 else {
               plVar13 = (long*)( **(code**)( lVar16 + 0xf0 ) )();
            }

            if (*(code**)( *plVar13 + 0x188 ) == TType::isParameterized) {
               if (plVar13[0x11] == 0) {
                  LAB_0014a005:pcVar2 = *(code**)( *plVar11 + 0xe8 );
                  plVar14 = (long*)( **(code**)( *plVar11 + 0x30 ) )(plVar11);
                  plVar13 = plVar14 + 0x18;
                  if (*(code**)( *plVar14 + 400 ) != TIntermAggregate::getSequence) {
                     plVar13 = (long*)( **(code**)( *plVar14 + 400 ) )();
                  }

                  plVar13 = (long*)( **(code**)( **(long**)( plVar13[1] + 0x10 ) + 0x18 ) )();
                  if (*(code**)( *plVar13 + 0xf0 ) == TIntermTyped::getType) {
                     plVar13 = plVar13 + 4;
                  }
 else {
                     plVar13 = (long*)( **(code**)( *plVar13 + 0xf0 ) )();
                  }

                  if (pcVar2 == TIntermTyped::setType) {
                     lVar16 = plVar13[3];
                     lVar30 = plVar13[1];
                     lVar5 = plVar13[0x10];
                     plVar11[6] = plVar13[2];
                     plVar11[7] = lVar16;
                     lVar16 = plVar13[4];
                     lVar18 = plVar13[5];
                     *(int*)( plVar11 + 0x14 ) = (int)lVar5;
                     plVar11[8] = lVar16;
                     plVar11[9] = lVar18;
                     lVar16 = plVar13[6];
                     lVar18 = plVar13[7];
                     *(char*)( plVar11 + 5 ) = (char)lVar30;
                     plVar11[10] = lVar16;
                     plVar11[0xb] = lVar18;
                     lVar16 = plVar13[9];
                     plVar11[0xc] = plVar13[8];
                     plVar11[0xd] = lVar16;
                     lVar16 = plVar13[0xb];
                     plVar11[0xe] = plVar13[10];
                     plVar11[0xf] = lVar16;
                     bVar24 = *(byte*)( (long)plVar13 + 9 ) & 0xf;
                     *(byte*)( (long)plVar11 + 0x29 ) = *(byte*)( (long)plVar11 + 0x29 ) & 0xf0 | bVar24;
                     *(byte*)( (long)plVar11 + 0x29 ) = bVar24 | *(byte*)( (long)plVar13 + 9 ) & 0xf0;
                     bVar24 = *(byte*)( (long)plVar11 + 0x2a );
                     bVar25 = *(byte*)( (long)plVar13 + 10 ) & 0xf;
                     *(byte*)( (long)plVar11 + 0x2a ) = bVar24 & 0xf0 | bVar25;
                     bVar26 = *(byte*)( (long)plVar13 + 10 ) & 0x10;
                     *(byte*)( (long)plVar11 + 0x2a ) = bVar24 & 0xe0 | bVar25 | bVar26;
                     lVar18 = plVar13[0xe];
                     lVar30 = plVar13[0xf];
                     plVar11[0x10] = plVar13[0xc];
                     lVar16 = plVar13[0xd];
                     plVar11[0x12] = lVar18;
                     plVar11[0x13] = lVar30;
                     plVar11[0x11] = lVar16;
                     lVar16 = plVar13[0x12];
                     plVar11[0x15] = plVar13[0x11];
                     plVar11[0x16] = lVar16;
                     bVar27 = *(byte*)( (long)plVar13 + 10 ) & 0x20;
                     *(byte*)( (long)plVar11 + 0x2a ) = bVar24 & 0xc0 | bVar25 | bVar26 | bVar27;
                     *(byte*)( (long)plVar11 + 0x2a ) = bVar24 & 0x80 | bVar25 | bVar26 | bVar27 | *(byte*)( (long)plVar13 + 10 ) & 0x40;
                     *(ushort*)( (long)plVar11 + 0x2a ) = *(ushort*)( (long)plVar11 + 0x2a ) & 0xfc7f | *(ushort*)( (long)plVar13 + 10 ) & 0x380;
                     *(byte*)( (long)plVar11 + 0x2b ) = *(byte*)( (long)plVar11 + 0x2b ) & 0xfb | *(byte*)( (long)plVar13 + 0xb ) & 4;
                  }
 else {
                     ( *pcVar2 )(plVar11);
                  }

                  goto LAB_00148d88;
               }

            }
 else {
               cVar7 = ( **(code**)( *plVar13 + 0x188 ) )();
               if (cVar7 == '\0') goto LAB_0014a005;
            }

         }

         LAB_00149a98:if (plVar11 != (long*)0x0) goto LAB_00148d88;
         goto LAB_00148d65;
      }

      /* glslang::TSmallArrayVector::~TSmallArrayVector() */
      void glslang::TSmallArrayVector::~TSmallArrayVector(TSmallArrayVector *this) {
         return;
      }

      /* glslang::TType::~TType() */
      void glslang::TType::~TType(TType *this) {
         return;
      }

      /* glslang::TType::hideMember() */
      void glslang::TType::hideMember(TType *this) {
         *(ushort*)( this + 8 ) = *(ushort*)( this + 8 ) & 0xf000 | 0x100;
         return;
      }

      /* glslang::TType::hiddenMember() const */
      bool glslang::TType::hiddenMember(TType *this) {
         return this[8] == (TType)0x0;
      }

      /* glslang::TType::getTypeName[abi:cxx11]() const */
      undefined8 glslang::TType::getTypeName_abi_cxx11_(TType *this) {
         return *(undefined8*)( this + 0x78 );
      }

      /* glslang::TType::getFieldName[abi:cxx11]() const */
      undefined8 glslang::TType::getFieldName_abi_cxx11_(TType *this) {
         return *(undefined8*)( this + 0x70 );
      }

      /* glslang::TType::getBasicType() const */
      TType glslang::TType::getBasicType(TType *this) {
         return this[8];
      }

      /* glslang::TType::getSampler() const */
      TType * __thiscallglslang::TType::getSampler(TType * this);
      {
         return this + 0x80;
      }

      /* glslang::TType::getSampler() */
      TType * __thiscallglslang::TType::getSampler(TType * this);
      {
         return this + 0x80;
      }

      /* glslang::TType::getQualifier() */
      TType * __thiscallglslang::TType::getQualifier(TType * this);
      {
         return this + 0x10;
      }

      /* glslang::TType::getQualifier() const */
      TType * __thiscallglslang::TType::getQualifier(TType * this);
      {
         return this + 0x10;
      }

      /* glslang::TType::getVectorSize() const */
      byte glslang::TType::getVectorSize(TType *this) {
         return (byte)this[9] & 0xf;
      }

      /* glslang::TType::getMatrixCols() const */
      byte glslang::TType::getMatrixCols(TType *this) {
         return (byte)this[9] >> 4;
      }

      /* glslang::TType::getMatrixRows() const */
      byte glslang::TType::getMatrixRows(TType *this) {
         return (byte)this[10] & 0xf;
      }

      /* glslang::TType::getOuterArraySize() const */
      undefined4 glslang::TType::getOuterArraySize(TType *this) {
         return **(undefined4**)( *(long*)( *(long*)( this + 0x60 ) + 8 ) + 8 );
      }

      /* glslang::TType::getOuterArrayNode() const */
      undefined8 glslang::TType::getOuterArrayNode(TType *this) {
         return *(undefined8*)( *(long*)( *(long*)( *(long*)( this + 0x60 ) + 8 ) + 8 ) + 8 );
      }

      /* glslang::TType::getImplicitArraySize() const */
      int glslang::TType::getImplicitArraySize(TType *this) {
         int iVar1;
         iVar1 = *(int*)( *(long*)( this + 0x60 ) + 0x10 );
         if (iVar1 < 1) {
            iVar1 = 1;
         }

         return iVar1;
      }

      /* glslang::TType::getArraySizes() const */
      undefined8 glslang::TType::getArraySizes(TType *this) {
         return *(undefined8*)( this + 0x60 );
      }

      /* glslang::TType::getArraySizes() */
      undefined8 glslang::TType::getArraySizes(TType *this) {
         return *(undefined8*)( this + 0x60 );
      }

      /* glslang::TType::getReferentType() const */
      undefined8 glslang::TType::getReferentType(TType *this) {
         return *(undefined8*)( this + 0x68 );
      }

      /* glslang::TType::getTypeParameters() const */
      undefined8 glslang::TType::getTypeParameters(TType *this) {
         return *(undefined8*)( this + 0x88 );
      }

      /* glslang::TType::getTypeParameters() */
      undefined8 glslang::TType::getTypeParameters(TType *this) {
         return *(undefined8*)( this + 0x88 );
      }

      /* glslang::TType::isVector() const */
      byte glslang::TType::isVector(TType *this) {
         if (1 < ( (byte)this[9] & 0xf )) {
            return 1;
         }

         return (byte)this[10] >> 4 & 1;
      }

      /* glslang::TType::isMatrix() const */
      bool glslang::TType::isMatrix(TType *this) {
         return 0xf < (byte)this[9];
      }

      /* glslang::TType::isArray() const */
      bool glslang::TType::isArray(TType *this) {
         return *(long*)( this + 0x60 ) != 0;
      }

      /* glslang::TType::isArrayVariablyIndexed() const */
      undefined1 glslang::TType::isArrayVariablyIndexed(TType *this) {
         return *(undefined1*)( *(long*)( this + 0x60 ) + 0x15 );
      }

      /* glslang::TType::setArrayVariablyIndexed() */
      void glslang::TType::setArrayVariablyIndexed(TType *this) {
         *(undefined1*)( *(long*)( this + 0x60 ) + 0x15 ) = 1;
         return;
      }

      /* glslang::TType::updateImplicitArraySize(int) */
      void glslang::TType::updateImplicitArraySize(TType *this, int param_1) {
         int iVar1;
         iVar1 = *(int*)( *(long*)( this + 0x60 ) + 0x10 );
         if (iVar1 < param_1) {
            iVar1 = param_1;
         }

         *(int*)( *(long*)( this + 0x60 ) + 0x10 ) = iVar1;
         return;
      }

      /* glslang::TType::setImplicitlySized(bool) */
      void glslang::TType::setImplicitlySized(TType *this, bool param_1) {
         *(bool*)( *(long*)( this + 0x60 ) + 0x14 ) = param_1;
         return;
      }

      /* glslang::TType::isStruct() const */
      undefined4 glslang::TType::isStruct(TType *this) {
         return CONCAT31(( int3 )((byte)this[8] - 0xf >> 8), ( byte )((byte)this[8] - 0xf) < 2);
      }

      /* glslang::TType::isFloatingDomain() const */
      undefined4 glslang::TType::isFloatingDomain(TType *this) {
         return CONCAT31(( int3 )((byte)this[8] - 1 >> 8), ( byte )((byte)this[8] - 1) < 3);
      }

      /* glslang::TType::isIntegerDomain() const */
      bool glslang::TType::isIntegerDomain(TType *this) {
         TType TVar1;
         TVar1 = this[8];
         if ((byte)TVar1 < 0xc) {
            return 3 < (byte)TVar1;
         }

         return TVar1 == (TType)0xd;
      }

      /* glslang::TType::isOpaque() const */
      undefined8 glslang::TType::isOpaque(TType *this) {
         undefined8 uVar1;
         uVar1 = 0;
         if ((byte)this[8] < 0x15) {
            uVar1 = CONCAT71(0x1a60, ( 0x1a6000UL >> ( (ulong)(byte)this[8] & 0x3f ) & 1 ) != 0);
         }

         return uVar1;
      }

      /* glslang::TType::isParameterized() const */
      bool glslang::TType::isParameterized(TType *this) {
         return *(long*)( this + 0x88 ) != 0;
      }

      /* glslang::TConstUnionArray::~TConstUnionArray() */
      void glslang::TConstUnionArray::~TConstUnionArray(TConstUnionArray *this) {
         return;
      }

      /* TIntermNode::getLoc() const */
      TIntermNode * TIntermNode::getLoc(TIntermNode * this);
      {
         return this + 8;
      }

      /* TIntermNode::setLoc(glslang::TSourceLoc const&) */
      void TIntermNode::setLoc(TIntermNode *this, TSourceLoc *param_1) {
         undefined8 uVar1;
         uVar1 = *(undefined8*)( param_1 + 8 );
         *(undefined8*)( this + 8 ) = *(undefined8*)param_1;
         *(undefined8*)( this + 0x10 ) = uVar1;
         *(undefined8*)( this + 0x18 ) = *(undefined8*)( param_1 + 0x10 );
         return;
      }

      /* glslang::TIntermTyped::getAsTyped() */
      TIntermTyped * __thiscallglslang::TIntermTyped::getAsTyped(TIntermTyped * this);
      {
         return this;
      }

      /* glslang::TIntermTyped::getType() const */
      TIntermTyped * __thiscallglslang::TIntermTyped::getType(TIntermTyped * this);
      {
         return this + 0x20;
      }

      /* glslang::TIntermTyped::getWritableType() */
      TIntermTyped * __thiscallglslang::TIntermTyped::getWritableType(TIntermTyped * this);
      {
         return this + 0x20;
      }

      /* glslang::TIntermTyped::getBasicType() const */
      TIntermTyped glslang::TIntermTyped::getBasicType(TIntermTyped *this) {
         return this[0x28];
      }

      /* glslang::TIntermTyped::getQualifier() */
      TIntermTyped * __thiscallglslang::TIntermTyped::getQualifier(TIntermTyped * this);
      {
         return this + 0x30;
      }

      /* glslang::TIntermTyped::getQualifier() const */
      TIntermTyped * __thiscallglslang::TIntermTyped::getQualifier(TIntermTyped * this);
      {
         return this + 0x30;
      }

      /* glslang::TIntermTyped::getVectorSize() const */
      byte glslang::TIntermTyped::getVectorSize(TIntermTyped *this) {
         return (byte)this[0x29] & 0xf;
      }

      /* glslang::TIntermTyped::isMatrix() const */
      bool glslang::TIntermTyped::isMatrix(TIntermTyped *this) {
         return 0xf < (byte)this[0x29];
      }

      /* glslang::TIntermTyped::isArray() const */
      bool glslang::TIntermTyped::isArray(TIntermTyped *this) {
         return *(long*)( this + 0x80 ) != 0;
      }

      /* glslang::TIntermTyped::isVector() const */
      byte glslang::TIntermTyped::isVector(TIntermTyped *this) {
         if (1 < ( (byte)this[0x29] & 0xf )) {
            return 1;
         }

         return (byte)this[0x2a] >> 4 & 1;
      }

      /* glslang::TIntermTyped::isStruct() const */
      undefined4 glslang::TIntermTyped::isStruct(TIntermTyped *this) {
         return CONCAT31(( int3 )((byte)this[0x28] - 0xf >> 8), ( byte )((byte)this[0x28] - 0xf) < 2);
      }

      /* glslang::TIntermTyped::isFloatingDomain() const */
      undefined4 glslang::TIntermTyped::isFloatingDomain(TIntermTyped *this) {
         return CONCAT31(( int3 )((byte)this[0x28] - 1 >> 8), ( byte )((byte)this[0x28] - 1) < 3);
      }

      /* glslang::TIntermTyped::isIntegerDomain() const */
      bool glslang::TIntermTyped::isIntegerDomain(TIntermTyped *this) {
         TIntermTyped TVar1;
         TVar1 = this[0x28];
         if ((byte)TVar1 < 0xc) {
            return 3 < (byte)TVar1;
         }

         return TVar1 == (TIntermTyped)0xd;
      }

      /* glslang::TIntermSymbol::getId() const */
      undefined8 glslang::TIntermSymbol::getId(TIntermSymbol *this) {
         return *(undefined8*)( this + 0xb8 );
      }

      /* glslang::TIntermSymbol::getName[abi:cxx11]() const */
      TIntermSymbol * __thiscallglslang::TIntermSymbol::getName_abi_cxx11_(TIntermSymbol * this);
      {
         return this + 200;
      }

      /* glslang::TIntermConstantUnion::getAsConstantUnion() */
      TIntermConstantUnion * __thiscallglslang::TIntermConstantUnion::getAsConstantUnion(TIntermConstantUnion * this);
      {
         return this;
      }

      /* glslang::TIntermBinary::getLeft() const */
      undefined8 glslang::TIntermBinary::getLeft(TIntermBinary *this) {
         return *(undefined8*)( this + 0xc0 );
      }

      /* glslang::TIntermBinary::getRight() const */
      undefined8 glslang::TIntermBinary::getRight(TIntermBinary *this) {
         return *(undefined8*)( this + 200 );
      }

      /* glslang::TIntermUnary::getOperand() */
      undefined8 glslang::TIntermUnary::getOperand(TIntermUnary *this) {
         return *(undefined8*)( this + 0xc0 );
      }

      /* glslang::TIntermAggregate::setOperator(glslang::TOperator) */
      void glslang::TIntermAggregate::setOperator(TIntermAggregate *this, undefined4 param_2) {
         *(undefined4*)( this + 0xb8 ) = param_2;
         return;
      }

      /* glslang::TIntermAggregate::getSequence() */
      TIntermAggregate * __thiscallglslang::TIntermAggregate::getSequence(TIntermAggregate * this);
      {
         return this + 0xc0;
      }

      /* glslang::TIntermAggregate::getSequence() const */
      TIntermAggregate * __thiscallglslang::TIntermAggregate::getSequence(TIntermAggregate * this);
      {
         return this + 0xc0;
      }

      /* glslang::TIntermAggregate::setUserDefined() */
      void glslang::TIntermAggregate::setUserDefined(TIntermAggregate *this) {
         this[0x128] = (TIntermAggregate)0x1;
         return;
      }

      /* glslang::TIntermAggregate::getQualifierList() */
      TIntermAggregate * __thiscallglslang::TIntermAggregate::getQualifierList(TIntermAggregate * this);
      {
         return this + 0xe0;
      }

      /* glslang::TIntermTraverser::~TIntermTraverser() */
      void glslang::TIntermTraverser::~TIntermTraverser(TIntermTraverser *this) {
         return;
      }

      /* glslang::TIntermTraverser::visitSymbol(glslang::TIntermSymbol*) */
      void glslang::TIntermTraverser::visitSymbol(TIntermSymbol *param_1) {
         return;
      }

      /* glslang::TIntermTraverser::visitConstantUnion(glslang::TIntermConstantUnion*) */
      void glslang::TIntermTraverser::visitConstantUnion(TIntermConstantUnion *param_1) {
         return;
      }

      /* glslang::TIntermTraverser::visitBinary(glslang::TVisit, glslang::TIntermBinary*) */
      undefined8 glslang::TIntermTraverser::visitBinary(void) {
         return 1;
      }

      /* glslang::TIntermTraverser::visitUnary(glslang::TVisit, glslang::TIntermUnary*) */
      undefined8 glslang::TIntermTraverser::visitUnary(void) {
         return 1;
      }

      /* glslang::TIntermTraverser::visitSelection(glslang::TVisit, glslang::TIntermSelection*) */
      undefined8 glslang::TIntermTraverser::visitSelection(void) {
         return 1;
      }

      /* glslang::TIntermTraverser::visitAggregate(glslang::TVisit, glslang::TIntermAggregate*) */
      undefined8 glslang::TIntermTraverser::visitAggregate(void) {
         return 1;
      }

      /* glslang::TIntermTraverser::visitLoop(glslang::TVisit, glslang::TIntermLoop*) */
      undefined8 glslang::TIntermTraverser::visitLoop(void) {
         return 1;
      }

      /* glslang::TIntermTraverser::visitBranch(glslang::TVisit, glslang::TIntermBranch*) */
      undefined8 glslang::TIntermTraverser::visitBranch(void) {
         return 1;
      }

      /* glslang::TIntermTraverser::visitSwitch(glslang::TVisit, glslang::TIntermSwitch*) */
      undefined8 glslang::TIntermTraverser::visitSwitch(void) {
         return 1;
      }

      /* glslang::TSymbol::getName[abi:cxx11]() const */
      undefined8 glslang::TSymbol::getName_abi_cxx11_(TSymbol *this) {
         return *(undefined8*)( this + 8 );
      }

      /* glslang::TSymbol::changeName(std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const*) */
      void glslang::TSymbol::changeName(TSymbol *this, basic_string *param_1) {
         *(basic_string**)( this + 8 ) = param_1;
         return;
      }

      /* glslang::TSymbol::setUniqueId(long long) */
      void glslang::TSymbol::setUniqueId(TSymbol *this, longlong param_1) {
         *(longlong*)( this + 0x10 ) = param_1;
         return;
      }

      /* glslang::TSymbol::getUniqueId() const */
      undefined8 glslang::TSymbol::getUniqueId(TSymbol *this) {
         return *(undefined8*)( this + 0x10 );
      }

      /* glslang::TSymbol::getNumExtensions() const */
      long glslang::TSymbol::getNumExtensions(TSymbol *this) {
         long lVar1;
         long lVar2;
         lVar1 = *(long*)( this + 0x18 );
         lVar2 = 0;
         if (lVar1 != 0) {
            lVar2 = *(long*)( lVar1 + 0x10 ) - *(long*)( lVar1 + 8 ) >> 3;
         }

         return lVar2;
      }

      /* glslang::TSymbol::getExtensions() const */
      undefined8 glslang::TSymbol::getExtensions(TSymbol *this) {
         return *(undefined8*)( *(long*)( this + 0x18 ) + 8 );
      }

      /* glslang::TSymbol::isReadOnly() const */
      byte glslang::TSymbol::isReadOnly(TSymbol *this) {
         return (byte)this[0x20] ^ 1;
      }

      /* glslang::TVariable::getAsVariable() const */
      TVariable * __thiscallglslang::TVariable::getAsVariable(TVariable * this);
      {
         return this;
      }

      /* glslang::TVariable::getType() const */
      TVariable * __thiscallglslang::TVariable::getType(TVariable * this);
      {
         return this + 0x28;
      }

      /* glslang::TVariable::getWritableType() */
      TVariable * __thiscallglslang::TVariable::getWritableType(TVariable * this);
      {
         return this + 0x28;
      }

      /* glslang::TVariable::getConstArray() const */
      TVariable * __thiscallglslang::TVariable::getConstArray(TVariable * this);
      {
         return this + 200;
      }

      /* glslang::TVariable::getWritableConstArray() */
      TVariable * __thiscallglslang::TVariable::getWritableConstArray(TVariable * this);
      {
         return this + 200;
      }

      /* glslang::TVariable::setConstArray(glslang::TConstUnionArray const&) */
      void glslang::TVariable::setConstArray(TVariable *this, TConstUnionArray *param_1) {
         *(undefined8*)( this + 0xd0 ) = *(undefined8*)( param_1 + 8 );
         return;
      }

      /* glslang::TVariable::setConstSubtree(glslang::TIntermTyped*) */
      void glslang::TVariable::setConstSubtree(TVariable *this, TIntermTyped *param_1) {
         *(TIntermTyped**)( this + 0xd8 ) = param_1;
         return;
      }

      /* glslang::TVariable::setAnonId(int) */
      void glslang::TVariable::setAnonId(TVariable *this, int param_1) {
         *(int*)( this + 0xe8 ) = param_1;
         return;
      }

      /* glslang::TVariable::getAnonId() const */
      undefined4 glslang::TVariable::getAnonId(TVariable *this) {
         return *(undefined4*)( this + 0xe8 );
      }

      /* glslang::TVariable::hasMemberExtensions() const */
      bool glslang::TVariable::hasMemberExtensions(TVariable *this) {
         return *(long*)( this + 0xe0 ) != 0;
      }

      /* glslang::TVariable::getNumMemberExtensions(int) const */
      long glslang::TVariable::getNumMemberExtensions(TVariable *this, int param_1) {
         long lVar1;
         lVar1 = 0;
         if (*(long*)( this + 0xe0 ) != 0) {
            lVar1 = (long)param_1 * 0x20 + *(long*)( *(long*)( this + 0xe0 ) + 8 );
            lVar1 = *(long*)( lVar1 + 0x10 ) - *(long*)( lVar1 + 8 ) >> 3;
         }

         return lVar1;
      }

      /* glslang::TVariable::getMemberExtensions(int) const */
      undefined8 glslang::TVariable::getMemberExtensions(TVariable *this, int param_1) {
         return *(undefined8*)( (long)param_1 * 0x20 + *(long*)( *(long*)( this + 0xe0 ) + 8 ) + 8 );
      }

      /* glslang::TFunction::getMangledName[abi:cxx11]() const */
      TFunction * __thiscallglslang::TFunction::getMangledName_abi_cxx11_(TFunction * this);
      {
         return this + 0xe8;
      }

      /* glslang::TFunction::getType() const */
      TFunction * __thiscallglslang::TFunction::getType(TFunction * this);
      {
         return this + 0x48;
      }

      /* glslang::TFunction::getBuiltInOp() const */
      undefined4 glslang::TFunction::getBuiltInOp(TFunction *this) {
         return *(undefined4*)( this + 0x110 );
      }

      /* glslang::TFunction::setDefined() */
      void glslang::TFunction::setDefined(TFunction *this) {
         this[0x114] = (TFunction)0x1;
         return;
      }

      /* glslang::TFunction::isDefined() const */
      TFunction glslang::TFunction::isDefined(TFunction *this) {
         return this[0x114];
      }

      /* glslang::TFunction::setPrototyped() */
      void glslang::TFunction::setPrototyped(TFunction *this) {
         this[0x115] = (TFunction)0x1;
         return;
      }

      /* glslang::TFunction::isPrototyped() const */
      TFunction glslang::TFunction::isPrototyped(TFunction *this) {
         return this[0x115];
      }

      /* glslang::TFunction::getParamCount() const */
      int glslang::TFunction::getParamCount(TFunction *this) {
         return (int)( *(long*)( this + 0x38 ) - *(long*)( this + 0x30 ) >> 3 ) * -0x55555555;
      }

      /* glslang::TFunction::operator[](int) */
      long glslang::TFunction::operator [](TFunction *this, int param_1) {
         return *(long*)( this + 0x30 ) + (long)param_1 * 0x18;
      }

      /* glslang::TFunction::operator[](int) const */
      long glslang::TFunction::operator [](TFunction *this, int param_1) {
         return *(long*)( this + 0x30 ) + (long)param_1 * 0x18;
      }

      /* glslang::TFunction::getSpirvInstruction() const */
      TFunction * __thiscallglslang::TFunction::getSpirvInstruction(TFunction * this);
      {
         return this + 0x120;
      }

      /* glslang::TAnonMember::getAnonContainer() const */
      undefined8 glslang::TAnonMember::getAnonContainer(TAnonMember *this) {
         return *(undefined8*)( this + 0x28 );
      }

      /* glslang::TAnonMember::getMemberNumber() const */
      undefined4 glslang::TAnonMember::getMemberNumber(TAnonMember *this) {
         return *(undefined4*)( this + 0x30 );
      }

      /* glslang::TPrecisionManager::~TPrecisionManager() */
      void glslang::TPrecisionManager::~TPrecisionManager(TPrecisionManager *this) {
         return;
      }

      /* glslang::AccessChainTraverser::~AccessChainTraverser() */
      void glslang::AccessChainTraverser::~AccessChainTraverser(AccessChainTraverser *this) {
         return;
      }

      /* glslang::TPrecisionManager::~TPrecisionManager() */
      void glslang::TPrecisionManager::~TPrecisionManager(TPrecisionManager *this) {
         operator_delete(this, 0x10);
         return;
      }

      /* glslang::TParseContextBase::notifyVersion(int, int, char const*) */
      void glslang::TParseContextBase::notifyVersion(TParseContextBase *this, int param_1, int param_2, char *param_3) {
         long in_FS_OFFSET;
         int local_20;
         int local_1c;
         char *local_18;
         long local_10;
         local_10 = *(long*)( in_FS_OFFSET + 0x28 );
         if (*(long*)( this + 0x420 ) != 0) {
            local_20 = param_1;
            local_1c = param_2;
            local_18 = param_3;
            ( **(code**)( this + 0x428 ) )(this + 0x410, &local_20, &local_1c, &local_18);
         }

         if (local_10 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return;
         }

         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      /* glslang::TParseContextBase::notifyErrorDirective(int, char const*) */
      void glslang::TParseContextBase::notifyErrorDirective(TParseContextBase *this, int param_1, char *param_2) {
         long in_FS_OFFSET;
         int local_1c;
         char *local_18;
         long local_10;
         local_10 = *(long*)( in_FS_OFFSET + 0x28 );
         if (*(long*)( this + 0x460 ) != 0) {
            local_1c = param_1;
            local_18 = param_2;
            ( **(code**)( this + 0x468 ) )(this + 0x450, &local_1c, &local_18, 0);
         }

         if (local_10 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return;
         }

         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      /* glslang::TParseContextBase::notifyLineDirective(int, int, bool, int, char const*) */
      void glslang::TParseContextBase::notifyLineDirective(TParseContextBase *this, int param_1, int param_2, bool param_3, int param_4, char *param_5) {
         long in_FS_OFFSET;
         undefined1 local_25;
         int local_24;
         int local_20;
         int local_1c;
         char *local_18;
         long local_10;
         local_10 = *(long*)( in_FS_OFFSET + 0x28 );
         if (*(long*)( this + 0x3e0 ) != 0) {
            local_25 = param_3;
            local_24 = param_1;
            local_20 = param_2;
            local_1c = param_4;
            local_18 = param_5;
            ( **(code**)( this + 1000 ) )(this + 0x3d0, &local_24, &local_20, &local_25, &local_1c, &local_18);
         }

         if (local_10 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return;
         }

         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      /* glslang::TParseContextBase::notifyExtensionDirective(int, char const*, char const*) */
      void glslang::TParseContextBase::notifyExtensionDirective(TParseContextBase *this, int param_1, char *param_2, char *param_3) {
         long in_FS_OFFSET;
         int local_24;
         char *local_20;
         char *local_18;
         long local_10;
         local_10 = *(long*)( in_FS_OFFSET + 0x28 );
         if (*(long*)( this + 0x440 ) != 0) {
            local_24 = param_1;
            local_20 = param_2;
            local_18 = param_3;
            ( **(code**)( this + 0x448 ) )(this + 0x430, &local_24, &local_20, &local_18);
         }

         if (local_10 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return;
         }

         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      /* std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>*,
   std::pair<glslang::TVector<glslang::TTypeLoc>* const, glslang::TVector<glslang::TTypeLoc>*>,
   std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>* const,
   glslang::TVector<glslang::TTypeLoc>*> >, std::less<glslang::TVector<glslang::TTypeLoc>*>,
   glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>* const,
   glslang::TVector<glslang::TTypeLoc>*> >
   >::_M_get_insert_unique_pos(glslang::TVector<glslang::TTypeLoc>* const&) [clone .isra.0] */
      undefined1[16];
      std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>*,std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>>,std::less<glslang::TVector<glslang::TTypeLoc>*>,glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>>>::_M_get_insert_unique_pos (_Rb_tree<glslang::TVector<glslang::TTypeLoc>*,std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>>,std::less<glslang::TVector<glslang::TTypeLoc>*>,glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>>>
           *this,TVector **param_1) {
         undefined1 auVar1[16];
         _Rb_tree_node_base *p_Var2;
         _Rb_tree_node_base *p_Var3;
         _Rb_tree_node_base *p_Var4;
         TVector **ppTVar5;
         undefined1 auVar6[16];
         p_Var2 = *(_Rb_tree_node_base**)( this + 0x18 );
         if (*(_Rb_tree_node_base**)( this + 0x18 ) == (_Rb_tree_node_base*)0x0) {
            p_Var2 = (_Rb_tree_node_base*)( this + 0x10 );
         }
 else {
            do {
               p_Var4 = p_Var2;
               ppTVar5 = *(TVector***)( p_Var4 + 0x20 );
               p_Var2 = *(_Rb_tree_node_base**)( p_Var4 + 0x18 );
               if (param_1 < ppTVar5) {
                  p_Var2 = *(_Rb_tree_node_base**)( p_Var4 + 0x10 );
               }

            }
 while ( p_Var2 != (_Rb_tree_node_base*)0x0 );
            p_Var2 = p_Var4;
            if (param_1 >= ppTVar5) goto LAB_00154b9a;
         }

         if (*(_Rb_tree_node_base**)( this + 0x20 ) == p_Var2) {
            auVar1._8_8_ = 0;
            auVar1._0_8_ = p_Var2;
            return auVar1 << 0x40;
         }

         p_Var4 = (_Rb_tree_node_base*)std::_Rb_tree_decrement(p_Var2);
         ppTVar5 = *(TVector***)( p_Var4 + 0x20 );
         LAB_00154b9a:p_Var3 = (_Rb_tree_node_base*)0x0;
         if (ppTVar5 < param_1) {
            p_Var4 = p_Var3;
            p_Var3 = p_Var2;
         }

         auVar6._8_8_ = p_Var3;
         auVar6._0_8_ = p_Var4;
         return auVar6;
      }

      /* std::vector<glslang::TSpirvTypeParameter, glslang::pool_allocator<glslang::TSpirvTypeParameter>
   >::TEMPNAMEPLACEHOLDERVALUE(std::vector<glslang::TSpirvTypeParameter,
   glslang::pool_allocator<glslang::TSpirvTypeParameter> > const&) [clone .isra.0] */
      void std::vector<glslang::TSpirvTypeParameter,glslang::pool_allocator<glslang::TSpirvTypeParameter>>::operator =(vector<glslang::TSpirvTypeParameter,glslang::pool_allocator<glslang::TSpirvTypeParameter>> *this, vector *param_1) {
         undefined8 uVar1;
         long lVar2;
         long lVar3;
         size_t __n;
         ulong uVar4;
         undefined8 *puVar5;
         undefined8 *__dest;
         ulong __n_00;
         long lVar6;
         undefined8 *puVar7;
         if (param_1 == (vector*)this) {
            return;
         }

         puVar7 = *(undefined8**)( param_1 + 0x10 );
         puVar5 = *(undefined8**)( param_1 + 8 );
         __dest = *(undefined8**)( this + 8 );
         __n_00 = (long)puVar7 - (long)puVar5;
         if (( ulong )(*(long*)( this + 0x18 ) - (long)__dest) < __n_00) {
            lVar2 = glslang::TPoolAllocator::allocate(*(ulong*)this);
            uVar4 = 0;
            if (puVar7 != puVar5) {
               do {
                  uVar1 = ( (undefined8*)( (long)puVar5 + uVar4 ) )[1];
                  *(undefined8*)( lVar2 + uVar4 ) = *(undefined8*)( (long)puVar5 + uVar4 );
                  ( (undefined8*)( lVar2 + uVar4 ) )[1] = uVar1;
                  uVar4 = uVar4 + 0x10;
               }
 while ( uVar4 != __n_00 );
            }

            *(long*)( this + 8 ) = lVar2;
            *(ulong*)( this + 0x18 ) = __n_00 + lVar2;
            *(ulong*)( this + 0x10 ) = __n_00 + lVar2;
            return;
         }

         lVar2 = *(long*)( this + 0x10 );
         __n = lVar2 - (long)__dest;
         if (__n < __n_00) {
            if ((long)__n < 0x11) {
               if (__n == 0x10) {
                  uVar1 = puVar5[1];
                  *__dest = *puVar5;
                  __dest[1] = uVar1;
               }

            }
 else {
               memmove(__dest, puVar5, __n);
               lVar2 = *(long*)( this + 0x10 );
               __dest = *(undefined8**)( this + 8 );
               puVar7 = *(undefined8**)( param_1 + 0x10 );
               puVar5 = *(undefined8**)( param_1 + 8 );
               __n = lVar2 - (long)__dest;
            }

            puVar5 = (undefined8*)( (long)puVar5 + __n );
            lVar6 = __n_00 + (long)__dest;
            if (puVar5 != puVar7) {
               lVar3 = 0;
               do {
                  uVar1 = ( (undefined8*)( (long)puVar5 + lVar3 ) )[1];
                  *(undefined8*)( lVar2 + lVar3 ) = *(undefined8*)( (long)puVar5 + lVar3 );
                  ( (undefined8*)( lVar2 + lVar3 ) )[1] = uVar1;
                  lVar3 = lVar3 + 0x10;
               }
 while ( lVar3 != (long)puVar7 - (long)puVar5 );
               *(long*)( this + 0x10 ) = lVar6;
               return;
            }

         }
 else if ((long)__n_00 < 0x11) {
            if (__n_00 == 0x10) {
               uVar1 = puVar5[1];
               *__dest = *puVar5;
               __dest[1] = uVar1;
            }

            lVar6 = __n_00 + (long)__dest;
         }
 else {
            memmove(__dest, puVar5, __n_00);
            lVar6 = __n_00 + *(long*)( this + 8 );
         }

         *(long*)( this + 0x10 ) = lVar6;
         return;
      }

      /* glslang::TType::isBuiltIn() const */
      bool glslang::TType::isBuiltIn(TType *this) {
         long lVar1;
         if (*(code**)( *(long*)this + 0x58 ) == getQualifier) {
            return 0x7f < *(ushort*)( this + 0x18 );
         }

         lVar1 = ( **(code**)( *(long*)this + 0x58 ) )();
         return 0x7f < *(ushort*)( lVar1 + 8 );
      }

      /* glslang::TType::isAttachmentEXT() const */
      bool glslang::TType::isAttachmentEXT(TType *this) {
         long lVar1;
         if (this[8] != (TType)0xe) {
            return false;
         }

         if (*(code**)( *(long*)this + 0x40 ) == getSampler) {
            return this[0x81] == (TType)0x8;
         }

         lVar1 = ( **(code**)( *(long*)this + 0x40 ) )();
         return *(char*)( lVar1 + 1 ) == '\b';
      }

      /* glslang::TType::isImage() const */
      undefined4 glslang::TType::isImage(TType *this) {
         int iVar1;
         undefined4 uVar2;
         long lVar3;
         if (this[8] == (TType)0xe) {
            if (*(code**)( *(long*)this + 0x40 ) != getSampler) {
               lVar3 = ( **(code**)( *(long*)this + 0x40 ) )();
               uVar2 = 0;
               if (( *(byte*)( lVar3 + 2 ) & 8 ) != 0) {
                  iVar1 = *(byte*)( lVar3 + 1 ) - 7;
                  uVar2 = CONCAT31(( int3 )((uint)iVar1 >> 8), 1 < (byte)iVar1);
               }

               return uVar2;
            }

            if (( (byte)this[0x82] & 8 ) != 0) {
               return CONCAT31(( int3 )((byte)this[0x81] - 7 >> 8), 1 < ( byte )((byte)this[0x81] - 7));
            }

         }

         return 0;
      }

      /* glslang::TType::isSubpass() const */
      bool glslang::TType::isSubpass(TType *this) {
         long lVar1;
         if (this[8] != (TType)0xe) {
            return false;
         }

         if (*(code**)( *(long*)this + 0x40 ) == getSampler) {
            return this[0x81] == (TType)0x7;
         }

         lVar1 = ( **(code**)( *(long*)this + 0x40 ) )();
         return *(char*)( lVar1 + 1 ) == '\a';
      }

      /* glslang::TType::isTexture() const */
      byte glslang::TType::isTexture(TType *this) {
         byte bVar1;
         long lVar2;
         if (this[8] == (TType)0xe) {
            if (*(code**)( *(long*)this + 0x40 ) != getSampler) {
               lVar2 = ( **(code**)( *(long*)this + 0x40 ) )();
               if (( *(byte*)( lVar2 + 2 ) & 0x20 ) == 0) {
                  bVar1 = *(byte*)( lVar2 + 2 ) >> 3 & 1 ^ 1;
               }
 else {
                  bVar1 = 0;
               }

               return bVar1;
            }

            if (( (byte)this[0x82] & 0x20 ) == 0) {
               return (byte)this[0x82] >> 3 & 1 ^ 1;
            }

         }

         return 0;
      }

      /* glslang::TSymbol::getMangledName[abi:cxx11]() const */
      undefined8 glslang::TSymbol::getMangledName_abi_cxx11_(TSymbol *this) {
         undefined8 uVar1;
         if (*(code**)( *(long*)this + 0x18 ) == getName_abi_cxx11_) {
            return *(undefined8*)( this + 8 );
         }

         /* WARNING: Could not recover jumptable at 0x001564e0. Too many branches */
         /* WARNING: Treating indirect jump as call */
         uVar1 = ( **(code**)( *(long*)this + 0x18 ) )();
         return uVar1;
      }

      /* glslang::TType::isSizedArray() const */
      undefined4 glslang::TType::isSizedArray(TType *this) {
         int iVar1;
         undefined4 uVar2;
         char cVar3;
         if (*(code**)( *(long*)this + 0xe8 ) == isArray) {
            if (*(long*)( this + 0x60 ) == 0) {
               return 0;
            }

            iVar1 = **(int**)( *(long*)( *(long*)( this + 0x60 ) + 8 ) + 8 );
            uVar2 = CONCAT31(( int3 )((uint)iVar1 >> 8), iVar1 != 0);
         }
 else {
            cVar3 = ( **(code**)( *(long*)this + 0xe8 ) )();
            if (cVar3 == '\0') {
               return 0;
            }

            iVar1 = **(int**)( *(long*)( *(long*)( this + 0x60 ) + 8 ) + 8 );
            uVar2 = CONCAT31(( int3 )((uint)iVar1 >> 8), iVar1 != 0);
         }

         return uVar2;
      }

      /* glslang::TType::isUnsizedArray() const */
      undefined4 glslang::TType::isUnsizedArray(TType *this) {
         int iVar1;
         undefined4 uVar2;
         char cVar3;
         if (*(code**)( *(long*)this + 0xe8 ) == isArray) {
            if (*(long*)( this + 0x60 ) == 0) {
               return 0;
            }

            iVar1 = **(int**)( *(long*)( *(long*)( this + 0x60 ) + 8 ) + 8 );
            uVar2 = CONCAT31(( int3 )((uint)iVar1 >> 8), iVar1 == 0);
         }
 else {
            cVar3 = ( **(code**)( *(long*)this + 0xe8 ) )();
            if (cVar3 == '\0') {
               return 0;
            }

            iVar1 = **(int**)( *(long*)( *(long*)( this + 0x60 ) + 8 ) + 8 );
            uVar2 = CONCAT31(( int3 )((uint)iVar1 >> 8), iVar1 == 0);
         }

         return uVar2;
      }

      /* glslang::TType::isImplicitlySizedArray() const */
      undefined1 glslang::TType::isImplicitlySizedArray(TType *this) {
         undefined1 uVar1;
         char cVar2;
         if (*(code**)( *(long*)this + 0xe8 ) == isArray) {
            if (*(long*)( this + 0x60 ) == 0) {
               return 0;
            }

            uVar1 = *(undefined1*)( *(long*)( this + 0x60 ) + 0x14 );
         }
 else {
            cVar2 = ( **(code**)( *(long*)this + 0xe8 ) )();
            if (cVar2 == '\0') {
               return 0;
            }

            uVar1 = *(undefined1*)( *(long*)( this + 0x60 ) + 0x14 );
         }

         return uVar1;
      }

      /* glslang::TType::isUnusableName() const */
      bool glslang::TType::isUnusableName(TType *this) {
         char cVar1;
         if (*(code**)( *(long*)this + 0x128 ) == isStruct) {
            if (1 < ( byte )((char)this[8] - 0xfU)) {
               return false;
            }

         }
 else {
            cVar1 = ( **(code**)( *(long*)this + 0x128 ) )();
            if (cVar1 == '\0') {
               return false;
            }

         }

         return *(long*)( this + 0x68 ) == 0;
      }

      /* glslang::TType::isScalarOrVector() const */
      uint glslang::TType::isScalarOrVector(TType *this) {
         char cVar1;
         uint uVar2;
         long lVar3;
         lVar3 = *(long*)this;
         if (*(code**)( lVar3 + 0xe0 ) == isMatrix) {
            if (0xf < (byte)this[9]) {
               return 0;
            }

         }
 else {
            cVar1 = ( **(code**)( lVar3 + 0xe0 ) )();
            if (cVar1 != '\0') {
               return 0;
            }

            lVar3 = *(long*)this;
         }

         if (*(code**)( lVar3 + 0x128 ) == isStruct) {
            if (( byte )((char)this[8] - 0xfU) < 2) {
               return 0;
            }

         }
 else {
            cVar1 = ( **(code**)( lVar3 + 0x128 ) )(this);
            if (cVar1 != '\0') {
               return 0;
            }

            lVar3 = *(long*)this;
         }

         if (*(code**)( lVar3 + 0xe8 ) == isArray) {
            uVar2 = (uint)CONCAT71(0x14ac, *(long*)( this + 0x60 ) != 0);
         }
 else {
            uVar2 = ( **(code**)( lVar3 + 0xe8 ) )(this);
         }

         return uVar2 ^ 1;
      }

      /* glslang::TType::isScalar() const */
      uint glslang::TType::isScalar(TType *this) {
         byte bVar1;
         char cVar2;
         uint uVar3;
         long lVar4;
         if (*(code**)( *(long*)this + 0xd8 ) == isVector) {
            if (1 < ( (byte)this[9] & 0xf )) {
               return 0;
            }

            bVar1 = (byte)this[10] >> 4 & 1;
         }
 else {
            bVar1 = ( **(code**)( *(long*)this + 0xd8 ) )();
         }

         if (bVar1 == 0) {
            lVar4 = *(long*)this;
            if (*(code**)( lVar4 + 0xe0 ) == isMatrix) {
               if (0xf < (byte)this[9]) {
                  return 0;
               }

            }
 else {
               cVar2 = ( **(code**)( lVar4 + 0xe0 ) )(this);
               if (cVar2 != '\0') {
                  return 0;
               }

               lVar4 = *(long*)this;
            }

            if (*(code**)( lVar4 + 0x128 ) == isStruct) {
               if (1 < ( byte )((char)this[8] - 0xfU)) {
                  LAB_00156791:if (*(code**)( lVar4 + 0xe8 ) == isArray) {
                     uVar3 = (uint)CONCAT71(0x14ac, *(long*)( this + 0x60 ) != 0);
                  }
 else {
                     uVar3 = ( **(code**)( lVar4 + 0xe8 ) )(this);
                  }

                  return uVar3 ^ 1;
               }

            }
 else {
               cVar2 = ( **(code**)( lVar4 + 0x128 ) )(this);
               if (cVar2 == '\0') {
                  lVar4 = *(long*)this;
                  goto LAB_00156791;
               }

            }

         }

         return 0;
      }

      /* glslang::TType::getCumulativeArraySize() const */
      int glslang::TType::getCumulativeArraySize(TType *this) {
         int *piVar1;
         long lVar2;
         int *piVar3;
         int iVar4;
         lVar2 = *(long*)( *(long*)( this + 0x60 ) + 8 );
         if (lVar2 != 0) {
            piVar3 = *(int**)( lVar2 + 8 );
            iVar4 = (int)( *(long*)( lVar2 + 0x10 ) - (long)piVar3 >> 4 );
            if (0 < iVar4) {
               piVar1 = piVar3 + ( ulong )(iVar4 - 1) * 4 + 4;
               iVar4 = 1;
               do {
                  iVar4 = iVar4 * *piVar3;
                  piVar3 = piVar3 + 4;
               }
 while ( piVar3 != piVar1 );
               return iVar4;
            }

         }

         return 1;
      }

      /* std::_Rb_tree<int, std::pair<int const, glslang::TVariable*>, std::_Select1st<std::pair<int
   const, glslang::TVariable*> >, std::less<int>, glslang::pool_allocator<std::pair<int const,
   glslang::TVariable*> > >::_M_erase(std::_Rb_tree_node<std::pair<int const, glslang::TVariable*>
   >*) [clone .isra.0] */
      void std::_Rb_tree<int,std::pair<int_const,glslang::TVariable*>,std::_Select1st<std::pair<int_const,glslang::TVariable*>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVariable*>>>::_M_erase(_Rb_tree_node *param_1) {
         long lVar1;
         long lVar2;
         long lVar3;
         long lVar4;
         long lVar5;
         long lVar6;
         long lVar7;
         long lVar8;
         if (param_1 != (_Rb_tree_node*)0x0) {
            do {
               for (lVar1 = *(long*)( param_1 + 0x18 ); lVar1 != 0; lVar1 = *(long*)( lVar1 + 0x10 )) {
                  for (lVar2 = *(long*)( lVar1 + 0x18 ); lVar2 != 0; lVar2 = *(long*)( lVar2 + 0x10 )) {
                     for (lVar3 = *(long*)( lVar2 + 0x18 ); lVar3 != 0; lVar3 = *(long*)( lVar3 + 0x10 )) {
                        for (lVar4 = *(long*)( lVar3 + 0x18 ); lVar4 != 0; lVar4 = *(long*)( lVar4 + 0x10 )) {
                           for (lVar5 = *(long*)( lVar4 + 0x18 ); lVar5 != 0; lVar5 = *(long*)( lVar5 + 0x10 )) {
                              for (lVar6 = *(long*)( lVar5 + 0x18 ); lVar6 != 0; lVar6 = *(long*)( lVar6 + 0x10 )) {
                                 for (lVar7 = *(long*)( lVar6 + 0x18 ); lVar7 != 0; lVar7 = *(long*)( lVar7 + 0x10 )) {
                                    for (lVar8 = *(long*)( lVar7 + 0x18 ); lVar8 != 0; lVar8 = *(long*)( lVar8 + 0x10 )) {
                                       _M_erase(*(_Rb_tree_node**)( lVar8 + 0x18 ));
                                    }

                                 }

                              }

                           }

                        }

                     }

                  }

               }

               param_1 = *(_Rb_tree_node**)( param_1 + 0x10 );
            }
 while ( param_1 != (_Rb_tree_node*)0x0 );
            return;
         }

         return;
      }

      /* std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> >, std::pair<std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const, std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > >,
   std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > > >, std::less<std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > >,
   glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > > >
   >::_M_erase(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > > >*) [clone .isra.0] */
      void std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>>::_M_erase(_Rb_tree_node *param_1) {
         long lVar1;
         long lVar2;
         long lVar3;
         long lVar4;
         long lVar5;
         long lVar6;
         long lVar7;
         long lVar8;
         if (param_1 != (_Rb_tree_node*)0x0) {
            do {
               for (lVar1 = *(long*)( param_1 + 0x18 ); lVar1 != 0; lVar1 = *(long*)( lVar1 + 0x10 )) {
                  for (lVar2 = *(long*)( lVar1 + 0x18 ); lVar2 != 0; lVar2 = *(long*)( lVar2 + 0x10 )) {
                     for (lVar3 = *(long*)( lVar2 + 0x18 ); lVar3 != 0; lVar3 = *(long*)( lVar3 + 0x10 )) {
                        for (lVar4 = *(long*)( lVar3 + 0x18 ); lVar4 != 0; lVar4 = *(long*)( lVar4 + 0x10 )) {
                           for (lVar5 = *(long*)( lVar4 + 0x18 ); lVar5 != 0; lVar5 = *(long*)( lVar5 + 0x10 )) {
                              for (lVar6 = *(long*)( lVar5 + 0x18 ); lVar6 != 0; lVar6 = *(long*)( lVar6 + 0x10 )) {
                                 for (lVar7 = *(long*)( lVar6 + 0x18 ); lVar7 != 0; lVar7 = *(long*)( lVar7 + 0x10 )) {
                                    for (lVar8 = *(long*)( lVar7 + 0x18 ); lVar8 != 0; lVar8 = *(long*)( lVar8 + 0x10 )) {
                                       _M_erase(*(_Rb_tree_node**)( lVar8 + 0x18 ));
                                    }

                                 }

                              }

                           }

                        }

                     }

                  }

               }

               param_1 = *(_Rb_tree_node**)( param_1 + 0x10 );
            }
 while ( param_1 != (_Rb_tree_node*)0x0 );
            return;
         }

         return;
      }

      /* std::_Rb_tree<int, std::pair<int const, glslang::TVector<glslang::TIntermTyped const*> >,
   std::_Select1st<std::pair<int const, glslang::TVector<glslang::TIntermTyped const*> > >,
   std::less<int>, glslang::pool_allocator<std::pair<int const,
   glslang::TVector<glslang::TIntermTyped const*> > > >::_M_erase(std::_Rb_tree_node<std::pair<int
   const, glslang::TVector<glslang::TIntermTyped const*> > >*) [clone .isra.0] */
      void std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>>::_M_erase(_Rb_tree_node *param_1) {
         long lVar1;
         long lVar2;
         long lVar3;
         long lVar4;
         long lVar5;
         long lVar6;
         long lVar7;
         long lVar8;
         if (param_1 != (_Rb_tree_node*)0x0) {
            do {
               for (lVar1 = *(long*)( param_1 + 0x18 ); lVar1 != 0; lVar1 = *(long*)( lVar1 + 0x10 )) {
                  for (lVar2 = *(long*)( lVar1 + 0x18 ); lVar2 != 0; lVar2 = *(long*)( lVar2 + 0x10 )) {
                     for (lVar3 = *(long*)( lVar2 + 0x18 ); lVar3 != 0; lVar3 = *(long*)( lVar3 + 0x10 )) {
                        for (lVar4 = *(long*)( lVar3 + 0x18 ); lVar4 != 0; lVar4 = *(long*)( lVar4 + 0x10 )) {
                           for (lVar5 = *(long*)( lVar4 + 0x18 ); lVar5 != 0; lVar5 = *(long*)( lVar5 + 0x10 )) {
                              for (lVar6 = *(long*)( lVar5 + 0x18 ); lVar6 != 0; lVar6 = *(long*)( lVar6 + 0x10 )) {
                                 for (lVar7 = *(long*)( lVar6 + 0x18 ); lVar7 != 0; lVar7 = *(long*)( lVar7 + 0x10 )) {
                                    for (lVar8 = *(long*)( lVar7 + 0x18 ); lVar8 != 0; lVar8 = *(long*)( lVar8 + 0x10 )) {
                                       _M_erase(*(_Rb_tree_node**)( lVar8 + 0x18 ));
                                    }

                                 }

                              }

                           }

                        }

                     }

                  }

               }

               param_1 = *(_Rb_tree_node**)( param_1 + 0x10 );
            }
 while ( param_1 != (_Rb_tree_node*)0x0 );
            return;
         }

         return;
      }

      /* std::_Rb_tree<int, std::pair<int const, int>, std::_Select1st<std::pair<int const, int> >,
   std::less<int>, glslang::pool_allocator<std::pair<int const, int> >
   >::_M_erase(std::_Rb_tree_node<std::pair<int const, int> >*) [clone .isra.0] */
      void std::_Rb_tree<int,std::pair<int_const,int>,std::_Select1st<std::pair<int_const,int>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,int>>>::_M_erase(_Rb_tree_node *param_1) {
         long lVar1;
         long lVar2;
         long lVar3;
         long lVar4;
         long lVar5;
         long lVar6;
         long lVar7;
         long lVar8;
         if (param_1 != (_Rb_tree_node*)0x0) {
            do {
               for (lVar1 = *(long*)( param_1 + 0x18 ); lVar1 != 0; lVar1 = *(long*)( lVar1 + 0x10 )) {
                  for (lVar2 = *(long*)( lVar1 + 0x18 ); lVar2 != 0; lVar2 = *(long*)( lVar2 + 0x10 )) {
                     for (lVar3 = *(long*)( lVar2 + 0x18 ); lVar3 != 0; lVar3 = *(long*)( lVar3 + 0x10 )) {
                        for (lVar4 = *(long*)( lVar3 + 0x18 ); lVar4 != 0; lVar4 = *(long*)( lVar4 + 0x10 )) {
                           for (lVar5 = *(long*)( lVar4 + 0x18 ); lVar5 != 0; lVar5 = *(long*)( lVar5 + 0x10 )) {
                              for (lVar6 = *(long*)( lVar5 + 0x18 ); lVar6 != 0; lVar6 = *(long*)( lVar6 + 0x10 )) {
                                 for (lVar7 = *(long*)( lVar6 + 0x18 ); lVar7 != 0; lVar7 = *(long*)( lVar7 + 0x10 )) {
                                    for (lVar8 = *(long*)( lVar7 + 0x18 ); lVar8 != 0; lVar8 = *(long*)( lVar8 + 0x10 )) {
                                       _M_erase(*(_Rb_tree_node**)( lVar8 + 0x18 ));
                                    }

                                 }

                              }

                           }

                        }

                     }

                  }

               }

               param_1 = *(_Rb_tree_node**)( param_1 + 0x10 );
            }
 while ( param_1 != (_Rb_tree_node*)0x0 );
            return;
         }

         return;
      }

      /* std::_Rb_tree<int, std::pair<int const, glslang::TVector<glslang::TIntermConstantUnion const*> >,
   std::_Select1st<std::pair<int const, glslang::TVector<glslang::TIntermConstantUnion const*> > >,
   std::less<int>, glslang::pool_allocator<std::pair<int const,
   glslang::TVector<glslang::TIntermConstantUnion const*> > >
   >::_M_erase(std::_Rb_tree_node<std::pair<int const,
   glslang::TVector<glslang::TIntermConstantUnion const*> > >*) [clone .isra.0] */
      void std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>::_M_erase(_Rb_tree_node *param_1) {
         long lVar1;
         long lVar2;
         long lVar3;
         long lVar4;
         long lVar5;
         long lVar6;
         long lVar7;
         long lVar8;
         if (param_1 != (_Rb_tree_node*)0x0) {
            do {
               for (lVar1 = *(long*)( param_1 + 0x18 ); lVar1 != 0; lVar1 = *(long*)( lVar1 + 0x10 )) {
                  for (lVar2 = *(long*)( lVar1 + 0x18 ); lVar2 != 0; lVar2 = *(long*)( lVar2 + 0x10 )) {
                     for (lVar3 = *(long*)( lVar2 + 0x18 ); lVar3 != 0; lVar3 = *(long*)( lVar3 + 0x10 )) {
                        for (lVar4 = *(long*)( lVar3 + 0x18 ); lVar4 != 0; lVar4 = *(long*)( lVar4 + 0x10 )) {
                           for (lVar5 = *(long*)( lVar4 + 0x18 ); lVar5 != 0; lVar5 = *(long*)( lVar5 + 0x10 )) {
                              for (lVar6 = *(long*)( lVar5 + 0x18 ); lVar6 != 0; lVar6 = *(long*)( lVar6 + 0x10 )) {
                                 for (lVar7 = *(long*)( lVar6 + 0x18 ); lVar7 != 0; lVar7 = *(long*)( lVar7 + 0x10 )) {
                                    for (lVar8 = *(long*)( lVar7 + 0x18 ); lVar8 != 0; lVar8 = *(long*)( lVar8 + 0x10 )) {
                                       _M_erase(*(_Rb_tree_node**)( lVar8 + 0x18 ));
                                    }

                                 }

                              }

                           }

                        }

                     }

                  }

               }

               param_1 = *(_Rb_tree_node**)( param_1 + 0x10 );
            }
 while ( param_1 != (_Rb_tree_node*)0x0 );
            return;
         }

         return;
      }

      /* glslang::TType::isBindlessTexture() const */
      TType glslang::TType::isBindlessTexture(TType *this) {
         code *pcVar1;
         char cVar2;
         TType *pTVar3;
         pcVar1 = *(code**)( *(long*)this + 0x168 );
         if (pcVar1 == isTexture) {
            if (this[8] == (TType)0xe) {
               pcVar1 = *(code**)( *(long*)this + 0x40 );
               if (pcVar1 == getSampler) {
                  pTVar3 = this + 0x80;
               }
 else {
                  pTVar3 = (TType*)( *pcVar1 )();
               }

               if (( ( (byte)pTVar3[2] & 0x20 ) == 0 ) && ( ( (byte)pTVar3[2] & 8 ) == 0 )) {
                  return this[0x58];
               }

            }

         }
 else {
            cVar2 = ( *pcVar1 )();
            if (cVar2 != '\0') {
               return this[0x58];
            }

         }

         return (TType)0x0;
      }

      /* glslang::TParseContextBase::setErrorCallback(std::function<void (int, char const*)> const&) */
      void glslang::TParseContextBase::setErrorCallback(TParseContextBase *this, function *param_1) {
         code *pcVar1;
         undefined1 auVar2[16];
         long in_FS_OFFSET;
         undefined8 uVar3;
         undefined8 uVar4;
         undefined1 local_48[16];
         undefined8 local_38;
         undefined8 uStack_30;
         long local_20;
         local_20 = *(long*)( in_FS_OFFSET + 0x28 );
         local_48 = (undefined1[16])0x0;
         uVar3 = 0;
         uVar4 = 0;
         local_38 = 0;
         uStack_30 = 0;
         if (*(code**)( param_1 + 0x10 ) != (code*)0x0) {
            ( **(code**)( param_1 + 0x10 ) )(local_48, param_1, 2);
            uVar3 = *(undefined8*)( param_1 + 0x10 );
            uVar4 = *(undefined8*)( param_1 + 0x18 );
         }

         auVar2 = *(undefined1(*) [16])( this + 0x450 );
         local_38 = *(undefined8*)( this + 0x460 );
         uStack_30 = *(undefined8*)( this + 0x468 );
         pcVar1 = *(code**)( this + 0x460 );
         *(undefined8*)( this + 0x460 ) = uVar3;
         *(undefined8*)( this + 0x468 ) = uVar4;
         *(undefined8*)( this + 0x450 ) = local_48._0_8_;
         *(undefined8*)( this + 0x458 ) = local_48._8_8_;
         local_48 = auVar2;
         if (pcVar1 != (code*)0x0) {
            ( *pcVar1 )(local_48, local_48, 3);
         }

         if (local_20 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return;
         }

         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      /* glslang::TParseContextBase::setPragmaCallback(std::function<void (int,
   glslang::TVector<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > > const&)> const&) */
      void glslang::TParseContextBase::setPragmaCallback(TParseContextBase *this, function *param_1) {
         code *pcVar1;
         undefined1 auVar2[16];
         long in_FS_OFFSET;
         undefined8 uVar3;
         undefined8 uVar4;
         undefined1 local_48[16];
         undefined8 local_38;
         undefined8 uStack_30;
         long local_20;
         local_20 = *(long*)( in_FS_OFFSET + 0x28 );
         local_48 = (undefined1[16])0x0;
         uVar3 = 0;
         uVar4 = 0;
         local_38 = 0;
         uStack_30 = 0;
         if (*(code**)( param_1 + 0x10 ) != (code*)0x0) {
            ( **(code**)( param_1 + 0x10 ) )(local_48, param_1, 2);
            uVar3 = *(undefined8*)( param_1 + 0x10 );
            uVar4 = *(undefined8*)( param_1 + 0x18 );
         }

         auVar2 = *(undefined1(*) [16])( this + 0x3f0 );
         local_38 = *(undefined8*)( this + 0x400 );
         uStack_30 = *(undefined8*)( this + 0x408 );
         pcVar1 = *(code**)( this + 0x400 );
         *(undefined8*)( this + 0x400 ) = uVar3;
         *(undefined8*)( this + 0x408 ) = uVar4;
         *(undefined8*)( this + 0x3f0 ) = local_48._0_8_;
         *(undefined8*)( this + 0x3f8 ) = local_48._8_8_;
         local_48 = auVar2;
         if (pcVar1 != (code*)0x0) {
            ( *pcVar1 )(local_48, local_48, 3);
         }

         if (local_20 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return;
         }

         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      /* glslang::TParseContextBase::setExtensionCallback(std::function<void (int, char const*, char
   const*)> const&) */
      void glslang::TParseContextBase::setExtensionCallback(TParseContextBase *this, function *param_1) {
         code *pcVar1;
         undefined1 auVar2[16];
         long in_FS_OFFSET;
         undefined8 uVar3;
         undefined8 uVar4;
         undefined1 local_48[16];
         undefined8 local_38;
         undefined8 uStack_30;
         long local_20;
         local_20 = *(long*)( in_FS_OFFSET + 0x28 );
         local_48 = (undefined1[16])0x0;
         uVar3 = 0;
         uVar4 = 0;
         local_38 = 0;
         uStack_30 = 0;
         if (*(code**)( param_1 + 0x10 ) != (code*)0x0) {
            ( **(code**)( param_1 + 0x10 ) )(local_48, param_1, 2);
            uVar3 = *(undefined8*)( param_1 + 0x10 );
            uVar4 = *(undefined8*)( param_1 + 0x18 );
         }

         auVar2 = *(undefined1(*) [16])( this + 0x430 );
         local_38 = *(undefined8*)( this + 0x440 );
         uStack_30 = *(undefined8*)( this + 0x448 );
         pcVar1 = *(code**)( this + 0x440 );
         *(undefined8*)( this + 0x440 ) = uVar3;
         *(undefined8*)( this + 0x448 ) = uVar4;
         *(undefined8*)( this + 0x430 ) = local_48._0_8_;
         *(undefined8*)( this + 0x438 ) = local_48._8_8_;
         local_48 = auVar2;
         if (pcVar1 != (code*)0x0) {
            ( *pcVar1 )(local_48, local_48, 3);
         }

         if (local_20 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return;
         }

         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      /* glslang::TParseContextBase::setLineCallback(std::function<void (int, int, bool, int, char
   const*)> const&) */
      void glslang::TParseContextBase::setLineCallback(TParseContextBase *this, function *param_1) {
         code *pcVar1;
         undefined1 auVar2[16];
         long in_FS_OFFSET;
         undefined8 uVar3;
         undefined8 uVar4;
         undefined1 local_48[16];
         undefined8 local_38;
         undefined8 uStack_30;
         long local_20;
         local_20 = *(long*)( in_FS_OFFSET + 0x28 );
         local_48 = (undefined1[16])0x0;
         uVar3 = 0;
         uVar4 = 0;
         local_38 = 0;
         uStack_30 = 0;
         if (*(code**)( param_1 + 0x10 ) != (code*)0x0) {
            ( **(code**)( param_1 + 0x10 ) )(local_48, param_1, 2);
            uVar3 = *(undefined8*)( param_1 + 0x10 );
            uVar4 = *(undefined8*)( param_1 + 0x18 );
         }

         auVar2 = *(undefined1(*) [16])( this + 0x3d0 );
         local_38 = *(undefined8*)( this + 0x3e0 );
         uStack_30 = *(undefined8*)( this + 1000 );
         pcVar1 = *(code**)( this + 0x3e0 );
         *(undefined8*)( this + 0x3e0 ) = uVar3;
         *(undefined8*)( this + 1000 ) = uVar4;
         *(undefined8*)( this + 0x3d0 ) = local_48._0_8_;
         *(undefined8*)( this + 0x3d8 ) = local_48._8_8_;
         local_48 = auVar2;
         if (pcVar1 != (code*)0x0) {
            ( *pcVar1 )(local_48, local_48, 3);
         }

         if (local_20 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return;
         }

         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      /* glslang::TParseContextBase::setVersionCallback(std::function<void (int, int, char const*)>
   const&) */
      void glslang::TParseContextBase::setVersionCallback(TParseContextBase *this, function *param_1) {
         code *pcVar1;
         undefined1 auVar2[16];
         long in_FS_OFFSET;
         undefined8 uVar3;
         undefined8 uVar4;
         undefined1 local_48[16];
         undefined8 local_38;
         undefined8 uStack_30;
         long local_20;
         local_20 = *(long*)( in_FS_OFFSET + 0x28 );
         local_48 = (undefined1[16])0x0;
         uVar3 = 0;
         uVar4 = 0;
         local_38 = 0;
         uStack_30 = 0;
         if (*(code**)( param_1 + 0x10 ) != (code*)0x0) {
            ( **(code**)( param_1 + 0x10 ) )(local_48, param_1, 2);
            uVar3 = *(undefined8*)( param_1 + 0x10 );
            uVar4 = *(undefined8*)( param_1 + 0x18 );
         }

         auVar2 = *(undefined1(*) [16])( this + 0x410 );
         local_38 = *(undefined8*)( this + 0x420 );
         uStack_30 = *(undefined8*)( this + 0x428 );
         pcVar1 = *(code**)( this + 0x420 );
         *(undefined8*)( this + 0x420 ) = uVar3;
         *(undefined8*)( this + 0x428 ) = uVar4;
         *(undefined8*)( this + 0x410 ) = local_48._0_8_;
         *(undefined8*)( this + 0x418 ) = local_48._8_8_;
         local_48 = auVar2;
         if (pcVar1 != (code*)0x0) {
            ( *pcVar1 )(local_48, local_48, 3);
         }

         if (local_20 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return;
         }

         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      /* glslang::TType::isBindlessImage() const */
      TType glslang::TType::isBindlessImage(TType *this) {
         code *pcVar1;
         char cVar2;
         TType *pTVar3;
         pcVar1 = *(code**)( *(long*)this + 0x158 );
         if (pcVar1 == isImage) {
            if (this[8] == (TType)0xe) {
               pcVar1 = *(code**)( *(long*)this + 0x40 );
               if (pcVar1 == getSampler) {
                  pTVar3 = this + 0x80;
               }
 else {
                  pTVar3 = (TType*)( *pcVar1 )();
               }

               if (( ( (byte)pTVar3[2] & 8 ) != 0 ) && ( 1 < ( byte )((char)pTVar3[1] - 7U) )) {
                  return this[0x59];
               }

            }

         }
 else {
            cVar2 = ( *pcVar1 )();
            if (cVar2 != '\0') {
               return this[0x59];
            }

         }

         return (TType)0x0;
      }

      /* glslang::TIntermTyped::setType(glslang::TType const&) */
      void glslang::TIntermTyped::setType(TIntermTyped *this, TType *param_1) {
         TType TVar1;
         TIntermTyped TVar2;
         undefined4 uVar3;
         undefined8 uVar4;
         undefined8 uVar5;
         undefined8 uVar6;
         byte bVar7;
         byte bVar8;
         uVar4 = *(undefined8*)( param_1 + 0x10 );
         uVar5 = *(undefined8*)( param_1 + 0x18 );
         uVar3 = *(undefined4*)( param_1 + 0x80 );
         *(TType*)( this + 0x28 ) = param_1[8];
         *(undefined8*)( this + 0x30 ) = uVar4;
         *(undefined8*)( this + 0x38 ) = uVar5;
         uVar4 = *(undefined8*)( param_1 + 0x20 );
         uVar5 = *(undefined8*)( param_1 + 0x28 );
         *(undefined4*)( this + 0xa0 ) = uVar3;
         *(undefined8*)( this + 0x40 ) = uVar4;
         *(undefined8*)( this + 0x48 ) = uVar5;
         for (int i = 0; i < 3; i++) {
            uVar4 = *(undefined8*)( param_1 + ( 16*i + 56 ) );
            *(undefined8*)( this + ( 16*i + 80 ) ) = *(undefined8*)( param_1 + ( 16*i + 48 ) );
            *(undefined8*)( this + ( 16*i + 88 ) ) = uVar4;
         }

         TVar1 = param_1[9];
         this[0x29] = ( TIntermTyped )((byte)this[0x29] & 0xf0 | (byte)TVar1 & 0xf);
         this[0x29] = ( TIntermTyped )((byte)TVar1 & 0xf | (byte)param_1[9] & 0xf0);
         TVar2 = this[0x2a];
         bVar7 = (byte)param_1[10] & 0xf;
         this[0x2a] = ( TIntermTyped )((byte)TVar2 & 0xf0 | bVar7);
         bVar8 = (byte)param_1[10] & 0x10;
         this[0x2a] = ( TIntermTyped )((byte)TVar2 & 0xe0 | bVar7 | bVar8);
         uVar5 = *(undefined8*)( param_1 + 0x70 );
         uVar6 = *(undefined8*)( param_1 + 0x78 );
         *(undefined8*)( this + 0x80 ) = *(undefined8*)( param_1 + 0x60 );
         uVar4 = *(undefined8*)( param_1 + 0x68 );
         *(undefined8*)( this + 0x90 ) = uVar5;
         *(undefined8*)( this + 0x98 ) = uVar6;
         *(undefined8*)( this + 0x88 ) = uVar4;
         uVar4 = *(undefined8*)( param_1 + 0x90 );
         *(undefined8*)( this + 0xa8 ) = *(undefined8*)( param_1 + 0x88 );
         *(undefined8*)( this + 0xb0 ) = uVar4;
         TVar1 = param_1[10];
         this[0x2a] = ( TIntermTyped )((byte)TVar2 & 0xc0 | bVar7 | bVar8 | (byte)TVar1 & 0x20);
         this[0x2a] = ( TIntermTyped )((byte)TVar2 & 0x80 | bVar7 | bVar8 | (byte)TVar1 & 0x20 | (byte)param_1[10] & 0x40);
         *(ushort*)( this + 0x2a ) = *(ushort*)( this + 0x2a ) & 0xfc7f | *(ushort*)( param_1 + 10 ) & 0x380;
         this[0x2b] = ( TIntermTyped )((byte)this[0x2b] & 0xfb | (byte)param_1[0xb] & 4);
         return;
      }

      /* std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> >, std::pair<std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const, glslang::TExtensionBehavior>,
   std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, glslang::TExtensionBehavior> >,
   std::less<std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   > >, glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, glslang::TExtensionBehavior> >
   >::_M_erase(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, glslang::TExtensionBehavior> >*) [clone .isra.0] */
      void std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TExtensionBehavior>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TExtensionBehavior>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TExtensionBehavior>>>::_M_erase(_Rb_tree_node *param_1) {
         long lVar1;
         long lVar2;
         long lVar3;
         long lVar4;
         long lVar5;
         long lVar6;
         long lVar7;
         long lVar8;
         if (param_1 != (_Rb_tree_node*)0x0) {
            do {
               for (lVar1 = *(long*)( param_1 + 0x18 ); lVar1 != 0; lVar1 = *(long*)( lVar1 + 0x10 )) {
                  for (lVar2 = *(long*)( lVar1 + 0x18 ); lVar2 != 0; lVar2 = *(long*)( lVar2 + 0x10 )) {
                     for (lVar3 = *(long*)( lVar2 + 0x18 ); lVar3 != 0; lVar3 = *(long*)( lVar3 + 0x10 )) {
                        for (lVar4 = *(long*)( lVar3 + 0x18 ); lVar4 != 0; lVar4 = *(long*)( lVar4 + 0x10 )) {
                           for (lVar5 = *(long*)( lVar4 + 0x18 ); lVar5 != 0; lVar5 = *(long*)( lVar5 + 0x10 )) {
                              for (lVar6 = *(long*)( lVar5 + 0x18 ); lVar6 != 0; lVar6 = *(long*)( lVar6 + 0x10 )) {
                                 for (lVar7 = *(long*)( lVar6 + 0x18 ); lVar7 != 0; lVar7 = *(long*)( lVar7 + 0x10 )) {
                                    for (lVar8 = *(long*)( lVar7 + 0x18 ); lVar8 != 0; lVar8 = *(long*)( lVar8 + 0x10 )) {
                                       _M_erase(*(_Rb_tree_node**)( lVar8 + 0x18 ));
                                    }

                                 }

                              }

                           }

                        }

                     }

                  }

               }

               param_1 = *(_Rb_tree_node**)( param_1 + 0x10 );
            }
 while ( param_1 != (_Rb_tree_node*)0x0 );
            return;
         }

         return;
      }

      /* std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> >, std::pair<std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const, unsigned int>,
   std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, unsigned int> >,
   std::less<std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   > >, glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, unsigned int> >
   >::_M_erase(std::_Rb_tree_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, unsigned int> >*) [clone .isra.0] */
      void std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,unsigned_int>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,unsigned_int>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,unsigned_int>>>::_M_erase(_Rb_tree_node *param_1) {
         long lVar1;
         long lVar2;
         long lVar3;
         long lVar4;
         long lVar5;
         long lVar6;
         long lVar7;
         long lVar8;
         if (param_1 != (_Rb_tree_node*)0x0) {
            do {
               for (lVar1 = *(long*)( param_1 + 0x18 ); lVar1 != 0; lVar1 = *(long*)( lVar1 + 0x10 )) {
                  for (lVar2 = *(long*)( lVar1 + 0x18 ); lVar2 != 0; lVar2 = *(long*)( lVar2 + 0x10 )) {
                     for (lVar3 = *(long*)( lVar2 + 0x18 ); lVar3 != 0; lVar3 = *(long*)( lVar3 + 0x10 )) {
                        for (lVar4 = *(long*)( lVar3 + 0x18 ); lVar4 != 0; lVar4 = *(long*)( lVar4 + 0x10 )) {
                           for (lVar5 = *(long*)( lVar4 + 0x18 ); lVar5 != 0; lVar5 = *(long*)( lVar5 + 0x10 )) {
                              for (lVar6 = *(long*)( lVar5 + 0x18 ); lVar6 != 0; lVar6 = *(long*)( lVar6 + 0x10 )) {
                                 for (lVar7 = *(long*)( lVar6 + 0x18 ); lVar7 != 0; lVar7 = *(long*)( lVar7 + 0x10 )) {
                                    for (lVar8 = *(long*)( lVar7 + 0x18 ); lVar8 != 0; lVar8 = *(long*)( lVar8 + 0x10 )) {
                                       _M_erase(*(_Rb_tree_node**)( lVar8 + 0x18 ));
                                    }

                                 }

                              }

                           }

                        }

                     }

                  }

               }

               param_1 = *(_Rb_tree_node**)( param_1 + 0x10 );
            }
 while ( param_1 != (_Rb_tree_node*)0x0 );
            return;
         }

         return;
      }

      /* glslang::TType::setFieldName(std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const&) */
      void glslang::TType::setFieldName(TType *this, basic_string *param_1) {
         char *__s;
         ulong uVar1;
         undefined8 *puVar2;
         undefined8 uVar3;
         size_t sVar4;
         __s = *(char**)( param_1 + 8 );
         uVar1 = glslang::GetThreadPoolAllocator();
         puVar2 = (undefined8*)glslang::TPoolAllocator::allocate(uVar1);
         uVar3 = glslang::GetThreadPoolAllocator();
         *puVar2 = uVar3;
         puVar2[1] = puVar2 + 3;
         if (__s != (char*)0x0) {
            sVar4 = strlen(__s);
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(puVar2, __s, __s + sVar4);
            *(undefined8**)( this + 0x70 ) = puVar2;
            return;
         }

         /* WARNING: Subroutine does not return */
         std::__throw_logic_error("basic_string: construction from null is not valid");
      }

      /* glslang::TIntermTyped::isScalar() const */
      bool glslang::TIntermTyped::isScalar(TIntermTyped *this) {
         bool bVar1;
         bVar1 = false;
         if (( (byte)this[0x29] & 0xf ) < 2) {
            bVar1 = (bool)( (byte)this[0x2a] >> 4 & 1 );
            if (( (byte)this[0x2a] >> 4 & 1 ) != 0) {
               return false;
            }

            if (( (byte)this[0x29] < 0x10 ) && ( 1 < ( byte )((char)this[0x28] - 0xfU) )) {
               return *(long*)( this + 0x80 ) == 0;
            }

         }

         return bVar1;
      }

      /* glslang::TType::isScalarOrVec1() const */
      byte glslang::TType::isScalarOrVec1(TType *this) {
         TType TVar1;
         code *pcVar2;
         byte bVar3;
         char cVar4;
         long lVar5;
         pcVar2 = *(code**)( *(long*)this + 0xc0 );
         if (pcVar2 == isScalar) {
            pcVar2 = *(code**)( *(long*)this + 0xd8 );
            if (pcVar2 == isVector) {
               TVar1 = this[10];
               bVar3 = (byte)TVar1 >> 4 & 1;
               if (1 < ( (byte)this[9] & 0xf )) goto LAB_001576b3;
            }
 else {
               bVar3 = ( *pcVar2 )();
            }

            if (bVar3 == 0) {
               lVar5 = *(long*)this;
               if (*(code**)( lVar5 + 0xe0 ) == isMatrix) {
                  if ((byte)this[9] < 0x10) {
                     LAB_001576dc:if (*(code**)( lVar5 + 0x128 ) == isStruct) {
                        if (1 < ( byte )((char)this[8] - 0xfU)) {
                           LAB_001576fb:if (*(code**)( lVar5 + 0xe8 ) == isArray) {
                              if (*(long*)( this + 0x60 ) == 0) {
                                 return 1;
                              }

                           }
 else {
                              cVar4 = ( **(code**)( lVar5 + 0xe8 ) )(this);
                              if (cVar4 == '\0') {
                                 return 1;
                              }

                           }

                        }

                     }
 else {
                        cVar4 = ( **(code**)( lVar5 + 0x128 ) )(this);
                        if (cVar4 == '\0') {
                           lVar5 = *(long*)this;
                           goto LAB_001576fb;
                        }

                     }

                  }

               }
 else {
                  cVar4 = ( **(code**)( lVar5 + 0xe0 ) )(this);
                  if (cVar4 == '\0') {
                     lVar5 = *(long*)this;
                     goto LAB_001576dc;
                  }

               }

            }

         }
 else {
            cVar4 = ( *pcVar2 )();
            if (cVar4 != '\0') {
               return 1;
            }

         }

         TVar1 = this[10];
         LAB_001576b3:return (byte)TVar1 >> 4 & 1;
      }

      /* glslang::TType::containsNonOpaque() const */
      ulong glslang::TType::containsNonOpaque(TType *this) {
         TType TVar1;
         long lVar2;
         char cVar3;
         undefined1 auVar4[16];
         TVar1 = this[8];
         if (( (byte)TVar1 < 0xd ) || ( TVar1 == (TType)0x12 )) {
            return 1;
         }

         if (*(code**)( *(long*)this + 0x128 ) == isStruct) {
            if (( byte )((char)TVar1 - 0xfU) < 2) {
               LAB_001577e0:lVar2 = *(long*)( *(long*)( this + 0x68 ) + 0x10 );
               auVar4 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsNonOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsNonOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( this + 0x68 ) + 8 ),lVar2 ));
               return CONCAT71(auVar4._9_7_, lVar2 != auVar4._0_8_) & 0xffffffff;
            }

         }
 else {
            cVar3 = ( **(code**)( *(long*)this + 0x128 ) )();
            if (cVar3 != '\0') goto LAB_001577e0;
         }

         return 0;
      }

      /* glslang::TType::containsBasicType(glslang::TBasicType) const */
      ulong glslang::TType::containsBasicType(TType *this, uint param_2) {
         long lVar1;
         char cVar2;
         undefined1 auVar3[16];
         if ((byte)this[8] == param_2) {
            return 1;
         }

         if (*(code**)( *(long*)this + 0x128 ) == isStruct) {
            if (( byte )((char)this[8] - 0xfU) < 2) {
               LAB_00157866:lVar1 = *(long*)( *(long*)( this + 0x68 ) + 0x10 );
               auVar3 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( this + 0x68 ) + 8 ),lVar1,param_2 ));
               return CONCAT71(auVar3._9_7_, lVar1 != auVar3._0_8_) & 0xffffffff;
            }

         }
 else {
            cVar2 = ( **(code**)( *(long*)this + 0x128 ) )();
            if (cVar2 != '\0') goto LAB_00157866;
         }

         return 0;
      }

      /* glslang::TType::containsSpecializationSize() const */
      bool glslang::TType::containsSpecializationSize(TType *this) {
         char cVar1;
         long lVar2;
         long lVar3;
         lVar2 = *(long*)this;
         if (*(code**)( lVar2 + 0xe8 ) == isArray) {
            lVar3 = *(long*)( this + 0x60 );
            if (lVar3 != 0) {
               LAB_001578fa:if (*(long*)( *(long*)( *(long*)( lVar3 + 8 ) + 8 ) + 8 ) != 0) {
                  return true;
               }

               goto LAB_0015790e;
            }

         }
 else {
            cVar1 = ( **(code**)( lVar2 + 0xe8 ) )();
            if (cVar1 != '\0') {
               lVar3 = *(long*)( this + 0x60 );
               goto LAB_001578fa;
            }

            LAB_0015790e:lVar2 = *(long*)this;
         }

         if (*(code**)( lVar2 + 0x128 ) == isStruct) {
            if (( byte )((char)this[8] - 0xfU) < 2) {
               LAB_00157921:lVar2 = *(long*)( *(long*)( this + 0x68 ) + 0x10 );
               lVar3 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSpecializationSize()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsSpecializationSize ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( this + 0x68 ) + 8 ),lVar2 ));
               return lVar2 != lVar3;
            }

         }
 else {
            cVar1 = ( **(code**)( lVar2 + 0x128 ) )(this);
            if (cVar1 != '\0') goto LAB_00157921;
         }

         return false;
      }

      /* glslang::TType::containsOpaque() const */
      bool glslang::TType::containsOpaque(TType *this) {
         char cVar1;
         long lVar2;
         long lVar3;
         lVar2 = *(long*)this;
         if (*(code**)( lVar2 + 0x140 ) == isOpaque) {
            if (( (byte)this[8] < 0x15 ) && ( ( 0x1a6000UL >> ( (ulong)(byte)this[8] & 0x3f ) & 1 ) != 0 )) {
               return true;
            }

         }
 else {
            cVar1 = ( **(code**)( lVar2 + 0x140 ) )();
            if (cVar1 != '\0') {
               return true;
            }

            lVar2 = *(long*)this;
         }

         if (*(code**)( lVar2 + 0x128 ) == isStruct) {
            if (( byte )((char)this[8] - 0xfU) < 2) {
               LAB_001579b9:lVar2 = *(long*)( *(long*)( this + 0x68 ) + 0x10 );
               lVar3 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsOpaque()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsOpaque ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( this + 0x68 ) + 8 ),lVar2 ));
               return lVar2 != lVar3;
            }

         }
 else {
            cVar1 = ( **(code**)( lVar2 + 0x128 ) )(this);
            if (cVar1 != '\0') goto LAB_001579b9;
         }

         return false;
      }

      /* glslang::TType::containsUnsizedArray() const */
      bool glslang::TType::containsUnsizedArray(TType *this) {
         char cVar1;
         long lVar2;
         long lVar3;
         lVar2 = *(long*)this;
         if (*(code**)( lVar2 + 0xf8 ) == isUnsizedArray) {
            if (*(code**)( lVar2 + 0xe8 ) != isArray) {
               cVar1 = ( **(code**)( lVar2 + 0xe8 ) )();
               if (cVar1 != '\0') {
                  lVar3 = *(long*)( this + 0x60 );
                  goto LAB_00157a4a;
               }

               goto LAB_00157a66;
            }

            lVar3 = *(long*)( this + 0x60 );
            if (lVar3 != 0) {
               LAB_00157a4a:if (**(int**)( *(long*)( lVar3 + 8 ) + 8 ) == 0) {
                  return true;
               }

               goto LAB_00157a66;
            }

         }
 else {
            cVar1 = ( **(code**)( lVar2 + 0xf8 ) )();
            if (cVar1 != '\0') {
               return true;
            }

            LAB_00157a66:lVar2 = *(long*)this;
         }

         if (*(code**)( lVar2 + 0x128 ) == isStruct) {
            if (( byte )((char)this[8] - 0xfU) < 2) {
               LAB_00157a79:lVar2 = *(long*)( *(long*)( this + 0x68 ) + 0x10 );
               lVar3 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsUnsizedArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsUnsizedArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( this + 0x68 ) + 8 ),lVar2 ));
               return lVar2 != lVar3;
            }

         }
 else {
            cVar1 = ( **(code**)( lVar2 + 0x128 ) )(this);
            if (cVar1 != '\0') goto LAB_00157a79;
         }

         return false;
      }

      /* glslang::TType::containsStructure() const */
      bool glslang::TType::containsStructure(TType *this) {
         long lVar1;
         char cVar2;
         long lVar3;
         if (*(code**)( *(long*)this + 0x128 ) == isStruct) {
            if (( byte )((char)this[8] - 0xfU) < 2) {
               LAB_00157ae6:lVar1 = *(long*)( *(long*)( this + 0x68 ) + 0x10 );
               lVar3 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsStructure()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsStructure ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( this + 0x68 ) + 8 ),lVar1,this ));
               return lVar1 != lVar3;
            }

         }
 else {
            cVar2 = ( **(code**)( *(long*)this + 0x128 ) )();
            if (cVar2 != '\0') goto LAB_00157ae6;
         }

         return false;
      }

      /* glslang::TType::containsArray() const */
      bool glslang::TType::containsArray(TType *this) {
         char cVar1;
         long lVar2;
         long lVar3;
         lVar2 = *(long*)this;
         if (*(code**)( lVar2 + 0xe8 ) == isArray) {
            if (*(long*)( this + 0x60 ) != 0) {
               return true;
            }

         }
 else {
            cVar1 = ( **(code**)( lVar2 + 0xe8 ) )();
            if (cVar1 != '\0') {
               return true;
            }

            lVar2 = *(long*)this;
         }

         if (*(code**)( lVar2 + 0x128 ) == isStruct) {
            if (( byte )((char)this[8] - 0xfU) < 2) {
               LAB_00157b69:lVar2 = *(long*)( *(long*)( this + 0x68 ) + 0x10 );
               lVar3 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsArray()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsArray ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( this + 0x68 ) + 8 ),lVar2 ));
               return lVar2 != lVar3;
            }

         }
 else {
            cVar1 = ( **(code**)( lVar2 + 0x128 ) )(this);
            if (cVar1 != '\0') goto LAB_00157b69;
         }

         return false;
      }

      /* glslang::TType::containsBuiltIn() const */
      bool glslang::TType::containsBuiltIn(TType *this) {
         code *pcVar1;
         long lVar2;
         char cVar3;
         long lVar4;
         TType *pTVar5;
         pcVar1 = *(code**)( *(long*)this + 0x148 );
         if (pcVar1 == isBuiltIn) {
            pcVar1 = *(code**)( *(long*)this + 0x58 );
            if (pcVar1 == getQualifier) {
               pTVar5 = this + 0x10;
            }
 else {
               pTVar5 = (TType*)( *pcVar1 )();
            }

            if (0x7f < *(ushort*)( pTVar5 + 8 )) {
               return true;
            }

         }
 else {
            cVar3 = ( *pcVar1 )();
            if (cVar3 != '\0') {
               return true;
            }

         }

         if (*(code**)( *(long*)this + 0x128 ) == isStruct) {
            if (( byte )((char)this[8] - 0xfU) < 2) {
               LAB_00157c09:lVar2 = *(long*)( *(long*)( this + 0x68 ) + 0x10 );
               lVar4 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBuiltIn()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBuiltIn ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( this + 0x68 ) + 8 ),lVar2 ));
               return lVar2 != lVar4;
            }

         }
 else {
            cVar3 = ( **(code**)( *(long*)this + 0x128 ) )(this);
            if (cVar3 != '\0') goto LAB_00157c09;
         }

         return false;
      }

      /* glslang::GetStorageQualifierString(glslang::TStorageQualifier) */
      char *glslang::GetStorageQualifierString(undefined4 param_1) {
         switch (param_1) {
            case 0:
    return "temp";
            case 1:
    return "global";
            case 2:
    return "const";
            case 3:
            case 0x10:
    return "in";
            case 4:
            case 0x11:
    return "out";
            case 5:
    return "uniform";
            case 6:
    return "buffer";
            case 7:
    return "shared";
            case 8:
    return "spirv_storage_class";
            case 9:
    return "rayPayloadNV";
            case 10:
    return "rayPayloadInNV";
            case 0xb:
    return "hitAttributeNV";
            case 0xc:
    return "callableDataNV";
            case 0xd:
    return "callableDataInNV";
            case 0xe:
    return "hitObjectAttributeNV";
            case 0xf:
    return "taskPayloadSharedEXT";
            case 0x12:
    return "inout";
            case 0x13:
    return "const (read only)";
            case 0x14:
    return "gl_VertexId";
            case 0x15:
    return "gl_InstanceId";
            case 0x16:
    return "gl_Position";
            case 0x17:
    return "gl_PointSize";
            case 0x18:
    return "gl_ClipVertex";
            case 0x19:
    return "gl_FrontFacing";
            case 0x1a:
    return "gl_FragCoord";
            case 0x1b:
    return "gl_PointCoord";
            case 0x1c:
    return "fragColor";
            case 0x1d:
    return "gl_FragDepth";
            case 0x1e:
    return "gl_FragStencilRefARB";
            default:
    return "unknown qualifier";
         }

      }

      /* glslang::GetBuiltInVariableString(glslang::TBuiltInVariable) */
      char *glslang::GetBuiltInVariableString(undefined4 param_1) {
         switch (param_1) {
            case 0:
    return "";
            case 1:
    return "NumWorkGroups";
            case 2:
    return "WorkGroupSize";
            case 3:
    return "WorkGroupID";
            case 4:
    return "LocalInvocationID";
            case 5:
    return "GlobalInvocationID";
            case 6:
    return "LocalInvocationIndex";
            case 7:
    return "NumSubgroups";
            case 8:
    return "SubgroupID";
            case 9:
    return "SubGroupSize";
            case 10:
    return "SubGroupInvocation";
            case 0xb:
    return "SubGroupEqMask";
            case 0xc:
    return "SubGroupGeMask";
            case 0xd:
    return "SubGroupGtMask";
            case 0xe:
    return "SubGroupLeMask";
            case 0xf:
    return "SubGroupLtMask";
            case 0x10:
    return "SubgroupSize";
            case 0x11:
    return "SubgroupInvocationID";
            case 0x12:
    return "SubgroupEqMask";
            case 0x13:
    return "SubgroupGeMask";
            case 0x14:
    return "SubgroupGtMask";
            case 0x15:
    return "SubgroupLeMask";
            case 0x16:
    return "SubgroupLtMask";
            case 0x17:
    return "VertexId";
            case 0x18:
    return "InstanceId";
            case 0x19:
    return "VertexIndex";
            case 0x1a:
    return "InstanceIndex";
            case 0x1b:
    return "BaseVertex";
            case 0x1c:
    return "BaseInstance";
            case 0x1d:
    return "DrawId";
            case 0x1e:
    return "Position";
            case 0x1f:
    return "PointSize";
            case 0x20:
    return "ClipVertex";
            case 0x21:
    return "ClipDistance";
            case 0x22:
    return "CullDistance";
            case 0x23:
    return "Normal";
            case 0x24:
    return "Vertex";
            case 0x25:
    return "MultiTexCoord0";
            case 0x26:
    return "MultiTexCoord1";
            case 0x27:
    return "MultiTexCoord2";
            case 0x28:
    return "MultiTexCoord3";
            case 0x29:
    return "MultiTexCoord4";
            case 0x2a:
    return "MultiTexCoord5";
            case 0x2b:
    return "MultiTexCoord6";
            case 0x2c:
    return "MultiTexCoord7";
            case 0x2d:
    return "FrontColor";
            case 0x2e:
    return "BackColor";
            case 0x2f:
    return "FrontSecondaryColor";
            case 0x30:
    return "BackSecondaryColor";
            case 0x31:
    return "TexCoord";
            case 0x32:
    return "FogFragCoord";
            case 0x33:
    return "InvocationID";
            case 0x34:
    return "PrimitiveID";
            case 0x35:
    return "Layer";
            case 0x36:
    return "ViewportIndex";
            case 0x37:
    return "PatchVertices";
            case 0x38:
    return "TessLevelOuter";
            case 0x39:
    return "TessLevelInner";
            case 0x3a:
    return "BoundingBox";
            case 0x3b:
    return "TessCoord";
            case 0x3c:
    return "Color";
            case 0x3d:
    return "SecondaryColor";
            case 0x3e:
    return "Face";
            case 0x3f:
    return "FragCoord";
            case 0x40:
    return "PointCoord";
            case 0x41:
    return "FragColor";
            case 0x42:
    return "FragData";
            case 0x43:
    return "FragDepth";
            case 0x44:
    return "FragStencilRef";
            case 0x45:
    return "SampleId";
            case 0x46:
    return "SamplePosition";
            case 0x47:
    return "SampleMaskIn";
            case 0x48:
    return "HelperInvocation";
            case 0x49:
    return "BaryCoordNoPersp";
            case 0x4a:
    return "BaryCoordNoPerspCentroid";
            case 0x4b:
    return "BaryCoordNoPerspSample";
            case 0x4c:
    return "BaryCoordSmooth";
            case 0x4d:
    return "BaryCoordSmoothCentroid";
            case 0x4e:
    return "BaryCoordSmoothSample";
            case 0x4f:
    return "BaryCoordPullModel";
            case 0x50:
    return "ViewIndex";
            case 0x51:
    return "DeviceIndex";
            case 0x52:
    return "ShadingRateKHR";
            case 0x53:
    return "PrimitiveShadingRateKHR";
            case 0x54:
    return "FragSizeEXT";
            case 0x55:
    return "FragInvocationCountEXT";
            case 0x56:
    return "SecondaryFragDataEXT";
            case 0x57:
    return "SecondaryFragColorEXT";
            case 0x58:
    return "ViewportMaskNV";
            case 0x59:
    return "SecondaryPositionNV";
            case 0x5a:
    return "SecondaryViewportMaskNV";
            case 0x5b:
    return "PositionPerViewNV";
            case 0x5c:
    return "ViewportMaskPerViewNV";
            case 0x5d:
    return "FragFullyCoveredNV";
            case 0x5e:
    return "FragmentSizeNV";
            case 0x5f:
    return "InvocationsPerPixelNV";
            case 0x60:
    return "LaunchIdNV";
            case 0x61:
    return "LaunchSizeNV";
            case 0x62:
    return "InstanceCustomIndexNV";
            case 99:
    return "GeometryIndexEXT";
            case 100:
    return "WorldRayOriginNV";
            case 0x65:
    return "WorldRayDirectionNV";
            case 0x66:
    return "ObjectRayOriginNV";
            case 0x67:
    return "ObjectRayDirectionNV";
            case 0x68:
    return "ObjectRayTminNV";
            case 0x69:
    return "ObjectRayTmaxNV";
            default:
    return "unknown built-in variable";
            case 0x6b:
    return "HitTNV";
            case 0x6c:
    return "HitKindNV";
            case 0x6d:
    return "ObjectToWorldNV";
            case 0x6f:
    return "WorldToObjectNV";
            case 0x71:
    return "IncomingRayFlagsNV";
            case 0x72:
    return "CurrentRayTimeNV";
            case 0x73:
            case 0x75:
    return "BaryCoordKHR";
            case 0x74:
            case 0x76:
    return "BaryCoordNoPerspKHR";
            case 0x77:
    return "TaskCountNV";
            case 0x78:
    return "PrimitiveCountNV";
            case 0x79:
    return "PrimitiveIndicesNV";
            case 0x7a:
    return "ClipDistancePerViewNV";
            case 0x7b:
    return "CullDistancePerViewNV";
            case 0x7c:
    return "LayerPerViewNV";
            case 0x7d:
    return "MeshViewCountNV";
            case 0x7e:
    return "MeshViewIndicesNV";
            case 0x81:
    return "HitKindFrontFacingMicroTriangleNV";
            case 0x82:
    return "HitKindBackFacingMicroTriangleNV";
            case 0x83:
    return "PrimitivePointIndicesEXT";
            case 0x84:
    return "PrimitiveLineIndicesEXT";
            case 0x85:
    return "PrimitiveTriangleIndicesEXT";
            case 0x86:
    return "CullPrimitiveEXT";
            case 0x87:
    return "WarpsPerSMNV";
            case 0x88:
    return "SMCountNV";
            case 0x89:
    return "WarpIDNV";
            case 0x8a:
    return "SMIDNV";
         }

      }

      /* glslang::TSpirvType::TEMPNAMEPLACEHOLDERVALUE(glslang::TSpirvType const&) const */
      undefined4 glslang::TSpirvType::operator ==(TSpirvType *this, TSpirvType *param_1) {
         size_t __n;
         TSpirvTypeParameter *pTVar1;
         int iVar2;
         undefined4 uVar3;
         TSpirvTypeParameter *pTVar4;
         TSpirvTypeParameter *this_00;
         uVar3 = 0;
         __n = *(size_t*)( this + 0x10 );
         if (__n == *(size_t*)( param_1 + 0x10 )) {
            if (( ( __n == 0 ) || ( iVar2 = memcmp(*(void**)( this + 8 ), *(void**)( param_1 + 8 ), __n) ),iVar2 == 0 )) {
               pTVar1 = *(TSpirvTypeParameter**)( this + 0x40 );
               this_00 = *(TSpirvTypeParameter**)( this + 0x38 );
               pTVar4 = *(TSpirvTypeParameter**)( param_1 + 0x38 );
               if ((long)pTVar1 - (long)this_00 == *(long*)( param_1 + 0x40 ) - (long)pTVar4) {
                  for (; this_00 != pTVar1; this_00 = this_00 + 0x10) {
                     uVar3 = glslang::TSpirvTypeParameter::operator ==(this_00, pTVar4);
                     if ((char)uVar3 == '\0') {
                        return uVar3;
                     }

                     pTVar4 = pTVar4 + 0x10;
                  }

                  uVar3 = 1;
               }

            }

         }

         return uVar3;
      }

      /* glslang::TQualifier::isMemory() const */
      byte glslang::TQualifier::isMemory(TQualifier *this) {
         TQualifier TVar1;
         byte bVar2;
         byte bVar3;
         TVar1 = this[0xe];
         bVar3 = -((char)TVar1 >> 7);
         if (( ( ( ( bVar3 == 0 ) && ( bVar3 = (byte)TVar1 >> 6 & 1((byte)TVar1 >> 6 & 1) == 0 ) ) && ( bVar3 = (byte)TVar1 >> 5 & 1((byte)TVar1 >> 5 & 1) == 0 ) ) && ( ( bVar3 = (byte)TVar1 >> 4 & 1((byte)TVar1 >> 4 & 1) == 0 && ( bVar3 = (byte)TVar1 >> 3 & 1((byte)TVar1 >> 3 & 1) == 0 ) ) ) ) && ( bVar3 = (byte)TVar1 >> 1 & 1((byte)TVar1 >> 1 & 1) == 0 )) {
            bVar3 = (byte)TVar1 >> 2 & 1;
            if (( (byte)TVar1 >> 2 & 1 ) == 0) {
               bVar2 = (byte)this[0xd] >> 6;
               bVar3 = bVar2 & 1;
               if (( ( ( bVar2 & 1 ) == 0 ) && ( bVar3 = -((char)this[0xd] >> 7) ),bVar3 == 0 )) {
                  return (byte)this[0xf] & 1;
               }

            }

         }

         return bVar3;
      }

      /* glslang::TQualifier::isAuxiliary() const */
      byte glslang::TQualifier::isAuxiliary(TQualifier *this) {
         TQualifier TVar1;
         byte bVar2;
         bVar2 = (byte)this[0xb] >> 5 & 1;
         if (( (byte)this[0xb] >> 5 & 1 ) == 0) {
            TVar1 = this[0xd];
            bVar2 = (byte)TVar1 >> 4 & 1;
            if (( ( (byte)TVar1 >> 4 & 1 ) == 0 ) && ( bVar2 = (byte)TVar1 >> 5 & 1((byte)TVar1 >> 5 & 1) == 0 )) {
               bVar2 = -((char)this[0xc] >> 7);
               if (( byte ) - ( (char)this[0xc] >> 7 ) == 0) {
                  bVar2 = (byte)TVar1 & 1;
               }

               return bVar2;
            }

         }

         return bVar2;
      }

      /* glslang::TQualifier::isArrayedIo(EShLanguage) const */
      ulong glslang::TQualifier::isArrayedIo(TQualifier *this, undefined4 param_2) {
         byte bVar1;
         uint uVar2;
         ulong uVar3;
         bool bVar4;
         switch (param_2) {
            default:
    return 0;
            case 1:
    if (((byte)this[0xd] & 0x10) != 0) {
      return 0;
    }
    uVar3 = (ulong)((byte)this[8] & 0x7f);
    bVar1 = (byte)((byte)this[8] & 0x7f);
    if (0x1b < bVar1) {
      return (ulong)(bVar1 < 0x1f);
    }
    bVar4 = (0xe300008UL >> (uVar3 & 0x3f) & 1) != 0;
    if (bVar4) {
      return CONCAT71(0xe3000,bVar4);
    }
    break;
            case 2:
    if (((byte)this[0xd] >> 4 & 1) != 0) {
      return 0;
    }
    uVar2 = (byte)this[8] & 0x7f;
    if (0x1b < (byte)uVar2) {
      return (ulong)((byte)this[0xd] >> 4 & 1);
    }
    goto LAB_00159075;
            case 4:
    if ((-1 < (char)this[0xc]) && (((byte)this[0xd] & 1) == 0)) {
      return (ulong)((byte)this[0xd] & 1);
    }
            case 3:
    uVar2 = (byte)this[8] & 0x7f;
    if (0x1b < (byte)uVar2) {
      return 0;
    }
LAB_00159075:
    return CONCAT71(0xe3000,(0xe300008UL >> ((ulong)uVar2 & 0x3f) & 1) != 0);
            case 0xd:
    if (((byte)this[0xd] >> 3 & 1) != 0) {
      return 0;
    }
    uVar3 = (ulong)((byte)this[8] & 0x7f);
    if (0x1e < (byte)((byte)this[8] & 0x7f)) {
      return (ulong)((byte)this[0xd] >> 3 & 1);
    }
         }

         return CONCAT71(0x71c000, ( 0x71c00010UL >> ( uVar3 & 0x3f ) & 1 ) != 0);
      }

      /* glslang::TQualifier::hasLayout() const */
      uint glslang::TQualifier::hasLayout(TQualifier *this) {
         uint uVar1;
         uVar1 = 1;
         if (( ( ( ( ( (byte)this[0xf] & 0x70 ) == 0 ) && ( ( (byte)this[0x10] & 0xf ) == 0 ) ) && ( *(int*)( this + 0x14 ) == -1 ) ) && ( ( ( *(short*)( this + 0x20 ) == -1 && ( ( *(uint*)( this + 0x1c ) & 0x3f8000 ) == 0x1f8000 ) ) && ( ( *(int*)( this + 0x18 ) == -1 && ( ( ( ~*(ushort *)(this + 0x1c) & 0xfff ) == 0 && ( ( (byte)this[0x1d] & 0x70 ) == 0x40 ) ) ) ) ) ) ) ) && ( ( this[0x22] == (TQualifier)0xff && ( ( ( ( ( this[0x23] == (TQualifier)0xff && ( this[0x2c] == (TQualifier)0x0 ) ) && ( uVar1 = (uint)(byte)this[0x38] ),this[0x38] == (TQualifier)0x0 ) ) && ( ( uVar1 = (uint)(byte)this[0x2d] ),this[0x2d] == (TQualifier)0x0 && ( uVar1 = (uint)(byte)this[0x2e] ),this[0x2e] == (TQualifier)0x0 ) ) ) ) && ( ( uVar1 = 1(~(byte)this[0x24] & 0xf) == 0 && ( ( ~*(uint *)(this + 0x24) & 0x3fff0 ) == 0 ) ) ) )) {
            return CONCAT31(( int3 )(~(uint) * (ushort*)( this + 0x26 ) >> 8), ( ~(uint) * (ushort*)( this + 0x26 ) & 0x7ffc ) != 0);
         }

         return uVar1;
      }

      /* glslang::TQualifier::getLayoutFormatString(glslang::TLayoutFormat) */
      char *glslang::TQualifier::getLayoutFormatString(undefined4 param_1) {
         switch (param_1) {
            default:
    return "none";
            case 1:
    return "rgba32f";
            case 2:
    return "rgba16f";
            case 3:
    return "r32f";
            case 4:
    return "rgba8";
            case 5:
    return "rgba8_snorm";
            case 7:
    return "rg32f";
            case 8:
    return "rg16f";
            case 9:
    return "r11f_g11f_b10f";
            case 10:
    return "r16f";
            case 0xb:
    return "rgba16";
            case 0xc:
    return "rgb10_a2";
            case 0xd:
    return "rg16";
            case 0xe:
    return "rg8";
            case 0xf:
    return "r16";
            case 0x10:
    return "r8";
            case 0x11:
    return "rgba16_snorm";
            case 0x12:
    return "rg16_snorm";
            case 0x13:
    return "rg8_snorm";
            case 0x14:
    return "r16_snorm";
            case 0x15:
    return "r8_snorm";
            case 0x17:
    return "rgba32i";
            case 0x18:
    return "rgba16i";
            case 0x19:
    return "rgba8i";
            case 0x1a:
    return "r32i";
            case 0x1c:
    return "rg32i";
            case 0x1d:
    return "rg16i";
            case 0x1e:
    return "rg8i";
            case 0x1f:
    return "r16i";
            case 0x20:
    return "r8i";
            case 0x21:
    return "r64i";
            case 0x23:
    return "rgba32ui";
            case 0x24:
    return "rgba16ui";
            case 0x25:
    return "rgba8ui";
            case 0x26:
    return "r32ui";
            case 0x28:
    return "rg32ui";
            case 0x29:
    return "rg16ui";
            case 0x2a:
    return "rgb10_a2ui";
            case 0x2b:
    return "rg8ui";
            case 0x2c:
    return "r16ui";
            case 0x2d:
    return "r8ui";
            case 0x2e:
    return "r64ui";
            case 0x30:
    return "size1x8";
            case 0x31:
    return "size1x16";
            case 0x32:
    return "size1x32";
            case 0x33:
    return "size2x32";
            case 0x34:
    return "size4x32";
         }

      }

      /* glslang::TQualifier::getBlendEquationString(glslang::TBlendEquationShift) */
      char *glslang::TQualifier::getBlendEquationString(undefined4 param_1) {
         switch (param_1) {
            case 0:
    return "blend_support_multiply";
            case 1:
    return "blend_support_screen";
            case 2:
    return "blend_support_overlay";
            case 3:
    return "blend_support_darken";
            case 4:
    return "blend_support_lighten";
            case 5:
    return "blend_support_colordodge";
            case 6:
    return "blend_support_colorburn";
            case 7:
    return "blend_support_hardlight";
            case 8:
    return "blend_support_softlight";
            case 9:
    return "blend_support_difference";
            case 10:
    return "blend_support_exclusion";
            case 0xb:
    return "blend_support_hsl_hue";
            case 0xc:
    return "blend_support_hsl_saturation";
            case 0xd:
    return "blend_support_hsl_color";
            case 0xe:
    return "blend_support_hsl_luminosity";
            case 0xf:
    return "blend_support_all_equations";
            default:
    return "unknown";
         }

      }

      /* glslang::TType::TType(glslang::TBasicType, glslang::TStorageQualifier, int, int, int, bool) */
      void glslang::TType::TType(TType *this, TType param_2, uint param_3, uint param_4, uint param_5, uint param_6, byte param_7) {
         this[8] = param_2;
         *(undefined***)this = &PTR__TType_00167f00;
         *(undefined8*)( this + 0x10 ) = 0;
         *(undefined8*)( this + 0x44 ) = 0xfffff800;
         *(undefined8*)( this + 0x24 ) = 0xffffffffffffffff;
         this[0x40] = (TType)0x0;
         *(uint*)( this + 0x80 ) = *(uint*)( this + 0x80 ) & 0x9fc00000;
         this[0x20] = ( TType )((byte)this[0x20] & 0xf0);
         *(undefined4*)( this + 0x4c ) = 0xffffffff;
         *(undefined8*)( this + 0x50 ) = 0;
         *(undefined1(*) [16])( this + 0x88 ) = (undefined1[16])0x0;
         *(undefined1(*) [16])( this + 0x60 ) = (undefined1[16])0x0;
         *(undefined1(*) [16])( this + 0x70 ) = (undefined1[16])0x0;
         *(undefined2*)( this + 0x58 ) = 0;
         *(uint*)( this + 8 ) = ( param_5 & 0xf ) << 0xc | ( param_4 & 0xf ) << 8 | ( param_6 & 0xf ) << 0x10 | ( uint )(param_4 == 1 & param_7) << 0x14 | *(uint*)( this + 8 ) & 0xf80000ff;
         *(ulong*)( this + 0x2d ) = *(ulong*)( this + 0x2d ) & 0xffffff0000ffc07f | 0xffff001f80;
         *(ulong*)( this + 0x38 ) = ( ulong )(( uint ) * (undefined8*)( this + 0x38 ) & 0xfe07ff00) | 0x1f800ff;
         *(ulong*)( this + 0x2c ) = *(ulong*)( this + 0x2c ) & 0xffffffff8000 | 0xffff000000004fff;
         *(ulong*)( this + 0x34 ) = *(ulong*)( this + 0x34 ) | 0x7ff007fffffff;
         *(ulong*)( this + 0x18 ) = *(ulong*)( this + 0x18 ) & 0x8000000400000000 | ( ulong )(param_3 & 0x7f);
         return;
      }

      /* glslang::TType::TType(glslang::TType const&, int, bool) */
      void glslang::TType::TType(TType *this, TType *param_1, int param_2, bool param_3) {
         undefined8 uVar1;
         undefined8 uVar2;
         TType TVar3;
         TType TVar4;
         ushort uVar5;
         uint uVar6;
         uint uVar7;
         undefined4 uVar8;
         code *pcVar9;
         undefined8 uVar10;
         undefined8 uVar11;
         undefined8 uVar12;
         undefined8 uVar13;
         undefined8 uVar14;
         undefined8 uVar15;
         undefined8 uVar16;
         undefined8 uVar17;
         char cVar18;
         ulong uVar19;
         undefined8 *puVar20;
         undefined8 *puVar21;
         undefined8 uVar22;
         long lVar23;
         uint uVar24;
         long lVar25;
         byte bVar26;
         lVar25 = *(long*)param_1;
         *(undefined***)this = &PTR__TType_00167f00;
         if (*(code**)( lVar25 + 0xe8 ) == isArray) {
            lVar23 = *(long*)( param_1 + 0x60 );
            if (lVar23 != 0) {
               LAB_00159cbd:uVar8 = *(undefined4*)( param_1 + 0x80 );
               uVar6 = *(uint*)( param_1 + 8 );
               *(long*)( this + 0x60 ) = lVar23;
               uVar22 = *(undefined8*)( param_1 + 0x10 );
               uVar12 = *(undefined8*)( param_1 + 0x18 );
               uVar16 = *(undefined8*)( param_1 + 0x20 );
               uVar17 = *(undefined8*)( param_1 + 0x28 );
               *(undefined4*)( this + 0x80 ) = uVar8;
               uVar1 = *(undefined8*)( param_1 + 0x30 );
               uVar2 = *(undefined8*)( param_1 + 0x38 );
               uVar10 = *(undefined8*)( param_1 + 0x40 );
               uVar11 = *(undefined8*)( param_1 + 0x48 );
               *(undefined8*)( this + 0x10 ) = uVar22;
               *(undefined8*)( this + 0x18 ) = uVar12;
               uVar12 = *(undefined8*)( param_1 + 0x50 );
               uVar13 = *(undefined8*)( param_1 + 0x58 );
               uVar14 = *(undefined8*)( param_1 + 0x70 );
               uVar15 = *(undefined8*)( param_1 + 0x78 );
               *(undefined8*)( this + 0x20 ) = uVar16;
               *(undefined8*)( this + 0x28 ) = uVar17;
               uVar22 = *(undefined8*)( param_1 + 0x68 );
               *(undefined8*)( this + 0x30 ) = uVar1;
               *(undefined8*)( this + 0x38 ) = uVar2;
               *(uint*)( this + 8 ) = *(uint*)( this + 8 ) & 0xffe00000 | uVar6 & 0x1fffff;
               *(undefined8*)( this + 0x68 ) = uVar22;
               uVar5 = *(ushort*)( param_1 + 10 );
               uVar22 = *(undefined8*)( param_1 + 0x88 );
               uVar1 = *(undefined8*)( param_1 + 0x90 );
               *(undefined8*)( this + 0x40 ) = uVar10;
               *(undefined8*)( this + 0x48 ) = uVar11;
               *(undefined8*)( this + 0x50 ) = uVar12;
               *(undefined8*)( this + 0x58 ) = uVar13;
               *(undefined8*)( this + 0x70 ) = uVar14;
               *(undefined8*)( this + 0x78 ) = uVar15;
               *(ushort*)( this + 10 ) = *(ushort*)( this + 10 ) & 0xf81f | uVar5 & 0x7e0;
               pcVar9 = *(code**)( lVar25 + 0x98 );
               *(undefined8*)( this + 0x88 ) = uVar22;
               *(undefined8*)( this + 0x90 ) = uVar1;
               if (pcVar9 != getArraySizes) {
                  lVar23 = ( *pcVar9 )(param_1);
               }

               lVar25 = *(long*)( lVar23 + 8 );
               if (( lVar25 != 0 ) && ( (int)( *(long*)( lVar25 + 0x10 ) - *(long*)( lVar25 + 8 ) >> 4 ) == 1 )) {
                  *(undefined8*)( this + 0x60 ) = 0;
                  return;
               }

               uVar19 = glslang::GetThreadPoolAllocator();
               puVar20 = (undefined8*)glslang::TPoolAllocator::allocate(uVar19);
               lVar25 = *(long*)( param_1 + 0x60 );
               puVar20[1] = 0;
               lVar23 = *(long*)( lVar25 + 8 );
               *puVar20 = &PTR__TSmallArrayVector_00167ee0;
               *(undefined4*)( puVar20 + 2 ) = 0;
               *(undefined2*)( (long)puVar20 + 0x14 ) = 1;
               *(undefined8**)( this + 0x60 ) = puVar20;
               if (lVar23 == 0) {
                  return;
               }

               if ((int)( *(long*)( lVar23 + 0x10 ) - *(long*)( lVar23 + 8 ) >> 4 ) < 2) {
                  return;
               }

               uVar19 = glslang::GetThreadPoolAllocator();
               puVar21 = (undefined8*)glslang::TPoolAllocator::allocate(uVar19);
               uVar22 = glslang::GetThreadPoolAllocator();
               for (int i = 0; i < 3; i++) {
                  puVar21[( i + 1 )] = 0;
               }

               *puVar21 = uVar22;
               puVar20[1] = puVar21;
               lVar25 = *(long*)( lVar25 + 8 );
               std::vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>::_M_range_insert<__gnu_cxx::__normal_iterator<glslang::TArraySize*,std::vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>>>(puVar21, 0, *(long*)( lVar25 + 8 ) + 0x10, *(undefined8*)( lVar25 + 0x10 ));
               return;
            }

         }
 else {
            cVar18 = ( **(code**)( lVar25 + 0xe8 ) )(param_1);
            if (cVar18 != '\0') {
               lVar25 = *(long*)param_1;
               lVar23 = *(long*)( param_1 + 0x60 );
               goto LAB_00159cbd;
            }

         }

         lVar25 = *(long*)( param_1 + 0x68 );
         if (( byte )((char)param_1[8] - 0xfU) < 2) {
            lVar25 = *(long*)( (long)param_2 * 0x20 + *(long*)( lVar25 + 8 ) );
            uVar6 = *(uint*)( lVar25 + 8 );
            uVar22 = *(undefined8*)( lVar25 + 0x10 );
            uVar1 = *(undefined8*)( lVar25 + 0x18 );
            uVar2 = *(undefined8*)( lVar25 + 0x20 );
            uVar10 = *(undefined8*)( lVar25 + 0x28 );
            *(undefined4*)( this + 0x80 ) = *(undefined4*)( lVar25 + 0x80 );
            uVar11 = *(undefined8*)( lVar25 + 0x30 );
            uVar12 = *(undefined8*)( lVar25 + 0x38 );
            uVar13 = *(undefined8*)( lVar25 + 0x70 );
            uVar14 = *(undefined8*)( lVar25 + 0x78 );
            *(undefined8*)( this + 0x10 ) = uVar22;
            *(undefined8*)( this + 0x18 ) = uVar1;
            uVar15 = *(undefined8*)( lVar25 + 0x40 );
            uVar16 = *(undefined8*)( lVar25 + 0x48 );
            *(undefined8*)( this + 0x20 ) = uVar2;
            *(undefined8*)( this + 0x28 ) = uVar10;
            uVar2 = *(undefined8*)( lVar25 + 0x50 );
            uVar10 = *(undefined8*)( lVar25 + 0x58 );
            uVar22 = *(undefined8*)( lVar25 + 0x68 );
            *(undefined8*)( this + 0x30 ) = uVar11;
            *(undefined8*)( this + 0x38 ) = uVar12;
            *(uint*)( this + 8 ) = *(uint*)( this + 8 ) & 0xffe00000 | uVar6 & 0x1fffff;
            uVar1 = *(undefined8*)( lVar25 + 0x60 );
            *(undefined8*)( this + 0x68 ) = uVar22;
            uVar22 = *(undefined8*)( lVar25 + 0x88 );
            uVar11 = *(undefined8*)( lVar25 + 0x90 );
            *(undefined8*)( this + 0x60 ) = uVar1;
            uVar5 = *(ushort*)( lVar25 + 10 );
            *(undefined8*)( this + 0x40 ) = uVar15;
            *(undefined8*)( this + 0x48 ) = uVar16;
            *(undefined8*)( this + 0x50 ) = uVar2;
            *(undefined8*)( this + 0x58 ) = uVar10;
            *(undefined8*)( this + 0x70 ) = uVar13;
            *(undefined8*)( this + 0x78 ) = uVar14;
            *(undefined8*)( this + 0x88 ) = uVar22;
            *(undefined8*)( this + 0x90 ) = uVar11;
            *(ushort*)( this + 10 ) = uVar5 & 0x7e0 | *(ushort*)( this + 10 ) & 0xf81f;
            return;
         }

         uVar2 = *(undefined8*)( param_1 + 0x10 );
         uVar10 = *(undefined8*)( param_1 + 0x18 );
         uVar6 = *(uint*)( param_1 + 8 );
         uVar22 = *(undefined8*)( param_1 + 0x70 );
         uVar1 = *(undefined8*)( param_1 + 0x60 );
         uVar11 = *(undefined8*)( param_1 + 0x20 );
         uVar12 = *(undefined8*)( param_1 + 0x28 );
         *(undefined4*)( this + 0x80 ) = *(undefined4*)( param_1 + 0x80 );
         TVar3 = param_1[9];
         uVar13 = *(undefined8*)( param_1 + 0x30 );
         uVar14 = *(undefined8*)( param_1 + 0x38 );
         *(undefined8*)( this + 0x10 ) = uVar2;
         *(undefined8*)( this + 0x18 ) = uVar10;
         uVar24 = uVar6 & 0x7ffffff;
         uVar10 = *(undefined8*)( param_1 + 0x40 );
         uVar15 = *(undefined8*)( param_1 + 0x48 );
         uVar2 = *(undefined8*)( param_1 + 0x78 );
         *(undefined8*)( this + 0x20 ) = uVar11;
         *(undefined8*)( this + 0x28 ) = uVar12;
         uVar11 = *(undefined8*)( param_1 + 0x50 );
         uVar12 = *(undefined8*)( param_1 + 0x58 );
         *(undefined8*)( this + 0x30 ) = uVar13;
         *(undefined8*)( this + 0x38 ) = uVar14;
         TVar4 = param_1[10];
         *(undefined8*)( this + 0x40 ) = uVar10;
         *(undefined8*)( this + 0x48 ) = uVar15;
         uVar10 = *(undefined8*)( param_1 + 0x88 );
         uVar13 = *(undefined8*)( param_1 + 0x90 );
         *(undefined8*)( this + 0x50 ) = uVar11;
         *(undefined8*)( this + 0x58 ) = uVar12;
         uVar7 = *(uint*)( this + 8 );
         *(undefined8*)( this + 0x60 ) = uVar1;
         *(long*)( this + 0x68 ) = lVar25;
         *(undefined8*)( this + 0x70 ) = uVar22;
         *(undefined8*)( this + 0x78 ) = uVar2;
         *(undefined8*)( this + 0x88 ) = uVar10;
         *(undefined8*)( this + 0x90 ) = uVar13;
         *(uint*)( this + 8 ) = uVar7 & 0xf8000000 | uVar24;
         if (( byte )(uVar24 >> 8) < 0x10) {
            if (( 1 < ( (byte)TVar3 & 0xf ) ) || ( ( (byte)TVar4 >> 4 & 1 ) != 0 )) {
               *(uint*)( this + 8 ) = *(uint*)( this + 8 ) & 0xffeff0ff | 0x100;
               return;
            }

            if (( ( (byte)TVar4 >> 5 & 1 ) != 0 ) || ( ( (byte)TVar4 >> 6 & 1 ) != 0 )) {
               *(ushort*)( this + 10 ) = *(ushort*)( this + 10 ) & 0xf81f;
               *(undefined8*)( this + 0x88 ) = 0;
            }

         }
 else {
            bVar26 = (byte)TVar4 & 0xf;
            if (param_3) {
               bVar26 = (byte)TVar3 >> 4;
            }

            *(uint*)( this + 8 ) = uVar7 & 0xf8000000 | uVar6 & 0x7f000ff | (uint)bVar26 << 8;
            if (bVar26 == 1) {
               this[10] = ( TType )((byte)this[10] | 0x10);
            }

         }

         return;
      }

      /* glslang::TType::contains64BitInt() const */
      bool glslang::TType::contains64BitInt(TType *this) {
         undefined1 uVar1;
         char cVar2;
         long lVar3;
         long lVar4;
         TType TVar5;
         lVar3 = *(long*)this;
         if (*(code**)( lVar3 + 400 ) == containsBasicType) {
            TVar5 = this[8];
            if (TVar5 == (TType)0xa) {
               return true;
            }

            if (*(code**)( lVar3 + 0x128 ) != isStruct) {
               cVar2 = ( **(code**)( lVar3 + 0x128 ) )();
               if (cVar2 != '\0') goto LAB_0015a00e;
               goto LAB_0015a02c;
            }

            if (( byte )((char)TVar5 - 0xfU) < 2) {
               LAB_0015a00e:lVar3 = *(long*)( *(long*)( this + 0x68 ) + 0x10 );
               lVar4 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( this + 0x68 ) + 8 ),lVar3,10 ));
               if (lVar3 != lVar4) {
                  return true;
               }

               goto LAB_0015a02c;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar3 + 400 ) )(this, 10);
            if (cVar2 != '\0') {
               return true;
            }

            LAB_0015a02c:lVar3 = *(long*)this;
            if (*(code**)( lVar3 + 400 ) != containsBasicType) {
               /* WARNING: Could not recover jumptable at 0x0015a047. Too many branches */
               /* WARNING: Treating indirect jump as call */
               uVar1 = ( **(code**)( lVar3 + 400 ) )(this, 0xb);
               return (bool)uVar1;
            }

            TVar5 = this[8];
         }

         if (TVar5 == (TType)0xb) {
            return true;
         }

         if (*(code**)( lVar3 + 0x128 ) == isStruct) {
            if (( byte )((char)TVar5 - 0xfU) < 2) {
               LAB_0015a059:lVar3 = *(long*)( *(long*)( this + 0x68 ) + 0x10 );
               lVar4 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( this + 0x68 ) + 8 ),lVar3,0xb ));
               return lVar3 != lVar4;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar3 + 0x128 ) )(this);
            if (cVar2 != '\0') goto LAB_0015a059;
         }

         return false;
      }

      /* glslang::TType::contains16BitInt() const */
      bool glslang::TType::contains16BitInt(TType *this) {
         undefined1 uVar1;
         char cVar2;
         long lVar3;
         long lVar4;
         TType TVar5;
         lVar3 = *(long*)this;
         if (*(code**)( lVar3 + 400 ) == containsBasicType) {
            TVar5 = this[8];
            if (TVar5 == (TType)0x6) {
               return true;
            }

            if (*(code**)( lVar3 + 0x128 ) != isStruct) {
               cVar2 = ( **(code**)( lVar3 + 0x128 ) )();
               if (cVar2 != '\0') goto LAB_0015a11e;
               goto LAB_0015a13c;
            }

            if (( byte )((char)TVar5 - 0xfU) < 2) {
               LAB_0015a11e:lVar3 = *(long*)( *(long*)( this + 0x68 ) + 0x10 );
               lVar4 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( this + 0x68 ) + 8 ),lVar3,6 ));
               if (lVar3 != lVar4) {
                  return true;
               }

               goto LAB_0015a13c;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar3 + 400 ) )(this, 6);
            if (cVar2 != '\0') {
               return true;
            }

            LAB_0015a13c:lVar3 = *(long*)this;
            if (*(code**)( lVar3 + 400 ) != containsBasicType) {
               /* WARNING: Could not recover jumptable at 0x0015a157. Too many branches */
               /* WARNING: Treating indirect jump as call */
               uVar1 = ( **(code**)( lVar3 + 400 ) )(this, 7);
               return (bool)uVar1;
            }

            TVar5 = this[8];
         }

         if (TVar5 == (TType)0x7) {
            return true;
         }

         if (*(code**)( lVar3 + 0x128 ) == isStruct) {
            if (( byte )((char)TVar5 - 0xfU) < 2) {
               LAB_0015a169:lVar3 = *(long*)( *(long*)( this + 0x68 ) + 0x10 );
               lVar4 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( this + 0x68 ) + 8 ),lVar3,7 ));
               return lVar3 != lVar4;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar3 + 0x128 ) )(this);
            if (cVar2 != '\0') goto LAB_0015a169;
         }

         return false;
      }

      /* glslang::TType::contains8BitInt() const */
      bool glslang::TType::contains8BitInt(TType *this) {
         undefined1 uVar1;
         char cVar2;
         long lVar3;
         long lVar4;
         TType TVar5;
         lVar3 = *(long*)this;
         if (*(code**)( lVar3 + 400 ) == containsBasicType) {
            TVar5 = this[8];
            if (TVar5 == (TType)0x4) {
               return true;
            }

            if (*(code**)( lVar3 + 0x128 ) != isStruct) {
               cVar2 = ( **(code**)( lVar3 + 0x128 ) )();
               if (cVar2 != '\0') goto LAB_0015a22e;
               goto LAB_0015a24c;
            }

            if (( byte )((char)TVar5 - 0xfU) < 2) {
               LAB_0015a22e:lVar3 = *(long*)( *(long*)( this + 0x68 ) + 0x10 );
               lVar4 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( this + 0x68 ) + 8 ),lVar3,4 ));
               if (lVar3 != lVar4) {
                  return true;
               }

               goto LAB_0015a24c;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar3 + 400 ) )(this, 4);
            if (cVar2 != '\0') {
               return true;
            }

            LAB_0015a24c:lVar3 = *(long*)this;
            if (*(code**)( lVar3 + 400 ) != containsBasicType) {
               /* WARNING: Could not recover jumptable at 0x0015a267. Too many branches */
               /* WARNING: Treating indirect jump as call */
               uVar1 = ( **(code**)( lVar3 + 400 ) )(this, 5);
               return (bool)uVar1;
            }

            TVar5 = this[8];
         }

         if (TVar5 == (TType)0x5) {
            return true;
         }

         if (*(code**)( lVar3 + 0x128 ) == isStruct) {
            if (( byte )((char)TVar5 - 0xfU) < 2) {
               LAB_0015a279:lVar3 = *(long*)( *(long*)( this + 0x68 ) + 0x10 );
               lVar4 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsBasicType(glslang::TBasicType)const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsBasicType (glslang::TBasicType)const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( this + 0x68 ) + 8 ),lVar3,5 ));
               return lVar3 != lVar4;
            }

         }
 else {
            cVar2 = ( **(code**)( lVar3 + 0x128 ) )(this);
            if (cVar2 != '\0') goto LAB_0015a279;
         }

         return false;
      }

      /* glslang::TType::getBasicString(glslang::TBasicType) */
      char *glslang::TType::getBasicString(undefined4 param_1) {
         switch (param_1) {
            case 0:
    return "void";
            case 1:
    return "float";
            case 2:
    return "double";
            case 3:
    return "float16_t";
            case 4:
    return "int8_t";
            case 5:
    return "uint8_t";
            case 6:
    return "int16_t";
            case 7:
    return "uint16_t";
            case 8:
    return "int";
            case 9:
    return "uint";
            case 10:
    return "int64_t";
            case 0xb:
    return "uint64_t";
            case 0xc:
    return "bool";
            case 0xd:
    return "atomic_uint";
            case 0xe:
    return "sampler/image";
            case 0xf:
    return "structure";
            case 0x10:
    return "block";
            case 0x11:
    return "accelerationStructureNV";
            case 0x12:
    return "reference";
            case 0x13:
    return "rayQueryEXT";
            default:
    return "unknown type";
            case 0x15:
    return "coopmat";
            case 0x16:
    return "spirv_type";
            case 0x17:
    return "string";
         }

      }

      /* glslang::TType::computeNumComponents() const */
      uint glslang::TType::computeNumComponents(TType *this) {
         int *piVar1;
         long lVar2;
         long *plVar3;
         long *plVar4;
         long *plVar5;
         long *plVar6;
         long *plVar7;
         long *plVar8;
         long *plVar9;
         TType *this_00;
         uint uVar10;
         uint uVar11;
         uint uVar12;
         int iVar13;
         uint uVar14;
         uint uVar15;
         uint uVar16;
         int *piVar17;
         int iVar18;
         uint uVar19;
         uint uVar20;
         long *plVar21;
         long *plVar22;
         undefined8 *puVar23;
         uint uVar24;
         long *plVar25;
         long *plVar26;
         long *plVar27;
         long *plVar28;
         long *plVar29;
         if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
            uVar10 = (uint)(byte)this[8];
            if (this[8] != (TType)0xf) {
               LAB_0015a5cb:if (uVar10 != 0x10) {
                  if ((byte)this[9] < 0x10) {
                     uVar10 = (byte)this[9] & 0xf;
                  }
 else {
                     uVar10 = ( uint )((byte)this[9] >> 4) * ( (byte)this[10] & 0xf );
                  }

                  goto LAB_0015a5f4;
               }

            }

         }
 else {
            iVar13 = ( **(code**)( *(long*)this + 0x38 ) )();
            if (iVar13 != 0xf) {
               if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                  uVar10 = (uint)(byte)this[8];
               }
 else {
                  uVar10 = ( **(code**)( *(long*)this + 0x38 ) )(this);
               }

               goto LAB_0015a5cb;
            }

         }

         uVar10 = 0;
         plVar21 = *(long**)( *(long*)( this + 0x68 ) + 8 );
         if (plVar21 != *(long**)( *(long*)( this + 0x68 ) + 0x10 )) {
            do {
               plVar3 = (long*)*plVar21;
               if (*(code**)( *plVar3 + 0x38 ) == getBasicType) {
                  uVar16 = ( uint ) * (byte*)( plVar3 + 1 );
                  if (*(byte*)( plVar3 + 1 ) == 0xf) goto LAB_0015a76e;
                  LAB_0015a6bb:if (uVar16 == 0x10) goto LAB_0015a76e;
                  if (*(byte*)( (long)plVar3 + 9 ) < 0x10) {
                     uVar11 = *(byte*)( (long)plVar3 + 9 ) & 0xf;
                  }
 else {
                     uVar11 = ( uint )(*(byte*)( (long)plVar3 + 9 ) >> 4) * ( *(byte*)( (long)plVar3 + 10 ) & 0xf );
                  }

               }
 else {
                  iVar13 = ( **(code**)( *plVar3 + 0x38 ) )(plVar3);
                  if (iVar13 != 0xf) {
                     if (*(code**)( *plVar3 + 0x38 ) == getBasicType) {
                        uVar16 = ( uint ) * (byte*)( plVar3 + 1 );
                     }
 else {
                        uVar16 = ( **(code**)( *plVar3 + 0x38 ) )(plVar3);
                     }

                     goto LAB_0015a6bb;
                  }

                  LAB_0015a76e:uVar16 = 0;
                  uVar11 = 0;
                  plVar27 = *(long**)( plVar3[0xd] + 8 );
                  if (plVar27 != *(long**)( plVar3[0xd] + 0x10 )) {
                     do {
                        plVar4 = (long*)*plVar27;
                        if (*(code**)( *plVar4 + 0x38 ) == getBasicType) {
                           uVar11 = ( uint ) * (byte*)( plVar4 + 1 );
                           if (*(byte*)( plVar4 + 1 ) == 0xf) goto LAB_0015a87d;
                           LAB_0015a7bf:if (uVar11 == 0x10) goto LAB_0015a87d;
                           if (*(byte*)( (long)plVar4 + 9 ) < 0x10) {
                              uVar11 = *(byte*)( (long)plVar4 + 9 ) & 0xf;
                           }
 else {
                              uVar11 = ( *(byte*)( (long)plVar4 + 10 ) & 0xf ) * ( uint )(*(byte*)( (long)plVar4 + 9 ) >> 4);
                           }

                        }
 else {
                           iVar13 = ( **(code**)( *plVar4 + 0x38 ) )(plVar4);
                           if (iVar13 != 0xf) {
                              if (*(code**)( *plVar4 + 0x38 ) == getBasicType) {
                                 uVar11 = ( uint ) * (byte*)( plVar4 + 1 );
                              }
 else {
                                 uVar11 = ( **(code**)( *plVar4 + 0x38 ) )(plVar4);
                              }

                              goto LAB_0015a7bf;
                           }

                           LAB_0015a87d:uVar11 = 0;
                           plVar22 = *(long**)( plVar4[0xd] + 8 );
                           if (plVar22 != *(long**)( plVar4[0xd] + 0x10 )) {
                              do {
                                 plVar5 = (long*)*plVar22;
                                 if (*(code**)( *plVar5 + 0x38 ) == getBasicType) {
                                    uVar19 = ( uint ) * (byte*)( plVar5 + 1 );
                                    if (*(byte*)( plVar5 + 1 ) == 0xf) goto LAB_0015a99a;
                                    LAB_0015a8d4:if (uVar19 == 0x10) goto LAB_0015a99a;
                                    if (*(byte*)( (long)plVar5 + 9 ) < 0x10) {
                                       uVar19 = *(byte*)( (long)plVar5 + 9 ) & 0xf;
                                    }
 else {
                                       uVar19 = ( *(byte*)( (long)plVar5 + 10 ) & 0xf ) * ( uint )(*(byte*)( (long)plVar5 + 9 ) >> 4);
                                    }

                                 }
 else {
                                    iVar13 = ( **(code**)( *plVar5 + 0x38 ) )(plVar5);
                                    if (iVar13 != 0xf) {
                                       if (*(code**)( *plVar5 + 0x38 ) == getBasicType) {
                                          uVar19 = ( uint ) * (byte*)( plVar5 + 1 );
                                       }
 else {
                                          uVar19 = ( **(code**)( *plVar5 + 0x38 ) )(plVar5);
                                       }

                                       goto LAB_0015a8d4;
                                    }

                                    LAB_0015a99a:uVar19 = 0;
                                    plVar28 = *(long**)( plVar5[0xd] + 8 );
                                    if (plVar28 != *(long**)( plVar5[0xd] + 0x10 )) {
                                       do {
                                          plVar6 = (long*)*plVar28;
                                          if (*(code**)( *plVar6 + 0x38 ) == getBasicType) {
                                             uVar12 = ( uint ) * (byte*)( plVar6 + 1 );
                                             if (*(byte*)( plVar6 + 1 ) == 0xf) goto LAB_0015aac8;
                                             LAB_0015a9f2:if (uVar12 == 0x10) goto LAB_0015aac8;
                                             if (*(byte*)( (long)plVar6 + 9 ) < 0x10) {
                                                uVar12 = *(byte*)( (long)plVar6 + 9 ) & 0xf;
                                             }
 else {
                                                uVar12 = ( uint )(*(byte*)( (long)plVar6 + 9 ) >> 4) * ( *(byte*)( (long)plVar6 + 10 ) & 0xf );
                                             }

                                          }
 else {
                                             iVar13 = ( **(code**)( *plVar6 + 0x38 ) )(plVar6);
                                             if (iVar13 != 0xf) {
                                                if (*(code**)( *plVar6 + 0x38 ) == getBasicType) {
                                                   uVar12 = ( uint ) * (byte*)( plVar6 + 1 );
                                                }
 else {
                                                   uVar12 = ( **(code**)( *plVar6 + 0x38 ) )(plVar6);
                                                }

                                                goto LAB_0015a9f2;
                                             }

                                             LAB_0015aac8:uVar12 = 0;
                                             plVar25 = *(long**)( plVar6[0xd] + 8 );
                                             if (plVar25 != *(long**)( plVar6[0xd] + 0x10 )) {
                                                uVar12 = 0;
                                                do {
                                                   plVar7 = (long*)*plVar25;
                                                   if (*(code**)( *plVar7 + 0x38 ) == getBasicType) {
                                                      uVar15 = ( uint ) * (byte*)( plVar7 + 1 );
                                                      if (*(byte*)( plVar7 + 1 ) == 0xf) goto LAB_0015abf0;
                                                      LAB_0015ab21:if (uVar15 == 0x10) goto LAB_0015abf0;
                                                      if (*(byte*)( (long)plVar7 + 9 ) < 0x10) {
                                                         uVar24 = *(byte*)( (long)plVar7 + 9 ) & 0xf;
                                                      }
 else {
                                                         uVar24 = ( uint )(*(byte*)( (long)plVar7 + 9 ) >> 4) * ( *(byte*)( (long)plVar7 + 10 ) & 0xf );
                                                      }

                                                   }
 else {
                                                      iVar13 = ( **(code**)( *plVar7 + 0x38 ) )(plVar7);
                                                      if (iVar13 != 0xf) {
                                                         if (*(code**)( *plVar7 + 0x38 ) == getBasicType) {
                                                            uVar15 = ( uint ) * (byte*)( plVar7 + 1 );
                                                         }
 else {
                                                            uVar15 = ( **(code**)( *plVar7 + 0x38 ) )(plVar7);
                                                         }

                                                         goto LAB_0015ab21;
                                                      }

                                                      LAB_0015abf0:uVar15 = 0;
                                                      uVar24 = 0;
                                                      plVar29 = *(long**)( plVar7[0xd] + 8 );
                                                      if (*(long**)( plVar7[0xd] + 0x10 ) != plVar29) {
                                                         do {
                                                            plVar8 = (long*)*plVar29;
                                                            if (*(code**)( *plVar8 + 0x38 ) == getBasicType) {
                                                               uVar24 = ( uint ) * (byte*)( plVar8 + 1 );
                                                               if (*(byte*)( plVar8 + 1 ) == 0xf) goto LAB_0015ad10;
                                                               LAB_0015ac46:if (uVar24 == 0x10) goto LAB_0015ad10;
                                                               if (*(byte*)( (long)plVar8 + 9 ) < 0x10) {
                                                                  uVar24 = *(byte*)( (long)plVar8 + 9 ) & 0xf;
                                                               }
 else {
                                                                  uVar24 = ( uint )(*(byte*)( (long)plVar8 + 9 ) >> 4) * ( *(byte*)( (long)plVar8 + 10 ) & 0xf );
                                                               }

                                                            }
 else {
                                                               iVar13 = ( **(code**)( *plVar8 + 0x38 ) )(plVar8);
                                                               if (iVar13 != 0xf) {
                                                                  if (*(code**)( *plVar8 + 0x38 ) == getBasicType) {
                                                                     uVar24 = ( uint ) * (byte*)( plVar8 + 1 );
                                                                  }
 else {
                                                                     uVar24 = ( **(code**)( *plVar8 + 0x38 ) )(plVar8);
                                                                  }

                                                                  goto LAB_0015ac46;
                                                               }

                                                               LAB_0015ad10:uVar24 = 0;
                                                               plVar26 = *(long**)( plVar8[0xd] + 8 );
                                                               if (*(long**)( plVar8[0xd] + 0x10 ) != plVar26) {
                                                                  uVar24 = 0;
                                                                  do {
                                                                     plVar9 = (long*)*plVar26;
                                                                     if (*(code**)( *plVar9 + 0x38 ) == getBasicType) {
                                                                        uVar14 = ( uint ) * (byte*)( plVar9 + 1 );
                                                                        if (*(byte*)( plVar9 + 1 ) == 0xf) goto LAB_0015ae30;
                                                                        LAB_0015ad66:if (uVar14 == 0x10) goto LAB_0015ae30;
                                                                        if (*(byte*)( (long)plVar9 + 9 ) < 0x10) {
                                                                           uVar20 = *(byte*)( (long)plVar9 + 9 ) & 0xf;
                                                                        }
 else {
                                                                           uVar20 = ( uint )(*(byte*)( (long)plVar9 + 9 ) >> 4) * ( *(byte*)( (long)plVar9 + 10 ) & 0xf );
                                                                        }

                                                                     }
 else {
                                                                        iVar13 = ( **(code**)( *plVar9 + 0x38 ) )(plVar9);
                                                                        if (iVar13 != 0xf) {
                                                                           if (*(code**)( *plVar9 + 0x38 ) == getBasicType) {
                                                                              uVar14 = ( uint ) * (byte*)( plVar9 + 1 );
                                                                           }
 else {
                                                                              uVar14 = ( **(code**)( *plVar9 + 0x38 ) )(plVar9);
                                                                           }

                                                                           goto LAB_0015ad66;
                                                                        }

                                                                        LAB_0015ae30:uVar20 = 0;
                                                                        puVar23 = *(undefined8**)( plVar9[0xd] + 8 );
                                                                        uVar14 = 0;
                                                                        if (puVar23 != *(undefined8**)( plVar9[0xd] + 0x10 )) {
                                                                           do {
                                                                              this_00 = (TType*)*puVar23;
                                                                              puVar23 = puVar23 + 4;
                                                                              iVar13 = computeNumComponents(this_00);
                                                                              uVar20 = uVar14 + iVar13;
                                                                              uVar14 = uVar20;
                                                                           }
 while ( *(undefined8**)( plVar9[0xd] + 0x10 ) != puVar23 );
                                                                        }

                                                                     }

                                                                     if (( plVar9[0xc] != 0 ) && ( lVar2 = lVar2 != 0 )) {
                                                                        piVar17 = *(int**)( lVar2 + 8 );
                                                                        iVar13 = (int)( *(long*)( lVar2 + 0x10 ) - (long)piVar17 >> 4 );
                                                                        if (iVar13 < 1) {
                                                                           iVar18 = 1;
                                                                        }
 else {
                                                                           piVar1 = piVar17 + 4;
                                                                           iVar18 = 1;
                                                                           if (( (int)( piVar1 + ( ulong )(iVar13 - 1) * 4 ) - (int)piVar17 & 0x10U ) == 0) goto LAB_0015ade2;
                                                                           iVar18 = *piVar17;
                                                                           for (piVar17 = piVar1; piVar17 != piVar1 + ( ulong )(iVar13 - 1) * 4; piVar17 = piVar17 + 8) {
                                                                              LAB_0015ade2:iVar18 = iVar18 * *piVar17 * piVar17[4];
                                                                           }

                                                                        }

                                                                        uVar20 = uVar20 * iVar18;
                                                                     }

                                                                     uVar24 = uVar24 + uVar20;
                                                                     plVar26 = plVar26 + 4;
                                                                  }
 while ( *(long**)( plVar8[0xd] + 0x10 ) != plVar26 );
                                                               }

                                                            }

                                                            if (( plVar8[0xc] != 0 ) && ( lVar2 = lVar2 != 0 )) {
                                                               piVar17 = *(int**)( lVar2 + 8 );
                                                               iVar13 = (int)( *(long*)( lVar2 + 0x10 ) - (long)piVar17 >> 4 );
                                                               if (iVar13 < 1) {
                                                                  iVar18 = 1;
                                                               }
 else {
                                                                  piVar1 = piVar17 + 4;
                                                                  iVar18 = 1;
                                                                  if (( (int)( piVar1 + ( ulong )(iVar13 - 1) * 4 ) - (int)piVar17 & 0x10U ) == 0) goto LAB_0015acc4;
                                                                  iVar18 = *piVar17;
                                                                  for (piVar17 = piVar1; piVar17 != piVar1 + ( ulong )(iVar13 - 1) * 4; piVar17 = piVar17 + 8) {
                                                                     LAB_0015acc4:iVar18 = iVar18 * *piVar17 * piVar17[4];
                                                                  }

                                                               }

                                                               uVar24 = uVar24 * iVar18;
                                                            }

                                                            uVar24 = uVar15 + uVar24;
                                                            plVar29 = plVar29 + 4;
                                                            uVar15 = uVar24;
                                                         }
 while ( *(long**)( plVar7[0xd] + 0x10 ) != plVar29 );
                                                      }

                                                   }

                                                   if (( plVar7[0xc] != 0 ) && ( lVar2 = lVar2 != 0 )) {
                                                      piVar17 = *(int**)( lVar2 + 8 );
                                                      iVar13 = (int)( *(long*)( lVar2 + 0x10 ) - (long)piVar17 >> 4 );
                                                      if (iVar13 < 1) {
                                                         iVar18 = 1;
                                                      }
 else {
                                                         piVar1 = piVar17 + 4;
                                                         iVar18 = 1;
                                                         if (( (int)( piVar1 + ( ulong )(iVar13 - 1) * 4 ) - (int)piVar17 & 0x10U ) == 0) goto LAB_0015aba8;
                                                         iVar18 = *piVar17;
                                                         for (piVar17 = piVar1; piVar17 != piVar1 + ( ulong )(iVar13 - 1) * 4; piVar17 = piVar17 + 8) {
                                                            LAB_0015aba8:iVar18 = iVar18 * *piVar17 * piVar17[4];
                                                         }

                                                      }

                                                      uVar24 = uVar24 * iVar18;
                                                   }

                                                   uVar12 = uVar12 + uVar24;
                                                   plVar25 = plVar25 + 4;
                                                }
 while ( *(long**)( plVar6[0xd] + 0x10 ) != plVar25 );
                                             }

                                          }

                                          if (( plVar6[0xc] != 0 ) && ( lVar2 = lVar2 != 0 )) {
                                             piVar17 = *(int**)( lVar2 + 8 );
                                             iVar13 = (int)( *(long*)( lVar2 + 0x10 ) - (long)piVar17 >> 4 );
                                             if (iVar13 < 1) {
                                                iVar18 = 1;
                                             }
 else {
                                                piVar1 = piVar17 + 4;
                                                iVar18 = 1;
                                                if (( (int)( piVar1 + ( ulong )(iVar13 - 1) * 4 ) - (int)piVar17 & 0x10U ) == 0) goto LAB_0015aa80;
                                                iVar18 = *piVar17;
                                                for (piVar17 = piVar1; piVar17 != piVar1 + ( ulong )(iVar13 - 1) * 4; piVar17 = piVar17 + 8) {
                                                   LAB_0015aa80:iVar18 = iVar18 * *piVar17 * piVar17[4];
                                                }

                                             }

                                             uVar12 = uVar12 * iVar18;
                                          }

                                          uVar19 = uVar19 + uVar12;
                                          plVar28 = plVar28 + 4;
                                       }
 while ( *(long**)( plVar5[0xd] + 0x10 ) != plVar28 );
                                    }

                                 }

                                 if (( plVar5[0xc] != 0 ) && ( lVar2 = lVar2 != 0 )) {
                                    piVar17 = *(int**)( lVar2 + 8 );
                                    iVar13 = (int)( *(long*)( lVar2 + 0x10 ) - (long)piVar17 >> 4 );
                                    if (iVar13 < 1) {
                                       iVar18 = 1;
                                    }
 else {
                                       piVar1 = piVar17 + 4;
                                       iVar18 = 1;
                                       if (( (int)( piVar1 + ( ulong )(iVar13 - 1) * 4 ) - (int)piVar17 & 0x10U ) == 0) goto LAB_0015a958;
                                       iVar18 = *piVar17;
                                       for (piVar17 = piVar1; piVar17 != piVar1 + ( ulong )(iVar13 - 1) * 4; piVar17 = piVar17 + 8) {
                                          LAB_0015a958:iVar18 = iVar18 * *piVar17 * piVar17[4];
                                       }

                                    }

                                    uVar19 = uVar19 * iVar18;
                                 }

                                 uVar11 = uVar11 + uVar19;
                                 plVar22 = plVar22 + 4;
                              }
 while ( *(long**)( plVar4[0xd] + 0x10 ) != plVar22 );
                           }

                        }

                        if (( plVar4[0xc] != 0 ) && ( lVar2 = lVar2 != 0 )) {
                           piVar17 = *(int**)( lVar2 + 8 );
                           iVar13 = (int)( *(long*)( lVar2 + 0x10 ) - (long)piVar17 >> 4 );
                           if (iVar13 < 1) {
                              iVar18 = 1;
                           }
 else {
                              piVar1 = piVar17 + 4;
                              iVar18 = 1;
                              if (( (int)( piVar1 + ( ulong )(iVar13 - 1) * 4 ) - (int)piVar17 & 0x10U ) == 0) goto LAB_0015a840;
                              iVar18 = *piVar17;
                              for (piVar17 = piVar1; piVar17 != piVar1 + ( ulong )(iVar13 - 1) * 4; piVar17 = piVar17 + 8) {
                                 LAB_0015a840:iVar18 = iVar18 * *piVar17 * piVar17[4];
                              }

                           }

                           uVar11 = uVar11 * iVar18;
                        }

                        uVar11 = uVar16 + uVar11;
                        plVar27 = plVar27 + 4;
                        uVar16 = uVar11;
                     }
 while ( *(long**)( plVar3[0xd] + 0x10 ) != plVar27 );
                  }

               }

               if (( plVar3[0xc] != 0 ) && ( lVar2 = lVar2 != 0 )) {
                  piVar17 = *(int**)( lVar2 + 8 );
                  iVar13 = (int)( *(long*)( lVar2 + 0x10 ) - (long)piVar17 >> 4 );
                  if (iVar13 < 1) {
                     iVar18 = 1;
                  }
 else {
                     piVar1 = piVar17 + 4;
                     iVar18 = 1;
                     if (( (int)( piVar1 + ( ulong )(iVar13 - 1) * 4 ) - (int)piVar17 & 0x10U ) == 0) goto LAB_0015a73d;
                     iVar18 = *piVar17;
                     for (piVar17 = piVar1; piVar17 != piVar1 + ( ulong )(iVar13 - 1) * 4; piVar17 = piVar17 + 8) {
                        LAB_0015a73d:iVar18 = iVar18 * *piVar17 * piVar17[4];
                     }

                  }

                  uVar11 = uVar11 * iVar18;
               }

               uVar10 = uVar10 + uVar11;
               plVar21 = plVar21 + 4;
            }
 while ( *(long**)( *(long*)( this + 0x68 ) + 0x10 ) != plVar21 );
         }

         LAB_0015a5f4:if (( *(long*)( this + 0x60 ) != 0 ) && ( lVar2 = lVar2 != 0 )) {
            piVar17 = *(int**)( lVar2 + 8 );
            iVar13 = (int)( *(long*)( lVar2 + 0x10 ) - (long)piVar17 >> 4 );
            if (iVar13 < 1) {
               iVar18 = 1;
            }
 else {
               piVar1 = piVar17 + 4;
               iVar18 = 1;
               if (( (int)( piVar1 + ( ulong )(iVar13 - 1) * 4 ) - (int)piVar17 & 0x10U ) == 0) goto LAB_0015a645;
               iVar18 = *piVar17;
               for (piVar17 = piVar1; piVar17 != piVar1 + ( ulong )(iVar13 - 1) * 4; piVar17 = piVar17 + 8) {
                  LAB_0015a645:iVar18 = iVar18 * *piVar17 * piVar17[4];
               }

            }

            uVar10 = uVar10 * iVar18;
         }

         return uVar10;
      }

      /* glslang::TType::coopMatParameterOK(glslang::TType const&) const */
      bool glslang::TType::coopMatParameterOK(TType *this, TType *param_1) {
         uint uVar1;
         uint uVar2;
         if (( (byte)this[10] & 0x20 ) == 0) {
            if (( ( (byte)this[10] & 0x40 ) != 0 ) && ( ( (byte)param_1[10] & 0x40 ) != 0 )) {
               if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                  uVar2 = (uint)(byte)this[8];
               }
 else {
                  uVar2 = ( **(code**)( *(long*)this + 0x38 ) )();
               }

               if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                  uVar1 = (uint)(byte)param_1[8];
               }
 else {
                  uVar1 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
               }

               if (uVar2 != uVar1) {
                  if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                     uVar2 = (uint)(byte)this[8];
                  }
 else {
                     uVar2 = ( **(code**)( *(long*)this + 0x38 ) )(this);
                  }

                  if (uVar2 != 0x15) {
                     if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                        uVar2 = (uint)(byte)param_1[8];
                     }
 else {
                        uVar2 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
                     }

                     if (uVar2 != 0x15) {
                        return false;
                     }

                  }

               }

               if (*(long*)( this + 0x88 ) == 0) {
                  return *(long*)( param_1 + 0x88 ) != 0;
               }

               return *(long*)( param_1 + 0x88 ) == 0;
            }

         }
 else if (( (byte)param_1[10] & 0x20 ) != 0) {
            if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
               uVar2 = (uint)(byte)this[8];
            }
 else {
               uVar2 = ( **(code**)( *(long*)this + 0x38 ) )();
            }

            if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
               uVar1 = (uint)(byte)param_1[8];
            }
 else {
               uVar1 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
            }

            if (( uVar2 == uVar1 ) && ( *(long*)( this + 0x88 ) == 0 )) {
               return *(long*)( param_1 + 0x88 ) != 0;
            }

         }

         return false;
      }

      /* glslang::TType::sameCoopMatBaseType(glslang::TType const&) const */
      bool glslang::TType::sameCoopMatBaseType(TType *this, TType *param_1) {
         int iVar1;
         uint uVar2;
         TType TVar3;
         bool bVar4;
         if (( (byte)this[10] & 0x20 ) != 0) {
            if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
               TVar3 = this[8];
               if (TVar3 != (TType)0x1) {
                  LAB_0015b329:if (TVar3 != (TType)0x3) {
                     LAB_0015b32e:if (TVar3 != (TType)0x9) {
                        LAB_0015b337:if (TVar3 != (TType)0x5) {
                           LAB_0015b340:if (TVar3 != (TType)0x7) {
                              LAB_0015b349:if (TVar3 != (TType)0x8) {
                                 LAB_0015b352:uVar2 = (uint)(byte)TVar3;
                                 if (TVar3 != (TType)0x4) {
                                    LAB_0015b51f:if (uVar2 != 6) {
                                       return false;
                                    }

                                 }

                              }

                              LAB_0015b528:if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                                 TVar3 = param_1[8];
                                 if (TVar3 != (TType)0x8) {
                                    LAB_0015b549:uVar2 = (uint)(byte)TVar3;
                                    if (TVar3 != (TType)0x4) {
                                       LAB_0015b552:return uVar2 == 6;
                                    }

                                 }

                              }
 else {
                                 iVar1 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
                                 if (iVar1 != 8) {
                                    if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                                       TVar3 = param_1[8];
                                       goto LAB_0015b549;
                                    }

                                    iVar1 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
                                    if (iVar1 != 4) {
                                       if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                                          uVar2 = (uint)(byte)param_1[8];
                                       }
 else {
                                          uVar2 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
                                       }

                                       goto LAB_0015b552;
                                    }

                                 }

                              }

                              goto LAB_0015b410;
                           }

                        }

                     }

                     LAB_0015b420:if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                        TVar3 = param_1[8];
                        if (TVar3 != (TType)0x9) {
                           LAB_0015b43d:uVar2 = (uint)(byte)TVar3;
                           if (TVar3 != (TType)0x5) {
                              LAB_0015b442:return uVar2 == 7;
                           }

                        }

                     }
 else {
                        iVar1 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
                        if (iVar1 != 9) {
                           if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                              TVar3 = param_1[8];
                              goto LAB_0015b43d;
                           }

                           iVar1 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
                           if (iVar1 != 5) {
                              if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                                 uVar2 = (uint)(byte)param_1[8];
                              }
 else {
                                 uVar2 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
                              }

                              goto LAB_0015b442;
                           }

                        }

                     }

                     goto LAB_0015b410;
                  }

               }

            }
 else {
               iVar1 = ( **(code**)( *(long*)this + 0x38 ) )();
               if (iVar1 != 1) {
                  if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                     TVar3 = this[8];
                     goto LAB_0015b329;
                  }

                  iVar1 = ( **(code**)( *(long*)this + 0x38 ) )(this);
                  if (iVar1 != 3) {
                     if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                        TVar3 = this[8];
                        goto LAB_0015b32e;
                     }

                     iVar1 = ( **(code**)( *(long*)this + 0x38 ) )(this);
                     if (iVar1 != 9) {
                        if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                           TVar3 = this[8];
                           goto LAB_0015b337;
                        }

                        iVar1 = ( **(code**)( *(long*)this + 0x38 ) )(this);
                        if (iVar1 != 5) {
                           if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                              TVar3 = this[8];
                              goto LAB_0015b340;
                           }

                           iVar1 = ( **(code**)( *(long*)this + 0x38 ) )(this);
                           if (iVar1 != 7) {
                              if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                                 TVar3 = this[8];
                                 goto LAB_0015b349;
                              }

                              iVar1 = ( **(code**)( *(long*)this + 0x38 ) )(this);
                              if (iVar1 != 8) {
                                 if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                                    TVar3 = this[8];
                                    goto LAB_0015b352;
                                 }

                                 iVar1 = ( **(code**)( *(long*)this + 0x38 ) )(this);
                                 if (iVar1 != 4) {
                                    if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                                       uVar2 = (uint)(byte)this[8];
                                    }
 else {
                                       uVar2 = ( **(code**)( *(long*)this + 0x38 ) )(this);
                                    }

                                    goto LAB_0015b51f;
                                 }

                              }

                              goto LAB_0015b528;
                           }

                        }

                     }

                     goto LAB_0015b420;
                  }

               }

            }

            if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
               uVar2 = (uint)(byte)param_1[8];
               if (param_1[8] != (TType)0x1) {
                  LAB_0015b3a1:return uVar2 == 3;
               }

            }
 else {
               iVar1 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
               if (iVar1 != 1) {
                  if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                     uVar2 = (uint)(byte)param_1[8];
                  }
 else {
                     uVar2 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
                  }

                  goto LAB_0015b3a1;
               }

            }

            goto LAB_0015b410;
         }

         if (( (byte)this[10] & 0x40 ) == 0) {
            return false;
         }

         if (( (byte)param_1[10] & 0x40 ) == 0) {
            return false;
         }

         if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
            TVar3 = this[8];
            if (TVar3 == (TType)0x1) goto LAB_0015b3ec;
            LAB_0015b3e4:if (TVar3 == (TType)0x3) goto LAB_0015b3ec;
            LAB_0015b568:if (TVar3 != (TType)0x9) {
               LAB_0015b56c:if (TVar3 != (TType)0x5) {
                  LAB_0015b570:if (TVar3 != (TType)0x7) {
                     LAB_0015b574:if (TVar3 != (TType)0x8) {
                        LAB_0015b578:uVar2 = (uint)(byte)TVar3;
                        if (TVar3 != (TType)0x4) {
                           LAB_0015b57c:if (uVar2 != 6) {
                              return false;
                           }

                        }

                     }

                     LAB_0015b585:if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                        TVar3 = param_1[8];
                        if (TVar3 != (TType)0x8) {
                           LAB_0015b5a5:if (TVar3 != (TType)0x4) {
                              LAB_0015b5ad:uVar2 = (uint)(byte)TVar3;
                              if (TVar3 != (TType)0x6) {
                                 LAB_0015b5b5:return uVar2 == 0x15;
                              }

                           }

                        }

                     }
 else {
                        iVar1 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
                        if (iVar1 != 8) {
                           if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                              TVar3 = param_1[8];
                              goto LAB_0015b5a5;
                           }

                           iVar1 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
                           if (iVar1 != 4) {
                              if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                                 TVar3 = param_1[8];
                                 goto LAB_0015b5ad;
                              }

                              iVar1 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
                              if (iVar1 != 6) {
                                 if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                                    uVar2 = (uint)(byte)param_1[8];
                                 }
 else {
                                    uVar2 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
                                 }

                                 goto LAB_0015b5b5;
                              }

                           }

                        }

                     }

                     goto LAB_0015b410;
                  }

               }

            }

            LAB_0015b5e8:if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
               TVar3 = param_1[8];
               if (TVar3 == (TType)0x9) goto LAB_0015b410;
               LAB_0015b609:if (TVar3 == (TType)0x5) goto LAB_0015b410;
               LAB_0015b612:uVar2 = (uint)(byte)TVar3;
               if (TVar3 == (TType)0x7) goto LAB_0015b410;
            }
 else {
               iVar1 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
               if (iVar1 == 9) goto LAB_0015b410;
               if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                  TVar3 = param_1[8];
                  goto LAB_0015b609;
               }

               iVar1 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
               if (iVar1 == 5) goto LAB_0015b410;
               if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                  TVar3 = param_1[8];
                  goto LAB_0015b612;
               }

               iVar1 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
               if (iVar1 == 7) goto LAB_0015b410;
               LAB_0015b77d:if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                  uVar2 = (uint)(byte)param_1[8];
               }
 else {
                  uVar2 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
               }

            }

            LAB_0015b5d9:bVar4 = uVar2 == 0x15;
         }
 else {
            iVar1 = ( **(code**)( *(long*)this + 0x38 ) )();
            if (iVar1 != 1) {
               if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                  TVar3 = this[8];
                  goto LAB_0015b3e4;
               }

               iVar1 = ( **(code**)( *(long*)this + 0x38 ) )(this);
               if (iVar1 != 3) {
                  if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                     TVar3 = this[8];
                     goto LAB_0015b568;
                  }

                  iVar1 = ( **(code**)( *(long*)this + 0x38 ) )(this);
                  if (iVar1 != 9) {
                     if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                        TVar3 = this[8];
                        goto LAB_0015b56c;
                     }

                     iVar1 = ( **(code**)( *(long*)this + 0x38 ) )(this);
                     if (iVar1 != 5) {
                        if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                           TVar3 = this[8];
                           goto LAB_0015b570;
                        }

                        iVar1 = ( **(code**)( *(long*)this + 0x38 ) )(this);
                        if (iVar1 != 7) {
                           if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                              TVar3 = this[8];
                              goto LAB_0015b574;
                           }

                           iVar1 = ( **(code**)( *(long*)this + 0x38 ) )(this);
                           if (iVar1 != 8) {
                              if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                                 TVar3 = this[8];
                                 goto LAB_0015b578;
                              }

                              iVar1 = ( **(code**)( *(long*)this + 0x38 ) )(this);
                              if (iVar1 != 4) {
                                 if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                                    uVar2 = (uint)(byte)this[8];
                                 }
 else {
                                    uVar2 = ( **(code**)( *(long*)this + 0x38 ) )(this);
                                 }

                                 goto LAB_0015b57c;
                              }

                           }

                           goto LAB_0015b585;
                        }

                     }

                  }

                  goto LAB_0015b5e8;
               }

            }

            LAB_0015b3ec:if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
               TVar3 = param_1[8];
               if (TVar3 != (TType)0x1) {
                  LAB_0015b5d0:uVar2 = (uint)(byte)TVar3;
                  if (TVar3 != (TType)0x3) goto LAB_0015b5d9;
               }

            }
 else {
               iVar1 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
               if (iVar1 != 1) {
                  if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                     TVar3 = param_1[8];
                     goto LAB_0015b5d0;
                  }

                  iVar1 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
                  if (iVar1 != 3) goto LAB_0015b77d;
               }

            }

            LAB_0015b410:bVar4 = true;
         }

         return bVar4;
      }

      /* glslang::TType::TEMPNAMEPLACEHOLDERVALUE(glslang::TType const&) const */
      ulong glslang::TType::operator ==(TType *this, TType *param_1) {
         long lVar1;
         int *piVar2;
         int *piVar3;
         long lVar4;
         size_t __n;
         TSpirvTypeParameter *pTVar5;
         char cVar6;
         int iVar7;
         ulong uVar8;
         ulong uVar9;
         TSpirvTypeParameter *pTVar10;
         TSpirvTypeParameter *this_00;
         if (this[8] != param_1[8]) {
            return 0;
         }

         uVar8 = sameElementShape(this, param_1, (int*)0x0, (int*)0x0);
         if ((char)uVar8 != '\0') {
            lVar1 = *(long*)( param_1 + 0x60 );
            if (*(long*)( this + 0x60 ) == 0) {
               if (lVar1 != 0) {
                  return 0;
               }

            }
 else {
               if (lVar1 == 0) {
                  return 0;
               }

               cVar6 = TSmallArrayVector::operator ==(*(TSmallArrayVector**)( *(long*)( this + 0x60 ) + 8 ), *(TSmallArrayVector**)( lVar1 + 8 ));
               if (cVar6 == '\0') {
                  if (*(char*)( *(long*)( this + 0x60 ) + 0x14 ) == '\0') {
                     return 0;
                  }

                  if (*(char*)( *(long*)( param_1 + 0x60 ) + 0x14 ) == '\0') {
                     return 0;
                  }

                  if (( *(int*)( *(long*)( param_1 + 0x60 ) + 0x10 ) != 0 ) && ( *(int*)( *(long*)( this + 0x60 ) + 0x10 ) != 0 )) {
                     return 0;
                  }

               }

            }

            piVar2 = *(int**)( this + 0x88 );
            piVar3 = *(int**)( param_1 + 0x88 );
            if (piVar2 == (int*)0x0) {
               if (piVar3 != (int*)0x0) {
                  return 0;
               }

            }
 else {
               if (piVar3 == (int*)0x0) {
                  return 0;
               }

               if (*piVar2 != *piVar3) {
                  return 0;
               }

               cVar6 = TSmallArrayVector::operator ==(*(TSmallArrayVector**)( *(long*)( piVar2 + 2 ) + 8 ), *(TSmallArrayVector**)( *(long*)( piVar3 + 2 ) + 8 ));
               if (cVar6 == '\0') {
                  return 0;
               }

               if (( *piVar2 == 0x16 ) && ( cVar6 = TSpirvType::operator ==(*(TSpirvType**)( piVar2 + 4 ), *(TSpirvType**)( piVar3 + 4 )) ),cVar6 == '\0') {
                  return 0;
               }

            }

            if (( ( *(ushort*)( this + 10 ) ^ *(ushort*)( param_1 + 10 ) ) & 0x380 ) == 0) {
               lVar1 = *(long*)( param_1 + 0x90 );
               lVar4 = *(long*)( this + 0x90 );
               if (lVar4 == 0) {
                  return (ulong)CONCAT11((char)( ( *(ushort*)( this + 10 ) ^ *(ushort*)( param_1 + 10 ) ) >> 8 ), lVar1 == 0);
               }

               if (( lVar1 != 0 ) && ( __n = *(size_t*)( lVar4 + 0x10 ) ),__n == *(size_t*)( lVar1 + 0x10 )) {
                  if (( ( __n == 0 ) || ( iVar7 = memcmp(*(void**)( lVar4 + 8 ), *(void**)( lVar1 + 8 ), __n) ),iVar7 == 0 )) {
                     pTVar5 = *(TSpirvTypeParameter**)( lVar4 + 0x40 );
                     this_00 = *(TSpirvTypeParameter**)( lVar4 + 0x38 );
                     pTVar10 = *(TSpirvTypeParameter**)( lVar1 + 0x38 );
                     if ((long)pTVar5 - (long)this_00 == *(long*)( lVar1 + 0x40 ) - (long)pTVar10) {
                        while (true) {
                           if (this_00 == pTVar5) {
                              return uVar8 & 0xffffffff;
                           }

                           uVar9 = glslang::TSpirvTypeParameter::operator ==(this_00, pTVar10);
                           if ((char)uVar9 == '\0') break;
                           this_00 = this_00 + 0x10;
                           pTVar10 = pTVar10 + 0x10;
                        }
;
                        return uVar9;
                     }

                  }

               }

            }

         }

         return 0;
      }

      /* WARNING: Type propagation algorithm not settling */
      /* glslang::TType::sameStructType(glslang::TType const&, int*, int*) const */
      undefined8 glslang::TType::sameStructType(TType *this, TType *param_1, int *param_2, int *param_3) {
         size_t sVar1;
         bool bVar2;
         TType TVar3;
         char cVar4;
         int iVar5;
         code *pcVar6;
         long lVar7;
         long lVar8;
         long lVar9;
         ulong uVar10;
         ulong uVar11;
         long lVar12;
         ulong uVar13;
         long *plVar14;
         long lVar15;
         long lVar16;
         TType *this_00;
         if (param_2 != (int*)0x0) {
            *param_2 = -1;
            *param_3 = -1;
         }

         if (*(code**)( *(long*)this + 0x128 ) != isStruct) {
            cVar4 = ( **(code**)( *(long*)this + 0x128 ) )(this);
            if (cVar4 == '\0') {
               pcVar6 = *(code**)( *(long*)param_1 + 0x128 );
               if (pcVar6 != isStruct) goto LAB_0015bf48;
               LAB_0015bbfa:if (1 < ( byte )((char)param_1[8] - 0xfU)) {
                  return 1;
               }

            }

            LAB_0015bc0a:if (*(code**)( *(long*)this + 0x128 ) == isStruct) {
               TVar3 = this[8];
               goto LAB_0015bc22;
            }

            cVar4 = ( **(code**)( *(long*)this + 0x128 ) )(this);
            if (cVar4 != '\0') goto LAB_0015bc2a;
            goto LAB_0015bc45;
         }

         TVar3 = this[8];
         if (1 < ( byte )((char)TVar3 - 0xfU)) {
            pcVar6 = *(code**)( *(long*)param_1 + 0x128 );
            if (pcVar6 == isStruct) goto LAB_0015bbfa;
            LAB_0015bf48:cVar4 = ( *pcVar6 )(param_1);
            if (cVar4 == '\0') {
               return 1;
            }

            goto LAB_0015bc0a;
         }

         LAB_0015bc22:if (( byte )((char)TVar3 - 0xfU) < 2) {
            LAB_0015bc2a:if (*(code**)( *(long*)param_1 + 0x128 ) == isStruct) {
               if (( byte )((char)param_1[8] - 0xfU) < 2) {
                  LAB_0015bcb0:if (*(long*)( this + 0x68 ) == *(long*)( param_1 + 0x68 )) {
                     return 1;
                  }

               }

            }
 else {
               cVar4 = ( **(code**)( *(long*)param_1 + 0x128 ) )(param_1);
               if (cVar4 != '\0') goto LAB_0015bcb0;
            }

            LAB_0015bc45:if (*(code**)( *(long*)this + 0x128 ) == isStruct) {
               TVar3 = this[8];
               goto LAB_0015bc5d;
            }

            cVar4 = ( **(code**)( *(long*)this + 0x128 ) )(this);
            if (cVar4 == '\0') {
               return 0;
            }

            pcVar6 = *(code**)( *(long*)param_1 + 0x128 );
            if (pcVar6 != isStruct) goto LAB_0015bf30;
         }
 else {
            LAB_0015bc5d:if (1 < ( byte )((char)TVar3 - 0xfU)) {
               return 0;
            }

            pcVar6 = *(code**)( *(long*)param_1 + 0x128 );
            if (pcVar6 != isStruct) {
               LAB_0015bf30:cVar4 = ( *pcVar6 )(param_1);
               if (cVar4 == '\0') {
                  return 0;
               }

               goto LAB_0015bc83;
            }

         }

         if (1 < ( byte )((char)param_1[8] - 0xfU)) {
            return 0;
         }

         LAB_0015bc83:sVar1 = *(size_t*)( *(long*)( this + 0x78 ) + 0x10 );
         if (sVar1 == *(size_t*)( *(long*)( param_1 + 0x78 ) + 0x10 )) {
            plVar14 = *(long**)( *(long*)( this + 0x78 ) + 8 );
            if (sVar1 == 0) {
               bVar2 = false;
            }
 else {
               iVar5 = memcmp(plVar14, *(void**)( *(long*)( param_1 + 0x78 ) + 8 ), sVar1);
               if (iVar5 != 0) {
                  return 0;
               }

               bVar2 = false;
               if (sVar1 == 0xc) {
                  if (( *plVar14 != 0x65567265505f6c67 ) || ( bVar2 = false ),(int)plVar14[1] != 0x78657472) {
                     bVar2 = true;
                  }

                  bVar2 = !bVar2;
               }

            }

            lVar9 = *(long*)( this + 0x68 );
            lVar12 = *(long*)( lVar9 + 8 );
            lVar16 = *(long*)( *(long*)( param_1 + 0x68 ) + 0x10 );
            lVar7 = *(long*)( lVar9 + 0x10 );
            lVar8 = *(long*)( *(long*)( param_1 + 0x68 ) + 8 );
            if (( ( param_2 != (int*)0x0 ) || ( lVar16 - lVar8 == lVar7 - lVar12 ) ) || ( bVar2 )) {
               uVar10 = 0;
               uVar11 = 0;
               LAB_0015bd60:uVar13 = lVar16 - lVar8 >> 5;
               if (uVar11 < ( ulong )(lVar7 - lVar12 >> 5)) {
                  if (param_2 != (int*)0x0) {
                     *param_2 = (int)uVar11;
                     *param_3 = (int)uVar10;
                  }

                  lVar15 = uVar11 * 0x20;
                  if (uVar13 <= uVar10) {
                     plVar14 = *(long**)( lVar12 + lVar15 );
                     pcVar6 = *(code**)( *plVar14 + 0x18 );
                     if (pcVar6 == hiddenMember) {
                        if ((char)plVar14[1] == '\0') goto LAB_0015c0a0;
                        pcVar6 = *(code**)( *plVar14 + 0x30 );
                        if (pcVar6 == getFieldName_abi_cxx11_) goto LAB_0015c03f;
                        LAB_0015c190:lVar9 = ( *pcVar6 )();
                        lVar12 = *(long*)( lVar9 + 0x10 );
                     }
 else {
                        cVar4 = ( *pcVar6 )();
                        if (cVar4 != '\0') goto LAB_0015c122;
                        plVar14 = *(long**)( *(long*)( *(long*)( this + 0x68 ) + 8 ) + lVar15 );
                        pcVar6 = *(code**)( *plVar14 + 0x30 );
                        if (pcVar6 != getFieldName_abi_cxx11_) goto LAB_0015c190;
                        LAB_0015c03f:lVar9 = plVar14[0xe];
                        lVar12 = *(long*)( lVar9 + 0x10 );
                     }

                     if (lVar12 == 0x16) {
                        plVar14 = *(long**)( lVar9 + 8 );
                        if (( *plVar14 != 0x6e6f6365535f6c67 || plVar14[1] != 0x69736f5079726164 ) || ( *(long*)( (long)plVar14 + 0xe ) != 0x564e6e6f69746973 )) goto LAB_0015c080;
                     }
 else if (( lVar12 != 0x14 ) || ( ( plVar14 = *(long**)( lVar9 + 8 ) * plVar14 != 0x7469736f505f6c67 || plVar14[1] != 0x69567265506e6f69 || ( (int)plVar14[2] != 0x564e7765 ) ) )) {
                        LAB_0015c080:if (param_2 == (int*)0x0) {
                           return 0;
                        }

                        *param_3 = -1;
                        return 0;
                     }

                     goto LAB_0015c122;
                  }

                  lVar16 = uVar10 * 0x20;
                  pcVar6 = *(code**)( **(long**)( lVar8 + lVar16 ) + 0x30 );
                  if (pcVar6 == getFieldName_abi_cxx11_) {
                     lVar7 = ( *(long**)( lVar8 + lVar16 ) )[0xe];
                  }
 else {
                     lVar7 = ( *pcVar6 )();
                     lVar9 = *(long*)( this + 0x68 );
                     lVar12 = *(long*)( lVar9 + 8 );
                  }

                  this_00 = *(TType**)( lVar12 + lVar15 );
                  if (*(code**)( *(long*)this_00 + 0x30 ) == getFieldName_abi_cxx11_) {
                     lVar8 = *(long*)( this_00 + 0x70 );
                  }
 else {
                     lVar8 = ( **(code**)( *(long*)this_00 + 0x30 ) )(this_00);
                     lVar9 = *(long*)( this + 0x68 );
                     lVar12 = *(long*)( lVar9 + 8 );
                     this_00 = *(TType**)( lVar12 + lVar15 );
                  }

                  sVar1 = *(size_t*)( lVar8 + 0x10 );
                  if (sVar1 == *(size_t*)( lVar7 + 0x10 )) {
                     if (( sVar1 == 0 ) || ( iVar5 = memcmp(*(void**)( lVar8 + 8 ), *(void**)( lVar7 + 8 ), sVar1) ),iVar5 == 0) {
                        cVar4 = operator == ( this_00,*(TType**)( *(long*)( *(long*)( param_1 + 0x68 ) + 8 ) + lVar16 ) );
                        if (cVar4 == '\0') {
                           return 0;
                        }

                        goto LAB_0015c122;
                     }

                  }

                  if (*(code**)( *(long*)this_00 + 0x18 ) == hiddenMember) {
                     if (this_00[8] != (TType)0x0) goto LAB_0015be0e;
                     LAB_0015c2e0:lVar7 = *(long*)( lVar9 + 0x10 );
                     uVar11 = uVar11 + 1;
                     lVar16 = *(long*)( *(long*)( param_1 + 0x68 ) + 0x10 );
                     lVar8 = *(long*)( *(long*)( param_1 + 0x68 ) + 8 );
                     goto LAB_0015bd60;
                  }

                  cVar4 = ( **(code**)( *(long*)this_00 + 0x18 ) )(this_00);
                  if (cVar4 != '\0') {
                     lVar9 = *(long*)( this + 0x68 );
                     lVar12 = *(long*)( lVar9 + 8 );
                     goto LAB_0015c2e0;
                  }

                  LAB_0015be0e:lVar12 = *(long*)( param_1 + 0x68 );
                  lVar8 = *(long*)( lVar12 + 8 );
                  pcVar6 = *(code**)( **(long**)( lVar8 + lVar16 ) + 0x18 );
                  if (pcVar6 == hiddenMember) {
                     if ((char)( *(long**)( lVar8 + lVar16 ) )[1] == '\0') {
                        LAB_0015c3a0:lVar9 = *(long*)( this + 0x68 );
                        lVar16 = *(long*)( lVar12 + 0x10 );
                        uVar10 = uVar10 + 1;
                        lVar7 = *(long*)( lVar9 + 0x10 );
                        lVar12 = *(long*)( lVar9 + 8 );
                        goto LAB_0015bd60;
                     }

                  }
 else {
                     cVar4 = ( *pcVar6 )();
                     if (cVar4 != '\0') {
                        lVar12 = *(long*)( param_1 + 0x68 );
                        lVar8 = *(long*)( lVar12 + 8 );
                        goto LAB_0015c3a0;
                     }

                  }

                  if (!bVar2) {
                     return 0;
                  }

                  plVar14 = *(long**)( *(long*)( *(long*)( this + 0x68 ) + 8 ) + lVar15 );
                  pcVar6 = *(code**)( *plVar14 + 0x30 );
                  if (pcVar6 == getFieldName_abi_cxx11_) {
                     lVar9 = plVar14[0xe];
                  }
 else {
                     lVar9 = ( *pcVar6 )();
                  }

                  if (*(long*)( lVar9 + 0x10 ) == 0x16) {
                     plVar14 = *(long**)( lVar9 + 8 );
                     if (( *plVar14 == 0x6e6f6365535f6c67 && plVar14[1] == 0x69736f5079726164 ) && ( *(long*)( (long)plVar14 + 0xe ) == 0x564e6e6f69746973 )) goto LAB_0015c12a;
                     LAB_0015bea8:lVar12 = *(long*)( param_1 + 0x68 );
                     lVar8 = *(long*)( lVar12 + 8 );
                     pcVar6 = *(code**)( **(long**)( lVar8 + lVar16 ) + 0x30 );
                     if (pcVar6 == getFieldName_abi_cxx11_) {
                        lVar15 = ( *(long**)( lVar8 + lVar16 ) )[0xe];
                     }
 else {
                        lVar15 = ( *pcVar6 )();
                        lVar12 = *(long*)( param_1 + 0x68 );
                        lVar8 = *(long*)( lVar12 + 8 );
                     }

                     lVar9 = *(long*)( this + 0x68 );
                     uVar10 = uVar10 + 1;
                     lVar16 = *(long*)( lVar12 + 0x10 );
                     lVar7 = *(long*)( lVar9 + 0x10 );
                     lVar12 = *(long*)( lVar9 + 8 );
                     if (*(long*)( lVar15 + 0x10 ) == 0x16) {
                        plVar14 = *(long**)( lVar15 + 8 );
                        if (( *plVar14 == 0x6e6f6365535f6c67 && plVar14[1] == 0x69736f5079726164 ) && ( *(long*)( (long)plVar14 + 0xe ) == 0x564e6e6f69746973 )) goto LAB_0015bd60;
                     }
 else if (( *(long*)( lVar15 + 0x10 ) == 0x14 ) && ( ( plVar14 = *(long**)( lVar15 + 8 ) * plVar14 == 0x7469736f505f6c67 && plVar14[1] == 0x69567265506e6f69 && ( (int)plVar14[2] == 0x564e7765 ) ) )) goto LAB_0015bd60;
                     uVar11 = uVar11 + 1;
                     goto LAB_0015bd60;
                  }

                  if (( ( *(long*)( lVar9 + 0x10 ) != 0x14 ) || ( plVar14 = *(long**)( lVar9 + 8 ) * plVar14 != 0x7469736f505f6c67 || plVar14[1] != 0x69567265506e6f69 ) ) || ( (int)plVar14[2] != 0x564e7765 )) goto LAB_0015bea8;
               }
 else {
                  if (uVar13 <= uVar10) {
                     return 1;
                  }

                  if (param_2 != (int*)0x0) {
                     *param_2 = (int)uVar11;
                     *param_3 = (int)uVar10;
                  }

                  plVar14 = *(long**)( lVar8 + uVar10 * 0x20 );
                  pcVar6 = *(code**)( *plVar14 + 0x18 );
                  if (pcVar6 == hiddenMember) {
                     if ((char)plVar14[1] == '\0') {
                        LAB_0015c0a0:uVar11 = uVar11 + 1;
                        uVar10 = uVar10 + 1;
                        goto LAB_0015bd60;
                     }

                     pcVar6 = *(code**)( *plVar14 + 0x30 );
                     if (pcVar6 == getFieldName_abi_cxx11_) goto LAB_0015bfb1;
                     LAB_0015c240:lVar9 = ( *pcVar6 )();
                     lVar12 = *(long*)( lVar9 + 0x10 );
                  }
 else {
                     cVar4 = ( *pcVar6 )();
                     if (cVar4 != '\0') goto LAB_0015c122;
                     plVar14 = *(long**)( *(long*)( *(long*)( param_1 + 0x68 ) + 8 ) + uVar10 * 0x20 );
                     pcVar6 = *(code**)( *plVar14 + 0x30 );
                     if (pcVar6 != getFieldName_abi_cxx11_) goto LAB_0015c240;
                     LAB_0015bfb1:lVar9 = plVar14[0xe];
                     lVar12 = *(long*)( lVar9 + 0x10 );
                  }

                  if (lVar12 == 0x16) {
                     plVar14 = *(long**)( lVar9 + 8 );
                     if (( *plVar14 != 0x6e6f6365535f6c67 || plVar14[1] != 0x69736f5079726164 ) || ( *(long*)( (long)plVar14 + 0xe ) != 0x564e6e6f69746973 )) goto LAB_0015bff8;
                  }
 else if (( lVar12 != 0x14 ) || ( ( plVar14 = *(long**)( lVar9 + 8 ) * plVar14 != 0x7469736f505f6c67 || plVar14[1] != 0x69567265506e6f69 || ( (int)plVar14[2] != 0x564e7765 ) ) )) {
                     LAB_0015bff8:if (param_2 == (int*)0x0) {
                        return 0;
                     }

                     *param_2 = -1;
                     return 0;
                  }

                  LAB_0015c122:uVar10 = uVar10 + 1;
               }

               LAB_0015c12a:uVar11 = uVar11 + 1;
               lVar9 = *(long*)( this + 0x68 );
               lVar7 = *(long*)( lVar9 + 0x10 );
               lVar16 = *(long*)( *(long*)( param_1 + 0x68 ) + 0x10 );
               lVar12 = *(long*)( lVar9 + 8 );
               lVar8 = *(long*)( *(long*)( param_1 + 0x68 ) + 8 );
               goto LAB_0015bd60;
            }

         }

         return 0;
      }

      /* glslang::TType::sameElementShape(glslang::TType const&, int*, int*) const */
      ulong glslang::TType::sameElementShape(TType *this, TType *param_1, int *param_2, int *param_3) {
         TType TVar1;
         TType TVar2;
         uint uVar3;
         uint uVar4;
         uint uVar5;
         ulong uVar6;
         if (param_2 != (int*)0x0) {
            *param_2 = -1;
            *param_3 = -1;
         }

         if (( this[8] == (TType)0xe ) || ( param_1[8] == (TType)0xe )) {
            if (*(short*)( this + 0x80 ) != *(short*)( param_1 + 0x80 )) {
               return 0;
            }

            TVar2 = this[0x82];
            if (( ( (byte)param_1[0x82] ^ (byte)TVar2 ) & 3 ) != 0) {
               return 0;
            }

            TVar1 = param_1[0x82];
            for (int i = 0; i < 4; i++) {
               if (( (byte)TVar2 >> ( i + 2 ) & 1 ) != ( (byte)TVar1 >> ( i + 2 ) & 1 )) {
                  return 0;
               }

            }

            if (( (byte)this[0x83] >> 5 & 1 ) != ( (byte)param_1[0x83] >> 5 & 1 )) {
               return 0;
            }

            if (( (byte)this[0x83] >> 6 & 1 ) != ( (byte)param_1[0x83] >> 6 & 1 )) {
               return 0;
            }

         }

         if (( ( ( ( ( (byte)this[9] ^ (byte)param_1[9] ) & 0xf ) == 0 ) && ( ( (byte)this[9] ^ (byte)param_1[9] ) < 0x10 ) ) && ( TVar2 = this[10](( (byte)param_1[10] ^ (byte)TVar2 ) & 0x1f) == 0 ) ) && ( ( ( (byte)TVar2 >> 5 & 1 ) == ( (byte)param_1[10] >> 5 & 1 ) && ( ( (byte)TVar2 >> 6 & 1 ) == ( (byte)param_1[10] >> 6 & 1 ) ) ) )) {
            uVar3 = sameStructType(this, param_1, param_2, param_3);
            if ((char)uVar3 != '\0') {
               if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                  uVar5 = (uint)(byte)this[8];
               }
 else {
                  uVar5 = ( **(code**)( *(long*)this + 0x38 ) )(this);
               }

               if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                  uVar4 = (uint)(byte)param_1[8];
               }
 else {
                  uVar4 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
               }

               if (( uVar5 == 0x12 ) == ( uVar4 == 0x12 )) {
                  if (*(code**)( *(long*)this + 0x38 ) == getBasicType) {
                     uVar5 = (uint)(byte)this[8];
                  }
 else {
                     uVar5 = ( **(code**)( *(long*)this + 0x38 ) )(this);
                  }

                  if (uVar5 != 0x12) {
                     if (*(code**)( *(long*)param_1 + 0x38 ) == getBasicType) {
                        uVar5 = (uint)(byte)param_1[8];
                     }
 else {
                        uVar5 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
                     }

                     if (uVar5 != 0x12) {
                        return (ulong)uVar3;
                     }

                  }

                  if (*(TType**)( this + 0x68 ) != *(TType**)( param_1 + 0x68 )) {
                     uVar6 = operator == ( *(TType**)( this + 0x68 ),*(TType**)( param_1 + 0x68 ) );
                     return uVar6;
                  }

                  return (ulong)uVar3;
               }

            }

         }

         return 0;
      }

      /* glslang::TVariable::TVariable(std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const*, glslang::TType const&, bool) */
      void glslang::TVariable::TVariable(TVariable *this, basic_string *param_1, TType *param_2, bool param_3) {
         ushort uVar1;
         undefined4 uVar2;
         uint uVar3;
         undefined8 uVar4;
         undefined8 uVar5;
         undefined8 uVar6;
         undefined8 uVar7;
         undefined8 uVar8;
         undefined8 uVar9;
         undefined8 uVar10;
         undefined8 uVar11;
         undefined8 uVar12;
         undefined8 uVar13;
         *(basic_string**)( this + 8 ) = param_1;
         this[0x40] = ( TVariable )((byte)this[0x40] & 0x80);
         uVar1 = ( ushort )(( uint ) * (undefined4*)( this + 0x30 ) >> 0x10);
         *(undefined1(*) [16])( this + 0xb0 ) = (undefined1[16])0x0;
         *(code**)this = std::_Hash_bytes;
         *(uint*)( this + 0x30 ) = CONCAT22(uVar1, 0x100) & 0xf800ffff;
         *(undefined1(*) [16])( this + 0x88 ) = (undefined1[16])0x0;
         *(undefined1(*) [16])( this + 0x98 ) = (undefined1[16])0x0;
         uVar4 = *(undefined8*)( param_2 + 0x10 );
         uVar5 = *(undefined8*)( param_2 + 0x18 );
         uVar6 = *(undefined8*)( param_2 + 0x20 );
         uVar7 = *(undefined8*)( param_2 + 0x28 );
         uVar8 = *(undefined8*)( param_2 + 0x30 );
         uVar9 = *(undefined8*)( param_2 + 0x38 );
         uVar10 = *(undefined8*)( param_2 + 0x40 );
         uVar11 = *(undefined8*)( param_2 + 0x48 );
         *(undefined***)( this + 0x28 ) = &PTR__TType_00167f00;
         *(uint*)( this + 0xa8 ) = *(uint*)( this + 0xa8 ) & 0x9fc00000;
         uVar12 = *(undefined8*)( param_2 + 0x50 );
         uVar13 = *(undefined8*)( param_2 + 0x58 );
         this[0xc0] = (TVariable)param_3;
         uVar2 = *(undefined4*)( param_2 + 0x80 );
         *(undefined8*)( this + 0x10 ) = 0;
         *(undefined4*)( this + 0xa8 ) = uVar2;
         *(undefined8*)( this + 0x18 ) = 0;
         this[0x20] = (TVariable)0x1;
         *(undefined***)( this + 200 ) = &PTR__TConstUnionArray_001680e8;
         for (int i = 0; i < 3; i++) {
            *(undefined8*)( this + ( 8*i + 208 ) ) = 0;
         }

         *(undefined4*)( this + 0xe8 ) = 0xffffffff;
         *(undefined8*)( this + 0x38 ) = uVar4;
         *(undefined8*)( this + 0x40 ) = uVar5;
         *(undefined8*)( this + 0x48 ) = uVar6;
         *(undefined8*)( this + 0x50 ) = uVar7;
         *(undefined8*)( this + 0x58 ) = uVar8;
         *(undefined8*)( this + 0x60 ) = uVar9;
         *(undefined8*)( this + 0x68 ) = uVar10;
         *(undefined8*)( this + 0x70 ) = uVar11;
         *(undefined8*)( this + 0x78 ) = uVar12;
         *(undefined8*)( this + 0x80 ) = uVar13;
         uVar3 = *(uint*)( param_2 + 8 );
         uVar4 = *(undefined8*)( param_2 + 0x78 );
         *(undefined8*)( this + 0x98 ) = *(undefined8*)( param_2 + 0x70 );
         *(undefined8*)( this + 0xa0 ) = uVar4;
         *(uint*)( this + 0x30 ) = ( uint )(uVar1 & 0xf800) << 0x10 | uVar3 & 0x1fffff;
         *(undefined8*)( this + 0x88 ) = *(undefined8*)( param_2 + 0x60 );
         *(undefined8*)( this + 0x90 ) = *(undefined8*)( param_2 + 0x68 );
         uVar4 = *(undefined8*)( param_2 + 0x90 );
         uVar1 = *(ushort*)( param_2 + 10 );
         *(undefined8*)( this + 0xb0 ) = *(undefined8*)( param_2 + 0x88 );
         *(undefined8*)( this + 0xb8 ) = uVar4;
         *(ushort*)( this + 0x32 ) = uVar1 & 0x7e0 | *(ushort*)( this + 0x32 ) & 0xf81f;
         return;
      }

      /* glslang::TSymbolTableLevel::findFunctionNameList(std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const&,
   glslang::TVector<glslang::TFunction const*>&) */
      void glslang::TSymbolTableLevel::findFunctionNameList(TSymbolTableLevel *this, basic_string *param_1, TVector *param_2) {
         void *__s;
         undefined8 *puVar1;
         undefined8 *puVar2;
         undefined1 *puVar3;
         int iVar4;
         uint uVar5;
         void *pvVar6;
         ulong uVar7;
         undefined8 uVar8;
         ulong uVar9;
         _Rb_tree_node_base *p_Var10;
         long lVar11;
         ulong __n;
         undefined8 *puVar12;
         long lVar13;
         _Rb_tree_node_base *p_Var14;
         long lVar15;
         _Rb_tree_node_base *p_Var16;
         _Rb_tree_node_base *p_Var17;
         long in_FS_OFFSET;
         long local_70;
         undefined8 local_68;
         undefined1 *local_60;
         ulong local_58;
         undefined1 local_50[16];
         long local_40;
         uVar9 = *(ulong*)( param_1 + 0x10 );
         __s = *(void**)( param_1 + 8 );
         local_40 = *(long*)( in_FS_OFFSET + 0x28 );
         local_70 = -1;
         if (uVar9 != 0) {
            pvVar6 = memchr(__s, 0x28, uVar9);
            if (pvVar6 == (void*)0x0) {
               uVar9 = 0;
            }
 else {
               local_70 = (long)pvVar6 - (long)__s;
               uVar9 = local_70 + 1;
            }

         }

         local_68 = glslang::GetThreadPoolAllocator();
         local_60 = local_50;
         uVar7 = *(ulong*)( param_1 + 0x10 );
         if (uVar9 <= *(ulong*)( param_1 + 0x10 )) {
            uVar7 = uVar9;
         }

         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_68, *(long*)( param_1 + 8 ), uVar7 + *(long*)( param_1 + 8 ));
         uVar9 = local_58;
         puVar3 = local_60;
         p_Var14 = (_Rb_tree_node_base*)( this + 0x10 );
         p_Var17 = *(_Rb_tree_node_base**)( this + 0x18 );
         p_Var10 = p_Var14;
         if (*(_Rb_tree_node_base**)( this + 0x18 ) != (_Rb_tree_node_base*)0x0) {
            do {
               while (true) {
                  p_Var16 = p_Var17;
                  uVar7 = *(ulong*)( p_Var16 + 0x30 );
                  __n = uVar9;
                  if (uVar7 <= uVar9) {
                     __n = uVar7;
                  }

                  if (( __n != 0 ) && ( iVar4 = memcmp(*(void**)( p_Var16 + 0x28 ), puVar3, __n) ),iVar4 != 0) break;
                  lVar15 = uVar7 - uVar9;
                  if (lVar15 < 0x80000000) {
                     if (-0x80000001 < lVar15) {
                        iVar4 = (int)lVar15;
                        break;
                     }

                     goto LAB_0015c9e0;
                  }

                  LAB_0015ca37:p_Var17 = *(_Rb_tree_node_base**)( p_Var16 + 0x10 );
                  p_Var10 = p_Var16;
                  if (*(_Rb_tree_node_base**)( p_Var16 + 0x10 ) == (_Rb_tree_node_base*)0x0) goto LAB_0015ca44;
               }
;
               if (-1 < iVar4) goto LAB_0015ca37;
               LAB_0015c9e0:p_Var17 = *(_Rb_tree_node_base**)( p_Var16 + 0x18 );
            }
 while ( *(_Rb_tree_node_base**)( p_Var16 + 0x18 ) != (_Rb_tree_node_base*)0x0 );
            LAB_0015ca44:puVar3[local_70] = 0x29;
            p_Var17 = *(_Rb_tree_node_base**)( this + 0x18 );
            puVar3 = local_60;
            goto joined_r0x0015ca5e;
         }

         local_60[local_70] = 0x29;
         p_Var17 = *(_Rb_tree_node_base**)( this + 0x18 );
         if (p_Var17 != (_Rb_tree_node_base*)0x0) {
            do {
               while (true) {
                  uVar9 = *(ulong*)( p_Var17 + 0x30 );
                  uVar7 = uVar9;
                  if (local_58 <= uVar9) {
                     uVar7 = local_58;
                  }

                  if (uVar7 != 0) break;
                  LAB_0015caa9:uVar7 = local_58 - uVar9;
                  if (0x7fffffff < (long)uVar7) goto LAB_0015cacc;
                  if (-0x80000001 < (long)uVar7) goto LAB_0015cac8;
                  LAB_0015ca78:p_Var14 = p_Var17;
                  p_Var17 = *(_Rb_tree_node_base**)( p_Var17 + 0x10 );
                  joined_r0x0015ca5e:if (p_Var17 == (_Rb_tree_node_base*)0x0) goto joined_r0x0015cad8;
               }
;
               uVar5 = memcmp(puVar3, *(void**)( p_Var17 + 0x28 ), uVar7);
               uVar7 = (ulong)uVar5;
               if (uVar5 == 0) goto LAB_0015caa9;
               LAB_0015cac8:if ((int)uVar7 < 0) goto LAB_0015ca78;
               LAB_0015cacc:p_Var17 = *(_Rb_tree_node_base**)( p_Var17 + 0x18 );
            }
 while ( p_Var17 != (_Rb_tree_node_base*)0x0 );
            joined_r0x0015cad8:if (p_Var10 != p_Var14) {
               uVar8 = ( **(code**)( **(long**)( p_Var10 + 0x48 ) + 0x38 ) )();
               puVar1 = *(undefined8**)( param_2 + 0x10 );
               if (puVar1 == *(undefined8**)( param_2 + 0x18 )) {
                  puVar2 = *(undefined8**)( param_2 + 8 );
                  puVar12 = (undefined8*)( (long)puVar1 - (long)puVar2 );
                  uVar9 = (long)puVar12 >> 3;
                  if (uVar9 == 0xfffffffffffffff) {
                     /* WARNING: Subroutine does not return */
                     std::__throw_length_error("vector::_M_realloc_insert");
                  }

                  if (puVar1 == puVar2) {
                     uVar7 = uVar9 + 1;
                     if (0xfffffffffffffffe < uVar9) goto LAB_0015cc30;
                     if (0xfffffffffffffff < uVar7) {
                        uVar7 = 0xfffffffffffffff;
                     }

                     lVar15 = uVar7 * 8;
                     LAB_0015cbf7:lVar11 = glslang::TPoolAllocator::allocate(*(ulong*)param_2);
                     *(undefined8*)( lVar11 + (long)puVar12 ) = uVar8;
                     lVar15 = lVar11 + lVar15;
                     lVar13 = lVar11 + 8;
                     if (puVar1 != puVar2) goto LAB_0015cb61;
                  }
 else {
                     uVar7 = uVar9 * 2;
                     if (uVar7 < uVar9) {
                        LAB_0015cc30:lVar15 = 0x7ffffffffffffff8;
                        goto LAB_0015cbf7;
                     }

                     if (uVar7 != 0) {
                        if (0xfffffffffffffff < uVar7) {
                           uVar7 = 0xfffffffffffffff;
                        }

                        lVar15 = uVar7 << 3;
                        goto LAB_0015cbf7;
                     }

                     *puVar12 = uVar8;
                     lVar15 = 0;
                     lVar11 = 0;
                     LAB_0015cb61:lVar13 = 0;
                     do {
                        *(undefined8*)( lVar11 + lVar13 ) = *(undefined8*)( (long)puVar2 + lVar13 );
                        lVar13 = lVar13 + 8;
                     }
 while ( lVar13 != (long)puVar1 - (long)puVar2 );
                     lVar13 = lVar11 + 8 + lVar13;
                  }

                  *(long*)( param_2 + 0x18 ) = lVar15;
                  *(long*)( param_2 + 8 ) = lVar11;
                  *(long*)( param_2 + 0x10 ) = lVar13;
                  p_Var10 = (_Rb_tree_node_base*)std::_Rb_tree_increment(p_Var10);
               }
 else {
                  *puVar1 = uVar8;
                  *(undefined8**)( param_2 + 0x10 ) = puVar1 + 1;
                  p_Var10 = (_Rb_tree_node_base*)std::_Rb_tree_increment(p_Var10);
               }

               goto joined_r0x0015cad8;
            }

         }

         if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
            /* WARNING: Subroutine does not return */
            __stack_chk_fail();
         }

         return;
      }

      /* glslang::TSymbolTableLevel::hasFunctionName(std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const&) const */
      bool glslang::TSymbolTableLevel::hasFunctionName(TSymbolTableLevel *this, basic_string *param_1) {
         TSymbolTableLevel *pTVar1;
         void *__s2;
         ulong uVar2;
         void *__s;
         int iVar3;
         void *pvVar4;
         ulong uVar5;
         long lVar6;
         ulong uVar7;
         TSymbolTableLevel *pTVar8;
         TSymbolTableLevel *pTVar9;
         bool bVar10;
         if (*(TSymbolTableLevel**)( this + 0x18 ) == (TSymbolTableLevel*)0x0) {
            bVar10 = false;
         }
 else {
            __s2 = *(void**)( param_1 + 8 );
            uVar2 = *(ulong*)( param_1 + 0x10 );
            pTVar8 = this + 0x10;
            pTVar9 = *(TSymbolTableLevel**)( this + 0x18 );
            do {
               while (true) {
                  uVar7 = *(ulong*)( pTVar9 + 0x30 );
                  uVar5 = uVar2;
                  if (uVar7 <= uVar2) {
                     uVar5 = uVar7;
                  }

                  if (( uVar5 != 0 ) && ( iVar3 = memcmp(*(void**)( pTVar9 + 0x28 ), __s2, uVar5) ),iVar3 != 0) break;
                  lVar6 = uVar7 - uVar2;
                  if (lVar6 < 0x80000000) {
                     if (-0x80000001 < lVar6) {
                        iVar3 = (int)lVar6;
                        break;
                     }

                     goto LAB_0015cce0;
                  }

                  LAB_0015cd29:pTVar1 = pTVar9 + 0x10;
                  pTVar8 = pTVar9;
                  pTVar9 = *(TSymbolTableLevel**)pTVar1;
                  if (*(TSymbolTableLevel**)pTVar1 == (TSymbolTableLevel*)0x0) goto LAB_0015cd35;
               }
;
               if (-1 < iVar3) goto LAB_0015cd29;
               LAB_0015cce0:pTVar9 = *(TSymbolTableLevel**)( pTVar9 + 0x18 );
            }
 while ( pTVar9 != (TSymbolTableLevel*)0x0 );
            LAB_0015cd35:bVar10 = false;
            if (( this + 0x10 != pTVar8 ) && ( uVar7 = uVar7 != 0 )) {
               __s = *(void**)( pTVar8 + 0x28 );
               pvVar4 = memchr(__s, 0x28, uVar7);
               if (( pvVar4 != (void*)0x0 ) && ( uVar5 = (long)pvVar4 - (long)__s ),bVar10 = false,uVar5 != 0xffffffffffffffff) {
                  if (uVar5 < uVar7) {
                     uVar7 = uVar5;
                  }

                  uVar5 = uVar7;
                  if (uVar2 <= uVar7) {
                     uVar5 = uVar2;
                  }

                  if (( uVar5 != 0 ) && ( iVar3 = iVar3 != 0 )) {
                     return false;
                  }

                  lVar6 = uVar7 - uVar2;
                  bVar10 = false;
                  if (( lVar6 < 0x80000000 ) && ( -0x80000001 < lVar6 )) {
                     bVar10 = (int)lVar6 == 0;
                  }

               }

            }

         }

         return bVar10;
      }

      /* glslang::TSymbolTable::find(std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const&, bool*, bool*, int*) */
      long glslang::TSymbolTable::find(TSymbolTable *this, basic_string *param_1, bool *param_2, bool *param_3, int *param_4) {
         long lVar1;
         long lVar2;
         void *__s2;
         ulong uVar3;
         ulong uVar4;
         int iVar5;
         int iVar6;
         int iVar8;
         long lVar9;
         ulong uVar10;
         long lVar11;
         long lVar12;
         long lVar13;
         bool bVar14;
         int local_60;
         int iVar7;
         lVar1 = *(long*)this;
         local_60 = 0;
         iVar7 = (int)( *(long*)( this + 8 ) - lVar1 >> 3 );
         iVar6 = iVar7 + -1;
         lVar12 = (long)iVar6;
         do {
            iVar8 = (int)lVar12;
            lVar2 = *(long*)( lVar1 + lVar12 * 8 );
            lVar9 = *(long*)( lVar2 + 0x18 );
            local_60 = ( local_60 + 1 ) - ( uint )(*(char*)( lVar2 + 100 ) == '\0');
            if (lVar9 == 0) {
               LAB_0015cf4d:bVar14 = true;
               if (-1 < -iVar8) break;
            }
 else {
               __s2 = *(void**)( param_1 + 8 );
               uVar3 = *(ulong*)( param_1 + 0x10 );
               lVar13 = lVar2 + 0x10;
               do {
                  while (true) {
                     lVar11 = lVar9;
                     uVar4 = *(ulong*)( lVar11 + 0x30 );
                     uVar10 = uVar3;
                     if (uVar4 <= uVar3) {
                        uVar10 = uVar4;
                     }

                     if (( uVar10 != 0 ) && ( iVar5 = memcmp(*(void**)( lVar11 + 0x28 ), __s2, uVar10) ),iVar5 != 0) break;
                     lVar9 = uVar4 - uVar3;
                     if (lVar9 < 0x80000000) {
                        if (-0x80000001 < lVar9) {
                           iVar5 = (int)lVar9;
                           break;
                        }

                        goto LAB_0015ce80;
                     }

                     LAB_0015cecc:lVar9 = *(long*)( lVar11 + 0x10 );
                     lVar13 = lVar11;
                     if (lVar9 == 0) goto LAB_0015ced8;
                  }
;
                  if (-1 < iVar5) goto LAB_0015cecc;
                  LAB_0015ce80:lVar9 = *(long*)( lVar11 + 0x18 );
               }
 while ( lVar9 != 0 );
               LAB_0015ced8:if (lVar2 + 0x10 == lVar13) goto LAB_0015cf4d;
               uVar4 = *(ulong*)( lVar13 + 0x30 );
               uVar10 = uVar3;
               if (uVar4 <= uVar3) {
                  uVar10 = uVar4;
               }

               if (( uVar10 == 0 ) || ( iVar5 = memcmp(__s2, *(void**)( lVar13 + 0x28 ), uVar10) ),iVar5 == 0) {
                  lVar11 = uVar3 - uVar4;
                  if (lVar11 < 0x80000000) {
                     if (lVar11 < -0x80000000) goto LAB_0015cf4d;
                     iVar5 = (int)lVar11;
                     goto LAB_0015cf44;
                  }

               }
 else {
                  LAB_0015cf44:if (iVar5 < 0) goto LAB_0015cf4d;
               }

               lVar9 = *(long*)( lVar13 + 0x48 );
               bVar14 = lVar9 == 0;
               if (iVar8 < 1) break;
            }

            lVar12 = lVar12 + -1;
         }
 while ( bVar14 );
         if (param_2 != (bool*)0x0) {
            *param_2 = iVar8 < 3;
         }

         if (param_3 != (bool*)0x0) {
            *param_3 = iVar8 == iVar6 || iVar7 < 5;
         }

         if (param_4 != (int*)0x0) {
            iVar6 = 0;
            if (*(char*)( lVar2 + 100 ) != '\0') {
               iVar6 = local_60;
            }

            *param_4 = iVar6;
         }

         return lVar9;
      }

      /* glslang::TIntermediate::getBlockStorageOverride(char const*) const */
      undefined4 glslang::TIntermediate::getBlockStorageOverride(TIntermediate *this, char *param_1) {
         ulong uVar1;
         undefined8 *puVar2;
         int iVar3;
         size_t sVar4;
         ulong uVar5;
         ulong uVar6;
         ulong uVar7;
         undefined4 uVar8;
         undefined8 *puVar9;
         undefined8 *puVar10;
         long *__s1;
         long in_FS_OFFSET;
         long *local_68;
         size_t local_60;
         long local_58[3];
         long local_40;
         local_40 = *(long*)( in_FS_OFFSET + 0x28 );
         local_68 = local_58;
         if (param_1 == (char*)0x0) {
            /* WARNING: Subroutine does not return */
            std::__throw_logic_error("basic_string: construction from null is not valid");
         }

         sVar4 = strlen(param_1);
         std::__cxx11::string::_M_construct<char_const*>(&local_68, param_1, param_1 + sVar4);
         __s1 = local_68;
         if (*(ulong*)( this + 0x5e8 ) < 0x15) {
            for (puVar9 = *(undefined8**)( this + 0x5e0 ); puVar9 != (undefined8*)0x0; puVar9 = (undefined8*)*puVar9) {
               if (( local_60 == puVar9[2] ) && ( ( local_60 == 0 || ( iVar3 = memcmp(__s1, (void*)puVar9[1], local_60) ),iVar3 == 0 ) )) goto LAB_0015d0b2;
            }

         }
 else {
            uVar5 = std::_Hash_bytes(local_68, local_60, 0xc70f6907);
            __s1 = local_68;
            uVar1 = *(ulong*)( this + 0x5d8 );
            uVar7 = uVar5 % uVar1;
            puVar9 = *(undefined8**)( *(long*)( this + 0x5d0 ) + uVar7 * 8 );
            if (puVar9 == (undefined8*)0x0) {
               uVar8 = 3;
               goto LAB_0015d0b5;
            }

            uVar6 = ( (undefined8*)*puVar9 )[6];
            puVar2 = (undefined8*)*puVar9;
            while (( ( puVar10 = puVar2 ),uVar6 != uVar5 || ( local_60 != puVar10[2] ) ) || ( ( local_60 != 0 && ( iVar3 = memcmp(__s1, (void*)puVar10[1], local_60) ),iVar3 != 0 ) )) {
               puVar2 = (undefined8*)*puVar10;
               if (( puVar2 == (undefined8*)0x0 ) || ( uVar6 = puVar2[6] ),puVar9 = puVar10,uVar7 != uVar6 % uVar1) goto LAB_0015d1a0;
            }
;
            puVar9 = (undefined8*)*puVar9;
            if (puVar9 != (undefined8*)0x0) goto LAB_0015d0b2;
         }

         LAB_0015d1a0:uVar8 = 3;
         LAB_0015d0b5:if (__s1 != local_58) {
            operator_delete(__s1, local_58[0] + 1);
         }

         if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return uVar8;
         }

         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
         LAB_0015d0b2:uVar8 = *(undefined4*)( puVar9 + 5 );
         goto LAB_0015d0b5;
      }

      /* glslang::TParseContextBase::~TParseContextBase() */
      void glslang::TParseContextBase::~TParseContextBase(TParseContextBase *this) {
         long lVar1;
         lVar1 = *(long*)( this + 0x4e0 );
         *(code**)this = glslang::TIntermediate::addConversion;
         for (; lVar1 != 0; lVar1 = *(long*)( lVar1 + 0x10 )) {
            std::_Rb_tree<int,std::pair<int_const,int>,std::_Select1st<std::pair<int_const,int>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,int>>>::_M_erase(*(_Rb_tree_node**)( lVar1 + 0x18 ));
         }

         for (lVar1 = *(long*)( this + 0x4a0 ); lVar1 != 0; lVar1 = *(long*)( lVar1 + 0x10 )) {
            std::_Rb_tree<int,std::pair<int_const,glslang::TVariable*>,std::_Select1st<std::pair<int_const,glslang::TVariable*>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVariable*>>>::_M_erase(*(_Rb_tree_node**)( lVar1 + 0x18 ));
         }

         for (int i = 0; i < 5; i++) {
            if (*(code**)( this + ( -32*i + 1120 ) ) != (code*)0) {
               ( **(code**)( this + ( -32*i + 1120 ) ) )(this + ( -32*i + 1104 ), this + ( -32*i + 1104 ), 3);
            }

         }

         for (lVar1 = *(long*)( this + 0x198 ); lVar1 != 0; lVar1 = *(long*)( lVar1 + 0x10 )) {
            std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>>::_M_erase(*(_Rb_tree_node**)( lVar1 + 0x18 ));
         }

         for (lVar1 = *(long*)( this + 0x90 ); lVar1 != 0; lVar1 = *(long*)( lVar1 + 0x10 )) {
            std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,unsigned_int>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,unsigned_int>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,unsigned_int>>>::_M_erase(*(_Rb_tree_node**)( lVar1 + 0x18 ));
         }

         for (lVar1 = *(long*)( this + 0x58 ); lVar1 != 0; lVar1 = *(long*)( lVar1 + 0x10 )) {
            std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TExtensionBehavior>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TExtensionBehavior>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TExtensionBehavior>>>::_M_erase(*(_Rb_tree_node**)( lVar1 + 0x18 ));
         }

         return;
      }

      /* glslang::TParseContextBase::~TParseContextBase() */
      void glslang::TParseContextBase::~TParseContextBase(TParseContextBase *this) {
         ~TParseContextBase(this)
         ;;
         operator_delete(this, 0x500);
         return;
      }

      /* WARNING: Globals starting with '_' overlap smaller symbols at the same address */
      /* void std::__detail::__to_chars_10_impl<unsigned int>(char*, unsigned int, unsigned int) */
      void std::__detail::__to_chars_10_impl<unsigned_int>(char *param_1, uint param_2, uint param_3) {
         char cVar1;
         uint uVar2;
         ulong uVar3;
         uint uVar4;
         uint uVar5;
         long in_FS_OFFSET;
         undefined8 local_e8;
         undefined8 uStack_e0;
         undefined8 local_d8;
         undefined8 uStack_d0;
         undefined8 local_c8;
         undefined8 uStack_c0;
         undefined8 local_b8;
         undefined8 uStack_b0;
         undefined8 local_a8;
         undefined8 uStack_a0;
         undefined8 local_98;
         undefined8 uStack_90;
         undefined8 local_88;
         undefined8 uStack_80;
         undefined8 local_78;
         undefined8 uStack_70;
         undefined8 local_68;
         undefined8 uStack_60;
         undefined8 local_58;
         undefined8 uStack_50;
         undefined8 local_48;
         undefined8 uStack_40;
         undefined8 local_38;
         undefined1 uStack_30;
         undefined7 uStack_2f;
         char cStack_28;
         char acStack_27[23];
         long local_10;
         uVar5 = param_2 - 1;
         local_10 = *(long*)( in_FS_OFFSET + 0x28 );
         local_e8 = __LC616;
         uStack_e0 = _UNK_00168678;
         local_d8 = __LC617;
         uStack_d0 = _UNK_00168688;
         local_c8 = __LC618;
         uStack_c0 = _UNK_00168698;
         local_b8 = __LC619;
         uStack_b0 = _UNK_001686a8;
         local_a8 = __LC620;
         uStack_a0 = _UNK_001686b8;
         local_98 = __LC621;
         uStack_90 = _UNK_001686c8;
         local_88 = __LC622;
         uStack_80 = _UNK_001686d8;
         local_78 = __LC623;
         uStack_70 = _UNK_001686e8;
         local_68 = __LC624;
         uStack_60 = _UNK_001686f8;
         local_58 = __LC625;
         uStack_50 = _UNK_00168708;
         local_48 = __LC626;
         uStack_40 = _UNK_00168718;
         local_38 = __LC627;
         uStack_30 = (undefined1)_UNK_00168728;
         uStack_2f = (undefined7)_LC628._0_8_;
         cStack_28 = SUB81(_LC628._0_8_, 7);
         acStack_27._0_8_ = _LC628._8_8_;
         uVar3 = (ulong)param_3;
         if (99 < param_3) {
            do {
               param_3 = ( uint )(uVar3 / 100);
               uVar2 = (uint)uVar3;
               uVar4 = ( uVar2 + param_3 * -100 ) * 2;
               cVar1 = *(char*)( (long)&local_e8 + (ulong)uVar4 );
               param_1[uVar5] = *(char*)( (long)&local_e8 + ( ulong )(uVar4 + 1) );
               uVar4 = uVar5 - 1;
               uVar5 = uVar5 - 2;
               param_1[uVar4] = cVar1;
               uVar3 = uVar3 / 100;
            }
 while ( 9999 < uVar2 );
         }

         cVar1 = (char)param_3 + '0';
         if (9 < param_3) {
            param_1[1] = *(char*)( (long)&local_e8 + ( ulong )(param_3 * 2 + 1) );
            cVar1 = *(char*)( (long)&local_e8 + ( ulong )(param_3 * 2) );
         }

         *param_1 = cVar1;
         if (local_10 == *(long*)( in_FS_OFFSET + 0x28 )) {
            return;
         }

         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      /* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::basic_string<glslang::std::allocator<char> >(char const*, glslang::std::allocator<char>
   const&) */
      void std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::basic_string<glslang::std::allocator<char>>(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *this, char *param_1, allocator *param_2) {
         size_t sVar1;
         *(undefined8*)this = *(undefined8*)param_2;
         *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 ) = this + 0x18;
         if (param_1 != (char*)0x0) {
            sVar1 = strlen(param_1);
            _M_construct<char_const*>(this, param_1, param_1 + sVar1);
            return;
         }

         /* WARNING: Subroutine does not return */
         std::__throw_logic_error("basic_string: construction from null is not valid");
      }

      /* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const&) */
      void std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::basic_string(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *this, basic_string *param_1) {
         basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> bVar1;
         basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *__src;
         ulong __n;
         ulong uVar2;
         basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *__dest;
         uVar2 = glslang::GetThreadPoolAllocator();
         __dest = this + 0x18;
         *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 ) = __dest;
         __src = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
         __n = *(ulong*)( param_1 + 0x10 );
         *(ulong*)this = uVar2;
         if (__n < 0x10) {
            if (__n == 1) {
               bVar1 = *__src;
               *(undefined8*)( this + 0x10 ) = 1;
               this[0x18] = bVar1;
               this[0x19] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x0;
               return;
            }

            if (__n == 0) {
               *(undefined8*)( this + 0x10 ) = 0;
               *__dest = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x0;
               return;
            }

         }
 else {
            if ((long)__n < 0) {
               /* WARNING: Subroutine does not return */
               std::__throw_length_error("basic_string::_M_create");
            }

            __dest = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)glslang::TPoolAllocator::allocate(uVar2);
            *(ulong*)( this + 0x18 ) = __n;
            *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 ) = __dest;
         }

         memcpy(__dest, __src, __n);
         *(ulong*)( this + 0x10 ) = __n;
         *(undefined1*)( *(long*)( this + 8 ) + __n ) = 0;
         return;
      }

      /* bool glslang::TType::contains<glslang::TType::containsStructure() const::{lambda(glslang::TType
   const*)#1}>(glslang::TType::containsStructure() const::{lambda(glslang::TType const*)#1}) const
    */
      bool glslang::TType::contains<glslang::TType::containsStructure()const::_lambda(glslang::TType_const *)(TType *this, TType *param_2) {
         TType TVar1;
         long lVar2;
         char cVar3;
         code *pcVar4;
         long lVar5;
         pcVar4 = *(code**)( *(long*)this + 0x128 );
         if (this == param_2) {
            LAB_0015d5f0:if (pcVar4 != isStruct) {
               cVar3 = ( *pcVar4 )(this);
               if (cVar3 == '\0') {
                  return false;
               }

               goto LAB_0015d619;
            }

            TVar1 = this[8];
         }
 else {
            if (pcVar4 != isStruct) {
               cVar3 = ( *pcVar4 )();
               if (cVar3 != '\0') {
                  return true;
               }

               pcVar4 = *(code**)( *(long*)this + 0x128 );
               goto LAB_0015d5f0;
            }

            TVar1 = this[8];
            if (( byte )((char)TVar1 - 0xfU) < 2) {
               return true;
            }

         }

         if (1 < ( byte )((char)TVar1 - 0xfU)) {
            return false;
         }

         LAB_0015d619:lVar2 = *(long*)( *(long*)( this + 0x68 ) + 0x10 );
         lVar5 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsStructure()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsStructure ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( this + 0x68 ) + 8 ),lVar2,param_2 ));
         return lVar2 != lVar5;
      }

      /* bool glslang::TType::contains<glslang::TType::containsSampler() const::{lambda(glslang::TType
   const*)#1}>(glslang::TType::containsSampler() const::{lambda(glslang::TType const*)#1}) const */
      bool glslang::TType::contains<glslang::TType::containsSampler()const::_lambda(glslang::TType_const *);
      _1_ > ( long *param_1)

{
  char cVar1;
  long lVar2;
  long lVar3;
  long *plVar4; );
      lVar2 = *param_1;
      if (*(code**)( lVar2 + 0x168 ) == isTexture) {
         if ((char)param_1[1] == '\x0e') {
            if (*(code**)( lVar2 + 0x40 ) == getSampler) {
               plVar4 = param_1 + 0x10;
            }
 else {
               plVar4 = (long*)( **(code**)( lVar2 + 0x40 ) )();
            }

            if (( ( *plVar4 & 0x200000 ) == 0 ) && ( ( *plVar4 & 0x80000 ) == 0 )) {
               return true;
            }

            goto LAB_0015d710;
         }

         pcVar5 = *(code**)( lVar2 + 0x158 );
         if (pcVar5 != isImage) goto LAB_0015d760;
      }
 else {
         cVar1 = ( **(code**)( lVar2 + 0x168 ) )();
         if (cVar1 != '\0') {
            return true;
         }

         LAB_0015d710:lVar2 = *param_1;
         pcVar5 = *(code**)( lVar2 + 0x158 );
         if (pcVar5 == isImage) {
            if ((char)param_1[1] != '\x0e') goto LAB_0015d67f;
            if (*(code**)( lVar2 + 0x40 ) == getSampler) {
               plVar4 = param_1 + 0x10;
            }
 else {
               plVar4 = (long*)( **(code**)( lVar2 + 0x40 ) )(param_1);
            }

            if (( ( *plVar4 & 0x80000 ) != 0 ) && ( 1 < ( byte )(*(char*)( (long)plVar4 + 1 ) - 7U) )) {
               return true;
            }

         }
 else {
            LAB_0015d760:cVar1 = ( *pcVar5 )(param_1);
            if (cVar1 != '\0') {
               return true;
            }

         }

         lVar2 = *param_1;
      }

      LAB_0015d67f:if (*(code**)( lVar2 + 0x128 ) == isStruct) {
         if (( byte )((char)param_1[1] - 0xfU) < 2) {
            LAB_0015d6b1:lVar2 = *(long*)( param_1[0xd] + 0x10 );
            lVar3 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSampler()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsSampler ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( param_1[0xd] + 8 ),lVar2 ));
            return lVar2 != lVar3;
         }

      }
 else {
         cVar1 = ( **(code**)( lVar2 + 0x128 ) )(param_1);
         if (cVar1 != '\0') goto LAB_0015d6b1;
      }

      return false;
   }

   /* glslang::TType::containsSampler() const */
   bool glslang::TType::containsSampler(TType *this) {
      char cVar1;
      long lVar2;
      long lVar3;
      TType *pTVar4;
      code *pcVar5;
      lVar2 = *(long*)this;
      if (*(code**)( lVar2 + 0x168 ) == isTexture) {
         if (this[8] == (TType)0xe) {
            if (*(code**)( lVar2 + 0x40 ) == getSampler) {
               pTVar4 = this + 0x80;
            }
 else {
               pTVar4 = (TType*)( **(code**)( lVar2 + 0x40 ) )();
            }

            if (( ( (byte)pTVar4[2] & 0x20 ) == 0 ) && ( ( (byte)pTVar4[2] & 8 ) == 0 )) {
               return true;
            }

            goto LAB_0015d860;
         }

         pcVar5 = *(code**)( lVar2 + 0x158 );
         if (pcVar5 != isImage) goto LAB_0015d8b0;
      }
 else {
         cVar1 = ( **(code**)( lVar2 + 0x168 ) )();
         if (cVar1 != '\0') {
            return true;
         }

         LAB_0015d860:lVar2 = *(long*)this;
         pcVar5 = *(code**)( lVar2 + 0x158 );
         if (pcVar5 == isImage) {
            if (this[8] != (TType)0xe) goto LAB_0015d7cf;
            if (*(code**)( lVar2 + 0x40 ) == getSampler) {
               pTVar4 = this + 0x80;
            }
 else {
               pTVar4 = (TType*)( **(code**)( lVar2 + 0x40 ) )(this);
            }

            if (( ( (byte)pTVar4[2] & 8 ) != 0 ) && ( 1 < ( byte )((char)pTVar4[1] - 7U) )) {
               return true;
            }

         }
 else {
            LAB_0015d8b0:cVar1 = ( *pcVar5 )(this);
            if (cVar1 != '\0') {
               return true;
            }

         }

         lVar2 = *(long*)this;
      }

      LAB_0015d7cf:if (*(code**)( lVar2 + 0x128 ) == isStruct) {
         if (( byte )((char)this[8] - 0xfU) < 2) {
            LAB_0015d801:lVar2 = *(long*)( *(long*)( this + 0x68 ) + 0x10 );
            lVar3 = std::__find_if<__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>>,__gnu_cxx::__ops::_Iter_pred<glslang::TType::contains<glslang::TType::containsSampler()const::_lambda(glslang::TType_const *)_1_>(glslang::TType::containsSampler ()const::_lambda(glslang::TType_const*) _1_)const::_lambda(glslang::TTypeLoc_const & _1_ >> ( *(undefined8*)( *(long*)( this + 0x68 ) + 8 ),lVar2 ));
            return lVar2 != lVar3;
         }

      }
 else {
         cVar1 = ( **(code**)( lVar2 + 0x128 ) )(this);
         if (cVar1 != '\0') goto LAB_0015d801;
      }

      return false;
   }

   /* WARNING: Unknown calling convention -- yet parameter storage is locked */
   /* bool std::TEMPNAMEPLACEHOLDERVALUE(std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const&, char const*) */
   bool std::operator ==(basic_string *param_1, char *param_2) {
      size_t __n;
      bool bVar1;
      int iVar2;
      size_t sVar3;
      __n = *(size_t*)( param_1 + 0x10 );
      sVar3 = strlen(param_2);
      bVar1 = false;
      if (( __n == sVar3 ) && ( bVar1 = __n != 0 )) {
         iVar2 = memcmp(*(void**)( param_1 + 8 ), param_2, __n);
         return iVar2 == 0;
      }

      return bVar1;
   }

   /* std::map<glslang::TVector<glslang::TTypeLoc>*, glslang::TVector<glslang::TTypeLoc>*,
   std::less<glslang::TVector<glslang::TTypeLoc>*>,
   glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>* const,
   glslang::TVector<glslang::TTypeLoc>*> > >::operator[](glslang::TVector<glslang::TTypeLoc>*
   const&) */
   _Rb_tree_node_base * __thiscallstd::map<glslang::TVector<glslang::TTypeLoc>*,glslang::TVector<glslang::TTypeLoc>*,std::less<glslang::TVector<glslang::TTypeLoc>*>,glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>>>::operator [](map<glslang::TVector<glslang::TTypeLoc>*,glslang::TVector<glslang::TTypeLoc>*,std::less<glslang::TVector<glslang::TTypeLoc>*>,glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>>> * this, TVector * *param_1);
   {
      _Rb_tree_node_base *p_Var1;
      _Rb_tree_node_base *p_Var2;
      long lVar3;
      _Rb_tree_node_base *p_Var4;
      _Rb_tree_node_base *p_Var5;
      _Rb_tree_node_base *p_Var6;
      TVector *pTVar7;
      bool bVar8;
      undefined1 auVar9[16];
      p_Var1 = (_Rb_tree_node_base*)( this + 0x10 );
      if (*(_Rb_tree_node_base**)( this + 0x18 ) == (_Rb_tree_node_base*)0x0) {
         LAB_0015da70:p_Var4 = (_Rb_tree_node_base*)glslang::TPoolAllocator::allocate(*(ulong*)this);
         pTVar7 = *param_1;
         lVar3 = *(long*)( this + 0x30 );
         *(undefined8*)( p_Var4 + 0x28 ) = 0;
         *(TVector**)( p_Var4 + 0x20 ) = pTVar7;
         if (( lVar3 == 0 ) || ( p_Var5 = *(_Rb_tree_node_base**)( this + 0x28 ) ),pTVar7 <= *(TVector**)( p_Var5 + 0x20 )) {
            LAB_0015da40:auVar9 = _Rb_tree<glslang::TVector<glslang::TTypeLoc>*,std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>>,std::less<glslang::TVector<glslang::TTypeLoc>*>,glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>>>::_M_get_insert_unique_pos(( _Rb_tree<glslang::TVector<glslang::TTypeLoc>*,std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector < glslang::TTypeLoc>*>>,std::less<glslang::TVector<glslang::TTypeLoc>*>,glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>> > *)this,(TVector**)pTVar7 ));
            p_Var5 = auVar9._8_8_;
            p_Var6 = auVar9._0_8_;
            if (p_Var5 == (_Rb_tree_node_base*)0x0) goto LAB_0015da07;
            bVar8 = p_Var6 != (_Rb_tree_node_base*)0x0;
         }
 else {
            LAB_0015daa2:bVar8 = false;
         }

         LAB_0015da5c:if (( p_Var1 == p_Var5 ) || ( p_Var6 = bVar8 )) {
            bVar8 = true;
            p_Var6 = p_Var4;
         }
 else {
            LAB_0015daac:p_Var5 = p_Var6;
            bVar8 = pTVar7 < *(TVector**)( p_Var5 + 0x20 );
            p_Var6 = p_Var4;
         }

      }
 else {
         p_Var4 = *(_Rb_tree_node_base**)( this + 0x18 );
         p_Var5 = p_Var1;
         do {
            while (true) {
               p_Var6 = p_Var4;
               p_Var2 = p_Var6 + 0x18;
               if (*param_1 <= *(TVector**)( p_Var6 + 0x20 )) break;
               p_Var4 = *(_Rb_tree_node_base**)p_Var2;
               p_Var6 = p_Var5;
               if (*(_Rb_tree_node_base**)p_Var2 == (_Rb_tree_node_base*)0x0) goto LAB_0015d991;
            }
;
            p_Var4 = *(_Rb_tree_node_base**)( p_Var6 + 0x10 );
            p_Var5 = p_Var6;
         }
 while ( *(_Rb_tree_node_base**)( p_Var6 + 0x10 ) != (_Rb_tree_node_base*)0x0 );
         LAB_0015d991:if (p_Var1 == p_Var6) goto LAB_0015da70;
         if (*(TVector**)( p_Var6 + 0x20 ) <= *param_1) goto LAB_0015da07;
         p_Var4 = (_Rb_tree_node_base*)glslang::TPoolAllocator::allocate(*(ulong*)this);
         pTVar7 = *param_1;
         *(undefined8*)( p_Var4 + 0x28 ) = 0;
         *(TVector**)( p_Var4 + 0x20 ) = pTVar7;
         if (*(TVector**)( p_Var6 + 0x20 ) <= pTVar7) {
            if (pTVar7 <= *(TVector**)( p_Var6 + 0x20 )) goto LAB_0015da07;
            if (*(_Rb_tree_node_base**)( this + 0x28 ) != p_Var6) {
               p_Var5 = (_Rb_tree_node_base*)std::_Rb_tree_increment(p_Var6);
               if (*(TVector**)( p_Var5 + 0x20 ) <= pTVar7) goto LAB_0015da40;
               if (*(long*)( p_Var6 + 0x18 ) == 0) goto LAB_0015daac;
               bVar8 = true;
               goto LAB_0015da5c;
            }

            goto LAB_0015daac;
         }

         if (*(_Rb_tree_node_base**)( this + 0x20 ) != p_Var6) {
            p_Var5 = (_Rb_tree_node_base*)std::_Rb_tree_decrement(p_Var6);
            if (pTVar7 <= *(TVector**)( p_Var5 + 0x20 )) goto LAB_0015da40;
            if (*(long*)( p_Var5 + 0x18 ) != 0) goto LAB_0015d9ec;
            goto LAB_0015daa2;
         }

         LAB_0015d9ec:bVar8 = true;
         p_Var5 = p_Var6;
         p_Var6 = p_Var4;
      }

      std::_Rb_tree_insert_and_rebalance(bVar8, p_Var6, p_Var5, p_Var1);
      *(long*)( this + 0x30 ) = *(long*)( this + 0x30 ) + 1;
      LAB_0015da07:return p_Var6 + 0x28;
   }

   /* std::vector<glslang::TArraySize, glslang::pool_allocator<glslang::TArraySize>
   >::_M_default_append(unsigned long) */
   void std::vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>::_M_default_append(vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>> *this, ulong param_1) {
      ulong uVar1;
      undefined4 *puVar2;
      undefined8 uVar3;
      ulong uVar4;
      long lVar5;
      ulong uVar6;
      undefined4 *puVar7;
      undefined4 *puVar8;
      long lVar9;
      undefined4 *puVar10;
      undefined4 *puVar11;
      if (param_1 == 0) {
         return;
      }

      puVar2 = *(undefined4**)( this + 0x10 );
      puVar10 = *(undefined4**)( this + 8 );
      if (param_1 <= ( ulong )(*(long*)( this + 0x18 ) - (long)puVar2 >> 4)) {
         puVar10 = puVar2;
         do {
            *puVar10 = 0;
            puVar11 = puVar10 + 4;
            *(undefined8*)( puVar10 + 2 ) = 0;
            puVar10 = puVar11;
         }
 while ( puVar11 != puVar2 + param_1 * 4 );
         *(undefined4**)( this + 0x10 ) = puVar11;
         return;
      }

      uVar4 = (long)puVar2 - (long)puVar10 >> 4;
      if (param_1 <= 0x7ffffffffffffff - uVar4) {
         uVar1 = param_1 + uVar4;
         uVar6 = 0x7ffffffffffffff;
         if (uVar1 < 0x800000000000000) {
            uVar6 = uVar1;
         }

         if (( param_1 <= uVar4 ) && ( uVar6 = 0x7ffffffffffffff < uVar6 )) {
            uVar6 = 0x7ffffffffffffff;
         }

         lVar5 = glslang::TPoolAllocator::allocate(*(ulong*)this);
         puVar11 = (undefined4*)( lVar5 + ( (long)puVar2 - (long)puVar10 ) );
         puVar7 = puVar11;
         do {
            *puVar7 = 0;
            puVar8 = puVar7 + 4;
            *(undefined8*)( puVar7 + 2 ) = 0;
            puVar7 = puVar8;
         }
 while ( puVar8 != puVar11 + param_1 * 4 );
         lVar9 = 0;
         if (puVar10 != puVar2) {
            do {
               uVar3 = ( (undefined8*)( (long)puVar10 + lVar9 ) )[1];
               *(undefined8*)( lVar5 + lVar9 ) = *(undefined8*)( (long)puVar10 + lVar9 );
               ( (undefined8*)( lVar5 + lVar9 ) )[1] = uVar3;
               lVar9 = lVar9 + 0x10;
            }
 while ( lVar9 != (long)puVar2 - (long)puVar10 );
         }

         *(long*)( this + 8 ) = lVar5;
         *(ulong*)( this + 0x10 ) = uVar1 * 0x10 + lVar5;
         *(ulong*)( this + 0x18 ) = lVar5 + uVar6 * 0x10;
         return;
      }

      /* WARNING: Subroutine does not return */
      std::__throw_length_error("vector::_M_default_append");
   }

   /* glslang::TType::TType(glslang::TPublicType const&) */
   void glslang::TType::TType(TType *this, TPublicType *param_1) {
      TPublicType TVar1;
      TPublicType TVar2;
      undefined4 uVar3;
      int iVar4;
      long *plVar5;
      char *__s;
      long lVar6;
      long lVar7;
      undefined8 uVar8;
      undefined8 uVar9;
      undefined8 uVar10;
      undefined8 uVar11;
      undefined8 uVar12;
      undefined8 uVar13;
      undefined8 uVar14;
      undefined8 uVar15;
      ulong uVar16;
      undefined8 *puVar17;
      undefined8 uVar18;
      size_t sVar19;
      undefined4 *puVar20;
      long lVar21;
      byte bVar22;
      int iVar23;
      uint uVar24;
      long lVar25;
      TVar1 = param_1[0xb8];
      *(undefined***)this = &PTR__TType_00167f00;
      TVar2 = param_1[0xb9];
      uVar3 = *(undefined4*)param_1;
      *(undefined8*)( this + 0x68 ) = 0;
      uVar18 = *(undefined8*)( param_1 + 0xe8 );
      uVar8 = *(undefined8*)( param_1 + 0xf0 );
      *(undefined8*)( this + 0x70 ) = 0;
      this[8] = SUB41(uVar3, 0);
      uVar24 = (byte)TVar2 >> 4 & 1;
      *(undefined8*)( this + 0x88 ) = uVar18;
      *(undefined8*)( this + 0x90 ) = uVar8;
      *(undefined8*)( this + 0x78 ) = 0;
      bVar22 = (byte)TVar2 >> 5 & 1;
      *(uint*)( this + 8 ) = ( uint )((byte)TVar1 >> 4) << 0xc | ( (byte)TVar1 & 0xf ) << 8 | ( (byte)TVar2 & 0xf ) << 0x10 | uVar24 << 0x15 | (uint)bVar22 << 0x16 | *(uint*)( this + 8 ) & 0xf80000ff;
      *(undefined8*)( this + 0x60 ) = *(undefined8*)( param_1 + 0xc0 );
      if (SUB41(uVar3, 0) == (TType)0xe) {
         *(undefined4*)( this + 0x80 ) = *(undefined4*)( param_1 + 4 );
      }
 else {
         *(uint*)( this + 0x80 ) = *(uint*)( this + 0x80 ) & 0x9fc00000;
      }

      uVar18 = *(undefined8*)( param_1 + 0x10 );
      uVar8 = *(undefined8*)( param_1 + 0x18 );
      uVar9 = *(undefined8*)( param_1 + 0x20 );
      uVar10 = *(undefined8*)( param_1 + 0x28 );
      uVar11 = *(undefined8*)( param_1 + 0x30 );
      uVar12 = *(undefined8*)( param_1 + 0x38 );
      uVar13 = *(undefined8*)( param_1 + 0x40 );
      uVar14 = *(undefined8*)( param_1 + 0x48 );
      uVar15 = *(undefined8*)( param_1 + 0x50 );
      plVar5 = *(long**)( param_1 + 200 );
      *(undefined8*)( this + 0x10 ) = *(undefined8*)( param_1 + 8 );
      *(undefined8*)( this + 0x18 ) = uVar18;
      *(undefined8*)( this + 0x20 ) = uVar8;
      *(undefined8*)( this + 0x28 ) = uVar9;
      *(undefined8*)( this + 0x30 ) = uVar10;
      *(undefined8*)( this + 0x38 ) = uVar11;
      *(undefined8*)( this + 0x40 ) = uVar12;
      *(undefined8*)( this + 0x48 ) = uVar13;
      *(undefined8*)( this + 0x50 ) = uVar14;
      *(undefined8*)( this + 0x58 ) = uVar15;
      if (plVar5 != (long*)0x0) {
         lVar21 = plVar5[0xd];
         if ((char)plVar5[1] == '\x12') {
            this[8] = (TType)0x12;
            *(long*)( this + 0x68 ) = lVar21;
         }
 else {
            *(long*)( this + 0x68 ) = lVar21;
         }

         if (*(code**)( *plVar5 + 0x28 ) == getTypeName_abi_cxx11_) {
            lVar21 = plVar5[0xf];
         }
 else {
            lVar21 = ( **(code**)( *plVar5 + 0x28 ) )();
         }

         __s = *(char**)( lVar21 + 8 );
         uVar16 = glslang::GetThreadPoolAllocator();
         puVar17 = (undefined8*)glslang::TPoolAllocator::allocate(uVar16);
         uVar18 = glslang::GetThreadPoolAllocator();
         *puVar17 = uVar18;
         puVar17[1] = puVar17 + 3;
         if (__s == (char*)0x0) {
            /* WARNING: Subroutine does not return */
            std::__throw_logic_error("basic_string: construction from null is not valid");
         }

         sVar19 = strlen(__s);
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(puVar17, __s, __s + sVar19);
         TVar1 = param_1[0xb9];
         *(undefined8**)( this + 0x78 ) = puVar17;
         bVar22 = (byte)TVar1 >> 5 & 1;
         uVar24 = (byte)TVar1 >> 4 & 1;
      }

      if ((char)uVar24 == '\0') {
         if (bVar22 == 0) {
            return;
         }

         puVar20 = *(undefined4**)( param_1 + 0xe8 );
         if (puVar20 == (undefined4*)0x0) {
            return;
         }

         lVar21 = *(long*)( *(long*)( puVar20 + 2 ) + 8 );
         if (lVar21 == 0) {
            return;
         }

      }
 else {
         puVar20 = *(undefined4**)( param_1 + 0xe8 );
         if (puVar20 == (undefined4*)0x0) {
            return;
         }

         lVar21 = *(long*)( *(long*)( puVar20 + 2 ) + 8 );
         if (lVar21 == 0) {
            return;
         }

         if ((int)( *(long*)( lVar21 + 0x10 ) - (long)*(int**)( lVar21 + 8 ) >> 4 ) < 1) {
            return;
         }

         iVar23 = *(int*)param_1;
         iVar4 = **(int**)( lVar21 + 8 );
         if (iVar23 == 1) {
            if (iVar4 == 0x10) {
               this[0x1b] = ( TType )((byte)this[0x1b] & 0xf1);
               this[8] = (TType)0x3;
            }

         }
 else if (iVar23 == 9) {
            if (iVar4 == 8) {
               this[0x1b] = ( TType )((byte)this[0x1b] & 0xf1);
               this[8] = (TType)0x5;
            }
 else if (iVar4 == 0x10) {
               this[0x1b] = ( TType )((byte)this[0x1b] & 0xf1);
               this[8] = (TType)0x7;
            }

         }
 else if (iVar23 == 8) {
            if (iVar4 == 8) {
               this[0x1b] = ( TType )((byte)this[0x1b] & 0xf1);
               this[8] = (TType)0x4;
            }
 else if (iVar4 == 0x10) {
               this[0x1b] = ( TType )((byte)this[0x1b] & 0xf1);
               this[8] = (TType)0x6;
            }

         }

         if (bVar22 == 0) {
            return;
         }

      }

      lVar6 = *(long*)( lVar21 + 0x10 );
      lVar7 = *(long*)( lVar21 + 8 );
      lVar25 = lVar6 - lVar7;
      iVar23 = (int)( lVar25 >> 4 );
      if (0 < iVar23) {
         uVar3 = *puVar20;
         this[8] = SUB41(uVar3, 0);
         if (SUB41(uVar3, 0) == (TType)0x16) {
            *(undefined8*)( this + 0x90 ) = *(undefined8*)( puVar20 + 4 );
         }

         if (iVar23 == 4) {
            *(ushort*)( this + 10 ) = ( ushort )(( *(uint*)( lVar7 + 0x30 ) & 7 ) << 7) | 0x400 | *(ushort*)( this + 10 ) & 0xf87f;
            lVar25 = lVar7 + -0x10 + lVar25;
            if (lVar6 != lVar25) {
               *(long*)( lVar21 + 0x10 ) = lVar25;
            }

         }

      }

      return;
   }

   /* void std::vector<glslang::TTypeLoc, glslang::pool_allocator<glslang::TTypeLoc>
   >::_M_realloc_insert<glslang::TTypeLoc const&>(__gnu_cxx::__normal_iterator<glslang::TTypeLoc*,
   std::vector<glslang::TTypeLoc, glslang::pool_allocator<glslang::TTypeLoc> > >, glslang::TTypeLoc
   const&) */
   void std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>::_M_realloc_insert<glslang::TTypeLoc_const&>(vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>> *this, long param_2, undefined8 *param_3) {
      undefined8 *puVar1;
      long lVar2;
      undefined8 uVar3;
      ulong uVar4;
      long lVar5;
      long lVar6;
      ulong uVar7;
      long lVar8;
      undefined8 *puVar9;
      long lVar10;
      lVar2 = *(long*)( this + 0x10 );
      lVar10 = *(long*)( this + 8 );
      uVar4 = lVar2 - lVar10 >> 5;
      if (uVar4 == 0x3ffffffffffffff) {
         /* WARNING: Subroutine does not return */
         std::__throw_length_error("vector::_M_realloc_insert");
      }

      puVar9 = (undefined8*)( param_2 - lVar10 );
      if (lVar10 == lVar2) {
         if (0xfffffffffffffffe < uVar4) goto LAB_0015e0a0;
         uVar7 = 0x3ffffffffffffff;
         if (uVar4 + 1 < 0x400000000000000) {
            uVar7 = uVar4 + 1;
         }

         lVar8 = uVar7 << 5;
         LAB_0015e0aa:lVar5 = glslang::TPoolAllocator::allocate(*(ulong*)this);
         uVar3 = param_3[1];
         lVar8 = lVar5 + lVar8;
         lVar6 = lVar5 + 0x20;
         *(undefined8*)( lVar5 + (long)puVar9 ) = *param_3;
         ( (undefined8*)( lVar5 + (long)puVar9 ) )[1] = uVar3;
         uVar3 = param_3[3];
         puVar9 = (undefined8*)( lVar5 + 0x10 + (long)puVar9 );
         *puVar9 = param_3[2];
         puVar9[1] = uVar3;
         if (param_2 != lVar10) {
            LAB_0015e025:lVar6 = 0;
            do {
               uVar3 = ( (undefined8*)( lVar10 + lVar6 ) )[1];
               *(undefined8*)( lVar5 + lVar6 ) = *(undefined8*)( lVar10 + lVar6 );
               ( (undefined8*)( lVar5 + lVar6 ) )[1] = uVar3;
               puVar9 = (undefined8*)( lVar10 + 0x10 + lVar6 );
               uVar3 = puVar9[1];
               puVar1 = (undefined8*)( lVar5 + 0x10 + lVar6 );
               *puVar1 = *puVar9;
               puVar1[1] = uVar3;
               lVar6 = lVar6 + 0x20;
            }
 while ( lVar6 != param_2 - lVar10 );
            lVar6 = lVar5 + 0x20 + lVar6;
         }

         if (param_2 == lVar2) goto LAB_0015e080;
      }
 else {
         uVar7 = uVar4 * 2;
         if (uVar7 < uVar4) {
            LAB_0015e0a0:lVar8 = 0x7fffffffffffffe0;
            goto LAB_0015e0aa;
         }

         if (uVar7 != 0) {
            if (0x3ffffffffffffff < uVar7) {
               uVar7 = 0x3ffffffffffffff;
            }

            lVar8 = uVar7 << 5;
            goto LAB_0015e0aa;
         }

         uVar3 = param_3[1];
         lVar5 = 0;
         lVar8 = 0;
         lVar6 = 0x20;
         *puVar9 = *param_3;
         puVar9[1] = uVar3;
         uVar3 = param_3[3];
         puVar9[2] = param_3[2];
         puVar9[3] = uVar3;
         if (param_2 != lVar10) goto LAB_0015e025;
      }

      lVar10 = 0;
      do {
         uVar3 = ( (undefined8*)( param_2 + lVar10 ) )[1];
         *(undefined8*)( lVar6 + lVar10 ) = *(undefined8*)( param_2 + lVar10 );
         ( (undefined8*)( lVar6 + lVar10 ) )[1] = uVar3;
         puVar9 = (undefined8*)( param_2 + 0x10 + lVar10 );
         uVar3 = puVar9[1];
         puVar1 = (undefined8*)( lVar6 + 0x10 + lVar10 );
         *puVar1 = *puVar9;
         puVar1[1] = uVar3;
         lVar10 = lVar10 + 0x20;
      }
 while ( lVar10 != lVar2 - param_2 );
      lVar6 = lVar6 + lVar10;
      LAB_0015e080:*(long*)( this + 8 ) = lVar5;
      *(long*)( this + 0x10 ) = lVar6;
      *(long*)( this + 0x18 ) = lVar8;
      return;
   }

   /* void std::vector<glslang::TParameter, glslang::pool_allocator<glslang::TParameter>
   >::_M_realloc_insert<glslang::TParameter
   const&>(__gnu_cxx::__normal_iterator<glslang::TParameter*, std::vector<glslang::TParameter,
   glslang::pool_allocator<glslang::TParameter> > >, glslang::TParameter const&) */
   void std::vector<glslang::TParameter,glslang::pool_allocator<glslang::TParameter>>::_M_realloc_insert<glslang::TParameter_const&>(vector<glslang::TParameter,glslang::pool_allocator<glslang::TParameter>> *this, undefined8 *param_2, undefined8 *param_3) {
      undefined8 *puVar1;
      undefined8 uVar2;
      long lVar3;
      ulong uVar4;
      undefined8 *puVar5;
      undefined8 *puVar6;
      undefined8 *puVar7;
      ulong uVar8;
      undefined8 *puVar9;
      undefined8 *puVar10;
      undefined8 *puVar11;
      undefined8 *puVar12;
      puVar1 = *(undefined8**)( this + 0x10 );
      puVar6 = *(undefined8**)( this + 8 );
      lVar3 = (long)puVar1 - (long)puVar6 >> 3;
      uVar4 = lVar3 * -0x5555555555555555;
      if (uVar4 == 0x555555555555555) {
         /* WARNING: Subroutine does not return */
         std::__throw_length_error("vector::_M_realloc_insert");
      }

      puVar12 = (undefined8*)( (long)param_2 - (long)puVar6 );
      if (puVar6 == puVar1) {
         uVar8 = uVar4 + 1;
         if (0xfffffffffffffffe < uVar4) goto LAB_0015e270;
         if (0x555555555555555 < uVar8) {
            uVar8 = 0x555555555555555;
         }

         lVar3 = uVar8 * 0x18;
         LAB_0015e27a:puVar7 = (undefined8*)glslang::TPoolAllocator::allocate(*(ulong*)this);
         uVar2 = param_3[1];
         *(undefined8*)( (long)puVar7 + (long)puVar12 ) = *param_3;
         ( (undefined8*)( (long)puVar7 + (long)puVar12 ) )[1] = uVar2;
         lVar3 = (long)puVar7 + lVar3;
         puVar10 = puVar7 + 3;
         *(undefined8*)( (long)( puVar7 + 2 ) + (long)puVar12 ) = param_3[2];
         puVar12 = puVar6;
         puVar9 = puVar7;
         if (param_2 != puVar6) {
            LAB_0015e1e0:do {
               uVar2 = puVar12[1];
               puVar10 = puVar12 + 3;
               *puVar7 = *puVar12;
               puVar7[1] = uVar2;
               puVar7[2] = puVar12[2];
               puVar12 = puVar10;
               puVar7 = puVar7 + 3;
            }
 while ( param_2 != puVar10 );
            puVar10 = (undefined8*)( (long)puVar9 + ( (long)param_2 + ( -0x18 - (long)puVar6 ) & 0xfffffffffffffff8U ) + 0x30 );
            puVar7 = puVar9;
         }

         puVar5 = param_2;
         puVar11 = puVar10;
         if (param_2 == puVar1) goto LAB_0015e24d;
      }
 else {
         uVar8 = lVar3 * 0x5555555555555556;
         if (uVar8 < uVar4) {
            LAB_0015e270:lVar3 = 0x7ffffffffffffff8;
            goto LAB_0015e27a;
         }

         if (uVar8 != 0) {
            if (0x555555555555555 < uVar8) {
               uVar8 = 0x555555555555555;
            }

            lVar3 = uVar8 * 0x18;
            goto LAB_0015e27a;
         }

         uVar2 = param_3[1];
         puVar7 = (undefined8*)0x0;
         lVar3 = 0;
         puVar10 = (undefined8*)&DAT_00000018;
         *puVar12 = *param_3;
         puVar12[1] = uVar2;
         puVar12[2] = param_3[2];
         puVar5 = param_2;
         puVar12 = puVar6;
         puVar9 = puVar7;
         puVar11 = puVar10;
         if (param_2 != puVar6) goto LAB_0015e1e0;
      }

      do {
         uVar2 = puVar5[1];
         puVar6 = puVar5 + 3;
         *puVar10 = *puVar5;
         puVar10[1] = uVar2;
         puVar10[2] = puVar5[2];
         puVar5 = puVar6;
         puVar10 = puVar10 + 3;
      }
 while ( puVar1 != puVar6 );
      puVar10 = (undefined8*)( (long)puVar11 + ( (long)puVar1 + ( -0x18 - (long)param_2 ) & 0xfffffffffffffff8U ) + 0x18 );
      LAB_0015e24d:*(undefined8**)( this + 8 ) = puVar7;
      *(undefined8**)( this + 0x10 ) = puVar10;
      *(long*)( this + 0x18 ) = lVar3;
      return;
   }

   /* std::pair<std::_Rb_tree_iterator<std::pair<std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const, glslang::TSymbol*> >, bool>
   std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> >, std::pair<std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const, glslang::TSymbol*>,
   std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, glslang::TSymbol*> >,
   std::less<std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   > >, glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, glslang::TSymbol*> >
   >::_M_emplace_unique<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, glslang::TSymbol*>
   const>(std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, glslang::TSymbol*> const&&) */
   undefined1[16];
   std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>>::_M_emplace_unique<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>const> (_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>>
           *this,pair_conflict *param_1) {
      uint uVar1;
      int iVar2;
      ulong uVar3;
      _Rb_tree_node_base *p_Var4;
      ulong uVar5;
      _Rb_tree_node_base *p_Var6;
      ulong uVar7;
      bool bVar8;
      long lVar9;
      _Rb_tree_node_base *p_Var10;
      void *__s2;
      ulong uVar11;
      undefined1 auVar12[16];
      undefined1 auVar13[16];
      void *local_58;
      auVar12._0_8_ = (_Rb_tree_node_base*)glslang::TPoolAllocator::allocate(*(ulong*)this);
      uVar3 = glslang::GetThreadPoolAllocator();
      uVar11 = *(ulong*)( param_1 + 0x10 );
      p_Var4 = auVar12._0_8_ + 0x38;
      *(_Rb_tree_node_base**)( auVar12._0_8_ + 0x28 ) = p_Var4;
      p_Var6 = *(_Rb_tree_node_base**)( param_1 + 8 );
      *(ulong*)( auVar12._0_8_ + 0x20 ) = uVar3;
      if (uVar11 < 0x10) {
         if (uVar11 == 1) {
            auVar12._0_8_[0x38] = *p_Var6;
         }
 else if (uVar11 != 0) goto LAB_0015e531;
      }
 else {
         if ((long)uVar11 < 0) {
            /* WARNING: Subroutine does not return */
            std::__throw_length_error("basic_string::_M_create");
         }

         p_Var4 = (_Rb_tree_node_base*)glslang::TPoolAllocator::allocate(uVar3);
         *(ulong*)( auVar12._0_8_ + 0x38 ) = uVar11;
         *(_Rb_tree_node_base**)( auVar12._0_8_ + 0x28 ) = p_Var4;
         LAB_0015e531:memcpy(p_Var4, p_Var6, uVar11);
         p_Var4 = *(_Rb_tree_node_base**)( auVar12._0_8_ + 0x28 );
      }

      *(ulong*)( auVar12._0_8_ + 0x30 ) = uVar11;
      p_Var4[uVar11] = (_Rb_tree_node_base)0x0;
      *(undefined8*)( auVar12._0_8_ + 0x48 ) = *(undefined8*)( param_1 + 0x28 );
      p_Var4 = (_Rb_tree_node_base*)( this + 0x10 );
      if (*(_Rb_tree_node_base**)( this + 0x18 ) == (_Rb_tree_node_base*)0x0) {
         p_Var10 = p_Var4;
         if (p_Var4 != *(_Rb_tree_node_base**)( this + 0x20 )) {
            local_58 = *(void**)( auVar12._0_8_ + 0x28 );
            uVar11 = *(ulong*)( auVar12._0_8_ + 0x30 );
            LAB_0015e4e3:p_Var6 = (_Rb_tree_node_base*)std::_Rb_tree_decrement(p_Var10);
            uVar3 = *(ulong*)( p_Var6 + 0x30 );
            __s2 = *(void**)( p_Var6 + 0x28 );
            uVar7 = uVar11;
            if (uVar3 <= uVar11) {
               uVar7 = uVar3;
            }

            LAB_0015e425:if (( uVar7 == 0 ) || ( iVar2 = iVar2 == 0 )) {
               lVar9 = uVar3 - uVar11;
               if (0x7fffffff < lVar9) goto LAB_0015e4c0;
               if (lVar9 < -0x80000000) goto LAB_0015e466;
               iVar2 = (int)lVar9;
            }

            if (-1 < iVar2) {
               LAB_0015e4c0:auVar13._8_8_ = 0;
               auVar13._0_8_ = p_Var6;
               return auVar13;
            }

            goto LAB_0015e466;
         }

         LAB_0015e5d1:bVar8 = true;
      }
 else {
         local_58 = *(void**)( auVar12._0_8_ + 0x28 );
         uVar11 = *(ulong*)( auVar12._0_8_ + 0x30 );
         p_Var6 = *(_Rb_tree_node_base**)( this + 0x18 );
         do {
            p_Var10 = p_Var6;
            uVar3 = *(ulong*)( p_Var10 + 0x30 );
            __s2 = *(void**)( p_Var10 + 0x28 );
            uVar7 = uVar3;
            if (uVar11 <= uVar3) {
               uVar7 = uVar11;
            }

            if (uVar7 == 0) {
               LAB_0015e3eb:uVar5 = uVar11 - uVar3;
               if ((long)uVar5 < 0x80000000) {
                  if (-0x80000001 < (long)uVar5) goto LAB_0015e40a;
                  goto LAB_0015e3b0;
               }

               LAB_0015e40e:p_Var6 = *(_Rb_tree_node_base**)( p_Var10 + 0x18 );
               bVar8 = false;
            }
 else {
               uVar1 = memcmp(local_58, __s2, uVar7);
               uVar5 = (ulong)uVar1;
               if (uVar1 == 0) goto LAB_0015e3eb;
               LAB_0015e40a:if (-1 < (int)uVar5) goto LAB_0015e40e;
               LAB_0015e3b0:p_Var6 = *(_Rb_tree_node_base**)( p_Var10 + 0x10 );
               bVar8 = true;
            }

         }
 while ( p_Var6 != (_Rb_tree_node_base*)0x0 );
         p_Var6 = p_Var10;
         if (!bVar8) goto LAB_0015e425;
         if (*(_Rb_tree_node_base**)( this + 0x20 ) != p_Var10) goto LAB_0015e4e3;
         LAB_0015e466:bVar8 = true;
         if (p_Var4 == p_Var10) goto LAB_0015e476;
         uVar3 = *(ulong*)( p_Var10 + 0x30 );
         uVar7 = uVar3;
         if (uVar11 <= uVar3) {
            uVar7 = uVar11;
         }

         if (( uVar7 == 0 ) || ( iVar2 = memcmp(local_58, *(void**)( p_Var10 + 0x28 ), uVar7) ),iVar2 == 0) {
            bVar8 = false;
            lVar9 = uVar11 - uVar3;
            if (0x7fffffff < lVar9) goto LAB_0015e476;
            if (lVar9 < -0x80000000) goto LAB_0015e5d1;
            iVar2 = (int)lVar9;
         }

         bVar8 = SUB41((uint)iVar2 >> 0x1f, 0);
      }

      LAB_0015e476:std::_Rb_tree_insert_and_rebalance(bVar8, auVar12._0_8_, p_Var10, p_Var4);
      *(long*)( this + 0x30 ) = *(long*)( this + 0x30 ) + 1;
      auVar12._8_8_ = 1;
      return auVar12;
   }

   /* glslang::TSymbolTableLevel::insertAnonymousMembers(glslang::TSymbol&, int) */
   ulong glslang::TSymbolTableLevel::insertAnonymousMembers(TSymbolTableLevel *this, TSymbol *param_1, int param_2) {
      long lVar1;
      code *pcVar2;
      undefined1 *__src;
      undefined4 uVar3;
      long *plVar4;
      undefined8 *puVar5;
      undefined8 uVar6;
      long lVar7;
      ulong uVar8;
      ulong extraout_RDX;
      ulong uVar9;
      long in_FS_OFFSET;
      ulong local_78;
      ulong *local_70;
      ulong local_68;
      ulong local_60[2];
      undefined8 *local_50;
      long local_40;
      uVar9 = (ulong)(uint)param_2;
      local_40 = *(long*)( in_FS_OFFSET + 0x28 );
      plVar4 = (long*)( **(code**)( *(long*)param_1 + 0x48 ) )(param_1);
      if (*(code**)( *plVar4 + 0x60 ) == TVariable::getType) {
         plVar4 = plVar4 + 5;
      }
 else {
         plVar4 = (long*)( **(code**)( *plVar4 + 0x60 ) )();
      }

      lVar1 = plVar4[0xd];
      if (uVar9 < ( ulong )(*(long*)( lVar1 + 0x10 ) - *(long*)( lVar1 + 8 ) >> 5)) {
         do {
            uVar8 = glslang::GetThreadPoolAllocator();
            puVar5 = (undefined8*)glslang::TPoolAllocator::allocate(uVar8);
            plVar4 = (long*)( **(code**)( *(long*)param_1 + 0x48 ) )(param_1);
            if (*(code**)( *plVar4 + 0xe8 ) == TVariable::getAnonId) {
               uVar3 = (undefined4)plVar4[0x1d];
            }
 else {
               uVar3 = ( **(code**)( *plVar4 + 0xe8 ) )();
            }

            uVar6 = ( **(code**)( *(long*)param_1 + 0x48 ) )(param_1);
            plVar4 = *(long**)( uVar9 * 0x20 + *(long*)( lVar1 + 8 ) );
            pcVar2 = *(code**)( *plVar4 + 0x30 );
            if (pcVar2 == TType::getFieldName_abi_cxx11_) {
               lVar7 = plVar4[0xe];
            }
 else {
               lVar7 = ( *pcVar2 )();
            }

            puVar5[1] = lVar7;
            *(undefined4*)( (long)puVar5 + 0x34 ) = uVar3;
            puVar5[2] = 0;
            puVar5[3] = 0;
            *(undefined1*)( puVar5 + 4 ) = 1;
            *puVar5 = glslang::TParseContextBase::makeEditable;
            puVar5[5] = uVar6;
            *(int*)( puVar5 + 6 ) = (int)uVar9;
            local_78 = glslang::GetThreadPoolAllocator();
            __src = *(undefined1**)( lVar7 + 8 );
            uVar8 = *(ulong*)( lVar7 + 0x10 );
            local_70 = local_60;
            if (uVar8 < 0x10) {
               if (uVar8 == 1) {
                  local_60[0] = CONCAT71(local_60[0]._1_7_, *__src);
               }
 else if (uVar8 != 0) goto LAB_0015e7be;
            }
 else {
               if ((long)uVar8 < 0) {
                  /* WARNING: Subroutine does not return */
                  std::__throw_length_error("basic_string::_M_create");
               }

               local_70 = (ulong*)glslang::TPoolAllocator::allocate(local_78);
               local_60[0] = uVar8;
               LAB_0015e7be:memcpy(local_70, __src, uVar8);
            }

            *(undefined1*)( (long)local_70 + uVar8 ) = 0;
            local_68 = uVar8;
            local_50 = puVar5;
            std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>>::_M_emplace_unique<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>const>((_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>>*)this, (pair_conflict*)&local_78);
            uVar8 = extraout_RDX & 0xffffffff;
            if ((char)extraout_RDX == '\0') goto LAB_0015e81d;
            uVar9 = ( ulong )((int)uVar9 + 1);
         }
 while ( uVar9 < ( ulong )(*(long*)( lVar1 + 0x10 ) - *(long*)( lVar1 + 8 ) >> 5) );
      }

      uVar8 = 1;
      LAB_0015e81d:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      return uVar8;
   }

   /* glslang::TSymbolTableLevel::insert(glslang::TSymbol&, bool, std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const&) */
   ulong glslang::TSymbolTableLevel::insert(TSymbolTableLevel *this, TSymbol *param_1, bool param_2, basic_string *param_3) {
      TSymbolTableLevel *pTVar1;
      void *__s2;
      ulong uVar2;
      code *pcVar3;
      undefined1 *puVar4;
      int iVar5;
      long lVar6;
      long lVar7;
      long *plVar8;
      undefined8 *puVar9;
      undefined8 uVar10;
      size_t sVar11;
      ulong uVar12;
      long lVar13;
      ulong uVar14;
      ulong extraout_RDX;
      ulong extraout_RDX_00;
      TSymbolTableLevel *pTVar15;
      TSymbolTableLevel *pTVar16;
      long in_FS_OFFSET;
      ulong local_e8;
      ulong *local_e0;
      ulong local_d8;
      ulong local_d0[2];
      TSymbol *local_c0;
      ulong local_b8;
      ulong *local_b0;
      ulong local_a8;
      ulong local_a0[2];
      TSymbol *local_90;
      ulong local_88;
      ulong *local_80;
      ulong local_78;
      ulong local_70[2];
      TSymbol *local_60;
      char local_58[24];
      long local_40;
      local_40 = *(long*)( in_FS_OFFSET + 0x28 );
      if (*(code**)( *(long*)param_1 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
         lVar13 = *(long*)( param_1 + 8 );
      }
 else {
         lVar13 = ( **(code**)( *(long*)param_1 + 0x18 ) )(param_1);
      }

      if (*(long*)( param_3 + 0x10 ) != 0) {
         local_e8 = glslang::GetThreadPoolAllocator();
         uVar12 = *(ulong*)( param_3 + 0x10 );
         local_e0 = local_d0;
         puVar4 = *(undefined1**)( param_3 + 8 );
         if (uVar12 < 0x10) {
            if (uVar12 == 1) {
               local_d0[0] = CONCAT71(local_d0[0]._1_7_, *puVar4);
            }
 else if (uVar12 != 0) goto LAB_0015ec22;
         }
 else {
            if ((long)uVar12 < 0) goto LAB_0015ed8f;
            local_e0 = (ulong*)glslang::TPoolAllocator::allocate(local_e8);
            local_d0[0] = uVar12;
            LAB_0015ec22:memcpy(local_e0, puVar4, uVar12);
         }

         *(undefined1*)( (long)local_e0 + uVar12 ) = 0;
         local_d8 = uVar12;
         local_c0 = param_1;
         std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>>::_M_emplace_unique<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>const>((_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>>*)this, (pair_conflict*)&local_e8);
         uVar12 = extraout_RDX & 0xffffffff;
         goto LAB_0015eaeb;
      }

      if (*(long*)( lVar13 + 0x10 ) == 0) {
         plVar8 = (long*)( **(code**)( *(long*)param_1 + 0x48 ) )(param_1);
         iVar5 = *(int*)( this + 0x60 );
         pcVar3 = *(code**)( *plVar8 + 0xe0 );
         *(int*)( this + 0x60 ) = iVar5 + 1;
         if (pcVar3 == TVariable::setAnonId) {
            *(int*)( plVar8 + 0x1d ) = iVar5;
         }
 else {
            ( *pcVar3 )();
         }

         plVar8 = (long*)( **(code**)( *(long*)param_1 + 0x48 ) )(param_1);
         if (*(code**)( *plVar8 + 0xe8 ) == TVariable::getAnonId) {
            uVar12 = ( ulong ) * (uint*)( plVar8 + 0x1d );
         }
 else {
            uVar12 = ( **(code**)( *plVar8 + 0xe8 ) )();
         }

         __snprintf_chk(local_58, 0x14, 2, 0x14, &_LC662, "anon@", uVar12);
         pcVar3 = *(code**)( *(long*)param_1 + 0x20 );
         uVar12 = glslang::GetThreadPoolAllocator();
         puVar9 = (undefined8*)glslang::TPoolAllocator::allocate(uVar12);
         uVar10 = glslang::GetThreadPoolAllocator();
         *puVar9 = uVar10;
         puVar9[1] = puVar9 + 3;
         sVar11 = strlen(local_58);
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(puVar9, local_58, local_58 + sVar11);
         if (pcVar3 == TSymbol::changeName) {
            *(undefined8**)( param_1 + 8 ) = puVar9;
         }
 else {
            ( *pcVar3 )(param_1, puVar9);
         }

         uVar12 = insertAnonymousMembers(this, param_1, 0);
         goto LAB_0015eaeb;
      }

      lVar6 = ( **(code**)( *(long*)param_1 + 0x30 ) )();
      lVar7 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
      if (lVar7 == 0) {
         local_88 = glslang::GetThreadPoolAllocator();
         local_80 = local_70;
         uVar12 = *(ulong*)( lVar6 + 0x10 );
         puVar4 = *(undefined1**)( lVar6 + 8 );
         if (uVar12 < 0x10) {
            if (uVar12 == 1) {
               local_70[0] = CONCAT71(local_70[0]._1_7_, *puVar4);
            }
 else if (uVar12 != 0) goto LAB_0015ed64;
         }
 else {
            if ((long)uVar12 < 0) goto LAB_0015ed8f;
            local_80 = (ulong*)glslang::TPoolAllocator::allocate(local_88);
            local_70[0] = uVar12;
            LAB_0015ed64:memcpy(local_80, puVar4, uVar12);
         }

         *(undefined1*)( (long)local_80 + uVar12 ) = 0;
         local_78 = uVar12;
         local_60 = param_1;
         std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>>::_M_emplace_unique<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>const>((_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>>*)this, (pair_conflict*)&local_88);
         uVar12 = extraout_RDX_00 & 0xffffffff;
         goto LAB_0015eaeb;
      }

      if (!param_2) {
         if (*(TSymbolTableLevel**)( this + 0x18 ) != (TSymbolTableLevel*)0x0) {
            __s2 = *(void**)( lVar13 + 8 );
            uVar12 = *(ulong*)( lVar13 + 0x10 );
            pTVar15 = this + 0x10;
            pTVar16 = *(TSymbolTableLevel**)( this + 0x18 );
            do {
               while (true) {
                  uVar2 = *(ulong*)( pTVar16 + 0x30 );
                  uVar14 = uVar12;
                  if (uVar2 <= uVar12) {
                     uVar14 = uVar2;
                  }

                  if (( uVar14 != 0 ) && ( iVar5 = memcmp(*(void**)( pTVar16 + 0x28 ), __s2, uVar14) ),iVar5 != 0) break;
                  lVar13 = uVar2 - uVar12;
                  if (lVar13 < 0x80000000) {
                     if (-0x80000001 < lVar13) {
                        iVar5 = (int)lVar13;
                        break;
                     }

                     goto LAB_0015e930;
                  }

                  LAB_0015e983:pTVar1 = pTVar16 + 0x10;
                  pTVar15 = pTVar16;
                  pTVar16 = *(TSymbolTableLevel**)pTVar1;
                  if (*(TSymbolTableLevel**)pTVar1 == (TSymbolTableLevel*)0x0) goto LAB_0015e98f;
               }
;
               if (-1 < iVar5) goto LAB_0015e983;
               LAB_0015e930:pTVar16 = *(TSymbolTableLevel**)( pTVar16 + 0x18 );
            }
 while ( pTVar16 != (TSymbolTableLevel*)0x0 );
            LAB_0015e98f:if (this + 0x10 != pTVar15) {
               uVar2 = *(ulong*)( pTVar15 + 0x30 );
               uVar14 = uVar12;
               if (uVar2 <= uVar12) {
                  uVar14 = uVar2;
               }

               if (( uVar14 == 0 ) || ( iVar5 = memcmp(__s2, *(void**)( pTVar15 + 0x28 ), uVar14) ),iVar5 == 0) {
                  lVar13 = uVar12 - uVar2;
                  if (lVar13 < 0x80000000) {
                     if (lVar13 < -0x80000000) goto LAB_0015eb88;
                     iVar5 = (int)lVar13;
                     goto LAB_0015e9de;
                  }

               }
 else {
                  LAB_0015e9de:if (iVar5 < 0) goto LAB_0015eb88;
               }

               uVar12 = (ulong)param_2;
               goto LAB_0015eaeb;
            }

         }

      }

      LAB_0015eb88:local_b8 = glslang::GetThreadPoolAllocator();
      local_b0 = local_a0;
      uVar12 = *(ulong*)( lVar6 + 0x10 );
      puVar4 = *(undefined1**)( lVar6 + 8 );
      if (uVar12 < 0x10) {
         if (uVar12 == 1) {
            local_a0[0] = CONCAT71(local_a0[0]._1_7_, *puVar4);
         }
 else if (uVar12 != 0) goto LAB_0015ed22;
      }
 else {
         if ((long)uVar12 < 0) {
            LAB_0015ed8f:/* WARNING: Subroutine does not return */std::__throw_length_error("basic_string::_M_create");
         }

         local_b0 = (ulong*)glslang::TPoolAllocator::allocate(local_b8);
         local_a0[0] = uVar12;
         LAB_0015ed22:memcpy(local_b0, puVar4, uVar12);
      }

      *(undefined1*)( (long)local_b0 + uVar12 ) = 0;
      local_a8 = uVar12;
      local_90 = param_1;
      std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>>::_M_emplace_unique<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>const>((_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,glslang::pool_allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::TSymbol*>>>*)this, (pair_conflict*)&local_b8);
      uVar12 = 1;
      LAB_0015eaeb:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      return uVar12;
   }

   /* glslang::TSymbolTable::copyUp(glslang::TSymbol*) */
   TSymbol * __thiscallglslang::TSymbolTable::copyUp(TSymbolTable * this, TSymbol * param_1);
   {
      TSymbol *pTVar1;
      TSymbolTableLevel *this_00;
      void *__s2;
      ulong uVar2;
      ulong uVar3;
      int iVar4;
      TSymbol *pTVar5;
      long lVar6;
      long lVar7;
      ulong uVar8;
      TSymbol *pTVar9;
      TSymbol *pTVar10;
      long in_FS_OFFSET;
      undefined8 local_68;
      undefined1 *local_60;
      undefined8 local_58;
      undefined1 local_50[16];
      long local_40;
      local_40 = *(long*)( in_FS_OFFSET + 0x28 );
      pTVar5 = (TSymbol*)copyUpDeferredInsert(param_1);
      this_00 = *(TSymbolTableLevel**)( *(long*)this + 0x18 );
      local_68 = glslang::GetThreadPoolAllocator();
      local_60 = local_50;
      local_58 = 0;
      local_50[0] = 0;
      TSymbolTableLevel::insert(this_00, pTVar5, (bool)this[0x21], (basic_string*)&local_68);
      lVar6 = ( **(code**)( *(long*)param_1 + 0x48 ) )(param_1);
      if (lVar6 != 0) goto LAB_0015ee22;
      lVar6 = *(long*)( *(long*)this + 0x18 );
      if (*(code**)( *(long*)param_1 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
         lVar7 = *(long*)( param_1 + 8 );
      }
 else {
         lVar7 = ( **(code**)( *(long*)param_1 + 0x18 ) )(param_1);
      }

      pTVar1 = (TSymbol*)( lVar6 + 0x10 );
      pTVar5 = *(TSymbol**)( lVar6 + 0x18 );
      if (pTVar5 == (TSymbol*)0x0) goto LAB_0015ee22;
      __s2 = *(void**)( lVar7 + 8 );
      uVar2 = *(ulong*)( lVar7 + 0x10 );
      pTVar10 = pTVar1;
      do {
         while (true) {
            pTVar9 = pTVar5;
            uVar3 = *(ulong*)( pTVar9 + 0x30 );
            uVar8 = uVar2;
            if (uVar3 <= uVar2) {
               uVar8 = uVar3;
            }

            if (uVar8 != 0) break;
            LAB_0015eecc:lVar6 = uVar3 - uVar2;
            if (lVar6 < 0x80000000) {
               if (-0x80000001 < lVar6) {
                  iVar4 = (int)lVar6;
                  goto LAB_0015eee8;
               }

               goto LAB_0015eea0;
            }

            LAB_0015eeec:pTVar5 = *(TSymbol**)( pTVar9 + 0x10 );
            pTVar10 = pTVar9;
            if (pTVar5 == (TSymbol*)0x0) goto LAB_0015eef8;
         }
;
         iVar4 = memcmp(*(void**)( pTVar9 + 0x28 ), __s2, uVar8);
         if (iVar4 == 0) goto LAB_0015eecc;
         LAB_0015eee8:if (-1 < iVar4) goto LAB_0015eeec;
         LAB_0015eea0:pTVar5 = *(TSymbol**)( pTVar9 + 0x18 );
      }
 while ( pTVar5 != (TSymbol*)0x0 );
      LAB_0015eef8:if (pTVar1 == pTVar10) goto LAB_0015ee22;
      uVar3 = *(ulong*)( pTVar10 + 0x30 );
      uVar8 = uVar2;
      if (uVar3 <= uVar2) {
         uVar8 = uVar3;
      }

      if (uVar8 == 0) {
         LAB_0015ef26:lVar6 = uVar2 - uVar3;
         if (lVar6 < 0x80000000) {
            if (lVar6 < -0x80000000) goto LAB_0015ee22;
            iVar4 = (int)lVar6;
            goto LAB_0015ef45;
         }

      }
 else {
         iVar4 = memcmp(__s2, *(void**)( pTVar10 + 0x28 ), uVar8);
         if (iVar4 == 0) goto LAB_0015ef26;
         LAB_0015ef45:if (iVar4 < 0) goto LAB_0015ee22;
      }

      pTVar5 = *(TSymbol**)( pTVar10 + 0x48 );
      LAB_0015ee22:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
         return pTVar5;
      }

      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   /* glslang::TSymbolTable::insert(glslang::TSymbol&) */
   undefined8 glslang::TSymbolTable::insert(TSymbolTable *this, TSymbol *param_1) {
      code *pcVar1;
      TSymbolTableLevel *pTVar2;
      char cVar3;
      int iVar4;
      long lVar5;
      undefined8 uVar6;
      basic_string *pbVar7;
      undefined8 *puVar8;
      long in_FS_OFFSET;
      undefined8 local_58;
      undefined1 *local_50;
      undefined8 local_48;
      undefined1 local_40[16];
      long local_30;
      lVar5 = *(long*)( this + 0x18 );
      local_30 = *(long*)( in_FS_OFFSET + 0x28 );
      pcVar1 = *(code**)( *(long*)param_1 + 0x70 );
      *(long*)( this + 0x18 ) = lVar5 + 1;
      if (pcVar1 == TSymbol::setUniqueId) {
         *(long*)( param_1 + 0x10 ) = lVar5 + 1;
      }
 else {
         ( *pcVar1 )(param_1);
      }

      if (this[0x21] == (TSymbolTable)0x0) {
         lVar5 = ( **(code**)( *(long*)param_1 + 0x38 ) )(param_1);
         if (lVar5 != 0) goto LAB_0015efd2;
         pTVar2 = *(TSymbolTableLevel**)( *(long*)this + (long)( (int)( *(long*)( this + 8 ) - *(long*)this >> 3 ) + -1 ) * 8 );
         if (*(code**)( *(long*)param_1 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
            pbVar7 = *(basic_string**)( param_1 + 8 );
         }
 else {
            pbVar7 = (basic_string*)( **(code**)( *(long*)param_1 + 0x18 ) )(param_1);
         }

         cVar3 = TSymbolTableLevel::hasFunctionName(pTVar2, pbVar7);
         if (cVar3 == '\0') goto LAB_0015efd2;
         LAB_0015f11f:uVar6 = 0;
      }
 else {
         LAB_0015efd2:puVar8 = *(undefined8**)this;
         iVar4 = (int)( *(long*)( this + 8 ) - (long)puVar8 >> 3 );
         if (( this[0x20] != (TSymbolTable)0x0 ) && ( iVar4 - 2U < 3 )) {
            pTVar2 = (TSymbolTableLevel*)*puVar8;
            if (*(code**)( *(long*)param_1 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
               pbVar7 = *(basic_string**)( param_1 + 8 );
            }
 else {
               pbVar7 = (basic_string*)( **(code**)( *(long*)param_1 + 0x18 ) )(param_1);
            }

            cVar3 = TSymbolTableLevel::hasFunctionName(pTVar2, pbVar7);
            if (cVar3 != '\0') goto LAB_0015f11f;
            puVar8 = *(undefined8**)this;
            iVar4 = (int)( *(long*)( this + 8 ) - (long)puVar8 >> 3 );
            if (2 < iVar4) {
               pTVar2 = (TSymbolTableLevel*)puVar8[1];
               if (*(code**)( *(long*)param_1 + 0x18 ) == TSymbol::getName_abi_cxx11_) {
                  pbVar7 = *(basic_string**)( param_1 + 8 );
               }
 else {
                  pbVar7 = (basic_string*)( **(code**)( *(long*)param_1 + 0x18 ) )(param_1);
               }

               cVar3 = TSymbolTableLevel::hasFunctionName(pTVar2, pbVar7);
               if (cVar3 != '\0') goto LAB_0015f11f;
               puVar8 = *(undefined8**)this;
               iVar4 = (int)( *(long*)( this + 8 ) - (long)puVar8 >> 3 );
            }

         }

         pTVar2 = (TSymbolTableLevel*)puVar8[iVar4 + -1];
         local_58 = glslang::GetThreadPoolAllocator();
         local_50 = local_40;
         local_48 = 0;
         local_40[0] = 0;
         uVar6 = TSymbolTableLevel::insert(pTVar2, param_1, (bool)this[0x21], (basic_string*)&local_58);
      }

      if (local_30 == *(long*)( in_FS_OFFSET + 0x28 )) {
         return uVar6;
      }

      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   /* std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> >, std::_Identity<std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > >,
   std::less<std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   > >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > > >::find(std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const&) const */
   _Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>> * __thiscallstd::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>::find(_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>> * this, basic_string * param_1);
   {
      _Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>> *p_Var1;
      _Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>> *p_Var2;
      void *__s2;
      ulong uVar3;
      ulong uVar4;
      int iVar5;
      ulong uVar6;
      long lVar7;
      _Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>> *p_Var8;
      _Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>> *p_Var9;
      p_Var1 = this + 8;
      p_Var8 = p_Var1;
      if (*(_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>**)( this + 0x10 ) != (_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>*)0x0) {
         __s2 = *(void**)( param_1 + 8 );
         uVar3 = *(ulong*)( param_1 + 0x10 );
         p_Var9 = *(_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>**)( this + 0x10 );
         do {
            while (true) {
               uVar4 = *(ulong*)( p_Var9 + 0x30 );
               uVar6 = uVar3;
               if (uVar4 <= uVar3) {
                  uVar6 = uVar4;
               }

               if (( uVar6 != 0 ) && ( iVar5 = memcmp(*(void**)( p_Var9 + 0x28 ), __s2, uVar6) ),iVar5 != 0) break;
               lVar7 = uVar4 - uVar3;
               if (lVar7 < 0x80000000) {
                  if (-0x80000001 < lVar7) {
                     iVar5 = (int)lVar7;
                     break;
                  }

                  goto LAB_0015f1a0;
               }

               LAB_0015f1e9:p_Var2 = p_Var9 + 0x10;
               p_Var8 = p_Var9;
               p_Var9 = *(_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>**)p_Var2;
               if (*(_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>**)p_Var2 == (_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>*)0x0) goto LAB_0015f1f5;
            }
;
            if (-1 < iVar5) goto LAB_0015f1e9;
            LAB_0015f1a0:p_Var9 = *(_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>**)( p_Var9 + 0x18 );
         }
 while ( p_Var9 != (_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::_Identity<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>>*)0x0 );
         LAB_0015f1f5:if (p_Var1 != p_Var8) {
            uVar4 = *(ulong*)( p_Var8 + 0x30 );
            uVar6 = uVar3;
            if (uVar4 <= uVar3) {
               uVar6 = uVar4;
            }

            if (( uVar6 == 0 ) || ( iVar5 = memcmp(__s2, *(void**)( p_Var8 + 0x28 ), uVar6) ),iVar5 == 0) {
               lVar7 = uVar3 - uVar4;
               if (0x7fffffff < lVar7) {
                  return p_Var8;
               }

               if (lVar7 < -0x80000000) {
                  return p_Var1;
               }

               iVar5 = (int)lVar7;
            }

            if (iVar5 < 0) {
               p_Var8 = p_Var1;
            }

         }

      }

      return p_Var8;
   }

   /* void std::vector<glslang::TSymbol*, glslang::pool_allocator<glslang::TSymbol*>
   >::_M_realloc_insert<glslang::TSymbol* const&>(__gnu_cxx::__normal_iterator<glslang::TSymbol**,
   std::vector<glslang::TSymbol*, glslang::pool_allocator<glslang::TSymbol*> > >, glslang::TSymbol*
   const&) */
   void std::vector<glslang::TSymbol*,glslang::pool_allocator<glslang::TSymbol*>>::_M_realloc_insert<glslang::TSymbol*const&>(vector<glslang::TSymbol*,glslang::pool_allocator<glslang::TSymbol*>> *this, long param_2, undefined8 *param_3) {
      long lVar1;
      ulong uVar2;
      long lVar3;
      long lVar4;
      ulong uVar5;
      long lVar6;
      long lVar7;
      lVar1 = *(long*)( this + 0x10 );
      lVar3 = *(long*)( this + 8 );
      uVar2 = lVar1 - lVar3 >> 3;
      if (uVar2 == 0xfffffffffffffff) {
         /* WARNING: Subroutine does not return */
         std::__throw_length_error("vector::_M_realloc_insert");
      }

      if (lVar3 == lVar1) {
         uVar5 = uVar2 + 1;
         if (0xfffffffffffffffe < uVar2) goto LAB_0015f340;
         if (0xfffffffffffffff < uVar5) {
            uVar5 = 0xfffffffffffffff;
         }

         lVar7 = uVar5 * 8;
         LAB_0015f34a:lVar4 = glslang::TPoolAllocator::allocate(*(ulong*)this);
         lVar7 = lVar4 + lVar7;
         lVar6 = lVar4 + 8;
         *(undefined8*)( lVar4 + ( param_2 - lVar3 ) ) = *param_3;
         if (param_2 != lVar3) {
            LAB_0015f2d9:lVar6 = 0;
            do {
               *(undefined8*)( lVar4 + lVar6 ) = *(undefined8*)( lVar3 + lVar6 );
               lVar6 = lVar6 + 8;
            }
 while ( lVar6 != param_2 - lVar3 );
            lVar6 = lVar4 + 8 + lVar6;
         }

         if (param_2 == lVar1) goto LAB_0015f324;
      }
 else {
         uVar5 = uVar2 * 2;
         if (uVar5 < uVar2) {
            LAB_0015f340:lVar7 = 0x7ffffffffffffff8;
            goto LAB_0015f34a;
         }

         if (uVar5 != 0) {
            if (0xfffffffffffffff < uVar5) {
               uVar5 = 0xfffffffffffffff;
            }

            lVar7 = uVar5 * 8;
            goto LAB_0015f34a;
         }

         lVar4 = 0;
         lVar7 = 0;
         lVar6 = 8;
         *(undefined8*)( param_2 - lVar3 ) = *param_3;
         if (param_2 != lVar3) goto LAB_0015f2d9;
      }

      lVar3 = 0;
      do {
         *(undefined8*)( lVar6 + lVar3 ) = *(undefined8*)( param_2 + lVar3 );
         lVar3 = lVar3 + 8;
      }
 while ( lVar3 != lVar1 - param_2 );
      lVar6 = lVar6 + lVar3;
      LAB_0015f324:*(long*)( this + 8 ) = lVar4;
      *(long*)( this + 0x10 ) = lVar6;
      *(long*)( this + 0x18 ) = lVar7;
      return;
   }

   /* std::pair<std::_Rb_tree_iterator<std::pair<int const,
   glslang::TVector<glslang::TIntermConstantUnion const*> > >, bool> std::_Rb_tree<int,
   std::pair<int const, glslang::TVector<glslang::TIntermConstantUnion const*> >,
   std::_Select1st<std::pair<int const, glslang::TVector<glslang::TIntermConstantUnion const*> > >,
   std::less<int>, glslang::pool_allocator<std::pair<int const,
   glslang::TVector<glslang::TIntermConstantUnion const*> > > >::_M_insert_unique<std::pair<int
   const, glslang::TVector<glslang::TIntermConstantUnion const*> > const&>(std::pair<int const,
   glslang::TVector<glslang::TIntermConstantUnion const*> > const&) */
   undefined1[16];
   std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>::_M_insert_unique<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>const&> (_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>
           *this,pair_conflict *param_1) {
      _Rb_tree_node_base *p_Var1;
      int iVar2;
      _Rb_tree_node_base *p_Var3;
      ulong uVar4;
      long lVar5;
      undefined8 uVar6;
      int iVar7;
      long lVar8;
      _Rb_tree_node_base *p_Var9;
      long lVar10;
      long lVar11;
      undefined1 auVar12[16];
      bool local_3c;
      p_Var1 = (_Rb_tree_node_base*)( this + 0x10 );
      iVar2 = *(int*)param_1;
      p_Var3 = *(_Rb_tree_node_base**)( this + 0x18 );
      if (*(_Rb_tree_node_base**)( this + 0x18 ) == (_Rb_tree_node_base*)0x0) {
         p_Var9 = p_Var1;
         if (*(_Rb_tree_node_base**)( this + 0x20 ) != p_Var1) {
            LAB_0015f52a:p_Var3 = (_Rb_tree_node_base*)std::_Rb_tree_decrement(p_Var9);
            iVar7 = *(int*)( p_Var3 + 0x20 );
            LAB_0015f424:uVar6 = 0;
            if (iVar2 <= iVar7) goto LAB_0015f4f4;
            goto LAB_0015f42e;
         }

         local_3c = true;
      }
 else {
         do {
            p_Var9 = p_Var3;
            iVar7 = *(int*)( p_Var9 + 0x20 );
            p_Var3 = *(_Rb_tree_node_base**)( p_Var9 + 0x18 );
            if (iVar2 < iVar7) {
               p_Var3 = *(_Rb_tree_node_base**)( p_Var9 + 0x10 );
            }

         }
 while ( p_Var3 != (_Rb_tree_node_base*)0x0 );
         p_Var3 = p_Var9;
         if (iVar7 <= iVar2) goto LAB_0015f424;
         if (*(_Rb_tree_node_base**)( this + 0x20 ) != p_Var9) goto LAB_0015f52a;
         LAB_0015f42e:local_3c = true;
         if (p_Var9 != p_Var1) {
            local_3c = iVar2 < *(int*)( p_Var9 + 0x20 );
         }

      }

      p_Var3 = (_Rb_tree_node_base*)glslang::TPoolAllocator::allocate(*(ulong*)this);
      *(undefined4*)( p_Var3 + 0x20 ) = *(undefined4*)param_1;
      uVar4 = glslang::GetThreadPoolAllocator();
      lVar10 = *(long*)( param_1 + 0x18 ) - *(long*)( param_1 + 0x10 );
      *(undefined8*)( p_Var3 + 0x30 ) = 0;
      *(ulong*)( p_Var3 + 0x28 ) = uVar4;
      *(undefined8*)( p_Var3 + 0x38 ) = 0;
      *(undefined8*)( p_Var3 + 0x40 ) = 0;
      if (lVar10 == 0) {
         lVar10 = 0;
         lVar5 = 0;
      }
 else {
         lVar5 = glslang::TPoolAllocator::allocate(uVar4);
      }

      *(long*)( p_Var3 + 0x40 ) = lVar10 + lVar5;
      *(long*)( p_Var3 + 0x30 ) = lVar5;
      *(long*)( p_Var3 + 0x38 ) = lVar5;
      lVar10 = *(long*)( param_1 + 0x10 );
      if (*(long*)( param_1 + 0x18 ) != lVar10) {
         lVar11 = *(long*)( param_1 + 0x18 ) - lVar10;
         lVar8 = 0;
         do {
            *(undefined8*)( lVar5 + lVar8 ) = *(undefined8*)( lVar10 + lVar8 );
            lVar8 = lVar8 + 8;
         }
 while ( lVar11 != lVar8 );
         lVar5 = lVar5 + lVar11;
      }

      *(long*)( p_Var3 + 0x38 ) = lVar5;
      std::_Rb_tree_insert_and_rebalance(local_3c, p_Var3, p_Var9, p_Var1);
      *(long*)( this + 0x30 ) = *(long*)( this + 0x30 ) + 1;
      uVar6 = 1;
      LAB_0015f4f4:auVar12._8_8_ = uVar6;
      auVar12._0_8_ = p_Var3;
      return auVar12;
   }

   /* std::pair<std::_Rb_tree_iterator<std::pair<int const, glslang::TVector<glslang::TIntermTyped
   const*> > >, bool> std::_Rb_tree<int, std::pair<int const, glslang::TVector<glslang::TIntermTyped
   const*> >, std::_Select1st<std::pair<int const, glslang::TVector<glslang::TIntermTyped const*> >
   >, std::less<int>, glslang::pool_allocator<std::pair<int const,
   glslang::TVector<glslang::TIntermTyped const*> > > >::_M_insert_unique<std::pair<int const,
   glslang::TVector<glslang::TIntermTyped const*> > const&>(std::pair<int const,
   glslang::TVector<glslang::TIntermTyped const*> > const&) */
   undefined1[16];
   std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>>::_M_insert_unique<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>const&> (_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>>
           *this,pair_conflict *param_1) {
      _Rb_tree_node_base *p_Var1;
      int iVar2;
      _Rb_tree_node_base *p_Var3;
      ulong uVar4;
      long lVar5;
      undefined8 uVar6;
      int iVar7;
      long lVar8;
      _Rb_tree_node_base *p_Var9;
      long lVar10;
      long lVar11;
      undefined1 auVar12[16];
      bool local_3c;
      p_Var1 = (_Rb_tree_node_base*)( this + 0x10 );
      iVar2 = *(int*)param_1;
      p_Var3 = *(_Rb_tree_node_base**)( this + 0x18 );
      if (*(_Rb_tree_node_base**)( this + 0x18 ) == (_Rb_tree_node_base*)0x0) {
         p_Var9 = p_Var1;
         if (*(_Rb_tree_node_base**)( this + 0x20 ) != p_Var1) {
            LAB_0015f6da:p_Var3 = (_Rb_tree_node_base*)std::_Rb_tree_decrement(p_Var9);
            iVar7 = *(int*)( p_Var3 + 0x20 );
            LAB_0015f5d4:uVar6 = 0;
            if (iVar2 <= iVar7) goto LAB_0015f6a4;
            goto LAB_0015f5de;
         }

         local_3c = true;
      }
 else {
         do {
            p_Var9 = p_Var3;
            iVar7 = *(int*)( p_Var9 + 0x20 );
            p_Var3 = *(_Rb_tree_node_base**)( p_Var9 + 0x18 );
            if (iVar2 < iVar7) {
               p_Var3 = *(_Rb_tree_node_base**)( p_Var9 + 0x10 );
            }

         }
 while ( p_Var3 != (_Rb_tree_node_base*)0x0 );
         p_Var3 = p_Var9;
         if (iVar7 <= iVar2) goto LAB_0015f5d4;
         if (*(_Rb_tree_node_base**)( this + 0x20 ) != p_Var9) goto LAB_0015f6da;
         LAB_0015f5de:local_3c = true;
         if (p_Var9 != p_Var1) {
            local_3c = iVar2 < *(int*)( p_Var9 + 0x20 );
         }

      }

      p_Var3 = (_Rb_tree_node_base*)glslang::TPoolAllocator::allocate(*(ulong*)this);
      *(undefined4*)( p_Var3 + 0x20 ) = *(undefined4*)param_1;
      uVar4 = glslang::GetThreadPoolAllocator();
      lVar10 = *(long*)( param_1 + 0x18 ) - *(long*)( param_1 + 0x10 );
      *(undefined8*)( p_Var3 + 0x30 ) = 0;
      *(ulong*)( p_Var3 + 0x28 ) = uVar4;
      *(undefined8*)( p_Var3 + 0x38 ) = 0;
      *(undefined8*)( p_Var3 + 0x40 ) = 0;
      if (lVar10 == 0) {
         lVar10 = 0;
         lVar5 = 0;
      }
 else {
         lVar5 = glslang::TPoolAllocator::allocate(uVar4);
      }

      *(long*)( p_Var3 + 0x40 ) = lVar10 + lVar5;
      *(long*)( p_Var3 + 0x30 ) = lVar5;
      *(long*)( p_Var3 + 0x38 ) = lVar5;
      lVar10 = *(long*)( param_1 + 0x10 );
      if (*(long*)( param_1 + 0x18 ) != lVar10) {
         lVar11 = *(long*)( param_1 + 0x18 ) - lVar10;
         lVar8 = 0;
         do {
            *(undefined8*)( lVar5 + lVar8 ) = *(undefined8*)( lVar10 + lVar8 );
            lVar8 = lVar8 + 8;
         }
 while ( lVar11 != lVar8 );
         lVar5 = lVar5 + lVar11;
      }

      *(long*)( p_Var3 + 0x38 ) = lVar5;
      std::_Rb_tree_insert_and_rebalance(local_3c, p_Var3, p_Var9, p_Var1);
      *(long*)( this + 0x30 ) = *(long*)( this + 0x30 ) + 1;
      uVar6 = 1;
      LAB_0015f6a4:auVar12._8_8_ = uVar6;
      auVar12._0_8_ = p_Var3;
      return auVar12;
   }

   /* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::reserve(unsigned long) */
   void std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::reserve(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *this, ulong param_1) {
      size_t __n;
      undefined1 *__dest;
      void *pvVar1;
      ulong uVar2;
      ulong uVar3;
      if (*(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 ) == this + 0x18) {
         uVar2 = 0xf;
      }
 else {
         uVar2 = *(ulong*)( this + 0x18 );
      }

      if (param_1 <= uVar2) {
         return;
      }

      if (-1 < (long)param_1) {
         uVar2 = uVar2 * 2;
         uVar3 = 0x7fffffffffffffff;
         if (uVar2 < 0x8000000000000000) {
            uVar3 = uVar2;
         }

         if (param_1 < uVar2) {
            param_1 = uVar3;
         }

         __dest = (undefined1*)glslang::TPoolAllocator::allocate(*(ulong*)this);
         __n = *(long*)( this + 0x10 ) + 1;
         if (*(long*)( this + 0x10 ) == 0) {
            *__dest = **(undefined1**)( this + 8 );
            *(undefined1**)( this + 8 ) = __dest;
            *(ulong*)( this + 0x18 ) = param_1;
         }
 else if (__n == 0) {
            *(undefined1**)( this + 8 ) = __dest;
            *(ulong*)( this + 0x18 ) = param_1;
         }
 else {
            pvVar1 = memcpy(__dest, *(undefined1**)( this + 8 ), __n);
            *(ulong*)( this + 0x18 ) = param_1;
            *(void**)( this + 8 ) = pvVar1;
         }

         return;
      }

      /* WARNING: Subroutine does not return */
      std::__throw_length_error("basic_string::_M_create");
   }

   /* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::_M_mutate(unsigned long, unsigned long, char const*, unsigned long) */
   void std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *this, ulong param_1, ulong param_2, char *param_3, ulong param_4) {
      undefined1 *__dest;
      ulong uVar1;
      ulong uVar2;
      ulong uVar3;
      size_t __n;
      undefined1 *__src;
      uVar3 = ( param_4 - param_2 ) + *(long*)( this + 0x10 );
      __n = *(long*)( this + 0x10 ) - ( param_1 + param_2 );
      if (*(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 ) == this + 0x18) {
         uVar1 = 0xf;
      }
 else {
         uVar1 = *(ulong*)( this + 0x18 );
      }

      if (-1 < (long)uVar3) {
         if (uVar1 < uVar3) {
            uVar1 = uVar1 * 2;
            uVar2 = 0x7fffffffffffffff;
            if (uVar1 < 0x8000000000000000) {
               uVar2 = uVar1;
            }

            if (uVar3 < uVar1) {
               uVar3 = uVar2;
            }

         }

         __dest = (undefined1*)glslang::TPoolAllocator::allocate(*(ulong*)this);
         if (param_1 != 0) {
            if (param_1 == 1) {
               *__dest = **(undefined1**)( this + 8 );
            }
 else {
               __dest = (undefined1*)memcpy(__dest, *(undefined1**)( this + 8 ), param_1);
            }

         }

         if (( param_3 != (char*)0x0 ) && ( param_4 != 0 )) {
            if (param_4 == 1) {
               __dest[param_1] = *param_3;
            }
 else {
               memcpy(__dest + param_1, param_3, param_4);
            }

         }

         if (__n != 0) {
            __src = (undefined1*)( param_1 + param_2 + *(long*)( this + 8 ) );
            if (__n == 1) {
               __dest[param_1 + param_4] = *__src;
            }
 else {
               memcpy(__dest + param_1 + param_4, __src, __n);
            }

         }

         *(undefined1**)( this + 8 ) = __dest;
         *(ulong*)( this + 0x18 ) = uVar3;
         return;
      }

      /* WARNING: Subroutine does not return */
      std::__throw_length_error("basic_string::_M_create");
   }

   /* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::_M_append(char const*, unsigned long) */
   basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> * __thiscallstd::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_append(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> * this, char, *param_1, ulong, param_2);
   {
      ulong uVar1;
      ulong uVar2;
      ulong uVar3;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *pbVar4;
      uVar2 = *(ulong*)( this + 0x10 );
      pbVar4 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 );
      uVar1 = param_2 + uVar2;
      if (pbVar4 == this + 0x18) {
         uVar3 = 0xf;
      }
 else {
         uVar3 = *(ulong*)( this + 0x18 );
      }

      if (uVar3 < uVar1) {
         _M_mutate(this, uVar2, 0, param_1, param_2);
         pbVar4 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 );
      }
 else if (param_2 != 0) {
         if (param_2 == 1) {
            pbVar4[uVar2] = ( basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> ) * param_1;
            pbVar4 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 );
         }
 else {
            memcpy(pbVar4 + uVar2, param_1, param_2);
            pbVar4 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 );
         }

      }

      *(ulong*)( this + 0x10 ) = uVar1;
      pbVar4[uVar1] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x0;
      return this;
   }

   /* glslang::TFunction::addParameter(glslang::TParameter&) */
   void glslang::TFunction::addParameter(TFunction *this, TParameter *param_1) {
      undefined8 *puVar1;
      ulong uVar2;
      undefined8 uVar3;
      TFunction *pTVar4;
      ulong uVar5;
      puVar1 = *(undefined8**)( this + 0x38 );
      if (puVar1 == *(undefined8**)( this + 0x40 )) {
         std::vector<glslang::TParameter,glslang::pool_allocator<glslang::TParameter>>::_M_realloc_insert<glslang::TParameter_const&>((vector<glslang::TParameter,glslang::pool_allocator<glslang::TParameter>>*)( this + 0x28 ), puVar1, param_1);
      }
 else {
         uVar3 = *(undefined8*)( param_1 + 8 );
         *puVar1 = *(undefined8*)param_1;
         puVar1[1] = uVar3;
         puVar1[2] = *(undefined8*)( param_1 + 0x10 );
         *(undefined8**)( this + 0x38 ) = puVar1 + 3;
      }

      glslang::TType::buildMangledName(*(basic_string**)( param_1 + 8 ));
      uVar2 = *(ulong*)( this + 0xf8 );
      pTVar4 = *(TFunction**)( this + 0xf0 );
      if (pTVar4 == this + 0x100) {
         uVar5 = 0xf;
      }
 else {
         uVar5 = *(ulong*)( this + 0x100 );
      }

      if (uVar5 < uVar2 + 1) {
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( this + 0xe8 ), uVar2, 0, (char*)0x0, 1);
         pTVar4 = *(TFunction**)( this + 0xf0 );
      }

      pTVar4[uVar2] = (TFunction)0x3b;
      *(ulong*)( this + 0xf8 ) = uVar2 + 1;
      *(undefined1*)( *(long*)( this + 0xf0 ) + 1 + uVar2 ) = 0;
      if (*(long*)( param_1 + 0x10 ) != 0) {
         *(int*)( this + 0x118 ) = *(int*)( this + 0x118 ) + 1;
      }

      return;
   }

   /* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::append(char const*) */
   basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> * __thiscallstd::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> * this, char, *param_1);
   {
      ulong uVar1;
      ulong uVar2;
      size_t __n;
      ulong uVar3;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *pbVar4;
      __n = strlen(param_1);
      uVar2 = *(ulong*)( this + 0x10 );
      if (__n <= 0x7fffffffffffffff - uVar2) {
         pbVar4 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 );
         uVar1 = uVar2 + __n;
         if (pbVar4 == this + 0x18) {
            uVar3 = 0xf;
         }
 else {
            uVar3 = *(ulong*)( this + 0x18 );
         }

         if (uVar3 < uVar1) {
            _M_mutate(this, uVar2, 0, param_1, __n);
            pbVar4 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 );
         }
 else if (__n != 0) {
            if (__n == 1) {
               pbVar4[uVar2] = ( basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> ) * param_1;
               pbVar4 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 );
            }
 else {
               memcpy(pbVar4 + uVar2, param_1, __n);
               pbVar4 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 );
            }

         }

         *(ulong*)( this + 0x10 ) = uVar1;
         pbVar4[uVar1] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x0;
         return this;
      }

      /* WARNING: Subroutine does not return */
      std::__throw_length_error("basic_string::append");
   }

   /* WARNING: Unknown calling convention -- yet parameter storage is locked */
   /* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> >
   std::TEMPNAMEPLACEHOLDERVALUE(std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const&, char const*) */
   basic_string *std::operator +(basic_string *param_1, char *param_2) {
      ulong uVar1;
      ulong uVar2;
      char *pcVar3;
      size_t __n;
      undefined8 uVar4;
      ulong uVar5;
      basic_string *in_RDX;
      basic_string *pbVar6;
      __n = strlen((char*)in_RDX);
      uVar2 = *(ulong*)( param_2 + 0x10 );
      pcVar3 = *(char**)( param_2 + 8 );
      uVar4 = glslang::GetThreadPoolAllocator();
      *(basic_string**)( param_1 + 8 ) = param_1 + 0x18;
      *(undefined8*)param_1 = uVar4;
      *(undefined8*)( param_1 + 0x10 ) = 0;
      param_1[0x18] = (basic_string)0x0;
      __cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::reserve((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)param_1, __n + uVar2);
      if (uVar2 <= 0x7fffffffffffffffU - *(long*)( param_1 + 0x10 )) {
         __cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_append((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)param_1, pcVar3, uVar2);
         uVar2 = *(ulong*)( param_1 + 0x10 );
         if (__n <= 0x7fffffffffffffff - uVar2) {
            pbVar6 = *(basic_string**)( param_1 + 8 );
            uVar1 = __n + uVar2;
            if (param_1 + 0x18 == pbVar6) {
               uVar5 = 0xf;
            }
 else {
               uVar5 = *(ulong*)( param_1 + 0x18 );
            }

            if (uVar5 < uVar1) {
               __cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)param_1, uVar2, 0, (char*)in_RDX, __n);
               pbVar6 = *(basic_string**)( param_1 + 8 );
            }
 else if (__n != 0) {
               if (__n == 1) {
                  pbVar6[uVar2] = *in_RDX;
                  pbVar6 = *(basic_string**)( param_1 + 8 );
               }
 else {
                  memcpy(pbVar6 + uVar2, in_RDX, __n);
                  pbVar6 = *(basic_string**)( param_1 + 8 );
               }

            }

            *(ulong*)( param_1 + 0x10 ) = uVar1;
            pbVar6[uVar1] = (basic_string)0x0;
            return param_1;
         }

      }

      /* WARNING: Subroutine does not return */
      std::__throw_length_error("basic_string::append");
   }

   /* glslang::AccessChainTraverser::visitSymbol(glslang::TIntermSymbol*) */
   void glslang::AccessChainTraverser::visitSymbol(AccessChainTraverser *this, TIntermSymbol *param_1) {
      ulong uVar1;
      ulong uVar2;
      ulong __n;
      AccessChainTraverser *__src;
      char cVar3;
      int iVar4;
      long lVar5;
      ulong uVar6;
      size_t __n_00;
      TIntermSymbol *pTVar7;
      AccessChainTraverser *pAVar8;
      if (*(code**)( *(long*)param_1 + 0xf0 ) == TIntermTyped::getType) {
         pTVar7 = param_1 + 0x20;
      }
 else {
         pTVar7 = (TIntermSymbol*)( **(code**)( *(long*)param_1 + 0xf0 ) )(param_1);
      }

      if (*(code**)( *(long*)pTVar7 + 0x140 ) == TType::isOpaque) {
         lVar5 = *(long*)param_1;
         if (( 0x14 < (byte)pTVar7[8] ) || ( ( 0x1a6000UL >> ( (ulong)(byte)pTVar7[8] & 0x3f ) & 1 ) == 0 )) goto LAB_0015fda0;
      }
 else {
         cVar3 = ( **(code**)( *(long*)pTVar7 + 0x140 ) )();
         if (cVar3 == '\0') {
            lVar5 = *(long*)param_1;
            goto LAB_0015fda0;
         }

         lVar5 = *(long*)param_1;
      }

      if (*(code**)( lVar5 + 0x108 ) == TIntermTyped::getQualifier) {
         pTVar7 = param_1 + 0x30;
      }
 else {
         pTVar7 = (TIntermSymbol*)( **(code**)( lVar5 + 0x108 ) )(param_1);
         lVar5 = *(long*)param_1;
      }

      *(uint*)( this + 0x60 ) = (byte)pTVar7[8] & 0x7f;
      LAB_0015fda0:if (*(code**)( lVar5 + 400 ) == TIntermSymbol::getName_abi_cxx11_) {
         pTVar7 = param_1 + 200;
      }
 else {
         pTVar7 = (TIntermSymbol*)( **(code**)( lVar5 + 400 ) )(param_1);
      }

      uVar2 = *(ulong*)( pTVar7 + 0x10 );
      if (uVar2 != 0) {
         __n_00 = 5;
         if (uVar2 < 6) {
            __n_00 = uVar2;
         }

         iVar4 = memcmp(*(void**)( pTVar7 + 8 ), "anon@", __n_00);
         if (iVar4 == 0 && (int)__n_00 == 5) {
            return;
         }

      }

      if (*(code**)( *(long*)param_1 + 400 ) == TIntermSymbol::getName_abi_cxx11_) {
         pTVar7 = param_1 + 200;
      }
 else {
         pTVar7 = (TIntermSymbol*)( **(code**)( *(long*)param_1 + 400 ) )(param_1);
      }

      uVar2 = *(ulong*)( this + 0x48 );
      __n = *(ulong*)( pTVar7 + 0x10 );
      __src = *(AccessChainTraverser**)( pTVar7 + 8 );
      if (__n <= 0x7fffffffffffffff - uVar2) {
         pAVar8 = *(AccessChainTraverser**)( this + 0x40 );
         uVar1 = __n + uVar2;
         if (pAVar8 == this + 0x50) {
            uVar6 = 0xf;
         }
 else {
            uVar6 = *(ulong*)( this + 0x50 );
         }

         if (uVar6 < uVar1) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( this + 0x38 ), uVar2, 0, (char*)__src, __n);
            *(ulong*)( this + 0x48 ) = uVar1;
            *(undefined1*)( *(long*)( this + 0x40 ) + uVar1 ) = 0;
         }
 else {
            if (__n != 0) {
               if (__n == 1) {
                  pAVar8[uVar2] = *__src;
                  pAVar8 = *(AccessChainTraverser**)( this + 0x40 );
               }
 else {
                  memcpy(pAVar8 + uVar2, __src, __n);
                  pAVar8 = *(AccessChainTraverser**)( this + 0x40 );
               }

            }

            *(ulong*)( this + 0x48 ) = uVar1;
            pAVar8[uVar1] = (AccessChainTraverser)0x0;
         }

         return;
      }

      /* WARNING: Subroutine does not return */
      std::__throw_length_error("basic_string::append");
   }

   /* glslang::TType::getCompleteString(bool, bool, bool, bool, std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> >, std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> >) const::{lambda(unsigned
   int)#2}::TEMPNAMEPLACEHOLDERVALUE(unsigned int) const */
   _func_getCompleteString_bool_bool_bool_bool_basic_string_basic_string * __thiscallconst::{lambda(unsigned_int);
   #2
   {
      ulong uVar1;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *this_00;
      ulong uVar2;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *__src;
      size_t __n;
      ulong uVar3;
      char cVar4;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *pbVar5;
      long in_FS_OFFSET;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *local_58;
      uint local_50;
      long local_48[3];
      long local_30;
      this_00 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)this;
      local_30 = *(long*)( in_FS_OFFSET + 0x28 );
      if (param_1 < 10) {
         cVar4 = '\x01';
      }
 else if (param_1 < 100) {
         cVar4 = '\x02';
      }
 else if (param_1 < 1000) {
         cVar4 = '\x03';
      }
 else if (param_1 < 10000) {
         cVar4 = '\x04';
      }
 else {
         cVar4 = '\x05';
         if (99999 < param_1) {
            if (param_1 < 1000000) {
               cVar4 = '\x05';
            }
 else {
               cVar4 = '\a';
               if (param_1 < 10000000) goto LAB_0015fff5;
               if (param_1 < 100000000) {
                  cVar4 = '\b';
                  goto LAB_0015fff5;
               }

               if (param_1 < 1000000000) {
                  cVar4 = '\t';
                  goto LAB_0015fff5;
               }

               cVar4 = '\t';
            }

            cVar4 = cVar4 + '\x01';
         }

      }

      LAB_0015fff5:local_58 = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)local_48;
      std::__cxx11::string::_M_construct(( ulong ) & local_58, cVar4);
      std::__detail::__to_chars_10_impl<unsigned_int>((char*)local_58, local_50, param_1);
      __src = local_58;
      __n = strlen((char*)local_58);
      uVar2 = *(ulong*)( this_00 + 0x10 );
      if (0x7fffffffffffffff - uVar2 < __n) {
         /* WARNING: Subroutine does not return */
         std::__throw_length_error("basic_string::append");
      }

      pbVar5 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this_00 + 8 );
      uVar1 = __n + uVar2;
      if (pbVar5 == this_00 + 0x18) {
         uVar3 = 0xf;
      }
 else {
         uVar3 = *(ulong*)( this_00 + 0x18 );
      }

      if (uVar3 < uVar1) {
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(this_00, uVar2, 0, (char*)__src, __n);
         pbVar5 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this_00 + 8 );
      }
 else if (__n != 0) {
         if (__n == 1) {
            pbVar5[uVar2] = *__src;
            pbVar5 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this_00 + 8 );
         }
 else {
            memcpy(pbVar5 + uVar2, __src, __n);
            pbVar5 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this_00 + 8 );
         }

      }

      *(ulong*)( this_00 + 0x10 ) = uVar1;
      pbVar5[uVar1] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x0;
      if (local_58 != (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)local_48) {
         operator_delete(local_58, local_48[0] + 1);
      }

      if (local_30 == *(long*)( in_FS_OFFSET + 0x28 )) {
         return (_func_getCompleteString_bool_bool_bool_bool_basic_string_basic_string*)0x0;
      }

      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   /* glslang::TType::getCompleteString(bool, bool, bool, bool, std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> >, std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> >)
   const::{lambda(int)#3}::TEMPNAMEPLACEHOLDERVALUE(int) const */
   _func_getCompleteString_bool_bool_bool_bool_basic_string_basic_string * __thiscall
const::{lambda(int)
   #3
   {
      ulong uVar1;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *this_00;
      ulong uVar2;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *__src;
      int iVar3;
      size_t __n;
      ulong uVar4;
      uint uVar5;
      uint uVar6;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *pbVar7;
      long in_FS_OFFSET;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *local_58[2];
      long local_48[3];
      long local_30;
      this_00 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)this;
      local_30 = *(long*)( in_FS_OFFSET + 0x28 );
      uVar5 = -param_1;
      if (0 < param_1) {
         uVar5 = param_1;
      }

      if (uVar5 < 10) {
         uVar6 = 1;
      }
 else if (uVar5 < 100) {
         uVar6 = 2;
      }
 else if (uVar5 < 1000) {
         uVar6 = 3;
      }
 else if (uVar5 < 10000) {
         uVar6 = 4;
      }
 else {
         uVar6 = 5;
         if (99999 < uVar5) {
            if (uVar5 < 1000000) {
               iVar3 = 5;
            }
 else {
               uVar6 = 7;
               if (uVar5 < 10000000) goto LAB_00160213;
               if (uVar5 < 100000000) {
                  uVar6 = 8;
                  goto LAB_00160213;
               }

               if (uVar5 < 1000000000) {
                  uVar6 = 9;
                  goto LAB_00160213;
               }

               iVar3 = 9;
            }

            uVar6 = iVar3 + 1;
         }

      }

      LAB_00160213:local_58[0] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)local_48;
      std::__cxx11::string::_M_construct((ulong)local_58, (char)uVar6 - (char)( param_1 >> 0x1f ));
      std::__detail::__to_chars_10_impl<unsigned_int>((char*)( local_58[0] + ( (uint)param_1 >> 0x1f ) ), uVar6, uVar5);
      __src = local_58[0];
      __n = strlen((char*)local_58[0]);
      uVar2 = *(ulong*)( this_00 + 0x10 );
      if (0x7fffffffffffffff - uVar2 < __n) {
         /* WARNING: Subroutine does not return */
         std::__throw_length_error("basic_string::append");
      }

      pbVar7 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this_00 + 8 );
      uVar1 = __n + uVar2;
      if (pbVar7 == this_00 + 0x18) {
         uVar4 = 0xf;
      }
 else {
         uVar4 = *(ulong*)( this_00 + 0x18 );
      }

      if (uVar4 < uVar1) {
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(this_00, uVar2, 0, (char*)__src, __n);
         pbVar7 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this_00 + 8 );
      }
 else if (__n != 0) {
         if (__n == 1) {
            pbVar7[uVar2] = *__src;
            pbVar7 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this_00 + 8 );
         }
 else {
            memcpy(pbVar7 + uVar2, __src, __n);
            pbVar7 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this_00 + 8 );
         }

      }

      *(ulong*)( this_00 + 0x10 ) = uVar1;
      pbVar7[uVar1] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x0;
      if (local_58[0] != (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)local_48) {
         operator_delete(local_58[0], local_48[0] + 1);
      }

      if (local_30 == *(long*)( in_FS_OFFSET + 0x28 )) {
         return (_func_getCompleteString_bool_bool_bool_bool_basic_string_basic_string*)0x0;
      }

      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   /* glslang::AccessChainTraverser::visitBinary(glslang::TVisit, glslang::TIntermBinary*) */
   undefined8 glslang::AccessChainTraverser::visitBinary(AccessChainTraverser *this, undefined8 param_2, long *param_3) {
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *this_00;
      int iVar1;
      code *pcVar2;
      undefined1 *__src;
      ulong uVar3;
      long lVar4;
      size_t sVar5;
      ulong uVar6;
      long *plVar7;
      long lVar8;
      ulong uVar9;
      ulong uVar10;
      AccessChainTraverser *pAVar11;
      AccessChainTraverser *pAVar12;
      long lVar13;
      long in_FS_OFFSET;
      AccessChainTraverser *local_b0;
      ulong local_a0[3];
      undefined8 local_88;
      AccessChainTraverser *local_80;
      ulong local_78;
      AccessChainTraverser local_70[24];
      char local_58[24];
      long local_40;
      local_40 = *(long*)( in_FS_OFFSET + 0x28 );
      iVar1 = (int)param_3[0x17];
      if (iVar1 != 0xb8) goto joined_r0x001605bb;
      if (*(code**)( *param_3 + 400 ) == TIntermBinary::getLeft) {
         plVar7 = (long*)param_3[0x18];
      }
 else {
         plVar7 = (long*)( **(code**)( *param_3 + 400 ) )(param_3);
      }

      if (*(code**)( *plVar7 + 0xf0 ) == TIntermTyped::getType) {
         plVar7 = plVar7 + 4;
      }
 else {
         plVar7 = (long*)( **(code**)( *plVar7 + 0xf0 ) )();
      }

      lVar8 = plVar7[0xd];
      if (*(code**)( *param_3 + 0x198 ) == TIntermBinary::getRight) {
         plVar7 = (long*)param_3[0x19];
      }
 else {
         plVar7 = (long*)( **(code**)( *param_3 + 0x198 ) )(param_3);
      }

      lVar13 = ( **(code**)( *plVar7 + 0x28 ) )();
      plVar7 = *(long**)( (long)**(int**)( *(long*)( lVar13 + 0xc0 ) + 8 ) * 0x20 + *(long*)( lVar8 + 8 ) );
      pcVar2 = *(code**)( *plVar7 + 0x30 );
      if (pcVar2 == TType::getFieldName_abi_cxx11_) {
         lVar8 = plVar7[0xe];
      }
 else {
         lVar8 = ( *pcVar2 )();
      }

      uVar10 = glslang::GetThreadPoolAllocator();
      local_b0 = (AccessChainTraverser*)local_a0;
      __src = *(undefined1**)( lVar8 + 8 );
      uVar3 = *(ulong*)( lVar8 + 0x10 );
      if (uVar3 < 0x10) {
         if (uVar3 == 1) {
            local_a0[0] = CONCAT71(local_a0[0]._1_7_, *__src);
         }
 else if (uVar3 != 0) goto LAB_00160893;
      }
 else {
         if ((long)uVar3 < 0) {
            /* WARNING: Subroutine does not return */
            std::__throw_length_error("basic_string::_M_create");
         }

         local_b0 = (AccessChainTraverser*)glslang::TPoolAllocator::allocate(uVar10);
         local_a0[0] = uVar3;
         LAB_00160893:memcpy(local_b0, __src, uVar3);
      }

      local_b0[uVar3] = (AccessChainTraverser)0x0;
      uVar10 = *(ulong*)( this + 0x48 );
      if (uVar10 != 0) {
         if (uVar10 == 0x7fffffffffffffff) goto LAB_00160966;
         uVar6 = uVar10 + 1;
         if (*(AccessChainTraverser**)( this + 0x40 ) == this + 0x50) {
            uVar9 = 0xf;
         }
 else {
            uVar9 = *(ulong*)( this + 0x50 );
         }

         if (uVar9 < uVar6) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( this + 0x38 ), uVar10, 0, ".", 1);
         }
 else {
            ( *(AccessChainTraverser**)( this + 0x40 ) )[uVar10] = (AccessChainTraverser)0x2e;
         }

         *(ulong*)( this + 0x48 ) = uVar6;
         *(undefined1*)( *(long*)( this + 0x40 ) + uVar6 ) = 0;
         uVar10 = *(ulong*)( this + 0x48 );
      }

      if (uVar3 <= 0x7fffffffffffffff - uVar10) {
         pAVar11 = *(AccessChainTraverser**)( this + 0x40 );
         uVar6 = uVar3 + uVar10;
         if (pAVar11 == this + 0x50) {
            uVar9 = 0xf;
         }
 else {
            uVar9 = *(ulong*)( this + 0x50 );
         }

         if (uVar9 < uVar6) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( this + 0x38 ), uVar10, 0, (char*)local_b0, uVar3);
            pAVar11 = *(AccessChainTraverser**)( this + 0x40 );
         }
 else if (uVar3 != 0) {
            if (uVar3 == 1) {
               pAVar11[uVar10] = *local_b0;
               pAVar11 = *(AccessChainTraverser**)( this + 0x40 );
            }
 else {
               memcpy(pAVar11 + uVar10, local_b0, uVar3);
               pAVar11 = *(AccessChainTraverser**)( this + 0x40 );
            }

         }

         *(ulong*)( this + 0x48 ) = uVar6;
         pAVar11[uVar6] = (AccessChainTraverser)0x0;
         iVar1 = (int)param_3[0x17];
         joined_r0x001605bb:if (iVar1 == 0xb6) {
            if (*(code**)( *param_3 + 0x198 ) == TIntermBinary::getRight) {
               plVar7 = (long*)param_3[0x19];
            }
 else {
               plVar7 = (long*)( **(code**)( *param_3 + 0x198 ) )(param_3);
            }

            lVar4 = ( **(code**)( *plVar7 + 0x28 ) )();
            this_00 = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( this + 0x38 );
            lVar8 = *(long*)( lVar4 + 0xc0 );
            for (lVar13 = 0; ( lVar8 != 0 && ( (int)lVar13 < (int)( *(long*)( lVar8 + 0x10 ) - *(long*)( lVar8 + 8 ) >> 4 ) ) ); lVar13 = lVar13 + 1) {
               uVar3 = *(ulong*)( this + 0x48 );
               if (uVar3 == 0x7fffffffffffffff) goto LAB_00160966;
               pAVar11 = this + 0x50;
               if (*(AccessChainTraverser**)( this + 0x40 ) == pAVar11) {
                  uVar10 = 0xf;
               }
 else {
                  uVar10 = *(ulong*)( this + 0x50 );
               }

               if (uVar10 < uVar3 + 1) {
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(this_00, uVar3, 0, "[", 1);
               }
 else {
                  ( *(AccessChainTraverser**)( this + 0x40 ) )[uVar3] = (AccessChainTraverser)0x5b;
               }

               *(ulong*)( this + 0x48 ) = uVar3 + 1;
               *(undefined1*)( *(long*)( this + 0x40 ) + 1 + uVar3 ) = 0;
               __snprintf_chk(local_58, 0x10, 2, 0x10, &_LC524, *(undefined4*)( lVar13 * 0x10 + *(long*)( *(long*)( lVar4 + 0xc0 ) + 8 ) ));
               local_88 = glslang::GetThreadPoolAllocator();
               local_80 = local_70;
               sVar5 = strlen(local_58);
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_88, local_58, local_58 + sVar5);
               uVar3 = *(ulong*)( this + 0x48 );
               if (0x7fffffffffffffff - uVar3 < local_78) goto LAB_00160966;
               pAVar12 = *(AccessChainTraverser**)( this + 0x40 );
               uVar10 = local_78 + uVar3;
               if (pAVar11 == pAVar12) {
                  uVar6 = 0xf;
               }
 else {
                  uVar6 = *(ulong*)( this + 0x50 );
               }

               if (uVar6 < uVar10) {
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(this_00, uVar3, 0, (char*)local_80, local_78);
                  pAVar12 = *(AccessChainTraverser**)( this + 0x40 );
               }
 else if (local_78 != 0) {
                  if (local_78 == 1) {
                     pAVar12[uVar3] = *local_80;
                     pAVar12 = *(AccessChainTraverser**)( this + 0x40 );
                  }
 else {
                     memcpy(pAVar12 + uVar3, local_80, local_78);
                     pAVar12 = *(AccessChainTraverser**)( this + 0x40 );
                  }

               }

               *(ulong*)( this + 0x48 ) = uVar10;
               pAVar12[uVar10] = (AccessChainTraverser)0x0;
               uVar3 = *(ulong*)( this + 0x48 );
               if (uVar3 == 0x7fffffffffffffff) goto LAB_00160966;
               if (pAVar11 == *(AccessChainTraverser**)( this + 0x40 )) {
                  uVar10 = 0xf;
               }
 else {
                  uVar10 = *(ulong*)( this + 0x50 );
               }

               if (uVar10 < uVar3 + 1) {
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(this_00, uVar3, 0, "]", 1);
               }
 else {
                  ( *(AccessChainTraverser**)( this + 0x40 ) )[uVar3] = (AccessChainTraverser)0x5d;
               }

               *(ulong*)( this + 0x48 ) = uVar3 + 1;
               *(undefined1*)( *(long*)( this + 0x40 ) + 1 + uVar3 ) = 0;
               lVar8 = *(long*)( lVar4 + 0xc0 );
            }

         }

         if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
            /* WARNING: Subroutine does not return */
            __stack_chk_fail();
         }

         return 1;
      }

      LAB_00160966:/* WARNING: Subroutine does not return */std::__throw_length_error("basic_string::append");
   }

   /* WARNING: Globals starting with '_' overlap smaller symbols at the same address */
   /* glslang::TSampler::getString[abi:cxx11]() const */
   void glslang::TSampler::getString_abi_cxx11_(void) {
      byte bVar1;
      undefined8 uVar2;
      ulong uVar3;
      uint uVar4;
      char *pcVar5;
      long lVar6;
      uint uVar7;
      ulong uVar8;
      ulong uVar9;
      ulong uVar10;
      undefined1 *in_RSI;
      undefined8 *in_RDI;
      long in_FS_OFFSET;
      undefined8 local_98;
      char *local_90;
      undefined8 local_88;
      char local_80[3];
      undefined1 auStack_7d[2];
      undefined8 uStack_7b;
      undefined8 local_68;
      uint *local_60;
      undefined8 local_58;
      uint local_50[4];
      long local_40;
      local_40 = *(long*)( in_FS_OFFSET + 0x28 );
      local_98 = glslang::GetThreadPoolAllocator();
      bVar1 = in_RSI[2];
      local_88 = 0;
      local_80[0] = '\0';
      local_90 = local_80;
      if (( bVar1 & 0x20 ) != 0) {
         *in_RDI = local_98;
         local_80[0] = 's';
         local_80[1] = 0x61;
         local_80[2] = 0x6d;
         uStack_7b._2_1_ = 0;
         _auStack_7d = 0x72656c70;
         in_RDI[1] = in_RDI + 3;
         in_RDI[2] = 7;
         in_RDI[3] = 0x72656c706d6173;
         goto LAB_00160a91;
      }

      switch (*in_RSI) {
         case 3:
    local_80[2] = 0x36;
    local_80[0] = 'f';
    local_80[1] = 0x31;
    _auStack_7d = (uint)stack0xffffffffffffff84 << 8;
    break;
         case 4:
    local_80[2] = 0;
    local_80[0] = 'i';
    local_80[1] = 0x38;
    goto LAB_00160bf2;
         case 5:
    local_80[2] = 0x36;
    local_80[0] = 'u';
    local_80[1] = 0x31;
    _auStack_7d = (uint)stack0xffffffffffffff84 << 8;
    break;
         case 6:
    local_80[2] = 0x36;
    local_80[0] = 'i';
    local_80[1] = 0x31;
    _auStack_7d = (uint)stack0xffffffffffffff84 << 8;
    break;
         case 7:
    local_80[2] = 0;
    local_80[0] = 'u';
    local_80[1] = 0x38;
LAB_00160bf2:
    local_80[1] = 0x38;
    local_80[2] = 0;
    local_88 = 2;
    lVar6 = 2;
    goto LAB_00160ae4;
         case 8:
    local_80[0] = 'i';
    local_80[1] = 0;
    goto LAB_00160c13;
         case 9:
    local_80[0] = 'u';
    local_80[1] = 0;
LAB_00160c13:
    local_80[1] = 0;
    local_88 = 1;
    lVar6 = 1;
    goto LAB_00160ae4;
         case 10:
    local_80[2] = 0x34;
    local_80[0] = 'i';
    local_80[1] = 0x36;
    _auStack_7d = (uint)stack0xffffffffffffff84 << 8;
    break;
         case 0xb:
    local_80[2] = 0x34;
    local_80[0] = 'u';
    local_80[1] = 0x36;
    _auStack_7d = (uint)stack0xffffffffffffff84 << 8;
    break;
         default:
    lVar6 = 0;
    goto LAB_00160ae4;
      }

      local_88 = 3;
      lVar6 = 3;
      LAB_00160ae4:if (( bVar1 & 8 ) == 0) {
         if (( bVar1 & 0x10 ) == 0) {
            builtin_strncpy(local_80 + lVar6, "text", 4);
            *(undefined4*)( auStack_7d + lVar6 ) = 0x65727574;
            local_88 = lVar6 + 7U;
            *(undefined1*)( (long)&uStack_7b + lVar6 + 2 ) = 0;
            goto LAB_00160b24;
         }

         builtin_strncpy(local_80 + lVar6, "samp", 4);
         *(undefined4*)( auStack_7d + lVar6 ) = 0x72656c70;
         local_88 = lVar6 + 7U;
         *(undefined1*)( (long)&uStack_7b + lVar6 + 2 ) = 0;
         bVar1 = in_RSI[3];
         pcVar5 = local_80;
         uVar8 = local_88;
      }
 else {
         if (in_RSI[1] == '\b') {
            if (lVar6 == 3) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_98, 3, 0, "attachmentEXT", 0xd);
            }
 else {
               builtin_strncpy(local_80 + lVar6, "attachme", 8);
               *(undefined8*)( (long)&uStack_7b + lVar6 ) = 0x545845746e656d68;
            }

            local_88 = lVar6 + 0xdU;
            local_90[lVar6 + 0xdU] = '\0';
         }
 else if (in_RSI[1] == '\a') {
            builtin_strncpy(local_80 + lVar6, "subp", 4);
            *(undefined4*)( auStack_7d + lVar6 ) = 0x73736170;
            local_88 = lVar6 + 7;
            *(undefined1*)( (long)&uStack_7b + lVar6 + 2 ) = 0;
         }
 else {
            builtin_strncpy(local_80 + lVar6, "imag", 4);
            auStack_7d[lVar6 + 1] = 0x65;
            local_88 = lVar6 + 5;
            /* WARNING (jumptable): Ignoring partial resolution of indirect */
            *(undefined1*)( (long)&uStack_7b + lVar6 ) = 0;
         }

         LAB_00160b24:bVar1 = in_RSI[3];
         pcVar5 = local_90;
         uVar8 = local_88;
      }

      local_90 = pcVar5;
      local_88 = uVar8;
      if (( bVar1 & 0x20 ) != 0) {
         if (0x7fffffffffffffff - uVar8 < 0xb) goto LAB_0016161e;
         uVar9 = uVar8 + 0xb;
         if (pcVar5 == local_80) {
            uVar10 = 0xf;
         }
 else {
            uVar10 = CONCAT17(uStack_7b._2_1_, CONCAT43(_auStack_7d, CONCAT12(local_80[2], CONCAT11(local_80[1], local_80[0]))));
         }

         if (uVar10 < uVar9) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_98, uVar8, 0, "ExternalOES", 0xb);
         }
 else {
            builtin_strncpy(pcVar5 + uVar8, "ExternalOES", 0xb);
         }

         local_88 = uVar9;
         local_90[uVar8 + 0xb] = '\0';
         *in_RDI = local_98;
         in_RDI[1] = in_RDI + 3;
         if (local_90 == local_80) {
            uVar10 = uVar8 + 0xc;
            uVar7 = (uint)uVar10;
            if (uVar7 < 8) {
               if (( uVar10 & 4 ) == 0) {
                  if (( uVar7 != 0 ) && ( *(char*)( in_RDI + 3 ) = local_80[0](uVar10 & 2) != 0 )) {
                     *(undefined2*)( (long)in_RDI + uVar8 + 0x22 ) = *(undefined2*)( (long)&uStack_7b + uVar8 + 5 );
                  }

               }
 else {
                  *(uint*)( in_RDI + 3 ) = CONCAT13(auStack_7d[0], CONCAT12(local_80[2], CONCAT11(local_80[1], local_80[0])));
                  *(undefined4*)( (long)in_RDI + uVar8 + 0x20 ) = *(undefined4*)( (long)&uStack_7b + uVar8 + 3 );
               }

            }
 else {
               in_RDI[3] = CONCAT17(uStack_7b._2_1_, CONCAT43(_auStack_7d, CONCAT12(local_80[2], CONCAT11(local_80[1], local_80[0]))));
               *(undefined8*)( (long)in_RDI + uVar8 + 0x1c ) = *(undefined8*)( auStack_7d + uVar8 + 1 );
               lVar6 = (long)( in_RDI + 3 ) - ( ( ulong )(in_RDI + 4) & 0xfffffffffffffff8 );
               uVar7 = uVar7 + (int)lVar6 & 0xfffffff8;
               if (7 < uVar7) {
                  uVar8 = 0;
                  do {
                     uVar4 = (int)uVar8 + 8;
                     *(undefined8*)( ( ( ulong )(in_RDI + 4) & 0xfffffffffffffff8 ) + uVar8 ) = *(undefined8*)( local_80 + ( uVar8 - lVar6 ) );
                     uVar8 = (ulong)uVar4;
                  }
 while ( uVar4 < uVar7 );
               }

            }

         }
 else {
            in_RDI[1] = local_90;
            in_RDI[3] = CONCAT17(uStack_7b._2_1_, CONCAT43(_auStack_7d, CONCAT12(local_80[2], CONCAT11(local_80[1], local_80[0]))));
         }

         in_RDI[2] = uVar9;
         goto LAB_00160a91;
      }

      if (( bVar1 & 0x40 ) != 0) {
         local_68 = glslang::GetThreadPoolAllocator();
         local_58 = 0;
         local_50[0] = local_50[0] & 0xffffff00;
         local_60 = local_50;
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::reserve((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_68, uVar8 + 2);
         uVar9 = local_58;
         if (1 < 0x7fffffffffffffff - local_58) {
            uVar10 = local_58 + 2;
            if (local_60 == local_50) {
               uVar3 = 0xf;
            }
 else {
               uVar3 = CONCAT44(local_50[1], local_50[0]);
            }

            if (uVar3 < uVar10) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_68, local_58, 0, "__", 2);
            }
 else {
               *(undefined2*)( (long)local_60 + local_58 ) = 0x5f5f;
            }

            *(undefined1*)( (long)local_60 + uVar9 + 2 ) = 0;
            local_58 = uVar10;
            if (uVar8 <= 0x7fffffffffffffff - uVar10) {
               uVar9 = uVar8 + uVar10;
               if (local_60 == local_50) {
                  uVar3 = 0xf;
               }
 else {
                  uVar3 = CONCAT44(local_50[1], local_50[0]);
               }

               if (uVar3 < uVar9) {
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_68, uVar10, 0, pcVar5, uVar8);
               }
 else if (uVar8 != 0) {
                  if (uVar8 == 1) {
                     *(char*)( (long)local_60 + uVar10 ) = *pcVar5;
                  }
 else {
                     memcpy((char*)( (long)local_60 + uVar10 ), pcVar5, uVar8);
                  }

               }

               *(undefined1*)( (long)local_60 + uVar9 ) = 0;
               uVar2 = _UNK_00168748;
               local_58 = uVar9;
               if (0xf < 0x7fffffffffffffff - uVar9) {
                  uVar8 = uVar9 + 0x10;
                  if (local_60 == local_50) {
                     uVar10 = 0xf;
                  }
 else {
                     uVar10 = CONCAT44(local_50[1], local_50[0]);
                  }

                  if (uVar10 < uVar8) {
                     std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_68, uVar9, 0, "External2DY2YEXT", 0x10);
                  }
 else {
                     *(undefined8*)( (long)local_60 + uVar9 ) = __LC837;
                     ( (undefined8*)( (long)local_60 + uVar9 ) )[1] = uVar2;
                  }

                  local_58 = uVar8;
                  *(undefined1*)( (long)local_60 + uVar9 + 0x10 ) = 0;
                  *in_RDI = local_68;
                  in_RDI[1] = in_RDI + 3;
                  if (local_60 == local_50) {
                     uVar9 = uVar9 + 0x11;
                     uVar7 = (uint)uVar9;
                     if (uVar7 < 8) {
                        if (( uVar9 & 4 ) == 0) {
                           if (uVar7 != 0) {
                              *(undefined1*)( in_RDI + 3 ) = (undefined1)local_50[0];
                              if (( uVar9 & 2 ) != 0) {
                                 *(undefined2*)( (long)in_RDI + ( uVar9 & 0xffffffff ) + 0x16 ) = *(undefined2*)( (long)&local_58 + ( uVar9 & 0xffffffff ) + 6 );
                              }

                           }

                        }
 else {
                           *(uint*)( in_RDI + 3 ) = local_50[0];
                           *(undefined4*)( (long)in_RDI + ( uVar9 & 0xffffffff ) + 0x14 ) = *(undefined4*)( (long)&local_58 + ( uVar9 & 0xffffffff ) + 4 );
                        }

                     }
 else {
                        in_RDI[3] = CONCAT44(local_50[1], local_50[0]);
                        *(undefined8*)( (long)in_RDI + ( uVar9 & 0xffffffff ) + 0x10 ) = *(undefined8*)( (long)&local_58 + ( uVar9 & 0xffffffff ) );
                        lVar6 = (long)( in_RDI + 3 ) - ( ( ulong )(in_RDI + 4) & 0xfffffffffffffff8 );
                        uVar7 = uVar7 + (int)lVar6 & 0xfffffff8;
                        if (7 < uVar7) {
                           uVar9 = 0;
                           do {
                              uVar4 = (int)uVar9 + 8;
                              *(undefined8*)( ( ( ulong )(in_RDI + 4) & 0xfffffffffffffff8 ) + uVar9 ) = *(undefined8*)( (long)local_50 + ( uVar9 - lVar6 ) );
                              uVar9 = (ulong)uVar4;
                           }
 while ( uVar4 < uVar7 );
                        }

                     }

                  }
 else {
                     in_RDI[1] = local_60;
                     in_RDI[3] = CONCAT44(local_50[1], local_50[0]);
                  }

                  in_RDI[2] = uVar8;
                  goto LAB_00160a91;
               }

            }

         }

         LAB_0016161e:/* WARNING: Subroutine does not return */std::__throw_length_error("basic_string::append");
      }

      switch (in_RSI[1]) {
         case 1:
    std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append
              ((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *)&local_98,
               "1D");
    break;
         case 2:
    std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append
              ((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *)&local_98,
               "2D");
    break;
         case 3:
    std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append
              ((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *)&local_98,
               "3D");
    break;
         case 4:
    std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append
              ((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *)&local_98,
               "Cube");
    break;
         case 5:
    std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append
              ((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *)&local_98,
               "2DRect");
    break;
         case 6:
    std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append
              ((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *)&local_98,
               "Buffer");
    break;
         case 7:
    std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append
              ((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *)&local_98,
               "Input");
    break;
         case 8:
    std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append
              ((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *)&local_98,
               "");
      }

      uVar8 = local_88;
      bVar1 = in_RSI[2];
      if (( bVar1 & 4 ) != 0) {
         if (0x7fffffffffffffff - local_88 < 2) goto LAB_0016161e;
         uVar9 = local_88 + 2;
         if (local_90 == local_80) {
            uVar10 = 0xf;
         }
 else {
            uVar10 = CONCAT17(uStack_7b._2_1_, CONCAT43(_auStack_7d, CONCAT12(local_80[2], CONCAT11(local_80[1], local_80[0]))));
         }

         if (uVar10 < uVar9) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_98, local_88, 0, "MS", 2);
         }
 else {
            ( local_90 + local_88 )[0] = 'M';
            ( local_90 + local_88 )[1] = 'S';
         }

         local_88 = uVar9;
         local_90[uVar8 + 2] = '\0';
         bVar1 = in_RSI[2];
      }

      uVar8 = local_88;
      if (( bVar1 & 1 ) != 0) {
         if (0x7fffffffffffffff - local_88 < 5) goto LAB_0016161e;
         uVar9 = local_88 + 5;
         if (local_90 == local_80) {
            uVar10 = 0xf;
         }
 else {
            uVar10 = CONCAT17(uStack_7b._2_1_, CONCAT43(_auStack_7d, CONCAT12(local_80[2], CONCAT11(local_80[1], local_80[0]))));
         }

         if (uVar10 < uVar9) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_98, local_88, 0, "Array", 5);
         }
 else {
            builtin_strncpy(local_90 + local_88, "Array", 5);
         }

         local_88 = uVar9;
         local_90[uVar8 + 5] = '\0';
         bVar1 = in_RSI[2];
      }

      if (( bVar1 & 2 ) == 0) {
         *in_RDI = local_98;
         in_RDI[1] = in_RDI + 3;
         if (local_90 == local_80) goto LAB_0016101b;
         LAB_00160dd0:in_RDI[1] = local_90;
         in_RDI[3] = CONCAT17(uStack_7b._2_1_, CONCAT43(_auStack_7d, CONCAT12(local_80[2], CONCAT11(local_80[1], local_80[0]))));
      }
 else {
         if (0x7fffffffffffffff - local_88 < 6) goto LAB_0016161e;
         uVar8 = local_88 + 6;
         if (local_90 == local_80) {
            uVar9 = 0xf;
         }
 else {
            uVar9 = CONCAT17(uStack_7b._2_1_, CONCAT43(_auStack_7d, CONCAT12(local_80[2], CONCAT11(local_80[1], local_80[0]))));
         }

         if (uVar9 < uVar8) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)&local_98, local_88, 0, "Shadow", 6);
         }
 else {
            builtin_strncpy(local_90 + local_88, "Shadow", 6);
         }

         local_88 = uVar8;
         local_90[uVar8] = '\0';
         *in_RDI = local_98;
         in_RDI[1] = in_RDI + 3;
         if (local_90 != local_80) goto LAB_00160dd0;
         LAB_0016101b:pcVar5 = (char*)( in_RDI + 3 );
         uVar8 = local_88 + 1;
         uVar7 = (uint)uVar8;
         if (uVar7 < 8) {
            if (( uVar8 & 4 ) == 0) {
               if (( uVar7 != 0 ) && ( *pcVar5 = local_80[0](uVar8 & 2) != 0 )) {
                  *(undefined2*)( (long)in_RDI + ( uVar8 & 0xffffffff ) + 0x16 ) = *(undefined2*)( local_80 + ( ( uVar8 & 0xffffffff ) - 2 ) );
               }

            }
 else {
               *(uint*)pcVar5 = CONCAT13(auStack_7d[0], CONCAT12(local_80[2], CONCAT11(local_80[1], local_80[0])));
               *(undefined4*)( (long)in_RDI + ( uVar8 & 0xffffffff ) + 0x14 ) = *(undefined4*)( local_80 + ( ( uVar8 & 0xffffffff ) - 4 ) );
            }

         }
 else {
            *(ulong*)pcVar5 = CONCAT17(uStack_7b._2_1_, CONCAT43(_auStack_7d, CONCAT12(local_80[2], CONCAT11(local_80[1], local_80[0]))));
            *(undefined8*)( (long)in_RDI + ( uVar8 & 0xffffffff ) + 0x10 ) = *(undefined8*)( local_80 + ( ( uVar8 & 0xffffffff ) - 8 ) );
            lVar6 = (long)pcVar5 - ( ( ulong )(in_RDI + 4) & 0xfffffffffffffff8 );
            uVar7 = uVar7 + (int)lVar6 & 0xfffffff8;
            if (7 < uVar7) {
               uVar4 = 0;
               do {
                  uVar8 = (ulong)uVar4;
                  uVar4 = uVar4 + 8;
                  *(undefined8*)( ( ( ulong )(in_RDI + 4) & 0xfffffffffffffff8 ) + uVar8 ) = *(undefined8*)( local_80 + ( uVar8 - lVar6 ) );
               }
 while ( uVar4 < uVar7 );
            }

         }

      }

      in_RDI[2] = local_88;
      LAB_00160a91:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      return;
   }

   /* glslang::TType::getBasicTypeString[abi:cxx11]() const */
   void glslang::TType::getBasicTypeString_abi_cxx11_(void) {
      long lVar1;
      undefined8 uVar2;
      long in_RSI;
      undefined8 *in_RDI;
      long in_FS_OFFSET;
      lVar1 = *(long*)( in_FS_OFFSET + 0x28 );
      if (*(char*)( in_RSI + 8 ) == '\x0e') {
         TSampler::getString_abi_cxx11_();
      }
 else {
         uVar2 = glslang::GetThreadPoolAllocator();
         switch (*(undefined1*)( in_RSI + 8 )) {
            case 0:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 1:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 2:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 3:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 4:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 5:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 6:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 7:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 8:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 9:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 10:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 0xb:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 0xc:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 0xd:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 0xe:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 0xf:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 0x10:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 0x11:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 0x12:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 0x13:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            default:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 0x15:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 0x16:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
      break;
            case 0x17:
      *in_RDI = uVar2;
      in_RDI[1] = in_RDI + 3;
         }

         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>();
      }

      if (lVar1 == *(long*)( in_FS_OFFSET + 0x28 )) {
         return;
      }

      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   /* WARNING: Globals starting with '_' overlap smaller symbols at the same address */
   /* glslang::TType::getCompleteString(bool, bool, bool, bool, std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> >, std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> >) const */
   basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *glslang::TType::getCompleteString(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *param_1, long *param_2, char param_3, char param_4, char param_5, char param_6, long param_7, long param_8) {
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *pbVar1;
      code *pcVar2;
      long *plVar3;
      undefined1 *__src;
      undefined8 uVar4;
      char cVar5;
      byte bVar6;
      ushort uVar7;
      uint uVar8;
      undefined8 uVar9;
      size_t __n;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *pbVar10;
      ulong uVar11;
      ulong uVar12;
      long lVar13;
      ulong uVar14;
      char *pcVar15;
      uint uVar16;
      ulong uVar17;
      int iVar18;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *pbVar19;
      ulong uVar20;
      long lVar21;
      long lVar22;
      long in_FS_OFFSET;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *local_218;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *local_210;
      long local_208;
      long lStack_200;
      long local_1f8;
      undefined8 uStack_1f0;
      undefined8 local_1e8;
      long lStack_1e0;
      long local_1d8;
      long lStack_1d0;
      long local_1c8;
      long lStack_1c0;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *local_1b0;
      ulong local_188;
      ulong *local_180;
      ulong local_178;
      ulong local_170[3];
      undefined8 local_158;
      undefined1 *local_150;
      undefined1 local_140[24];
      undefined1 local_128[8];
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *local_120;
      ulong local_118;
      undefined8 local_f8;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *local_f0;
      ulong local_e8;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> local_e0[24];
      undefined8 local_c8;
      undefined1 *local_c0;
      undefined1 local_b0[24];
      undefined8 local_98;
      undefined1 *local_90;
      undefined1 local_80[24];
      undefined1 local_68[8];
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *local_60;
      ulong local_58;
      long local_40;
      pbVar1 = param_1 + 0x18;
      local_40 = *(long*)( in_FS_OFFSET + 0x28 );
      uVar9 = glslang::GetThreadPoolAllocator();
      *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) = pbVar1;
      *(undefined8*)param_1 = uVar9;
      *(undefined8*)( param_1 + 0x10 ) = 0;
      param_1[0x18] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x0;
      local_218 = param_1;
      local_210 = param_1;
      if (param_4 != '\0') {
         if (param_2[10] != 0) {
            glslang::TQualifier::getSpirvDecorateQualifierString_abi_cxx11_();
            __n = strlen((char*)local_1b0);
            uVar20 = *(ulong*)( param_1 + 0x10 );
            if (0x7fffffffffffffff - uVar20 < __n) goto LAB_00165277;
            pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
            uVar14 = __n + uVar20;
            if (pbVar1 == pbVar10) {
               uVar11 = 0xf;
            }
 else {
               uVar11 = *(ulong*)( param_1 + 0x18 );
            }

            if (uVar11 < uVar14) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, (char*)local_1b0, __n);
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
            }
 else if (__n != 0) {
               if (__n == 1) {
                  pbVar10[uVar20] = *local_1b0;
                  pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
               }
 else {
                  memcpy(pbVar10 + uVar20, local_1b0, __n);
                  pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
               }

            }

            *(ulong*)( param_1 + 0x10 ) = uVar14;
            pbVar10[uVar14] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x0;
         }

         if (( ( *(byte*)( (long)param_2 + 0x1f ) & 0x70 ) == 0 ) && ( ( *(byte*)( param_2 + 4 ) & 0xf ) == 0 )) {
            if (( ( ( *(int*)( (long)param_2 + 0x24 ) != -1 ) || ( ( ( ( ( (short)param_2[6] != -1 || ( ( *(uint*)( (long)param_2 + 0x2c ) & 0x3f8000 ) != 0x1f8000 ) ) || ( (int)param_2[5] != -1 ) ) || ( ( ( ~*(ushort *)((long)param_2 + 0x2c) & 0xfff ) != 0 || ( ( *(byte*)( (long)param_2 + 0x2d ) & 0x70 ) != 0x40 ) ) ) ) || ( *(char*)( (long)param_2 + 0x32 ) != -1 ) ) ) ) || ( ( ( *(char*)( (long)param_2 + 0x33 ) != -1 || ( *(char*)( (long)param_2 + 0x3c ) != '\0' ) ) || ( (char)param_2[9] != '\0' ) ) ) ) || ( ( ( ( *(char*)( (long)param_2 + 0x3d ) != '\0' || ( *(char*)( (long)param_2 + 0x3e ) != '\0' ) ) || ( ( ~*(byte *)((long)param_2 + 0x34) & 0xf ) != 0 ) ) || ( ( ( ~*(uint *)((long)param_2 + 0x34) & 0x3fff0 ) != 0 || ( ( ~*(ushort *)((long)param_2 + 0x36) & 0x7ffc ) != 0 ) ) ) ) )) {
               local_208 = param_2[2];
               lStack_200 = param_2[3];
               local_1f8 = param_2[4];
               lVar13 = param_2[5];
               uVar20 = param_2[6];
               lStack_1e0 = param_2[7];
               local_1d8 = param_2[8];
               lStack_1d0 = param_2[9];
               local_1c8 = param_2[10];
               lStack_1c0 = param_2[0xb];
               uStack_1f0 = lVar13;
               local_1e8 = uVar20;
               if (( ( ( ( *(char*)( (long)param_2 + 0x3c ) == '\0' ) && ( ( (short)param_2[6] == -1 && ( uStack_1f0._4_4_ = ( uint )((ulong)lVar13 >> 0x20) ),uVar16 = uStack_1f0._4_4_ & 0x3f8000,uVar16 == 0x1f8000 ) ) ) ) && ( ( *(uint*)( param_2 + 5 ) & *(uint*)( (long)param_2 + 0x24 ) ) == 0xffffffff ) ) && ( ( ( uStack_1f0._4_2_ = ( ushort )((ulong)lVar13 >> 0x20) ),uVar7 = ~uStack_1f0._4_2_,( uVar7 & 0xfff ) == 0 && ( uStack_1f0._5_1_ = ( byte )((ulong)lVar13 >> 0x28) ),bVar6 = uStack_1f0._5_1_ & 0x70,bVar6 == 0x40 ) ) && ( ( *(byte*)( (long)param_2 + 0x33 ) & *(byte*)( (long)param_2 + 0x32 ) ) == 0xff )) {
                  local_1e8 = uVar20 | 0xf00000000;
                  uVar14 = local_1e8;
                  uVar16 = ~local_1e8._4_4_;
                  local_1e8 = uVar14;
                  if (( ( uVar16 & 0x3fff0 ) == 0 ) && ( local_1e8._6_2_ = ( ushort )(uVar20 >> 0x30) ),uVar7 = ~local_1e8._6_2_,( uVar7 & 0x7ffc ) == 0) goto LAB_00162365;
               }

               goto LAB_00162030;
            }

         }
 else {
            LAB_00162030:std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, "layout(");
            if (( ( ~*(ushort *)((long)param_2 + 0x2c) & 0xfff ) != 0 ) || ( ( ( *(byte*)( (long)param_2 + 0x2d ) & 0x70 ) != 0x40 || ( *(char*)( (long)param_2 + 0x32 ) != -1 ) ) )) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " location=");
               ::{lambda (unsigned_int);
               #2
               ( (_lambda_unsigned_int__2_*)&local_218,*(ushort*)( (long)param_2 + 0x2c ) & 0xfff );
               if (( *(byte*)( (long)param_2 + 0x2d ) & 0x70 ) != 0x40) {
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " component=");
                  ::{lambda (unsigned_int);
                  #2
                  ( (_lambda_unsigned_int__2_*)&local_218,*(byte*)( (long)param_2 + 0x2d ) >> 4 & 7 );
               }

               if (*(char*)( (long)param_2 + 0x32 ) != -1) {
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " index=");
                  ::{lambda (unsigned_int);
                  #2
                  ( (_lambda_unsigned_int__2_*)&local_218,( uint ) * (byte*)( (long)param_2 + 0x32 ) );
               }

            }

            if (( *(uint*)( (long)param_2 + 0x2c ) & 0x3f8000 ) != 0x1f8000) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " set=");
               ::{lambda (unsigned_int);
               #2
               ( (_lambda_unsigned_int__2_*)&local_218,*(uint*)( (long)param_2 + 0x2c ) >> 0xf & 0x7f );
            }

            if ((short)param_2[6] != -1) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " binding=");
               ::{lambda (unsigned_int);
               #2
               ( (_lambda_unsigned_int__2_*)&local_218,( uint ) * (ushort*)( param_2 + 6 ) );
            }

            if (*(char*)( (long)param_2 + 0x33 ) != -1) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " stream=");
               ::{lambda (unsigned_int);
               #2
               ( (_lambda_unsigned_int__2_*)&local_218,( uint ) * (byte*)( (long)param_2 + 0x33 ) );
            }

            if (( *(byte*)( (long)param_2 + 0x1f ) & 0x70 ) != 0) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " ");
               pcVar15 = "row_major";
               bVar6 = *(byte*)( (long)param_2 + 0x1f ) >> 4 & 7;
               if (( bVar6 != 1 ) && ( pcVar15 = bVar6 != 2 )) {
                  pcVar15 = "none";
               }

               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, pcVar15);
            }

            if (( *(byte*)( param_2 + 4 ) & 0xf ) != 0) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " ");
               switch (*(byte*)( param_2 + 4 ) & 0xf) {
                  case 1:
          pcVar15 = "shared";
          break;
                  case 2:
          pcVar15 = "std140";
          break;
                  case 3:
          pcVar15 = "std430";
          break;
                  case 4:
          pcVar15 = "packed";
          break;
                  case 5:
          pcVar15 = "scalar";
          break;
                  default:
          pcVar15 = "none";
               }

               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, pcVar15);
            }

            if (*(int*)( (long)param_2 + 0x24 ) != -1) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " offset=");
               ::{lambda (int);
               #3
               ( (_lambda_int__3_*)&local_210,*(int*)( (long)param_2 + 0x24 ) );
            }

            if ((int)param_2[5] != -1) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " align=");
               ::{lambda (int);
               #3
            }

            if (*(char*)( (long)param_2 + 0x3c ) != '\0') {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " ");
               pcVar15 = (char*)TQualifier::getLayoutFormatString(*(undefined1*)( (long)param_2 + 0x3c ));
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, pcVar15);
            }

            uVar7 = *(ushort*)( (long)param_2 + 0x36 );
            if (( ~*(byte *)((long)param_2 + 0x34) & 0xf ) == 0) {
               LAB_001621d0:if (( ~uVar7 & 0x7ffc ) != 0) {
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " xfb_offset=");
                  ::{lambda (unsigned_int);
                  #2
                  ( (_lambda_unsigned_int__2_*)&local_218,*(ushort*)( (long)param_2 + 0x36 ) >> 2 & 0x1fff );
               }

            }
 else if (( ~uVar7 & 0x7ffc ) != 0) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " xfb_buffer=");
               ::{lambda (unsigned_int);
               #2
               ( (_lambda_unsigned_int__2_*)&local_218,*(byte*)( (long)param_2 + 0x34 ) & 0xf );
               uVar7 = *(ushort*)( (long)param_2 + 0x36 );
               goto LAB_001621d0;
            }

            if (( ~*(uint *)((long)param_2 + 0x34) & 0x3fff0 ) != 0) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " xfb_stride=");
               ::{lambda (unsigned_int);
               #2
               ( (_lambda_unsigned_int__2_*)&local_218,*(uint*)( (long)param_2 + 0x34 ) >> 4 & 0x3fff );
            }

            if ((char)param_2[7] != -1) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " input_attachment_index=");
               ::{lambda (unsigned_int);
               #2
               ( (_lambda_unsigned_int__2_*)&local_218,( uint ) * (byte*)( param_2 + 7 ) );
            }

            if (( ~*(uint *)(param_2 + 7) & 0x7ff00 ) != 0) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " constant_id=");
               ::{lambda (unsigned_int);
               #2
               ( (_lambda_unsigned_int__2_*)&local_218,*(uint*)( param_2 + 7 ) >> 8 & 0x7ff );
            }

            if (*(char*)( (long)param_2 + 0x3d ) != '\0') {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " push_constant");
            }

            if (*(char*)( (long)param_2 + 0x3e ) != '\0') {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " buffer_reference");
            }

            if (( ~*(ushort *)((long)param_2 + 0x3a) & 0x1f8 ) != 0) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " buffer_reference_align=");
               ::{lambda (unsigned_int);
               #2
               ( (_lambda_unsigned_int__2_*)&local_218,1 << ( ( byte )(*(ushort*)( (long)param_2 + 0x3a ) >> 3) & 0x1f ) );
            }

            if (*(char*)( (long)param_2 + 0x3f ) != '\0') {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " passthrough");
            }

            if ((char)param_2[8] != '\0') {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " layoutViewportRelative");
            }

            if (*(int*)( (long)param_2 + 0x44 ) != -0x800) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " layoutSecondaryViewportRelativeOffset=");
               ::{lambda (int);
               #3
               ( (_lambda_int__3_*)&local_210,*(int*)( (long)param_2 + 0x44 ) );
            }

            if ((char)param_2[9] != '\0') {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " shaderRecordNV");
            }

            if (*(char*)( (long)param_2 + 0x49 ) != '\0') {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " full_quads");
            }

            if (*(char*)( (long)param_2 + 0x4a ) != '\0') {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " quad_derivatives");
            }

            if (*(char*)( (long)param_2 + 0x4b ) != '\0') {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " hitobjectshaderrecordnv");
            }

            if ((char)param_2[0xb] != '\0') {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " layoutBindlessSampler");
            }

            if (*(char*)( (long)param_2 + 0x59 ) != '\0') {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " layoutBindlessImage");
            }

            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, ")");
         }

         LAB_00162365:if (( *(byte*)( (long)param_2 + 0x1b ) & 0x10 ) != 0) {
            uVar20 = *(ulong*)( param_1 + 0x10 );
            if (0x7fffffffffffffff - uVar20 < 10) goto LAB_00165277;
            if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
               uVar14 = 0xf;
            }
 else {
               uVar14 = *(ulong*)( param_1 + 0x18 );
            }

            if (uVar14 < uVar20 + 10) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " invariant", 10);
            }
 else {
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20;
               *(undefined8*)pbVar10 = 0x61697261766e6920;
               *(undefined2*)( pbVar10 + 8 ) = 0x746e;
            }

            *(ulong*)( param_1 + 0x10 ) = uVar20 + 10;
            *(undefined1*)( *(long*)( param_1 + 8 ) + 10 + uVar20 ) = 0;
         }

         if (( *(byte*)( (long)param_2 + 0x1c ) & 0x10 ) == 0) {
            bVar6 = *(byte*)( (long)param_2 + 0x1b );
            if (( bVar6 & 0x20 ) == 0) goto LAB_00162388;
            LAB_0016444c:uVar20 = *(ulong*)( param_1 + 0x10 );
            if (0x7fffffffffffffff - uVar20 < 9) goto LAB_00165277;
            if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
               uVar14 = 0xf;
            }
 else {
               uVar14 = *(ulong*)( param_1 + 0x18 );
            }

            if (uVar14 < uVar20 + 9) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " centroid", 9);
            }
 else {
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20;
               *(undefined8*)pbVar10 = 0x696f72746e656320;
               pbVar10[8] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x64;
            }

            *(ulong*)( param_1 + 0x10 ) = uVar20 + 9;
            *(undefined1*)( *(long*)( param_1 + 8 ) + 9 + uVar20 ) = 0;
            bVar6 = *(byte*)( (long)param_2 + 0x1b );
            if (( bVar6 & 0x40 ) != 0) goto LAB_001644b4;
            LAB_00162390:if (-1 < (char)bVar6) goto LAB_00162398;
            LAB_001644d0:uVar20 = *(ulong*)( param_1 + 0x10 );
            if (0x7fffffffffffffff - uVar20 < 5) goto LAB_00165277;
            if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
               uVar14 = 0xf;
            }
 else {
               uVar14 = *(ulong*)( param_1 + 0x18 );
            }

            if (uVar14 < uVar20 + 5) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " flat", 5);
            }
 else {
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20;
               *(undefined4*)pbVar10 = 0x616c6620;
               pbVar10[4] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x74;
            }

            *(ulong*)( param_1 + 0x10 ) = uVar20 + 5;
            *(undefined1*)( *(long*)( param_1 + 8 ) + 5 + uVar20 ) = 0;
            bVar6 = *(byte*)( (long)param_2 + 0x1c );
         }
 else {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " noContraction");
            bVar6 = *(byte*)( (long)param_2 + 0x1b );
            if (( bVar6 & 0x20 ) != 0) goto LAB_0016444c;
            LAB_00162388:if (( bVar6 & 0x40 ) == 0) goto LAB_00162390;
            LAB_001644b4:std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " smooth");
            if (*(char*)( (long)param_2 + 0x1b ) < '\0') goto LAB_001644d0;
            LAB_00162398:bVar6 = *(byte*)( (long)param_2 + 0x1c );
         }

         if (( bVar6 & 0x20 ) != 0) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " noperspective");
            bVar6 = *(byte*)( (long)param_2 + 0x1c );
         }

         if (( bVar6 & 0x40 ) != 0) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " __explicitInterpAMD");
            bVar6 = *(byte*)( (long)param_2 + 0x1c );
         }

         if ((char)bVar6 < '\0') {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " pervertexNV");
         }

         bVar6 = *(byte*)( (long)param_2 + 0x1d );
         if (( bVar6 & 1 ) != 0) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " pervertexEXT");
            bVar6 = *(byte*)( (long)param_2 + 0x1d );
         }

         if (( bVar6 & 2 ) != 0) {
            uVar20 = *(ulong*)( param_1 + 0x10 );
            if (0x7fffffffffffffff - uVar20 < 0xf) goto LAB_00165277;
            if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
               uVar14 = 0xf;
            }
 else {
               uVar14 = *(ulong*)( param_1 + 0x18 );
            }

            if (uVar14 < uVar20 + 0xf) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " perprimitiveNV", 0xf);
            }
 else {
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20;
               *(undefined8*)pbVar10 = 0x6d69727072657020;
               *(undefined8*)( pbVar10 + 7 ) = 0x564e65766974696d;
            }

            *(ulong*)( param_1 + 0x10 ) = uVar20 + 0xf;
            *(undefined1*)( *(long*)( param_1 + 8 ) + 0xf + uVar20 ) = 0;
            bVar6 = *(byte*)( (long)param_2 + 0x1d );
         }

         if (( bVar6 & 4 ) == 0) {
            if (( bVar6 & 8 ) == 0) goto LAB_001623da;
            LAB_00163ed5:uVar20 = *(ulong*)( param_1 + 0x10 );
            if (0x7fffffffffffffff - uVar20 < 7) goto LAB_00165277;
            if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
               uVar14 = 0xf;
            }
 else {
               uVar14 = *(ulong*)( param_1 + 0x18 );
            }

            if (uVar14 < uVar20 + 7) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " taskNV", 7);
            }
 else {
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20;
               *(undefined4*)pbVar10 = 0x73617420;
               *(undefined4*)( pbVar10 + 3 ) = 0x564e6b73;
            }

            *(ulong*)( param_1 + 0x10 ) = uVar20 + 7;
            *(undefined1*)( *(long*)( param_1 + 8 ) + 7 + uVar20 ) = 0;
            bVar6 = *(byte*)( (long)param_2 + 0x1d );
            if (( bVar6 & 0x10 ) != 0) goto LAB_00163f39;
            LAB_001623e2:if (( bVar6 & 0x20 ) == 0) goto LAB_001623ea;
            LAB_00163f55:uVar20 = *(ulong*)( param_1 + 0x10 );
            if (0x7fffffffffffffff - uVar20 < 7) goto LAB_00165277;
            if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
               uVar14 = 0xf;
            }
 else {
               uVar14 = *(ulong*)( param_1 + 0x18 );
            }

            if (uVar14 < uVar20 + 7) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " sample", 7);
            }
 else {
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20;
               *(undefined4*)pbVar10 = 0x6d617320;
               *(undefined4*)( pbVar10 + 3 ) = 0x656c706d;
            }

            *(ulong*)( param_1 + 0x10 ) = uVar20 + 7;
            *(undefined1*)( *(long*)( param_1 + 8 ) + 7 + uVar20 ) = 0;
            bVar6 = *(byte*)( (long)param_2 + 0x1e );
            if (( bVar6 & 2 ) != 0) goto LAB_00163fb9;
            LAB_001623f7:if (( bVar6 & 8 ) == 0) goto LAB_001623ff;
            LAB_00164021:std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " devicecoherent");
            bVar6 = *(byte*)( (long)param_2 + 0x1e );
            if (( bVar6 & 0x10 ) != 0) goto LAB_0016403d;
            LAB_00162407:if (( bVar6 & 0x20 ) == 0) goto LAB_0016240f;
            LAB_00164059:std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " workgroupcoherent");
            bVar6 = *(byte*)( (long)param_2 + 0x1e );
            if (( bVar6 & 0x40 ) != 0) goto LAB_00164075;
            LAB_00162417:if (-1 < (char)bVar6) goto LAB_0016241f;
            LAB_00164091:std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " shadercallcoherent");
            if (( *(byte*)( (long)param_2 + 0x1f ) & 1 ) != 0) goto LAB_001640ab;
            LAB_0016242a:if (( *(byte*)( (long)param_2 + 0x1e ) & 4 ) == 0) goto LAB_00162435;
            LAB_00164114:std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " volatile");
            bVar6 = *(byte*)( (long)param_2 + 0x1d );
            if (( bVar6 & 0x40 ) != 0) goto LAB_00164130;
            LAB_00162442:if (-1 < (char)bVar6) goto LAB_0016244a;
            LAB_00164198:std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " readonly");
            if (( *(byte*)( (long)param_2 + 0x1e ) & 1 ) != 0) goto LAB_001641b2;
            LAB_00162455:bVar6 = *(byte*)( (long)param_2 + 0x1c );
            if (( bVar6 & 1 ) == 0) goto LAB_00162462;
            LAB_0016421f:uVar4 = _UNK_00168758;
            uVar9 = __LC993;
            uVar20 = *(ulong*)( param_1 + 0x10 );
            if (0x7fffffffffffffff - uVar20 < 0x18) goto LAB_00165277;
            if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
               uVar14 = 0xf;
            }
 else {
               uVar14 = *(ulong*)( param_1 + 0x18 );
            }

            if (uVar14 < uVar20 + 0x18) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " specialization-constant", 0x18);
            }
 else {
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20;
               *(undefined8*)( pbVar10 + 0x10 ) = 0x746e6174736e6f63;
               *(undefined8*)pbVar10 = uVar9;
               *(undefined8*)( pbVar10 + 8 ) = uVar4;
            }

            *(ulong*)( param_1 + 0x10 ) = uVar20 + 0x18;
            *(undefined1*)( *(long*)( param_1 + 8 ) + 0x18 + uVar20 ) = 0;
            if (( *(byte*)( (long)param_2 + 0x1c ) & 2 ) != 0) goto LAB_0016428f;
            LAB_0016246a:bVar6 = *(byte*)( (long)param_2 + 0x1f );
            if (( bVar6 & 2 ) == 0) goto LAB_00162477;
            LAB_001642fa:std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " null-init");
            bVar6 = *(byte*)( (long)param_2 + 0x1f );
            if (( bVar6 & 4 ) != 0) goto LAB_00164316;
            LAB_0016247f:uVar20 = *(ulong*)( param_1 + 0x10 );
         }
 else {
            uVar20 = *(ulong*)( param_1 + 0x10 );
            if (0x7fffffffffffffff - uVar20 < 10) goto LAB_00165277;
            if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
               uVar14 = 0xf;
            }
 else {
               uVar14 = *(ulong*)( param_1 + 0x18 );
            }

            if (uVar14 < uVar20 + 10) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " perviewNV", 10);
            }
 else {
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20;
               *(undefined8*)pbVar10 = 0x7765697672657020;
               *(undefined2*)( pbVar10 + 8 ) = 0x564e;
            }

            *(ulong*)( param_1 + 0x10 ) = uVar20 + 10;
            *(undefined1*)( *(long*)( param_1 + 8 ) + 10 + uVar20 ) = 0;
            bVar6 = *(byte*)( (long)param_2 + 0x1d );
            if (( bVar6 & 8 ) != 0) goto LAB_00163ed5;
            LAB_001623da:if (( bVar6 & 0x10 ) == 0) goto LAB_001623e2;
            LAB_00163f39:std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " patch");
            if (( *(byte*)( (long)param_2 + 0x1d ) & 0x20 ) != 0) goto LAB_00163f55;
            LAB_001623ea:bVar6 = *(byte*)( (long)param_2 + 0x1e );
            if (( bVar6 & 2 ) == 0) goto LAB_001623f7;
            LAB_00163fb9:uVar20 = *(ulong*)( param_1 + 0x10 );
            if (0x7fffffffffffffff - uVar20 < 9) goto LAB_00165277;
            if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
               uVar14 = 0xf;
            }
 else {
               uVar14 = *(ulong*)( param_1 + 0x18 );
            }

            if (uVar14 < uVar20 + 9) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " coherent", 9);
            }
 else {
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20;
               *(undefined8*)pbVar10 = 0x6e657265686f6320;
               pbVar10[8] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x74;
            }

            *(ulong*)( param_1 + 0x10 ) = uVar20 + 9;
            *(undefined1*)( *(long*)( param_1 + 8 ) + 9 + uVar20 ) = 0;
            bVar6 = *(byte*)( (long)param_2 + 0x1e );
            if (( bVar6 & 8 ) != 0) goto LAB_00164021;
            LAB_001623ff:if (( bVar6 & 0x10 ) == 0) goto LAB_00162407;
            LAB_0016403d:std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " queuefamilycoherent");
            bVar6 = *(byte*)( (long)param_2 + 0x1e );
            if (( bVar6 & 0x20 ) != 0) goto LAB_00164059;
            LAB_0016240f:if (( bVar6 & 0x40 ) == 0) goto LAB_00162417;
            LAB_00164075:std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " subgroupcoherent");
            if (*(char*)( (long)param_2 + 0x1e ) < '\0') goto LAB_00164091;
            LAB_0016241f:if (( *(byte*)( (long)param_2 + 0x1f ) & 1 ) == 0) goto LAB_0016242a;
            LAB_001640ab:uVar20 = *(ulong*)( param_1 + 0x10 );
            if (0x7fffffffffffffff - uVar20 < 0xb) goto LAB_00165277;
            if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
               uVar14 = 0xf;
            }
 else {
               uVar14 = *(ulong*)( param_1 + 0x18 );
            }

            if (uVar14 < uVar20 + 0xb) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " nonprivate", 0xb);
            }
 else {
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20;
               *(undefined8*)pbVar10 = 0x766972706e6f6e20;
               *(undefined4*)( pbVar10 + 7 ) = 0x65746176;
            }

            *(ulong*)( param_1 + 0x10 ) = uVar20 + 0xb;
            *(undefined1*)( *(long*)( param_1 + 8 ) + 0xb + uVar20 ) = 0;
            if (( *(byte*)( (long)param_2 + 0x1e ) & 4 ) != 0) goto LAB_00164114;
            LAB_00162435:bVar6 = *(byte*)( (long)param_2 + 0x1d );
            if (( bVar6 & 0x40 ) == 0) goto LAB_00162442;
            LAB_00164130:uVar20 = *(ulong*)( param_1 + 0x10 );
            if (0x7fffffffffffffff - uVar20 < 9) goto LAB_00165277;
            if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
               uVar14 = 0xf;
            }
 else {
               uVar14 = *(ulong*)( param_1 + 0x18 );
            }

            if (uVar14 < uVar20 + 9) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " restrict", 9);
            }
 else {
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20;
               *(undefined8*)pbVar10 = 0x6369727473657220;
               pbVar10[8] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x74;
            }

            *(ulong*)( param_1 + 0x10 ) = uVar20 + 9;
            *(undefined1*)( *(long*)( param_1 + 8 ) + 9 + uVar20 ) = 0;
            if (*(char*)( (long)param_2 + 0x1d ) < '\0') goto LAB_00164198;
            LAB_0016244a:if (( *(byte*)( (long)param_2 + 0x1e ) & 1 ) == 0) goto LAB_00162455;
            LAB_001641b2:uVar20 = *(ulong*)( param_1 + 0x10 );
            if (0x7fffffffffffffff - uVar20 < 10) goto LAB_00165277;
            if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
               uVar14 = 0xf;
            }
 else {
               uVar14 = *(ulong*)( param_1 + 0x18 );
            }

            if (uVar14 < uVar20 + 10) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " writeonly", 10);
            }
 else {
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20;
               *(undefined8*)pbVar10 = 0x6e6f657469727720;
               *(undefined2*)( pbVar10 + 8 ) = 0x796c;
            }

            *(ulong*)( param_1 + 0x10 ) = uVar20 + 10;
            *(undefined1*)( *(long*)( param_1 + 8 ) + 10 + uVar20 ) = 0;
            bVar6 = *(byte*)( (long)param_2 + 0x1c );
            if (( bVar6 & 1 ) != 0) goto LAB_0016421f;
            LAB_00162462:if (( bVar6 & 2 ) == 0) goto LAB_0016246a;
            LAB_0016428f:uVar20 = *(ulong*)( param_1 + 0x10 );
            if (0x7fffffffffffffff - uVar20 < 0xb) goto LAB_00165277;
            if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
               uVar14 = 0xf;
            }
 else {
               uVar14 = *(ulong*)( param_1 + 0x18 );
            }

            if (uVar14 < uVar20 + 0xb) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " nonuniform", 0xb);
            }
 else {
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20;
               *(undefined8*)pbVar10 = 0x66696e756e6f6e20;
               *(undefined4*)( pbVar10 + 7 ) = 0x6d726f66;
            }

            *(ulong*)( param_1 + 0x10 ) = uVar20 + 0xb;
            *(undefined1*)( *(long*)( param_1 + 8 ) + 0xb + uVar20 ) = 0;
            bVar6 = *(byte*)( (long)param_2 + 0x1f );
            if (( bVar6 & 2 ) != 0) goto LAB_001642fa;
            LAB_00162477:if (( bVar6 & 4 ) == 0) goto LAB_0016247f;
            LAB_00164316:std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " spirv_by_reference");
            bVar6 = *(byte*)( (long)param_2 + 0x1f );
            uVar20 = *(ulong*)( param_1 + 0x10 );
         }

         if (( bVar6 & 8 ) != 0) {
            if (0x7fffffffffffffff - uVar20 < 0xe) goto LAB_00165277;
            if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
               uVar14 = 0xf;
            }
 else {
               uVar14 = *(ulong*)( param_1 + 0x18 );
            }

            if (uVar14 < uVar20 + 0xe) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " spirv_literal", 0xe);
            }
 else {
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20;
               *(undefined8*)pbVar10 = 0x6c5f767269707320;
               *(undefined8*)( pbVar10 + 6 ) = 0x6c61726574696c5f;
            }

            *(ulong*)( param_1 + 0x10 ) = uVar20 + 0xe;
            *(undefined1*)( *(long*)( param_1 + 8 ) + 0xe + uVar20 ) = 0;
            uVar20 = *(ulong*)( param_1 + 0x10 );
         }

         if (uVar20 == 0x7fffffffffffffff) goto LAB_00165277;
         if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
            uVar14 = 0xf;
         }
 else {
            uVar14 = *(ulong*)( param_1 + 0x18 );
         }

         if (uVar14 < uVar20 + 1) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " ", 1);
         }
 else {
            ( *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) )[uVar20] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x20;
         }

         *(ulong*)( param_1 + 0x10 ) = uVar20 + 1;
         *(undefined1*)( *(long*)( param_1 + 8 ) + 1 + uVar20 ) = 0;
         switch (*(byte*)( param_2 + 3 ) & 0x7f) {
            case 0:
      uVar20 = 4;
      pcVar15 = &_LC65;
      break;
            case 1:
      uVar20 = 6;
      pcVar15 = "global";
      break;
            case 2:
      uVar20 = 5;
      pcVar15 = "const";
      break;
            case 3:
            case 0x10:
      uVar20 = 2;
      pcVar15 = &_LC70;
      break;
            case 4:
            case 0x11:
      uVar20 = 3;
      pcVar15 = &_LC71;
      break;
            case 5:
      uVar20 = 7;
      pcVar15 = "uniform";
      break;
            case 6:
      uVar20 = 6;
      pcVar15 = "buffer";
      break;
            case 7:
      uVar20 = 6;
      pcVar15 = "shared";
      break;
            case 8:
      uVar20 = 0x13;
      pcVar15 = "spirv_storage_class";
      break;
            case 9:
      uVar20 = 0xc;
      pcVar15 = "rayPayloadNV";
      break;
            case 10:
      uVar20 = 0xe;
      pcVar15 = "rayPayloadInNV";
      break;
            case 0xb:
      uVar20 = 0xe;
      pcVar15 = "hitAttributeNV";
      break;
            case 0xc:
      uVar20 = 0xe;
      pcVar15 = "callableDataNV";
      break;
            case 0xd:
      uVar20 = 0x10;
      pcVar15 = "callableDataInNV";
      break;
            case 0xe:
      uVar20 = 0x14;
      pcVar15 = "hitObjectAttributeNV";
      break;
            case 0xf:
      uVar20 = 0x14;
      pcVar15 = "taskPayloadSharedEXT";
      break;
            case 0x12:
      uVar20 = 5;
      pcVar15 = "inout";
      break;
            case 0x13:
      uVar20 = 0x11;
      pcVar15 = "const (read only)";
      break;
            case 0x14:
      uVar20 = 0xb;
      pcVar15 = "gl_VertexId";
      break;
            case 0x15:
      uVar20 = 0xd;
      pcVar15 = "gl_InstanceId";
      break;
            case 0x16:
      uVar20 = 0xb;
      pcVar15 = "gl_Position";
      break;
            case 0x17:
      uVar20 = 0xc;
      pcVar15 = "gl_PointSize";
      break;
            case 0x18:
      uVar20 = 0xd;
      pcVar15 = "gl_ClipVertex";
      break;
            case 0x19:
      uVar20 = 0xe;
      pcVar15 = "gl_FrontFacing";
      break;
            case 0x1a:
      uVar20 = 0xc;
      pcVar15 = "gl_FragCoord";
      break;
            case 0x1b:
      uVar20 = 0xd;
      pcVar15 = "gl_PointCoord";
      break;
            case 0x1c:
      uVar20 = 9;
      pcVar15 = "fragColor";
      break;
            case 0x1d:
      uVar20 = 0xc;
      pcVar15 = "gl_FragDepth";
      break;
            case 0x1e:
      uVar20 = 0x14;
      pcVar15 = "gl_FragStencilRefARB";
      break;
            default:
      uVar20 = 0x11;
      pcVar15 = "unknown qualifier";
         }

         uVar14 = *(ulong*)( param_1 + 0x10 );
         if (0x7fffffffffffffff - uVar14 < uVar20) goto LAB_00165277;
         pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
         uVar11 = uVar14 + uVar20;
         if (pbVar1 == pbVar10) {
            uVar17 = 0xf;
         }
 else {
            uVar17 = *(ulong*)( param_1 + 0x18 );
         }

         if (uVar17 < uVar11) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar14, 0, pcVar15, uVar20);
            LAB_00162570:pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
         }
 else {
            pbVar19 = pbVar10 + uVar14;
            uVar16 = (uint)uVar20;
            if (7 < uVar16) {
               *(undefined8*)pbVar19 = *(undefined8*)pcVar15;
               *(undefined8*)( pbVar19 + ( uVar20 - 8 ) ) = *(undefined8*)( (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)pcVar15 + ( uVar20 - 8 ) );
               lVar13 = (long)pbVar19 - ( ( ulong )(pbVar19 + 8) & 0xfffffffffffffff8 );
               uVar16 = uVar16 + (int)lVar13 & 0xfffffff8;
               if (7 < uVar16) {
                  uVar8 = 0;
                  do {
                     uVar20 = (ulong)uVar8;
                     uVar8 = uVar8 + 8;
                     *(undefined8*)( ( ( ulong )(pbVar19 + 8) & 0xfffffffffffffff8 ) + uVar20 ) = *(undefined8*)( (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)pcVar15 + ( uVar20 - lVar13 ) );
                  }
 while ( uVar8 < uVar16 );
               }

               goto LAB_00162570;
            }

            if (( uVar20 & 4 ) == 0) {
               if (uVar16 != 0) {
                  *pbVar19 = ( basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> ) * pcVar15;
                  if (( uVar20 & 2 ) == 0) goto LAB_00162570;
                  *(undefined2*)( pbVar19 + ( uVar20 - 2 ) ) = *(undefined2*)( (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)pcVar15 + ( uVar20 - 2 ) );
                  pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
               }

            }
 else {
               *(undefined4*)pbVar19 = *(undefined4*)pcVar15;
               *(undefined4*)( pbVar19 + ( uVar20 - 4 ) ) = *(undefined4*)( (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)pcVar15 + ( uVar20 - 4 ) );
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
            }

         }

         *(ulong*)( param_1 + 0x10 ) = uVar11;
         pbVar10[uVar11] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x0;
      }

      if (param_6 == '\0') goto LAB_00162b20;
      if (param_3 == '\0') {
         lVar13 = *param_2;
         if (*(code**)( lVar13 + 0xe8 ) == isArray) {
            lVar22 = param_2[0xc];
            if (lVar22 != 0) {
               LAB_00162b77:lVar21 = 0;
               lVar13 = *(long*)( lVar22 + 8 );
               uVar9 = _UNK_00168768;
               while (_UNK_00168768 = uVar9,lVar13 != 0) {
                  if ((int)( *(long*)( lVar13 + 0x10 ) - *(long*)( lVar13 + 8 ) >> 4 ) <= (int)lVar21) break;
                  uVar20 = *(ulong*)( param_1 + 0x10 );
                  iVar18 = *(int*)( *(long*)( lVar13 + 8 ) + lVar21 * 0x10 );
                  if (iVar18 == 0 && (int)lVar21 == 0) {
                     if (*(char*)( lVar22 + 0x15 ) == '\0') goto LAB_00162baa;
                     if (0x7fffffffffffffff - uVar20 < 0x17) goto LAB_00165277;
                     if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
                        uVar14 = 0xf;
                     }
 else {
                        uVar14 = *(ulong*)( param_1 + 0x18 );
                     }

                     if (uVar14 < uVar20 + 0x17) {
                        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " runtime-sized array of", 0x17);
                     }
 else {
                        pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20;
                        *(undefined8*)pbVar10 = __LC994;
                        *(undefined8*)( pbVar10 + 8 ) = uVar9;
                        *(undefined8*)( pbVar10 + 0xf ) = 0x666f207961727261;
                     }

                     *(ulong*)( param_1 + 0x10 ) = uVar20 + 0x17;
                     *(undefined1*)( *(long*)( param_1 + 8 ) + 0x17 + uVar20 ) = 0;
                  }
 else {
                     if (iVar18 == 0) {
                        LAB_00162baa:if (0x7fffffffffffffff - uVar20 < 8) goto LAB_00165277;
                        if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
                           uVar14 = 0xf;
                        }
 else {
                           uVar14 = *(ulong*)( param_1 + 0x18 );
                        }

                        if (uVar14 < uVar20 + 8) {
                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " unsized", 8);
                        }
 else {
                           *(undefined8*)( *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20 ) = 0x64657a69736e7520;
                        }

                        *(ulong*)( param_1 + 0x10 ) = uVar20 + 8;
                        *(undefined1*)( *(long*)( param_1 + 8 ) + 8 + uVar20 ) = 0;
                        if (lVar21 == 0) {
                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " ");
                           iVar18 = *(int*)( param_2[0xc] + 0x10 );
                           if (iVar18 < 1) {
                              iVar18 = 1;
                           }

                           ::{lambda (int);
                           #3
                        }

                     }
 else {
                        if (uVar20 == 0x7fffffffffffffff) goto LAB_00165277;
                        if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
                           uVar14 = 0xf;
                        }
 else {
                           uVar14 = *(ulong*)( param_1 + 0x18 );
                        }

                        if (uVar14 < uVar20 + 1) {
                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " ", 1);
                        }
 else {
                           ( *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) )[uVar20] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x20;
                        }

                        *(ulong*)( param_1 + 0x10 ) = uVar20 + 1;
                        *(undefined1*)( *(long*)( param_1 + 8 ) + 1 + uVar20 ) = 0;
                        ::{lambda (int);
                        #3
                        ( (_lambda_int__3_*)&local_210,*(int*)( *(long*)( *(long*)( param_2[0xc] + 8 ) + 8 ) + lVar21 * 0x10 ) );
                     }

                     uVar4 = _UNK_00168778;
                     uVar9 = __LC995;
                     uVar20 = *(ulong*)( param_1 + 0x10 );
                     if (0x7fffffffffffffff - uVar20 < 0x11) goto LAB_00165277;
                     if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
                        uVar14 = 0xf;
                     }
 else {
                        uVar14 = *(ulong*)( param_1 + 0x18 );
                     }

                     if (uVar14 < uVar20 + 0x11) {
                        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, "-element array of", 0x11);
                     }
 else {
                        pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20;
                        pbVar10[0x10] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x66;
                        *(undefined8*)pbVar10 = uVar9;
                        *(undefined8*)( pbVar10 + 8 ) = uVar4;
                     }

                     *(ulong*)( param_1 + 0x10 ) = uVar20 + 0x11;
                     *(undefined1*)( *(long*)( param_1 + 8 ) + 0x11 + uVar20 ) = 0;
                  }

                  lVar22 = param_2[0xc];
                  lVar21 = lVar21 + 1;
                  uVar9 = _UNK_00168768;
                  lVar13 = *(long*)( lVar22 + 8 );
               }
;
               goto LAB_00162d48;
            }

         }
 else {
            cVar5 = ( **(code**)( lVar13 + 0xe8 ) )(param_2);
            if (cVar5 != '\0') {
               lVar22 = param_2[0xc];
               goto LAB_00162b77;
            }

            LAB_00162d48:lVar13 = *param_2;
         }

         if (*(code**)( lVar13 + 0x188 ) == isParameterized) {
            if (param_2[0x11] != 0) {
               LAB_00162d70:if (( *(byte*)( (long)param_2 + 10 ) & 0x40 ) != 0) {
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " ");
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, "coopmat");
               }

               lVar22 = 0;
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, "<");
               lVar13 = *(long*)( *(long*)( param_2[0x11] + 8 ) + 8 );
               if (lVar13 != 0) {
                  while (true) {
                     if ((int)( *(long*)( lVar13 + 0x10 ) - *(long*)( lVar13 + 8 ) >> 4 ) <= (int)lVar22) break;
                     ::{lambda (int);
                     #3
                     ( (_lambda_int__3_*)&local_210,*(int*)( *(long*)( lVar13 + 8 ) + lVar22 * 0x10 ) );
                     lVar13 = *(long*)( *(long*)( param_2[0x11] + 8 ) + 8 );
                     if (( lVar13 == 0 ) || ( (int)( *(long*)( lVar13 + 0x10 ) - *(long*)( lVar13 + 8 ) >> 4 ) + -1 != (int)lVar22 )) {
                        uVar20 = *(ulong*)( param_1 + 0x10 );
                        if (0x7fffffffffffffff - uVar20 < 2) goto LAB_00165277;
                        if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
                           uVar14 = 0xf;
                        }
 else {
                           uVar14 = *(ulong*)( param_1 + 0x18 );
                        }

                        if (uVar14 < uVar20 + 2) {
                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, ", ", 2);
                        }
 else {
                           *(undefined2*)( *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20 ) = 0x202c;
                        }

                        *(ulong*)( param_1 + 0x10 ) = uVar20 + 2;
                        *(undefined1*)( *(long*)( param_1 + 8 ) + 2 + uVar20 ) = 0;
                        lVar13 = *(long*)( *(long*)( param_2[0x11] + 8 ) + 8 );
                        if (lVar13 == 0) break;
                     }

                     lVar22 = lVar22 + 1;
                  }
;
               }

               if (( *(byte*)( (long)param_2 + 0xb ) & 4 ) != 0) {
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, ", ");
                  ::{lambda (int);
                  #3
                  ( (_lambda_int__3_*)&local_210,*(ushort*)( (long)param_2 + 10 ) >> 7 & 7 );
               }

               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, ">");
            }

         }
 else {
            cVar5 = ( **(code**)( lVar13 + 0x188 ) )(param_2);
            if (cVar5 != '\0') goto LAB_00162d70;
         }

         if (( param_5 != '\0' ) && ( ( *(byte*)( (long)param_2 + 0x1b ) & 0xe ) != 0 )) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " ");
            pcVar15 = "mediump";
            bVar6 = *(byte*)( (long)param_2 + 0x1b ) >> 1 & 7;
            if (bVar6 != 2) {
               if (bVar6 < 3) {
                  pcVar15 = "";
                  if (bVar6 != 0) {
                     pcVar15 = "lowp";
                  }

               }
 else {
                  pcVar15 = "highp";
                  if (bVar6 != 3) {
                     pcVar15 = "unknown precision qualifier";
                  }

               }

            }

            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, pcVar15);
         }

         lVar13 = *param_2;
         if (*(code**)( lVar13 + 0xe0 ) == isMatrix) {
            if (*(byte*)( (long)param_2 + 9 ) < 0x10) goto LAB_00162ec4;
            LAB_001630e8:std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " ");
            ::{lambda (int);
            #3
            ( (_lambda_int__3_*)&local_210,( uint )(*(byte*)( (long)param_2 + 9 ) >> 4) );
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, "X");
            ::{lambda (int);
            #3
            ( (_lambda_int__3_*)&local_210,*(byte*)( (long)param_2 + 10 ) & 0xf );
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " matrix of");
         }
 else {
            cVar5 = ( **(code**)( lVar13 + 0xe0 ) )(param_2);
            if (cVar5 != '\0') goto LAB_001630e8;
            lVar13 = *param_2;
            LAB_00162ec4:if (*(code**)( lVar13 + 0xd8 ) == isVector) {
               if (( *(byte*)( (long)param_2 + 9 ) & 0xf ) < 2) {
                  bVar6 = *(byte*)( (long)param_2 + 10 ) >> 4 & 1;
                  goto LAB_001634eb;
               }

            }
 else {
               bVar6 = ( **(code**)( lVar13 + 0xd8 ) )(param_2);
               LAB_001634eb:if (bVar6 == 0) goto LAB_00162f1b;
            }

            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " ");
            ::{lambda (int);
            #3
            ( (_lambda_int__3_*)&local_210,*(byte*)( (long)param_2 + 9 ) & 0xf );
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, "-component vector of");
         }

         LAB_00162f1b:uVar20 = *(ulong*)( param_1 + 0x10 );
         if (uVar20 == 0x7fffffffffffffff) goto LAB_00165277;
         if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
            uVar14 = 0xf;
         }
 else {
            uVar14 = *(ulong*)( param_1 + 0x18 );
         }

         if (uVar14 < uVar20 + 1) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " ", 1);
         }
 else {
            ( *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) )[uVar20] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x20;
         }

         *(ulong*)( param_1 + 0x10 ) = uVar20 + 1;
         *(undefined1*)( *(long*)( param_1 + 8 ) + 1 + uVar20 ) = 0;
         if ((char)param_2[1] == '\x0e') {
            TSampler::getString_abi_cxx11_();
         }
 else {
            local_f8 = glslang::GetThreadPoolAllocator();
            switch ((char)param_2[1]) {
               case '\0':
        lVar13 = 4;
        pcVar15 = "void";
        break;
               case '\x01':
        lVar13 = 5;
        pcVar15 = "float";
        break;
               case '\x02':
        lVar13 = 6;
        pcVar15 = "double";
        break;
               case '\x03':
        lVar13 = 9;
        pcVar15 = "float16_t";
        break;
               case '\x04':
        lVar13 = 6;
        pcVar15 = "int8_t";
        break;
               case '\x05':
        lVar13 = 7;
        pcVar15 = "uint8_t";
        break;
               case '\x06':
        lVar13 = 7;
        pcVar15 = "int16_t";
        break;
               case '\a':
        lVar13 = 8;
        pcVar15 = "uint16_t";
        break;
               case '\b':
        lVar13 = 3;
        pcVar15 = "int";
        break;
               case '\t':
        lVar13 = 4;
        pcVar15 = "uint";
        break;
               case '\n':
        lVar13 = 7;
        pcVar15 = "int64_t";
        break;
               case '\v':
        lVar13 = 8;
        pcVar15 = "uint64_t";
        break;
               case '\f':
        lVar13 = 4;
        pcVar15 = "bool";
        break;
               case '\r':
        lVar13 = 0xb;
        pcVar15 = "atomic_uint";
        break;
               case '\x0e':
        lVar13 = 0xd;
        pcVar15 = "sampler/image";
        break;
               case '\x0f':
        lVar13 = 9;
        pcVar15 = "structure";
        break;
               case '\x10':
        lVar13 = 5;
        pcVar15 = "block";
        break;
               case '\x11':
        lVar13 = 0x17;
        pcVar15 = "accelerationStructureNV";
        break;
               case '\x12':
        lVar13 = 9;
        pcVar15 = "reference";
        break;
               case '\x13':
        lVar13 = 0xb;
        pcVar15 = "rayQueryEXT";
        break;
               default:
        lVar13 = 0xc;
        pcVar15 = "unknown type";
        break;
               case '\x15':
        lVar13 = 7;
        pcVar15 = "coopmat";
        break;
               case '\x16':
        lVar13 = 10;
        pcVar15 = "spirv_type";
        break;
               case '\x17':
        lVar13 = 6;
        pcVar15 = "string";
            }

            local_f0 = local_e0;
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_f8, pcVar15, pcVar15 + lVar13);
         }

         uVar20 = *(ulong*)( param_1 + 0x10 );
         if (0x7fffffffffffffff - uVar20 < local_e8) goto LAB_00165277;
         pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
         uVar14 = local_e8 + uVar20;
         if (pbVar1 == pbVar10) {
            uVar11 = 0xf;
         }
 else {
            uVar11 = *(ulong*)( param_1 + 0x18 );
         }

         if (uVar11 < uVar14) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, (char*)local_f0, local_e8);
            pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
         }
 else if (local_e8 != 0) {
            if (local_e8 == 1) {
               pbVar10[uVar20] = *local_f0;
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
            }
 else {
               memcpy(pbVar10 + uVar20, local_f0, local_e8);
               pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
            }

         }

         *(ulong*)( param_1 + 0x10 ) = uVar14;
         pbVar10[uVar14] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x0;
         if (0x7f < *(ushort*)( param_2 + 3 )) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " ");
            pcVar15 = (char*)GetBuiltInVariableString(*(ushort*)( param_2 + 3 ) >> 7);
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, pcVar15);
         }

         if (*(code**)( *param_2 + 0x128 ) == isStruct) {
            if (1 < ( byte )((char)param_2[1] - 0xfU)) goto LAB_00162b20;
         }
 else {
            cVar5 = ( **(code**)( *param_2 + 0x128 ) )(param_2);
            if (cVar5 == '\0') goto LAB_00162b20;
         }

         if (param_2[0xd] != 0) {
            uVar20 = 0;
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, "{");
            lVar13 = param_2[0xd];
            lVar22 = *(long*)( lVar13 + 8 );
            if (lVar22 != *(long*)( lVar13 + 0x10 )) {
               do {
                  lVar21 = uVar20 * 0x20;
                  pcVar2 = *(code**)( **(long**)( lVar22 + lVar21 ) + 0x18 );
                  if (pcVar2 == hiddenMember) {
                     if ((char)( *(long**)( lVar22 + lVar21 ) )[1] != '\0') {
                        LAB_00162946:if (param_6 == '\0') {
                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, ", ");
                        }

                        uVar9 = *(undefined8*)( *(long*)( param_2[0xd] + 8 ) + lVar21 );
                        local_98 = glslang::GetThreadPoolAllocator();
                        local_90 = local_80;
                        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_98, &_LC1);
                        local_c8 = glslang::GetThreadPoolAllocator();
                        local_c0 = local_b0;
                        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_c8, &_LC1);
                        getCompleteString(local_68, uVar9, 0, 1, 1, 1, &local_c8, &local_98);
                        uVar14 = *(ulong*)( param_1 + 0x10 );
                        if (local_58 <= 0x7fffffffffffffff - uVar14) {
                           pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
                           uVar11 = local_58 + uVar14;
                           if (pbVar1 == pbVar10) {
                              uVar17 = 0xf;
                           }
 else {
                              uVar17 = *(ulong*)( param_1 + 0x18 );
                           }

                           if (uVar17 < uVar11) {
                              std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar14, 0, (char*)local_60, local_58);
                              pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
                           }
 else if (local_58 != 0) {
                              if (local_58 == 1) {
                                 pbVar10[uVar14] = *local_60;
                                 pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
                              }
 else {
                                 memcpy(pbVar10 + uVar14, local_60, local_58);
                                 pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
                              }

                           }

                           *(ulong*)( param_1 + 0x10 ) = uVar11;
                           pbVar10[uVar11] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x0;
                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " ");
                           plVar3 = *(long**)( *(long*)( param_2[0xd] + 8 ) + lVar21 );
                           pcVar2 = *(code**)( *plVar3 + 0x30 );
                           if (pcVar2 == getFieldName_abi_cxx11_) {
                              lVar13 = plVar3[0xe];
                           }
 else {
                              lVar13 = ( *pcVar2 )();
                           }

                           uVar14 = *(ulong*)( param_1 + 0x10 );
                           uVar11 = *(ulong*)( lVar13 + 0x10 );
                           pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( lVar13 + 8 );
                           if (uVar11 <= 0x7fffffffffffffff - uVar14) {
                              pbVar19 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
                              uVar17 = uVar11 + uVar14;
                              if (pbVar1 == pbVar19) {
                                 uVar12 = 0xf;
                              }
 else {
                                 uVar12 = *(ulong*)( param_1 + 0x18 );
                              }

                              if (uVar12 < uVar17) {
                                 std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar14, 0, (char*)pbVar10, uVar11);
                                 pbVar19 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
                              }
 else if (uVar11 != 0) {
                                 if (uVar11 == 1) {
                                    pbVar19[uVar14] = *pbVar10;
                                    pbVar19 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
                                 }
 else {
                                    memcpy(pbVar19 + uVar14, pbVar10, uVar11);
                                    pbVar19 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
                                 }

                              }

                              *(ulong*)( param_1 + 0x10 ) = uVar17;
                              pbVar19[uVar17] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x0;
                              param_6 = '\0';
                              goto LAB_00162ae7;
                           }

                        }

                        goto LAB_00165277;
                     }

                  }
 else {
                     cVar5 = ( *pcVar2 )();
                     if (cVar5 == '\0') goto LAB_00162946;
                     LAB_00162ae7:lVar13 = param_2[0xd];
                  }

                  lVar22 = *(long*)( lVar13 + 8 );
                  uVar20 = uVar20 + 1;
               }
 while ( uVar20 < ( ulong )(*(long*)( lVar13 + 0x10 ) - lVar22 >> 5) );
            }

            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, "}");
         }

         goto LAB_00162b20;
      }

      if (( param_5 != '\0' ) && ( ( *(byte*)( (long)param_2 + 0x1b ) & 0xe ) != 0 )) {
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " ");
         pcVar15 = "mediump";
         bVar6 = *(byte*)( (long)param_2 + 0x1b ) >> 1 & 7;
         if (bVar6 != 2) {
            if (bVar6 < 3) {
               pcVar15 = "";
               if (bVar6 != 0) {
                  pcVar15 = "lowp";
               }

            }
 else {
               pcVar15 = "highp";
               if (bVar6 != 3) {
                  pcVar15 = "unknown precision qualifier";
               }

            }

         }

         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, pcVar15);
      }

      if (*(code**)( *param_2 + 0xd8 ) == isVector) {
         if (( *(byte*)( (long)param_2 + 9 ) & 0xf ) < 2) {
            bVar6 = *(byte*)( (long)param_2 + 10 ) >> 4 & 1;
            goto LAB_001631cb;
         }

         LAB_001625ca:uVar20 = *(ulong*)( param_1 + 0x10 );
         if (uVar20 == 0x7fffffffffffffff) {
            LAB_00165277:/* WARNING: Subroutine does not return */std::__throw_length_error("basic_string::append");
         }

         if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
            uVar14 = 0xf;
         }
 else {
            uVar14 = *(ulong*)( param_1 + 0x18 );
         }

         if (uVar14 < uVar20 + 1) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, " ", 1);
         }
 else {
            ( *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) )[uVar20] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x20;
         }

         *(ulong*)( param_1 + 0x10 ) = uVar20 + 1;
         *(undefined1*)( *(long*)( param_1 + 8 ) + 1 + uVar20 ) = 0;
         bVar6 = *(byte*)( param_2 + 1 );
         if (bVar6 == 9) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, "u");
         }
 else if (bVar6 < 10) {
            if (bVar6 == 2) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, "d");
            }
 else if (bVar6 == 8) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, "i");
            }

         }
 else if (bVar6 == 0xc) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, "b");
         }

         if (*(code**)( *param_2 + 0xd8 ) == isVector) {
            if (( *(byte*)( (long)param_2 + 9 ) & 0xf ) < 2) {
               bVar6 = *(byte*)( (long)param_2 + 10 ) >> 4 & 1;
               goto LAB_0016487b;
            }

         }
 else {
            bVar6 = ( **(code**)( *param_2 + 0xd8 ) )(param_2);
            LAB_0016487b:if (bVar6 == 0) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, "mat");
               ::{lambda (int);
               #3
               ( (_lambda_int__3_*)&local_210,( uint )(*(byte*)( (long)param_2 + 9 ) >> 4) );
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, "x");
               ::{lambda (int);
               #3
               ( (_lambda_int__3_*)&local_210,*(byte*)( (long)param_2 + 10 ) & 0xf );
               goto LAB_00162684;
            }

         }

         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, "vec");
         ::{lambda (int);
         #3
         ( (_lambda_int__3_*)&local_210,*(byte*)( (long)param_2 + 9 ) & 0xf );
      }
 else {
         bVar6 = ( **(code**)( *param_2 + 0xd8 ) )(param_2);
         LAB_001631cb:if (bVar6 != 0) goto LAB_001625ca;
         lVar13 = *param_2;
         if (*(code**)( lVar13 + 0xe0 ) != isMatrix) {
            cVar5 = ( **(code**)( lVar13 + 0xe0 ) )(param_2);
            if (cVar5 == '\0') {
               lVar13 = *param_2;
               goto LAB_001631f8;
            }

            goto LAB_001625ca;
         }

         if (0xf < *(byte*)( (long)param_2 + 9 )) goto LAB_001625ca;
         LAB_001631f8:if (*(code**)( lVar13 + 0x128 ) == isStruct) {
            if (( byte )((char)param_2[1] - 0xfU) < 2) goto LAB_0016321f;
            LAB_00163470:std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " ");
            switch ((char)param_2[1]) {
               default:
        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::
        append(param_1,"unexpected");
        break;
               case '\x01':
        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::
        append(param_1,"float");
        break;
               case '\x02':
        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::
        append(param_1,"double");
        break;
               case '\b':
        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::
        append(param_1,"int");
        break;
               case '\t':
        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::
        append(param_1,"uint");
        break;
               case '\f':
        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::
        append(param_1,"bool");
            }

         }
 else {
            cVar5 = ( **(code**)( lVar13 + 0x128 ) )(param_2);
            if (cVar5 == '\0') goto LAB_00163470;
            LAB_0016321f:if (param_2[0xd] == 0) goto LAB_00163470;
            uVar20 = 0;
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " ");
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, *(char**)( param_8 + 8 ));
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, "{");
            lVar13 = param_2[0xd];
            lVar22 = *(long*)( lVar13 + 8 );
            if (*(long*)( lVar13 + 0x10 ) != lVar22) {
               do {
                  lVar21 = uVar20 * 0x20;
                  pcVar2 = *(code**)( **(long**)( lVar22 + lVar21 ) + 0x18 );
                  if (pcVar2 == hiddenMember) {
                     if ((char)( *(long**)( lVar22 + lVar21 ) )[1] != '\0') {
                        LAB_001632b2:if (param_3 == '\0') {
                           std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, ", ");
                        }

                        uVar9 = *(undefined8*)( *(long*)( param_2[0xd] + 8 ) + lVar21 );
                        local_158 = glslang::GetThreadPoolAllocator();
                        local_150 = local_140;
                        std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(&local_158, &_LC1);
                        plVar3 = *(long**)( *(long*)( param_2[0xd] + 8 ) + lVar21 );
                        pcVar2 = *(code**)( *plVar3 + 0x30 );
                        if (pcVar2 == getFieldName_abi_cxx11_) {
                           lVar13 = plVar3[0xe];
                        }
 else {
                           lVar13 = ( *pcVar2 )();
                        }

                        local_188 = glslang::GetThreadPoolAllocator();
                        uVar14 = *(ulong*)( lVar13 + 0x10 );
                        local_180 = local_170;
                        __src = *(undefined1**)( lVar13 + 8 );
                        if (uVar14 < 0x10) {
                           if (uVar14 == 1) {
                              local_170[0] = CONCAT71(local_170[0]._1_7_, *__src);
                           }
 else if (uVar14 != 0) goto LAB_0016518c;
                        }
 else {
                           if ((long)uVar14 < 0) {
                              /* WARNING: Subroutine does not return */
                              std::__throw_length_error("basic_string::_M_create");
                           }

                           local_180 = (ulong*)glslang::TPoolAllocator::allocate(local_188);
                           local_170[0] = uVar14;
                           LAB_0016518c:memcpy(local_180, __src, uVar14);
                        }

                        *(undefined1*)( (long)local_180 + uVar14 ) = 0;
                        local_178 = uVar14;
                        getCompleteString(local_128, uVar9, 1, param_4, param_5, 1, &local_188, &local_158);
                        uVar14 = *(ulong*)( param_1 + 0x10 );
                        if (local_118 <= 0x7fffffffffffffff - uVar14) {
                           pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
                           uVar11 = local_118 + uVar14;
                           if (pbVar1 == pbVar10) {
                              uVar17 = 0xf;
                           }
 else {
                              uVar17 = *(ulong*)( param_1 + 0x18 );
                           }

                           if (uVar17 < uVar11) {
                              std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar14, 0, (char*)local_120, local_118);
                              pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
                           }
 else if (local_118 != 0) {
                              if (local_118 == 1) {
                                 pbVar10[uVar14] = *local_120;
                                 pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
                              }
 else {
                                 memcpy(pbVar10 + uVar14, local_120, local_118);
                                 pbVar10 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
                              }

                           }

                           *(ulong*)( param_1 + 0x10 ) = uVar11;
                           param_3 = '\0';
                           pbVar10[uVar11] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x0;
                           goto LAB_0016341d;
                        }

                        goto LAB_00165277;
                     }

                  }
 else {
                     cVar5 = ( *pcVar2 )();
                     if (cVar5 == '\0') goto LAB_001632b2;
                     LAB_0016341d:lVar13 = param_2[0xd];
                  }

                  lVar22 = *(long*)( lVar13 + 8 );
                  uVar20 = uVar20 + 1;
               }
 while ( uVar20 < ( ulong )(*(long*)( lVar13 + 0x10 ) - lVar22 >> 5) );
            }

            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, "}");
         }

      }

      LAB_00162684:if (*(long*)( param_7 + 0x10 ) != 0) {
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, " ");
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::append(param_1, *(char**)( param_7 + 8 ));
      }

      if (*(code**)( *param_2 + 0xe8 ) == isArray) {
         lVar13 = param_2[0xc];
         if (lVar13 == 0) goto LAB_00162b20;
      }
 else {
         cVar5 = ( **(code**)( *param_2 + 0xe8 ) )(param_2);
         if (cVar5 == '\0') goto LAB_00162b20;
         lVar13 = param_2[0xc];
      }

      lVar22 = *(long*)( lVar13 + 8 );
      if (lVar22 != 0) {
         lVar21 = 0;
         do {
            if ((int)( *(long*)( lVar22 + 0x10 ) - *(long*)( lVar22 + 8 ) >> 4 ) <= (int)lVar21) break;
            uVar20 = *(ulong*)( param_1 + 0x10 );
            iVar18 = *(int*)( *(long*)( lVar22 + 8 ) + lVar21 * 0x10 );
            if (iVar18 == 0 && (int)lVar21 == 0) {
               if (*(char*)( lVar13 + 0x15 ) == '\0') goto LAB_001626f2;
               if (0x7fffffffffffffff - uVar20 < 2) goto LAB_00165277;
               if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
                  uVar14 = 0xf;
               }
 else {
                  uVar14 = *(ulong*)( param_1 + 0x18 );
               }

               if (uVar14 < uVar20 + 2) {
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, "[]", 2);
               }
 else {
                  *(undefined2*)( *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) + uVar20 ) = 0x5d5b;
               }

               *(ulong*)( param_1 + 0x10 ) = uVar20 + 2;
               *(undefined1*)( *(long*)( param_1 + 8 ) + 2 + uVar20 ) = 0;
            }
 else {
               if (iVar18 == 0) {
                  LAB_001626f2:if (uVar20 == 0x7fffffffffffffff) goto LAB_00165277;
                  if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
                     uVar14 = 0xf;
                  }
 else {
                     uVar14 = *(ulong*)( param_1 + 0x18 );
                  }

                  if (uVar14 < uVar20 + 1) {
                     std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, "[", 1);
                  }
 else {
                     ( *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) )[uVar20] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x5b;
                  }

                  *(ulong*)( param_1 + 0x10 ) = uVar20 + 1;
                  *(undefined1*)( *(long*)( param_1 + 8 ) + 1 + uVar20 ) = 0;
                  if (lVar21 == 0) {
                     iVar18 = *(int*)( param_2[0xc] + 0x10 );
                     if (iVar18 < 1) {
                        iVar18 = 1;
                     }

                     ::{lambda (int);
                     #3
                  }

               }
 else {
                  if (uVar20 == 0x7fffffffffffffff) goto LAB_00165277;
                  if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
                     uVar14 = 0xf;
                  }
 else {
                     uVar14 = *(ulong*)( param_1 + 0x18 );
                  }

                  if (uVar14 < uVar20 + 1) {
                     std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, "[", 1);
                  }
 else {
                     ( *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) )[uVar20] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x5b;
                  }

                  *(ulong*)( param_1 + 0x10 ) = uVar20 + 1;
                  *(undefined1*)( *(long*)( param_1 + 8 ) + 1 + uVar20 ) = 0;
                  ::{lambda (int);
                  #3
                  ( (_lambda_int__3_*)&local_210,*(int*)( *(long*)( *(long*)( param_2[0xc] + 8 ) + 8 ) + lVar21 * 0x10 ) );
               }

               uVar20 = *(ulong*)( param_1 + 0x10 );
               if (uVar20 == 0x7fffffffffffffff) goto LAB_00165277;
               if (pbVar1 == *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 )) {
                  uVar14 = 0xf;
               }
 else {
                  uVar14 = *(ulong*)( param_1 + 0x18 );
               }

               if (uVar14 < uVar20 + 1) {
                  std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(param_1, uVar20, 0, "]", 1);
               }
 else {
                  ( *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ) )[uVar20] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x5d;
               }

               *(ulong*)( param_1 + 0x10 ) = uVar20 + 1;
               *(undefined1*)( *(long*)( param_1 + 8 ) + 1 + uVar20 ) = 0;
            }

            lVar13 = param_2[0xc];
            lVar21 = lVar21 + 1;
            lVar22 = *(long*)( lVar13 + 8 );
         }
 while ( lVar22 != 0 );
      }

      LAB_00162b20:if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
         return param_1;
      }

      /* WARNING: Subroutine does not return */
      __stack_chk_fail();
   }

   /* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::_M_assign(std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const&) */
   void std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_assign(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *this, basic_string *param_1) {
      ulong __n;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *__dest;
      ulong uVar1;
      ulong uVar2;
      if (this == (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)param_1) {
         return;
      }

      __dest = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 );
      __n = *(ulong*)( param_1 + 0x10 );
      if (__dest == this + 0x18) {
         uVar1 = 0xf;
      }
 else {
         uVar1 = *(ulong*)( this + 0x18 );
      }

      if (uVar1 < __n) {
         if ((long)__n < 0) {
            /* WARNING: Subroutine does not return */
            std::__throw_length_error("basic_string::_M_create");
         }

         uVar1 = uVar1 * 2;
         uVar2 = 0x7fffffffffffffff;
         if (uVar1 < 0x8000000000000000) {
            uVar2 = uVar1;
         }

         if (uVar1 <= __n) {
            uVar2 = __n;
         }

         __dest = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)glslang::TPoolAllocator::allocate(*(ulong*)this);
         *(ulong*)( this + 0x18 ) = uVar2;
         *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 ) = __dest;
      }
 else if (__n == 0) goto LAB_001653fc;
      if (__n == 1) {
         *__dest = **(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 );
         __dest = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 );
      }
 else {
         memcpy(__dest, *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( param_1 + 8 ), __n);
         __dest = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 8 );
      }

      LAB_001653fc:*(ulong*)( this + 0x10 ) = __n;
      __dest[__n] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x0;
      return;
   }

   /* glslang::TIntermAggregate::setName(std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const&) */
   void glslang::TIntermAggregate::setName(TIntermAggregate *this, basic_string *param_1) {
      std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( this + 0x100 ), param_1);
      return;
   }

   /* void std::vector<glslang::TSymbolTableLevel*, std::allocator<glslang::TSymbolTableLevel*>
   >::_M_realloc_insert<glslang::TSymbolTableLevel*>(__gnu_cxx::__normal_iterator<glslang::TSymbolTableLevel**,
   std::vector<glslang::TSymbolTableLevel*, std::allocator<glslang::TSymbolTableLevel*> > >,
   glslang::TSymbolTableLevel*&&) */
   void std::vector<glslang::TSymbolTableLevel*,std::allocator<glslang::TSymbolTableLevel*>>::_M_realloc_insert<glslang::TSymbolTableLevel*>(vector<glslang::TSymbolTableLevel*,std::allocator<glslang::TSymbolTableLevel*>> *this, void *param_2, undefined8 *param_3) {
      void *__dest;
      void *pvVar1;
      void *__src;
      ulong uVar2;
      void *__dest_00;
      ulong uVar3;
      size_t __n;
      long lVar4;
      size_t __n_00;
      pvVar1 = *(void**)( this + 8 );
      __src = *(void**)this;
      uVar2 = (long)pvVar1 - (long)__src >> 3;
      if (uVar2 == 0xfffffffffffffff) {
         /* WARNING: Subroutine does not return */
         std::__throw_length_error("vector::_M_realloc_insert");
      }

      __n = (long)param_2 - (long)__src;
      if (__src == pvVar1) {
         if (0xfffffffffffffffe < uVar2) goto LAB_00165560;
         uVar3 = 0xfffffffffffffff;
         if (uVar2 + 1 < 0x1000000000000000) {
            uVar3 = uVar2 + 1;
         }

         uVar3 = uVar3 << 3;
         LAB_0016556a:__dest_00 = operator_new(uVar3);
         lVar4 = uVar3 + (long)__dest_00;
      }
 else {
         uVar3 = uVar2 * 2;
         if (uVar3 < uVar2) {
            LAB_00165560:uVar3 = 0x7ffffffffffffff8;
            goto LAB_0016556a;
         }

         if (uVar3 != 0) {
            if (0xfffffffffffffff < uVar3) {
               uVar3 = 0xfffffffffffffff;
            }

            uVar3 = uVar3 * 8;
            goto LAB_0016556a;
         }

         lVar4 = 0;
         __dest_00 = (void*)0x0;
      }

      __dest = (void*)( (long)__dest_00 + __n + 8 );
      __n_00 = (long)pvVar1 - (long)param_2;
      *(undefined8*)( (long)__dest_00 + __n ) = *param_3;
      if ((long)__n < 1) {
         if (0 < (long)__n_00) {
            memcpy(__dest, param_2, __n_00);
         }

         if (__src == (void*)0x0) goto LAB_0016553c;
      }
 else {
         __dest_00 = memmove(__dest_00, __src, __n);
         if (0 < (long)__n_00) {
            memcpy(__dest, param_2, __n_00);
         }

      }

      operator_delete(__src, *(long*)( this + 0x10 ) - (long)__src);
      LAB_0016553c:*(void**)this = __dest_00;
      *(size_t*)( this + 8 ) = (long)__dest + __n_00;
      *(long*)( this + 0x10 ) = lVar4;
      return;
   }

   /* void std::vector<std::__cxx11::string, std::allocator<std::__cxx11::string >
   >::_M_realloc_insert<std::__cxx11::string >(__gnu_cxx::__normal_iterator<std::__cxx11::string*,
   std::vector<std::__cxx11::string, std::allocator<std::__cxx11::string > > >,
   std::__cxx11::string&&) */
   void std::vector<std::__cxx11::string,std::allocator<std::__cxx11::string>>::_M_realloc_insert<std::__cxx11::string>(vector<std::__cxx11::string,std::allocator<std::__cxx11::string>> *this, void *param_2, long *param_3) {
      long *plVar1;
      void *pvVar2;
      void *pvVar3;
      long *plVar4;
      ulong uVar5;
      long *plVar6;
      long *plVar7;
      ulong uVar8;
      long *plVar9;
      long *plVar10;
      long lVar11;
      uint uVar12;
      uint uVar13;
      long lVar14;
      long lVar15;
      pvVar2 = *(void**)( this + 8 );
      pvVar3 = *(void**)this;
      uVar5 = (long)pvVar2 - (long)pvVar3 >> 5;
      if (uVar5 == 0x3ffffffffffffff) {
         /* WARNING: Subroutine does not return */
         std::__throw_length_error("vector::_M_realloc_insert");
      }

      if (pvVar3 == pvVar2) {
         if (0xfffffffffffffffe < uVar5) goto LAB_00165768;
         uVar8 = 0x3ffffffffffffff;
         if (uVar5 + 1 < 0x400000000000000) {
            uVar8 = uVar5 + 1;
         }

         uVar8 = uVar8 << 5;
      }
 else {
         uVar8 = uVar5 * 2;
         if (uVar8 < uVar5) {
            LAB_00165768:uVar8 = 0x7fffffffffffffe0;
         }
 else {
            if (uVar8 == 0) {
               plVar6 = (long*)&DAT_00000020;
               lVar11 = 0;
               plVar7 = (long*)0x0;
               goto LAB_0016569d;
            }

            if (0x3ffffffffffffff < uVar8) {
               uVar8 = 0x3ffffffffffffff;
            }

            uVar8 = uVar8 << 5;
         }

      }

      plVar7 = (long*)operator_new(uVar8);
      lVar11 = uVar8 + (long)plVar7;
      plVar6 = plVar7 + 4;
      LAB_0016569d:plVar9 = (long*)( ( (long)param_2 - (long)pvVar3 ) + (long)plVar7 );
      lVar15 = *param_3;
      plVar10 = param_3 + 2;
      lVar14 = param_3[1];
      *plVar9 = (long)( plVar9 + 2 );
      if ((long*)lVar15 == plVar10) {
         uVar5 = lVar14 + 1;
         uVar12 = (uint)uVar5;
         if (uVar12 < 8) {
            if (( uVar5 & 4 ) == 0) {
               if (( uVar12 != 0 ) && ( *(char*)( plVar9 + 2 ) = (char)param_3[2](uVar5 & 2) != 0 )) {
                  *(undefined2*)( (long)plVar9 + ( uVar5 & 0xffffffff ) + 0xe ) = *(undefined2*)( (long)param_3 + ( uVar5 & 0xffffffff ) + 0xe );
               }

            }
 else {
               *(int*)( plVar9 + 2 ) = (int)param_3[2];
               *(undefined4*)( (long)plVar9 + ( uVar5 & 0xffffffff ) + 0xc ) = *(undefined4*)( (long)param_3 + ( uVar5 & 0xffffffff ) + 0xc );
            }

         }
 else {
            plVar9[2] = param_3[2];
            *(undefined8*)( (long)plVar9 + ( uVar5 & 0xffffffff ) + 8 ) = *(undefined8*)( (long)param_3 + ( uVar5 & 0xffffffff ) + 8 );
            lVar15 = (long)( plVar9 + 2 ) - ( ( ulong )(plVar9 + 3) & 0xfffffffffffffff8 );
            uVar12 = uVar12 + (int)lVar15 & 0xfffffff8;
            if (7 < uVar12) {
               uVar13 = 0;
               do {
                  uVar5 = (ulong)uVar13;
                  uVar13 = uVar13 + 8;
                  *(undefined8*)( ( ( ulong )(plVar9 + 3) & 0xfffffffffffffff8 ) + uVar5 ) = *(undefined8*)( (long)plVar10 + ( uVar5 - lVar15 ) );
               }
 while ( uVar13 < uVar12 );
            }

         }

      }
 else {
         *plVar9 = lVar15;
         plVar9[2] = param_3[2];
      }

      plVar9[1] = lVar14;
      *param_3 = (long)plVar10;
      param_3[1] = 0;
      *(undefined1*)( param_3 + 2 ) = 0;
      if (param_2 != pvVar3) {
         plVar10 = (long*)( (long)pvVar3 + 0x10 );
         plVar6 = (long*)( ( (long)param_2 - (long)pvVar3 ) + (long)plVar7 );
         plVar9 = plVar7;
         do {
            plVar1 = plVar9 + 2;
            lVar15 = plVar10[-1];
            *plVar9 = (long)plVar1;
            if (plVar10 == (long*)plVar10[-2]) {
               uVar5 = lVar15 + 1;
               uVar12 = (uint)uVar5;
               if (uVar12 < 8) {
                  if (( uVar5 & 4 ) == 0) {
                     if (uVar12 != 0) {
                        *(char*)plVar1 = (char)*plVar10;
                        if (( uVar5 & 2 ) == 0) goto LAB_0016575b;
                        *(undefined2*)( (long)plVar9 + ( uVar5 & 0xffffffff ) + 0xe ) = *(undefined2*)( (long)plVar10 + ( ( uVar5 & 0xffffffff ) - 2 ) );
                        lVar15 = plVar10[-1];
                     }

                  }
 else {
                     *(int*)plVar1 = (int)*plVar10;
                     *(undefined4*)( (long)plVar9 + ( uVar5 & 0xffffffff ) + 0xc ) = *(undefined4*)( (long)plVar10 + ( ( uVar5 & 0xffffffff ) - 4 ) );
                     lVar15 = plVar10[-1];
                  }

               }
 else {
                  *plVar1 = *plVar10;
                  *(undefined8*)( (long)plVar9 + ( uVar5 & 0xffffffff ) + 8 ) = *(undefined8*)( (long)plVar10 + ( ( uVar5 & 0xffffffff ) - 8 ) );
                  lVar15 = (long)plVar1 - ( ( ulong )(plVar9 + 3) & 0xfffffffffffffff8 );
                  uVar12 = uVar12 + (int)lVar15 & 0xfffffff8;
                  if (7 < uVar12) {
                     uVar13 = 0;
                     do {
                        uVar5 = (ulong)uVar13;
                        uVar13 = uVar13 + 8;
                        *(undefined8*)( ( ( ulong )(plVar9 + 3) & 0xfffffffffffffff8 ) + uVar5 ) = *(undefined8*)( (long)plVar10 + ( uVar5 - lVar15 ) );
                     }
 while ( uVar13 < uVar12 );
                  }

                  LAB_0016575b:lVar15 = plVar10[-1];
               }

            }
 else {
               *plVar9 = plVar10[-2];
               plVar9[2] = *plVar10;
            }

            plVar9[1] = lVar15;
            plVar9 = plVar9 + 4;
            plVar10 = plVar10 + 4;
         }
 while ( plVar6 != plVar9 );
         plVar6 = plVar6 + 4;
      }

      plVar10 = plVar6;
      if (param_2 != pvVar2) {
         plVar9 = (long*)( (long)param_2 + 0x10 );
         plVar10 = (long*)( ( (long)pvVar2 - (long)param_2 ) + (long)plVar6 );
         do {
            plVar4 = (long*)plVar9[-2];
            plVar1 = plVar6 + 2;
            lVar15 = plVar9[-1];
            *plVar6 = (long)plVar1;
            if (plVar9 == plVar4) {
               uVar5 = lVar15 + 1;
               uVar12 = (uint)uVar5;
               if (uVar12 < 8) {
                  if (( uVar5 & 4 ) == 0) {
                     if (( uVar12 != 0 ) && ( *(char*)plVar1 = (char)*plVar9(uVar5 & 2) != 0 )) {
                        *(undefined2*)( (long)plVar6 + ( uVar5 & 0xffffffff ) + 0xe ) = *(undefined2*)( (long)plVar9 + ( ( uVar5 & 0xffffffff ) - 2 ) );
                     }

                  }
 else {
                     *(int*)plVar1 = (int)*plVar9;
                     *(undefined4*)( (long)plVar6 + ( uVar5 & 0xffffffff ) + 0xc ) = *(undefined4*)( (long)plVar9 + ( ( uVar5 & 0xffffffff ) - 4 ) );
                  }

               }
 else {
                  *plVar1 = *plVar9;
                  *(undefined8*)( (long)plVar6 + ( uVar5 & 0xffffffff ) + 8 ) = *(undefined8*)( (long)plVar9 + ( ( uVar5 & 0xffffffff ) - 8 ) );
                  lVar14 = (long)plVar1 - ( ( ulong )(plVar6 + 3) & 0xfffffffffffffff8 );
                  uVar12 = uVar12 + (int)lVar14 & 0xfffffff8;
                  if (7 < uVar12) {
                     uVar13 = 0;
                     do {
                        uVar5 = (ulong)uVar13;
                        uVar13 = uVar13 + 8;
                        *(undefined8*)( ( ( ulong )(plVar6 + 3) & 0xfffffffffffffff8 ) + uVar5 ) = *(undefined8*)( (long)plVar9 + ( uVar5 - lVar14 ) );
                     }
 while ( uVar13 < uVar12 );
                  }

               }

            }
 else {
               *plVar6 = (long)plVar4;
               plVar6[2] = *plVar9;
            }

            plVar6[1] = lVar15;
            plVar6 = plVar6 + 4;
            plVar9 = plVar9 + 4;
         }
 while ( plVar6 != plVar10 );
      }

      if (pvVar3 != (void*)0x0) {
         operator_delete(pvVar3, *(long*)( this + 0x10 ) - (long)pvVar3);
      }

      *(long**)this = plVar7;
      *(long**)( this + 8 ) = plVar10;
      *(long*)( this + 0x10 ) = lVar11;
      return;
   }

   /* void std::vector<int, std::allocator<int>
   >::_M_realloc_insert<int>(__gnu_cxx::__normal_iterator<int*, std::vector<int, std::allocator<int>
   > >, int&&) */
   void std::vector<int,std::allocator<int>>::_M_realloc_insert<int>(vector<int,std::allocator<int>> *this, void *param_2, undefined4 *param_3) {
      void *__dest;
      void *pvVar1;
      void *__src;
      ulong uVar2;
      void *__dest_00;
      ulong uVar3;
      size_t __n;
      long lVar4;
      size_t __n_00;
      pvVar1 = *(void**)( this + 8 );
      __src = *(void**)this;
      uVar2 = (long)pvVar1 - (long)__src >> 2;
      if (uVar2 == 0x1fffffffffffffff) {
         /* WARNING: Subroutine does not return */
         std::__throw_length_error("vector::_M_realloc_insert");
      }

      __n = (long)param_2 - (long)__src;
      if (__src == pvVar1) {
         if (0xfffffffffffffffe < uVar2) goto LAB_00165b40;
         uVar3 = 0x1fffffffffffffff;
         if (uVar2 + 1 < 0x2000000000000000) {
            uVar3 = uVar2 + 1;
         }

         uVar3 = uVar3 << 2;
         LAB_00165b4a:__dest_00 = operator_new(uVar3);
         lVar4 = uVar3 + (long)__dest_00;
      }
 else {
         uVar3 = uVar2 * 2;
         if (uVar3 < uVar2) {
            LAB_00165b40:uVar3 = 0x7ffffffffffffffc;
            goto LAB_00165b4a;
         }

         if (uVar3 != 0) {
            if (0x1fffffffffffffff < uVar3) {
               uVar3 = 0x1fffffffffffffff;
            }

            uVar3 = uVar3 * 4;
            goto LAB_00165b4a;
         }

         lVar4 = 0;
         __dest_00 = (void*)0x0;
      }

      __dest = (void*)( (long)__dest_00 + __n + 4 );
      __n_00 = (long)pvVar1 - (long)param_2;
      *(undefined4*)( (long)__dest_00 + __n ) = *param_3;
      if ((long)__n < 1) {
         if (0 < (long)__n_00) {
            memcpy(__dest, param_2, __n_00);
         }

         if (__src == (void*)0x0) goto LAB_00165b1b;
      }
 else {
         __dest_00 = memmove(__dest_00, __src, __n);
         if (0 < (long)__n_00) {
            memcpy(__dest, param_2, __n_00);
         }

      }

      operator_delete(__src, *(long*)( this + 0x10 ) - (long)__src);
      LAB_00165b1b:*(void**)this = __dest_00;
      *(size_t*)( this + 8 ) = (long)__dest + __n_00;
      *(long*)( this + 0x10 ) = lVar4;
      return;
   }

   /* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::_M_replace_cold(char*, unsigned long, char const*, unsigned long, unsigned long) */
   void std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_replace_cold(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *this, char *param_1, ulong param_2, char *param_3, ulong param_4, ulong param_5) {
      long lVar1;
      char *pcVar2;
      size_t __n;
      byte bVar3;
      bVar3 = 0;
      if (param_4 - 1 < param_2) {
         if (param_4 == 1) {
            *param_1 = *param_3;
         }
 else {
            memmove(param_1, param_3, param_4);
         }

      }

      if (( param_5 != 0 ) && ( param_4 != param_2 )) {
         if (param_5 == 1) {
            param_1[param_4] = param_1[param_2];
         }
 else {
            memmove(param_1 + param_4, param_1 + param_2, param_5);
         }

      }

      if (param_2 < param_4) {
         pcVar2 = param_1 + param_2;
         if (pcVar2 < param_3 + param_4) {
            if (param_3 < pcVar2) {
               __n = (long)pcVar2 - (long)param_3;
               if (__n == 1) {
                  *param_1 = *param_3;
               }
 else {
                  memmove(param_1, param_3, __n);
               }

               pcVar2 = param_1 + param_4;
               param_1 = param_1 + __n;
               lVar1 = param_4 - __n;
               if (lVar1 != 1) {
                  if (lVar1 == 0) {
                     return;
                  }

                  for (; lVar1 != 0; lVar1 = lVar1 + -1) {
                     *param_1 = *pcVar2;
                     pcVar2 = pcVar2 + (ulong)bVar3 * -2 + 1;
                     param_1 = param_1 + (ulong)bVar3 * -2 + 1;
                  }

                  return;
               }

            }
 else {
               pcVar2 = param_3 + ( param_4 - param_2 );
               if (param_4 != 1) {
                  for (; param_4 != 0; param_4 = param_4 - 1) {
                     *param_1 = *pcVar2;
                     pcVar2 = pcVar2 + (ulong)bVar3 * -2 + 1;
                     param_1 = param_1 + (ulong)bVar3 * -2 + 1;
                  }

                  return;
               }

            }

            *param_1 = *pcVar2;
         }
 else {
            if (param_4 != 1) {
               memmove(param_1, param_3, param_4);
               return;
            }

            *param_1 = *param_3;
         }

      }

      return;
   }

   /* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::assign(char const*) [clone .isra.0] [clone .cold] */
   void std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::assign(char *param_1) {
      ulong in_RDX;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *unaff_RBX;
      ulong unaff_RBP;
      char *unaff_R12;
      _M_replace_cold(unaff_RBX, param_1, in_RDX, unaff_R12, unaff_RBP, 0);
      *(ulong*)( unaff_RBX + 0x10 ) = unaff_RBP;
      *(undefined1*)( *(long*)( unaff_RBX + 8 ) + unaff_RBP ) = 0;
      return;
   }

   /* glslang::TFunction::TFunction(std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const*, glslang::TType const&, glslang::TOperator) */
   void glslang::TFunction::TFunction(TFunction *this, long param_1, long *param_2, undefined4 param_4) {
      TFunction *pTVar1;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *this_00;
      ulong uVar2;
      ushort uVar3;
      uint uVar4;
      ulong uVar5;
      TFunction *__src;
      long lVar6;
      long lVar7;
      long lVar8;
      long lVar9;
      long lVar10;
      long lVar11;
      long lVar12;
      long lVar13;
      long lVar14;
      long lVar15;
      long lVar16;
      undefined8 uVar17;
      ulong uVar18;
      ulong uVar19;
      TFunction *pTVar20;
      long in_FS_OFFSET;
      TFunction local_41;
      long local_40;
      pTVar1 = this + 0x100;
      this_00 = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( this + 0xe8 );
      local_40 = *(long*)( in_FS_OFFSET + 0x28 );
      *(long*)( this + 8 ) = param_1;
      *(undefined8*)( this + 0x10 ) = 0;
      *(undefined8*)( this + 0x18 ) = 0;
      this[0x20] = (TFunction)0x1;
      *(undefined**)this = &TIntermSwitch::vtable;
      uVar17 = glslang::GetThreadPoolAllocator();
      *(uint*)( this + 200 ) = *(uint*)( this + 200 ) & 0x9fc00000;
      *(undefined8*)( this + 0x28 ) = uVar17;
      *(undefined***)( this + 0x48 ) = &PTR__TType_00167f00;
      *(undefined1(*) [16])( this + 0xd0 ) = (undefined1[16])0x0;
      *(undefined1(*) [16])( this + 0xa8 ) = (undefined1[16])0x0;
      *(undefined1(*) [16])( this + 0xb8 ) = (undefined1[16])0x0;
      *(uint*)( this + 0x50 ) = CONCAT22((short)( ( uint ) * (undefined4*)( this + 0x50 ) >> 0x10 ), 0x100) & 0xf800ffff;
      this[0x68] = ( TFunction )((byte)this[0x68] & 0xf0);
      *(ulong*)( this + 0x75 ) = *(ulong*)( this + 0x75 ) & 0xffffff0000ffc07f | 0xffff001f80;
      *(undefined8*)( this + 0x30 ) = 0;
      *(ulong*)( this + 0x80 ) = CONCAT71(( uint7 )(( ulong ) * (undefined8*)( this + 0x80 ) >> 8) & 0xffffffff, 0xff);
      *(undefined8*)( this + 0x8c ) = 0xfffff800;
      *(undefined2*)( this + 0xa0 ) = 0;
      *(undefined8*)( this + 0x38 ) = 0;
      *(ulong*)( this + 0x74 ) = *(ulong*)( this + 0x74 ) & 0xffffffff8000 | 0xffff000000004fff;
      *(undefined8*)( this + 0x40 ) = 0;
      *(ulong*)( this + 0x7c ) = *(ulong*)( this + 0x7c ) | 0x1ffff007fffffff;
      *(undefined8*)( this + 0x58 ) = 0;
      *(ulong*)( this + 0x60 ) = *(ulong*)( this + 0x60 ) & 0x8000000400000000;
      *(undefined8*)( this + 0x6c ) = 0xffffffffffffffff;
      this[0x88] = (TFunction)0x0;
      this[0x84] = (TFunction)0x0;
      *(undefined4*)( this + 0x94 ) = 0xffffffff;
      *(undefined8*)( this + 0x98 ) = 0;
      local_41 = (TFunction)0x28;
      uVar5 = *(ulong*)( param_1 + 0x10 );
      __src = *(TFunction**)( param_1 + 8 );
      uVar17 = glslang::GetThreadPoolAllocator();
      *(TFunction**)( this + 0xf0 ) = pTVar1;
      *(undefined8*)( this + 0xe8 ) = uVar17;
      *(undefined8*)( this + 0xf8 ) = 0;
      this[0x100] = (TFunction)0x0;
      std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::reserve(this_00, uVar5 + 1);
      uVar19 = *(ulong*)( this + 0xf8 );
      if (uVar5 <= 0x7fffffffffffffff - uVar19) {
         pTVar20 = *(TFunction**)( this + 0xf0 );
         uVar2 = uVar5 + uVar19;
         if (pTVar1 == pTVar20) {
            uVar18 = 0xf;
         }
 else {
            uVar18 = *(ulong*)( this + 0x100 );
         }

         if (uVar18 < uVar2) {
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(this_00, uVar19, 0, (char*)__src, uVar5);
            pTVar20 = *(TFunction**)( this + 0xf0 );
         }
 else if (uVar5 != 0) {
            if (uVar5 == 1) {
               pTVar20[uVar19] = *__src;
               pTVar20 = *(TFunction**)( this + 0xf0 );
            }
 else {
               memcpy(pTVar20 + uVar19, __src, uVar5);
               pTVar20 = *(TFunction**)( this + 0xf0 );
            }

         }

         *(ulong*)( this + 0xf8 ) = uVar2;
         pTVar20[uVar2] = (TFunction)0x0;
         uVar5 = *(ulong*)( this + 0xf8 );
         if (uVar5 != 0x7fffffffffffffff) {
            if (pTVar1 == *(TFunction**)( this + 0xf0 )) {
               uVar19 = 0xf;
            }
 else {
               uVar19 = *(ulong*)( this + 0x100 );
            }

            if (uVar19 < uVar5 + 1) {
               std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_mutate(this_00, uVar5, 0, (char*)&local_41, 1);
            }
 else {
               ( *(TFunction**)( this + 0xf0 ) )[uVar5] = local_41;
            }

            *(ulong*)( this + 0xf8 ) = uVar5 + 1;
            *(undefined1*)( *(long*)( this + 0xf0 ) + 1 + uVar5 ) = 0;
            *(undefined8*)( this + 0x114 ) = 0;
            *(undefined4*)( this + 0x110 ) = param_4;
            uVar17 = glslang::GetThreadPoolAllocator();
            this[0x138] = (TFunction)0x0;
            *(undefined8*)( this + 0x120 ) = uVar17;
            *(TFunction**)( this + 0x128 ) = this + 0x138;
            *(undefined8*)( this + 0x130 ) = 0;
            std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::assign((basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)( this + 0x120 ), "");
            lVar16 = param_2[0x10];
            lVar7 = param_2[0xe];
            lVar8 = param_2[0xf];
            *(undefined4*)( this + 0x148 ) = 0xffffffff;
            uVar4 = *(uint*)( param_2 + 1 );
            lVar6 = param_2[2];
            lVar9 = param_2[3];
            *(undefined4*)( this + 0x150 ) = 0;
            lVar10 = param_2[4];
            lVar11 = param_2[5];
            lVar12 = param_2[6];
            lVar13 = param_2[7];
            *(int*)( this + 200 ) = (int)lVar16;
            lVar16 = param_2[8];
            lVar14 = param_2[9];
            *(long*)( this + 0x58 ) = lVar6;
            *(long*)( this + 0x60 ) = lVar9;
            lVar9 = param_2[10];
            lVar15 = param_2[0xb];
            *(long*)( this + 0x68 ) = lVar10;
            *(long*)( this + 0x70 ) = lVar11;
            *(long*)( this + 0x78 ) = lVar12;
            *(long*)( this + 0x80 ) = lVar13;
            *(long*)( this + 0x88 ) = lVar16;
            *(long*)( this + 0x90 ) = lVar14;
            *(uint*)( this + 0x50 ) = *(uint*)( this + 0x50 ) & 0xffe00000 | uVar4 & 0x1fffff;
            lVar6 = param_2[0xc];
            *(long*)( this + 0x98 ) = lVar9;
            *(long*)( this + 0xa0 ) = lVar15;
            *(long*)( this + 0xa8 ) = lVar6;
            lVar6 = param_2[0xd];
            *(long*)( this + 0xb8 ) = lVar7;
            *(long*)( this + 0xc0 ) = lVar8;
            *(long*)( this + 0xb0 ) = lVar6;
            uVar3 = *(ushort*)( (long)param_2 + 10 );
            lVar6 = param_2[0x12];
            *(long*)( this + 0xd0 ) = param_2[0x11];
            *(long*)( this + 0xd8 ) = lVar6;
            *(ushort*)( this + 0x52 ) = *(ushort*)( this + 0x52 ) & 0xf81f | uVar3 & 0x7e0;
            if (*(code**)( *param_2 + 0x58 ) == TType::getQualifier) {
               param_2 = param_2 + 2;
            }
 else {
               param_2 = (long*)( **(code**)( *param_2 + 0x58 ) )(param_2);
            }

            *(uint*)( this + 0xe0 ) = ( uint )(*(ushort*)( param_2 + 1 ) >> 7);
            if (local_40 == *(long*)( in_FS_OFFSET + 0x28 )) {
               return;
            }

            /* WARNING: Subroutine does not return */
            __stack_chk_fail();
         }

      }

      /* WARNING: Subroutine does not return */
      std::__throw_length_error("basic_string::append");
   }

   /* std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> >, std::pair<std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const, glslang::AstRefType>,
   std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, glslang::AstRefType> >,
   std::less<std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, glslang::AstRefType> >
   >::_M_get_insert_unique_pos(std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const&) */
   undefined1[16];
   std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>::_M_get_insert_unique_pos (_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>
           *this,basic_string *param_1) {
      bool bVar1;
      uint uVar2;
      int iVar3;
      ulong uVar4;
      _Rb_tree_node_base *p_Var5;
      long lVar6;
      size_t __n;
      _Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>> *p_Var7;
      _Rb_tree_node_base *p_Var8;
      ulong uVar9;
      void *__s2;
      ulong uVar10;
      undefined1 auVar11[16];
      void *local_50;
      if (*(_Rb_tree_node_base**)( this + 0x10 ) == (_Rb_tree_node_base*)0x0) {
         p_Var7 = this + 8;
         LAB_00166304:if (*(_Rb_tree_node_base**)( this + 0x18 ) == (_Rb_tree_node_base*)p_Var7) {
            p_Var5 = (_Rb_tree_node_base*)0x0;
            p_Var8 = (_Rb_tree_node_base*)p_Var7;
            goto LAB_001662ca;
         }

         p_Var5 = (_Rb_tree_node_base*)std::_Rb_tree_decrement((_Rb_tree_node_base*)p_Var7);
         uVar9 = *(ulong*)( p_Var5 + 0x30 );
         __s2 = *(void**)( p_Var5 + 0x28 );
         uVar10 = *(ulong*)( param_1 + 0x10 );
         local_50 = *(void**)( param_1 + 8 );
         __n = uVar9;
         if (uVar10 <= uVar9) {
            __n = uVar10;
         }

      }
 else {
         local_50 = *(void**)( param_1 + 8 );
         uVar10 = *(ulong*)( param_1 + 0x10 );
         p_Var5 = *(_Rb_tree_node_base**)( this + 0x10 );
         do {
            p_Var7 = (_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>*)p_Var5;
            uVar9 = *(ulong*)( (_Rb_tree_node_base*)p_Var7 + 0x30 );
            __s2 = *(void**)( (_Rb_tree_node_base*)p_Var7 + 0x28 );
            __n = uVar9;
            if (uVar10 <= uVar9) {
               __n = uVar10;
            }

            if (__n == 0) {
               LAB_00166274:uVar4 = uVar10 - uVar9;
               if (0x7fffffff < (long)uVar4) goto LAB_00166292;
               if (-0x80000001 < (long)uVar4) goto LAB_0016628e;
               LAB_00166238:p_Var5 = *(_Rb_tree_node_base**)( (_Rb_tree_node_base*)p_Var7 + 0x10 );
               bVar1 = true;
            }
 else {
               uVar2 = memcmp(local_50, __s2, __n);
               uVar4 = (ulong)uVar2;
               if (uVar2 == 0) goto LAB_00166274;
               LAB_0016628e:if ((int)uVar4 < 0) goto LAB_00166238;
               LAB_00166292:p_Var5 = *(_Rb_tree_node_base**)( (_Rb_tree_node_base*)p_Var7 + 0x18 );
               bVar1 = false;
            }

         }
 while ( p_Var5 != (_Rb_tree_node_base*)0x0 );
         p_Var5 = (_Rb_tree_node_base*)p_Var7;
         if (bVar1) goto LAB_00166304;
      }

      if (( __n == 0 ) || ( iVar3 = iVar3 == 0 )) {
         lVar6 = uVar9 - uVar10;
         if (0x7fffffff < lVar6) {
            p_Var8 = (_Rb_tree_node_base*)0x0;
            goto LAB_001662ca;
         }

         if (lVar6 < -0x80000000) {
            p_Var5 = (_Rb_tree_node_base*)0x0;
            p_Var8 = (_Rb_tree_node_base*)p_Var7;
            goto LAB_001662ca;
         }

         iVar3 = (int)lVar6;
      }

      p_Var8 = (_Rb_tree_node_base*)0x0;
      if (iVar3 < 0) {
         p_Var8 = (_Rb_tree_node_base*)p_Var7;
         p_Var5 = (_Rb_tree_node_base*)0x0;
      }

      LAB_001662ca:auVar11._8_8_ = p_Var8;
      auVar11._0_8_ = p_Var5;
      return auVar11;
   }

   /* std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> >, std::pair<std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const, glslang::AstRefType>,
   std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, glslang::AstRefType> >,
   std::less<std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const, glslang::AstRefType> >
   >::_M_get_insert_hint_unique_pos(std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const, glslang::AstRefType> >,
   std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char> > const&)
    */
   undefined1[16];
   std::_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>::_M_get_insert_hint_unique_pos (_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>
           *this,_Rb_tree_node_base *param_2,basic_string *param_3) {
      ulong uVar1;
      ulong uVar2;
      void *__s1;
      void *__s2;
      int iVar3;
      uint uVar4;
      long lVar5;
      ulong uVar6;
      _Rb_tree_node_base *p_Var7;
      _Rb_tree_node_base *p_Var8;
      undefined1 auVar9[16];
      undefined1 auVar10[16];
      if (param_2 == (_Rb_tree_node_base*)( this + 8 )) {
         if (*(long*)( this + 0x28 ) != 0) {
            param_2 = *(_Rb_tree_node_base**)( this + 0x20 );
            uVar1 = *(ulong*)( param_3 + 0x10 );
            uVar2 = *(ulong*)( param_2 + 0x30 );
            uVar6 = uVar1;
            if (uVar2 <= uVar1) {
               uVar6 = uVar2;
            }

            if (( uVar6 == 0 ) || ( iVar3 = memcmp(*(void**)( param_2 + 0x28 ), *(void**)( param_3 + 8 ), uVar6) ),iVar3 == 0) {
               lVar5 = uVar2 - uVar1;
               if (0x7fffffff < lVar5) goto LAB_001665a6;
               if (lVar5 < -0x80000000) goto LAB_00166537;
               iVar3 = (int)lVar5;
            }

            if (-1 < iVar3) goto LAB_001665a6;
            goto LAB_00166537;
         }

         goto LAB_001665a6;
      }

      uVar1 = *(ulong*)( param_3 + 0x10 );
      uVar2 = *(ulong*)( param_2 + 0x30 );
      __s1 = *(void**)( param_3 + 8 );
      __s2 = *(void**)( param_2 + 0x28 );
      uVar6 = uVar2;
      if (uVar1 <= uVar2) {
         uVar6 = uVar1;
      }

      p_Var7 = param_2;
      if (uVar6 == 0) {
         lVar5 = uVar1 - uVar2;
         if (( lVar5 < 0x80000000 ) && ( ( lVar5 < -0x80000000 || ( (int)lVar5 < 0 ) ) )) {
            LAB_0016645a:if (*(_Rb_tree_node_base**)( this + 0x18 ) == param_2) goto LAB_0016642c;
            p_Var8 = (_Rb_tree_node_base*)std::_Rb_tree_decrement(param_2);
            uVar2 = *(ulong*)( p_Var8 + 0x30 );
            uVar6 = uVar1;
            if (uVar2 <= uVar1) {
               uVar6 = uVar2;
            }

            if (( uVar6 == 0 ) || ( iVar3 = memcmp(*(void**)( p_Var8 + 0x28 ), __s1, uVar6) ),iVar3 == 0) {
               lVar5 = uVar2 - uVar1;
               if (0x7fffffff < lVar5) goto LAB_001665a6;
               if (-0x80000001 < lVar5) {
                  iVar3 = (int)lVar5;
                  goto LAB_001664b8;
               }

            }
 else {
               LAB_001664b8:if (-1 < iVar3) goto LAB_001665a6;
            }

            if (*(long*)( p_Var8 + 0x18 ) == 0) {
               p_Var7 = (_Rb_tree_node_base*)0x0;
               param_2 = p_Var8;
            }

            goto LAB_0016642c;
         }

         LAB_00166405:uVar6 = uVar2 - uVar1;
         if ((long)uVar6 < 0x80000000) {
            if (-0x80000001 < (long)uVar6) goto LAB_0016641f;
            goto LAB_00166550;
         }

      }
 else {
         iVar3 = memcmp(__s1, __s2, uVar6);
         if (iVar3 == 0) {
            lVar5 = uVar1 - uVar2;
            if (lVar5 < 0x80000000) {
               if (lVar5 < -0x80000000) goto LAB_0016645a;
               iVar3 = (int)lVar5;
               goto LAB_001663f4;
            }

         }
 else {
            LAB_001663f4:if (iVar3 < 0) goto LAB_0016645a;
         }

         uVar4 = memcmp(__s2, __s1, uVar6);
         uVar6 = (ulong)uVar4;
         if (uVar4 == 0) goto LAB_00166405;
         LAB_0016641f:if ((int)uVar6 < 0) {
            LAB_00166550:if (*(_Rb_tree_node_base**)( this + 0x20 ) == param_2) {
               LAB_00166537:auVar10._8_8_ = 0;
               auVar10._0_8_ = param_2;
               return auVar10 << 0x40;
            }

            p_Var8 = (_Rb_tree_node_base*)std::_Rb_tree_increment(param_2);
            uVar2 = *(ulong*)( p_Var8 + 0x30 );
            uVar6 = uVar1;
            if (uVar2 <= uVar1) {
               uVar6 = uVar2;
            }

            if (uVar6 == 0) {
               LAB_0016658c:uVar6 = uVar1 - uVar2;
               if (0x7fffffff < (long)uVar6) goto LAB_001665a6;
               if (-0x80000001 < (long)uVar6) goto LAB_001665a2;
            }
 else {
               uVar4 = memcmp(__s1, *(void**)( p_Var8 + 0x28 ), uVar6);
               uVar6 = (ulong)uVar4;
               if (uVar4 == 0) goto LAB_0016658c;
               LAB_001665a2:if (-1 < (int)uVar6) {
                  LAB_001665a6:auVar10 = _M_get_insert_unique_pos(this, param_3);
                  return auVar10;
               }

            }

            p_Var7 = (_Rb_tree_node_base*)0x0;
            if (*(long*)( param_2 + 0x18 ) != 0) {
               p_Var7 = p_Var8;
               param_2 = p_Var8;
            }

            goto LAB_0016642c;
         }

      }

      param_2 = (_Rb_tree_node_base*)0x0;
      LAB_0016642c:auVar9._8_8_ = param_2;
      auVar9._0_8_ = p_Var7;
      return auVar9;
   }

   /* std::map<std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >, glslang::AstRefType, std::less<std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char,
   std::char_traits<char>, glslang::std::allocator<char> > const, glslang::AstRefType> >
   >::operator[](std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const&) */
   map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>> * __thiscallstd::map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>::operator [](map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>> * this, basic_string * param_1);
   {
      map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>> *pmVar1;
      void *__s2;
      ulong uVar2;
      ulong uVar3;
      int iVar4;
      map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>> *pmVar5;
      long lVar6;
      ulong uVar7;
      map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>> *pmVar8;
      map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>> *pmVar9;
      long in_FS_OFFSET;
      bool bVar10;
      basic_string *local_48;
      long local_40;
      pmVar8 = this + 8;
      local_40 = *(long*)( in_FS_OFFSET + 0x28 );
      if (*(map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>**)( this + 0x10 ) != (map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>*)0x0) {
         __s2 = *(void**)( param_1 + 8 );
         uVar2 = *(ulong*)( param_1 + 0x10 );
         pmVar5 = pmVar8;
         pmVar9 = *(map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>**)( this + 0x10 );
         do {
            while (true) {
               uVar3 = *(ulong*)( pmVar9 + 0x30 );
               uVar7 = uVar2;
               if (uVar3 <= uVar2) {
                  uVar7 = uVar3;
               }

               if (( uVar7 != 0 ) && ( iVar4 = memcmp(*(void**)( pmVar9 + 0x28 ), __s2, uVar7) ),iVar4 != 0) break;
               lVar6 = uVar3 - uVar2;
               if (lVar6 < 0x80000000) {
                  if (-0x80000001 < lVar6) {
                     iVar4 = (int)lVar6;
                     break;
                  }

                  goto LAB_00166638;
               }

               LAB_00166684:pmVar1 = pmVar9 + 0x10;
               pmVar5 = pmVar9;
               pmVar9 = *(map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>**)pmVar1;
               if (*(map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>**)pmVar1 == (map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>*)0x0) goto LAB_00166690;
            }
;
            if (-1 < iVar4) goto LAB_00166684;
            LAB_00166638:pmVar9 = *(map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>**)( pmVar9 + 0x18 );
         }
 while ( pmVar9 != (map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>*)0x0 );
         LAB_00166690:bVar10 = pmVar8 != pmVar5;
         pmVar8 = pmVar5;
         if (bVar10) {
            uVar3 = *(ulong*)( pmVar5 + 0x30 );
            uVar7 = uVar2;
            if (uVar3 <= uVar2) {
               uVar7 = uVar3;
            }

            if (( uVar7 == 0 ) || ( iVar4 = memcmp(__s2, *(void**)( pmVar5 + 0x28 ), uVar7) ),iVar4 == 0) {
               lVar6 = uVar2 - uVar3;
               if (0x7fffffff < lVar6) goto LAB_001666d9;
               if (lVar6 < -0x80000000) goto LAB_00166705;
               iVar4 = (int)lVar6;
            }

            if (-1 < iVar4) goto LAB_001666d9;
         }

      }

      LAB_00166705:local_48 = param_1;
      pmVar5 = (map<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,glslang::AstRefType,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>*)_Rb_tree<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>,std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>,std::_Select1st<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>,std::less<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>>,std::allocator<std::pair<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const,glslang::AstRefType>>>::_M_emplace_hint_unique<std::piecewise_construct_t_const&,std::tuple<std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>const&>,std::tuple<>>(this, pmVar8, &local_48);
      LAB_001666d9:if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      return pmVar5 + 0x48;
   }

   /* std::_Rb_tree_node<std::pair<int const, glslang::TVector<glslang::TIntermConstantUnion const*> >
   >* std::_Rb_tree<int, std::pair<int const, glslang::TVector<glslang::TIntermConstantUnion const*>
   >, std::_Select1st<std::pair<int const, glslang::TVector<glslang::TIntermConstantUnion const*> >
   >, std::less<int>, glslang::pool_allocator<std::pair<int const,
   glslang::TVector<glslang::TIntermConstantUnion const*> > >
   >::_Reuse_or_alloc_node::TEMPNAMEPLACEHOLDERVALUE(std::pair<int const,
   glslang::TVector<glslang::TIntermConstantUnion const*> > const&) */
   _Rb_tree_node * __thiscallstd::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>::_Reuse_or_alloc_node::operator ()(_Reuse_or_alloc_node * this, pair_conflict * param_1);
   {
      ulong uVar1;
      long lVar2;
      _Rb_tree_node *p_Var3;
      long lVar4;
      long lVar5;
      long lVar6;
      p_Var3 = *(_Rb_tree_node**)( this + 8 );
      if (p_Var3 == (_Rb_tree_node*)0x0) {
         p_Var3 = (_Rb_tree_node*)glslang::TPoolAllocator::allocate(**(ulong**)( this + 0x10 ));
         *(undefined4*)( p_Var3 + 0x20 ) = *(undefined4*)param_1;
         uVar1 = glslang::GetThreadPoolAllocator();
         lVar5 = *(long*)( param_1 + 0x18 );
         lVar2 = *(long*)( param_1 + 0x10 );
         *(undefined8*)( p_Var3 + 0x30 ) = 0;
         *(ulong*)( p_Var3 + 0x28 ) = uVar1;
         *(undefined8*)( p_Var3 + 0x38 ) = 0;
         *(undefined8*)( p_Var3 + 0x40 ) = 0;
         lVar4 = 0;
         if (lVar5 - lVar2 != 0) {
            lVar4 = glslang::TPoolAllocator::allocate(uVar1);
         }

         *(long*)( p_Var3 + 0x40 ) = ( lVar5 - lVar2 ) + lVar4;
         *(long*)( p_Var3 + 0x30 ) = lVar4;
         *(long*)( p_Var3 + 0x38 ) = lVar4;
         lVar5 = *(long*)( param_1 + 0x10 );
         if (*(long*)( param_1 + 0x18 ) != lVar5) {
            lVar6 = *(long*)( param_1 + 0x18 ) - lVar5;
            lVar2 = 0;
            do {
               *(undefined8*)( lVar4 + lVar2 ) = *(undefined8*)( lVar5 + lVar2 );
               lVar2 = lVar2 + 8;
            }
 while ( lVar6 != lVar2 );
            lVar4 = lVar4 + lVar6;
         }

         *(long*)( p_Var3 + 0x38 ) = lVar4;
         return p_Var3;
      }

      lVar5 = *(long*)( p_Var3 + 8 );
      *(long*)( this + 8 ) = lVar5;
      if (lVar5 == 0) {
         *(undefined8*)this = 0;
      }
 else if (p_Var3 == *(_Rb_tree_node**)( lVar5 + 0x18 )) {
         lVar2 = *(long*)( lVar5 + 0x10 );
         *(undefined8*)( lVar5 + 0x18 ) = 0;
         if (lVar2 != 0) {
            lVar5 = *(long*)( lVar2 + 0x18 );
            *(long*)( this + 8 ) = lVar2;
            if (lVar5 != 0) {
               do {
                  lVar2 = lVar5;
                  lVar5 = *(long*)( lVar2 + 0x18 );
               }
 while ( *(long*)( lVar2 + 0x18 ) != 0 );
               *(long*)( this + 8 ) = lVar2;
            }

            if (*(long*)( lVar2 + 0x10 ) != 0) {
               *(long*)( this + 8 ) = *(long*)( lVar2 + 0x10 );
            }

         }

      }
 else {
         *(undefined8*)( lVar5 + 0x10 ) = 0;
      }

      *(undefined4*)( p_Var3 + 0x20 ) = *(undefined4*)param_1;
      uVar1 = glslang::GetThreadPoolAllocator();
      lVar5 = *(long*)( param_1 + 0x18 ) - *(long*)( param_1 + 0x10 );
      *(undefined8*)( p_Var3 + 0x30 ) = 0;
      *(ulong*)( p_Var3 + 0x28 ) = uVar1;
      *(undefined8*)( p_Var3 + 0x38 ) = 0;
      *(undefined8*)( p_Var3 + 0x40 ) = 0;
      if (lVar5 == 0) {
         lVar5 = 0;
         lVar2 = 0;
      }
 else {
         lVar2 = glslang::TPoolAllocator::allocate(uVar1);
      }

      *(long*)( p_Var3 + 0x40 ) = lVar2 + lVar5;
      *(long*)( p_Var3 + 0x30 ) = lVar2;
      *(long*)( p_Var3 + 0x38 ) = lVar2;
      lVar5 = *(long*)( param_1 + 0x18 );
      lVar4 = *(long*)( param_1 + 0x10 );
      if (lVar5 != lVar4) {
         lVar6 = 0;
         do {
            *(undefined8*)( lVar2 + lVar6 ) = *(undefined8*)( lVar4 + lVar6 );
            lVar6 = lVar6 + 8;
         }
 while ( lVar6 != lVar5 - lVar4 );
         lVar2 = lVar2 + lVar6;
      }

      *(long*)( p_Var3 + 0x38 ) = lVar2;
      return p_Var3;
   }

   /* std::_Rb_tree_node<std::pair<int const, glslang::TVector<glslang::TIntermConstantUnion const*> >
   >* std::_Rb_tree<int, std::pair<int const, glslang::TVector<glslang::TIntermConstantUnion const*>
   >, std::_Select1st<std::pair<int const, glslang::TVector<glslang::TIntermConstantUnion const*> >
   >, std::less<int>, glslang::pool_allocator<std::pair<int const,
   glslang::TVector<glslang::TIntermConstantUnion const*> > > >::_M_copy<false, std::_Rb_tree<int,
   std::pair<int const, glslang::TVector<glslang::TIntermConstantUnion const*> >,
   std::_Select1st<std::pair<int const, glslang::TVector<glslang::TIntermConstantUnion const*> > >,
   std::less<int>, glslang::pool_allocator<std::pair<int const,
   glslang::TVector<glslang::TIntermConstantUnion const*> > >
   >::_Reuse_or_alloc_node>(std::_Rb_tree_node<std::pair<int const,
   glslang::TVector<glslang::TIntermConstantUnion const*> > >*, std::_Rb_tree_node_base*,
   std::_Rb_tree<int, std::pair<int const, glslang::TVector<glslang::TIntermConstantUnion const*> >,
   std::_Select1st<std::pair<int const, glslang::TVector<glslang::TIntermConstantUnion const*> > >,
   std::less<int>, glslang::pool_allocator<std::pair<int const,
   glslang::TVector<glslang::TIntermConstantUnion const*> > > >::_Reuse_or_alloc_node&) [clone
   .isra.0] */
   _Rb_tree_node *std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>::_M_copy<false,std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>::_Reuse_or_alloc_node>(_Rb_tree_node *param_1, _Rb_tree_node_base *param_2, _Reuse_or_alloc_node *param_3) {
      undefined4 uVar1;
      _Rb_tree_node *p_Var2;
      _Rb_tree_node *p_Var3;
      ulong uVar4;
      long lVar5;
      _Rb_tree_node_base *p_Var6;
      _Rb_tree_node_base *p_Var7;
      long lVar8;
      long lVar9;
      long lVar10;
      undefined4 *puVar11;
      p_Var2 = _Reuse_or_alloc_node::operator ()(param_3, (pair_conflict*)( param_1 + 0x20 ));
      uVar1 = *(undefined4*)param_1;
      *(undefined8*)( p_Var2 + 0x10 ) = 0;
      *(undefined8*)( p_Var2 + 0x18 ) = 0;
      *(_Rb_tree_node_base**)( p_Var2 + 8 ) = param_2;
      p_Var3 = *(_Rb_tree_node**)( param_1 + 0x18 );
      *(undefined4*)p_Var2 = uVar1;
      if (p_Var3 != (_Rb_tree_node*)0x0) {
         p_Var3 = _M_copy<false,std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>::_Reuse_or_alloc_node>(p_Var3, (_Rb_tree_node_base*)p_Var2, param_3);
         *(_Rb_tree_node**)( p_Var2 + 0x18 ) = p_Var3;
      }

      puVar11 = *(undefined4**)( param_1 + 0x10 );
      if (puVar11 == (undefined4*)0x0) {
         return p_Var2;
      }

      p_Var7 = *(_Rb_tree_node_base**)( param_3 + 8 );
      p_Var3 = p_Var2;
      if (p_Var7 == (_Rb_tree_node_base*)0x0) goto LAB_00166ab3;
      do {
         p_Var6 = p_Var7;
         lVar9 = *(long*)( p_Var6 + 8 );
         *(long*)( param_3 + 8 ) = lVar9;
         if (lVar9 == 0) {
            *(undefined8*)param_3 = 0;
         }
 else if (p_Var6 == *(_Rb_tree_node_base**)( lVar9 + 0x18 )) {
            lVar5 = *(long*)( lVar9 + 0x10 );
            *(undefined8*)( lVar9 + 0x18 ) = 0;
            if (lVar5 != 0) {
               lVar9 = *(long*)( lVar5 + 0x18 );
               *(long*)( param_3 + 8 ) = lVar5;
               if (lVar9 != 0) {
                  do {
                     lVar5 = lVar9;
                     lVar9 = *(long*)( lVar5 + 0x18 );
                  }
 while ( *(long*)( lVar5 + 0x18 ) != 0 );
                  *(long*)( param_3 + 8 ) = lVar5;
               }

               if (*(long*)( lVar5 + 0x10 ) != 0) {
                  *(long*)( param_3 + 8 ) = *(long*)( lVar5 + 0x10 );
               }

            }

         }
 else {
            *(undefined8*)( lVar9 + 0x10 ) = 0;
         }

         *(undefined4*)( p_Var6 + 0x20 ) = puVar11[8];
         uVar4 = glslang::GetThreadPoolAllocator();
         lVar9 = *(long*)( puVar11 + 0xe ) - *(long*)( puVar11 + 0xc );
         *(undefined8*)( p_Var6 + 0x30 ) = 0;
         *(ulong*)( p_Var6 + 0x28 ) = uVar4;
         *(undefined8*)( p_Var6 + 0x38 ) = 0;
         *(undefined8*)( p_Var6 + 0x40 ) = 0;
         if (lVar9 == 0) {
            lVar9 = 0;
            lVar5 = 0;
         }
 else {
            lVar5 = glslang::TPoolAllocator::allocate(uVar4);
         }

         *(long*)( p_Var6 + 0x40 ) = lVar5 + lVar9;
         *(long*)( p_Var6 + 0x30 ) = lVar5;
         *(long*)( p_Var6 + 0x38 ) = lVar5;
         lVar9 = *(long*)( puVar11 + 0xe );
         lVar8 = *(long*)( puVar11 + 0xc );
         if (lVar9 != lVar8) {
            lVar10 = 0;
            do {
               *(undefined8*)( lVar5 + lVar10 ) = *(undefined8*)( lVar8 + lVar10 );
               lVar10 = lVar10 + 8;
            }
 while ( lVar10 != lVar9 - lVar8 );
            lVar5 = lVar5 + lVar10;
         }

         *(long*)( p_Var6 + 0x38 ) = lVar5;
         while (true) {
            uVar1 = *puVar11;
            *(undefined8*)( p_Var6 + 0x10 ) = 0;
            *(undefined8*)( p_Var6 + 0x18 ) = 0;
            *(undefined4*)p_Var6 = uVar1;
            *(_Rb_tree_node_base**)( p_Var3 + 0x10 ) = p_Var6;
            *(_Rb_tree_node**)( p_Var6 + 8 ) = p_Var3;
            if (*(_Rb_tree_node**)( puVar11 + 6 ) != (_Rb_tree_node*)0x0) {
               p_Var3 = _M_copy<false,std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>::_Reuse_or_alloc_node>(*(_Rb_tree_node**)( puVar11 + 6 ), p_Var6, param_3);
               *(_Rb_tree_node**)( p_Var6 + 0x18 ) = p_Var3;
            }

            puVar11 = *(undefined4**)( puVar11 + 4 );
            if (puVar11 == (undefined4*)0x0) {
               return p_Var2;
            }

            p_Var7 = *(_Rb_tree_node_base**)( param_3 + 8 );
            p_Var3 = (_Rb_tree_node*)p_Var6;
            if (p_Var7 != (_Rb_tree_node_base*)0x0) break;
            LAB_00166ab3:p_Var6 = (_Rb_tree_node_base*)glslang::TPoolAllocator::allocate(**(ulong**)( param_3 + 0x10 ));
            *(undefined4*)( p_Var6 + 0x20 ) = puVar11[8];
            uVar4 = glslang::GetThreadPoolAllocator();
            lVar9 = *(long*)( puVar11 + 0xe );
            lVar5 = *(long*)( puVar11 + 0xc );
            *(undefined8*)( p_Var6 + 0x30 ) = 0;
            *(ulong*)( p_Var6 + 0x28 ) = uVar4;
            *(undefined8*)( p_Var6 + 0x38 ) = 0;
            *(undefined8*)( p_Var6 + 0x40 ) = 0;
            if (lVar9 - lVar5 != 0) {
               p_Var7 = (_Rb_tree_node_base*)glslang::TPoolAllocator::allocate(uVar4);
            }

            *(_Rb_tree_node_base**)( p_Var6 + 0x40 ) = p_Var7 + ( lVar9 - lVar5 );
            *(_Rb_tree_node_base**)( p_Var6 + 0x30 ) = p_Var7;
            *(_Rb_tree_node_base**)( p_Var6 + 0x38 ) = p_Var7;
            lVar9 = *(long*)( puVar11 + 0xc );
            if (*(long*)( puVar11 + 0xe ) != lVar9) {
               lVar8 = *(long*)( puVar11 + 0xe ) - lVar9;
               lVar5 = 0;
               do {
                  *(undefined8*)( p_Var7 + lVar5 ) = *(undefined8*)( lVar9 + lVar5 );
                  lVar5 = lVar5 + 8;
               }
 while ( lVar8 != lVar5 );
               p_Var7 = p_Var7 + lVar8;
            }

            *(_Rb_tree_node_base**)( p_Var6 + 0x38 ) = p_Var7;
         }
;
      }
 while ( true );
   }

   /* std::_Rb_tree<int, std::pair<int const, glslang::TVector<glslang::TIntermConstantUnion const*> >,
   std::_Select1st<std::pair<int const, glslang::TVector<glslang::TIntermConstantUnion const*> > >,
   std::less<int>, glslang::pool_allocator<std::pair<int const,
   glslang::TVector<glslang::TIntermConstantUnion const*> > >
   >::TEMPNAMEPLACEHOLDERVALUE(std::_Rb_tree<int, std::pair<int const,
   glslang::TVector<glslang::TIntermConstantUnion const*> >, std::_Select1st<std::pair<int const,
   glslang::TVector<glslang::TIntermConstantUnion const*> > >, std::less<int>,
   glslang::pool_allocator<std::pair<int const, glslang::TVector<glslang::TIntermConstantUnion
   const*> > > > const&) [clone .part.0] */
   void std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>::operator =(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>> *this, _Rb_tree *param_1) {
      undefined8 uVar1;
      _Rb_tree_node *p_Var2;
      _Rb_tree_node *p_Var3;
      long lVar4;
      _Rb_tree_node *p_Var5;
      long in_FS_OFFSET;
      long local_38;
      long lStack_30;
      _Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>> *local_28;
      long local_20;
      local_38 = *(long*)( this + 0x18 );
      local_20 = *(long*)( in_FS_OFFSET + 0x28 );
      lStack_30 = *(long*)( this + 0x28 );
      local_28 = this;
      if (local_38 == 0) {
         *(undefined8*)( this + 0x18 ) = 0;
         *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( this + 0x20 ) = this + 0x10;
         *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( this + 0x28 ) = this + 0x10;
         *(undefined8*)( this + 0x30 ) = 0;
         p_Var5 = *(_Rb_tree_node**)( param_1 + 0x18 );
         lStack_30 = 0;
         if (p_Var5 == (_Rb_tree_node*)0x0) goto LAB_00166cd2;
         LAB_00166c6f:p_Var2 = _M_copy<false,std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>::_Reuse_or_alloc_node>(p_Var5, (_Rb_tree_node_base*)( this + 0x10 ), (_Reuse_or_alloc_node*)&local_38);
         p_Var5 = p_Var2;
         do {
            p_Var3 = p_Var5;
            p_Var5 = *(_Rb_tree_node**)( p_Var3 + 0x10 );
         }
 while ( p_Var5 != (_Rb_tree_node*)0x0 );
         *(_Rb_tree_node**)( this + 0x20 ) = p_Var3;
         p_Var5 = p_Var2;
         do {
            p_Var3 = p_Var5;
            p_Var5 = *(_Rb_tree_node**)( p_Var3 + 0x18 );
         }
 while ( p_Var5 != (_Rb_tree_node*)0x0 );
         uVar1 = *(undefined8*)( param_1 + 0x30 );
         *(_Rb_tree_node**)( this + 0x28 ) = p_Var3;
         *(_Rb_tree_node**)( this + 0x18 ) = p_Var2;
         *(undefined8*)( this + 0x30 ) = uVar1;
         lVar4 = local_38;
         if (local_38 == 0) goto LAB_00166cd2;
      }
 else {
         lVar4 = *(long*)( lStack_30 + 0x10 );
         *(undefined8*)( local_38 + 8 ) = 0;
         if (lVar4 != 0) {
            lStack_30 = lVar4;
         }

         *(undefined8*)( this + 0x18 ) = 0;
         p_Var5 = *(_Rb_tree_node**)( param_1 + 0x18 );
         *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( this + 0x20 ) = this + 0x10;
         *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( this + 0x28 ) = this + 0x10;
         *(undefined8*)( this + 0x30 ) = 0;
         lVar4 = local_38;
         if (p_Var5 != (_Rb_tree_node*)0x0) goto LAB_00166c6f;
      }

      do {
         _M_erase(*(_Rb_tree_node**)( lVar4 + 0x18 ));
         lVar4 = *(long*)( lVar4 + 0x10 );
      }
 while ( lVar4 != 0 );
      LAB_00166cd2:if (local_20 != *(long*)( in_FS_OFFSET + 0x28 )) {
         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      return;
   }

   /* std::_Rb_tree_node<std::pair<int const, glslang::TVector<glslang::TIntermTyped const*> > >*
   std::_Rb_tree<int, std::pair<int const, glslang::TVector<glslang::TIntermTyped const*> >,
   std::_Select1st<std::pair<int const, glslang::TVector<glslang::TIntermTyped const*> > >,
   std::less<int>, glslang::pool_allocator<std::pair<int const,
   glslang::TVector<glslang::TIntermTyped const*> > >
   >::_Reuse_or_alloc_node::TEMPNAMEPLACEHOLDERVALUE(std::pair<int const,
   glslang::TVector<glslang::TIntermTyped const*> > const&) */
   _Rb_tree_node * __thiscallstd::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>>::_Reuse_or_alloc_node::operator ()(_Reuse_or_alloc_node * this, pair_conflict * param_1);
   {
      ulong uVar1;
      long lVar2;
      _Rb_tree_node *p_Var3;
      long lVar4;
      long lVar5;
      long lVar6;
      p_Var3 = *(_Rb_tree_node**)( this + 8 );
      if (p_Var3 == (_Rb_tree_node*)0x0) {
         p_Var3 = (_Rb_tree_node*)glslang::TPoolAllocator::allocate(**(ulong**)( this + 0x10 ));
         *(undefined4*)( p_Var3 + 0x20 ) = *(undefined4*)param_1;
         uVar1 = glslang::GetThreadPoolAllocator();
         lVar5 = *(long*)( param_1 + 0x18 );
         lVar2 = *(long*)( param_1 + 0x10 );
         *(undefined8*)( p_Var3 + 0x30 ) = 0;
         *(ulong*)( p_Var3 + 0x28 ) = uVar1;
         *(undefined8*)( p_Var3 + 0x38 ) = 0;
         *(undefined8*)( p_Var3 + 0x40 ) = 0;
         lVar4 = 0;
         if (lVar5 - lVar2 != 0) {
            lVar4 = glslang::TPoolAllocator::allocate(uVar1);
         }

         *(long*)( p_Var3 + 0x40 ) = ( lVar5 - lVar2 ) + lVar4;
         *(long*)( p_Var3 + 0x30 ) = lVar4;
         *(long*)( p_Var3 + 0x38 ) = lVar4;
         lVar5 = *(long*)( param_1 + 0x10 );
         if (*(long*)( param_1 + 0x18 ) != lVar5) {
            lVar6 = *(long*)( param_1 + 0x18 ) - lVar5;
            lVar2 = 0;
            do {
               *(undefined8*)( lVar4 + lVar2 ) = *(undefined8*)( lVar5 + lVar2 );
               lVar2 = lVar2 + 8;
            }
 while ( lVar6 != lVar2 );
            lVar4 = lVar4 + lVar6;
         }

         *(long*)( p_Var3 + 0x38 ) = lVar4;
         return p_Var3;
      }

      lVar5 = *(long*)( p_Var3 + 8 );
      *(long*)( this + 8 ) = lVar5;
      if (lVar5 == 0) {
         *(undefined8*)this = 0;
      }
 else if (p_Var3 == *(_Rb_tree_node**)( lVar5 + 0x18 )) {
         lVar2 = *(long*)( lVar5 + 0x10 );
         *(undefined8*)( lVar5 + 0x18 ) = 0;
         if (lVar2 != 0) {
            lVar5 = *(long*)( lVar2 + 0x18 );
            *(long*)( this + 8 ) = lVar2;
            if (lVar5 != 0) {
               do {
                  lVar2 = lVar5;
                  lVar5 = *(long*)( lVar2 + 0x18 );
               }
 while ( *(long*)( lVar2 + 0x18 ) != 0 );
               *(long*)( this + 8 ) = lVar2;
            }

            if (*(long*)( lVar2 + 0x10 ) != 0) {
               *(long*)( this + 8 ) = *(long*)( lVar2 + 0x10 );
            }

         }

      }
 else {
         *(undefined8*)( lVar5 + 0x10 ) = 0;
      }

      *(undefined4*)( p_Var3 + 0x20 ) = *(undefined4*)param_1;
      uVar1 = glslang::GetThreadPoolAllocator();
      lVar5 = *(long*)( param_1 + 0x18 ) - *(long*)( param_1 + 0x10 );
      *(undefined8*)( p_Var3 + 0x30 ) = 0;
      *(ulong*)( p_Var3 + 0x28 ) = uVar1;
      *(undefined8*)( p_Var3 + 0x38 ) = 0;
      *(undefined8*)( p_Var3 + 0x40 ) = 0;
      if (lVar5 == 0) {
         lVar5 = 0;
         lVar2 = 0;
      }
 else {
         lVar2 = glslang::TPoolAllocator::allocate(uVar1);
      }

      *(long*)( p_Var3 + 0x40 ) = lVar2 + lVar5;
      *(long*)( p_Var3 + 0x30 ) = lVar2;
      *(long*)( p_Var3 + 0x38 ) = lVar2;
      lVar5 = *(long*)( param_1 + 0x18 );
      lVar4 = *(long*)( param_1 + 0x10 );
      if (lVar5 != lVar4) {
         lVar6 = 0;
         do {
            *(undefined8*)( lVar2 + lVar6 ) = *(undefined8*)( lVar4 + lVar6 );
            lVar6 = lVar6 + 8;
         }
 while ( lVar6 != lVar5 - lVar4 );
         lVar2 = lVar2 + lVar6;
      }

      *(long*)( p_Var3 + 0x38 ) = lVar2;
      return p_Var3;
   }

   /* std::_Rb_tree_node<std::pair<int const, glslang::TVector<glslang::TIntermTyped const*> > >*
   std::_Rb_tree<int, std::pair<int const, glslang::TVector<glslang::TIntermTyped const*> >,
   std::_Select1st<std::pair<int const, glslang::TVector<glslang::TIntermTyped const*> > >,
   std::less<int>, glslang::pool_allocator<std::pair<int const,
   glslang::TVector<glslang::TIntermTyped const*> > > >::_M_copy<false, std::_Rb_tree<int,
   std::pair<int const, glslang::TVector<glslang::TIntermTyped const*> >,
   std::_Select1st<std::pair<int const, glslang::TVector<glslang::TIntermTyped const*> > >,
   std::less<int>, glslang::pool_allocator<std::pair<int const,
   glslang::TVector<glslang::TIntermTyped const*> > >
   >::_Reuse_or_alloc_node>(std::_Rb_tree_node<std::pair<int const,
   glslang::TVector<glslang::TIntermTyped const*> > >*, std::_Rb_tree_node_base*, std::_Rb_tree<int,
   std::pair<int const, glslang::TVector<glslang::TIntermTyped const*> >,
   std::_Select1st<std::pair<int const, glslang::TVector<glslang::TIntermTyped const*> > >,
   std::less<int>, glslang::pool_allocator<std::pair<int const,
   glslang::TVector<glslang::TIntermTyped const*> > > >::_Reuse_or_alloc_node&) [clone .isra.0] */
   _Rb_tree_node *std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>>::_M_copy<false,std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>>::_Reuse_or_alloc_node>(_Rb_tree_node *param_1, _Rb_tree_node_base *param_2, _Reuse_or_alloc_node *param_3) {
      undefined4 uVar1;
      _Rb_tree_node *p_Var2;
      _Rb_tree_node *p_Var3;
      ulong uVar4;
      long lVar5;
      _Rb_tree_node_base *p_Var6;
      _Rb_tree_node_base *p_Var7;
      long lVar8;
      long lVar9;
      long lVar10;
      undefined4 *puVar11;
      p_Var2 = _Reuse_or_alloc_node::operator ()(param_3, (pair_conflict*)( param_1 + 0x20 ));
      uVar1 = *(undefined4*)param_1;
      *(undefined8*)( p_Var2 + 0x10 ) = 0;
      *(undefined8*)( p_Var2 + 0x18 ) = 0;
      *(_Rb_tree_node_base**)( p_Var2 + 8 ) = param_2;
      p_Var3 = *(_Rb_tree_node**)( param_1 + 0x18 );
      *(undefined4*)p_Var2 = uVar1;
      if (p_Var3 != (_Rb_tree_node*)0x0) {
         p_Var3 = _M_copy<false,std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>>::_Reuse_or_alloc_node>(p_Var3, (_Rb_tree_node_base*)p_Var2, param_3);
         *(_Rb_tree_node**)( p_Var2 + 0x18 ) = p_Var3;
      }

      puVar11 = *(undefined4**)( param_1 + 0x10 );
      if (puVar11 == (undefined4*)0x0) {
         return p_Var2;
      }

      p_Var7 = *(_Rb_tree_node_base**)( param_3 + 8 );
      p_Var3 = p_Var2;
      if (p_Var7 == (_Rb_tree_node_base*)0x0) goto LAB_001670b3;
      do {
         p_Var6 = p_Var7;
         lVar9 = *(long*)( p_Var6 + 8 );
         *(long*)( param_3 + 8 ) = lVar9;
         if (lVar9 == 0) {
            *(undefined8*)param_3 = 0;
         }
 else if (p_Var6 == *(_Rb_tree_node_base**)( lVar9 + 0x18 )) {
            lVar5 = *(long*)( lVar9 + 0x10 );
            *(undefined8*)( lVar9 + 0x18 ) = 0;
            if (lVar5 != 0) {
               lVar9 = *(long*)( lVar5 + 0x18 );
               *(long*)( param_3 + 8 ) = lVar5;
               if (lVar9 != 0) {
                  do {
                     lVar5 = lVar9;
                     lVar9 = *(long*)( lVar5 + 0x18 );
                  }
 while ( *(long*)( lVar5 + 0x18 ) != 0 );
                  *(long*)( param_3 + 8 ) = lVar5;
               }

               if (*(long*)( lVar5 + 0x10 ) != 0) {
                  *(long*)( param_3 + 8 ) = *(long*)( lVar5 + 0x10 );
               }

            }

         }
 else {
            *(undefined8*)( lVar9 + 0x10 ) = 0;
         }

         *(undefined4*)( p_Var6 + 0x20 ) = puVar11[8];
         uVar4 = glslang::GetThreadPoolAllocator();
         lVar9 = *(long*)( puVar11 + 0xe ) - *(long*)( puVar11 + 0xc );
         *(undefined8*)( p_Var6 + 0x30 ) = 0;
         *(ulong*)( p_Var6 + 0x28 ) = uVar4;
         *(undefined8*)( p_Var6 + 0x38 ) = 0;
         *(undefined8*)( p_Var6 + 0x40 ) = 0;
         if (lVar9 == 0) {
            lVar9 = 0;
            lVar5 = 0;
         }
 else {
            lVar5 = glslang::TPoolAllocator::allocate(uVar4);
         }

         *(long*)( p_Var6 + 0x40 ) = lVar5 + lVar9;
         *(long*)( p_Var6 + 0x30 ) = lVar5;
         *(long*)( p_Var6 + 0x38 ) = lVar5;
         lVar9 = *(long*)( puVar11 + 0xe );
         lVar8 = *(long*)( puVar11 + 0xc );
         if (lVar9 != lVar8) {
            lVar10 = 0;
            do {
               *(undefined8*)( lVar5 + lVar10 ) = *(undefined8*)( lVar8 + lVar10 );
               lVar10 = lVar10 + 8;
            }
 while ( lVar10 != lVar9 - lVar8 );
            lVar5 = lVar5 + lVar10;
         }

         *(long*)( p_Var6 + 0x38 ) = lVar5;
         while (true) {
            uVar1 = *puVar11;
            *(undefined8*)( p_Var6 + 0x10 ) = 0;
            *(undefined8*)( p_Var6 + 0x18 ) = 0;
            *(undefined4*)p_Var6 = uVar1;
            *(_Rb_tree_node_base**)( p_Var3 + 0x10 ) = p_Var6;
            *(_Rb_tree_node**)( p_Var6 + 8 ) = p_Var3;
            if (*(_Rb_tree_node**)( puVar11 + 6 ) != (_Rb_tree_node*)0x0) {
               p_Var3 = _M_copy<false,std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>>::_Reuse_or_alloc_node>(*(_Rb_tree_node**)( puVar11 + 6 ), p_Var6, param_3);
               *(_Rb_tree_node**)( p_Var6 + 0x18 ) = p_Var3;
            }

            puVar11 = *(undefined4**)( puVar11 + 4 );
            if (puVar11 == (undefined4*)0x0) {
               return p_Var2;
            }

            p_Var7 = *(_Rb_tree_node_base**)( param_3 + 8 );
            p_Var3 = (_Rb_tree_node*)p_Var6;
            if (p_Var7 != (_Rb_tree_node_base*)0x0) break;
            LAB_001670b3:p_Var6 = (_Rb_tree_node_base*)glslang::TPoolAllocator::allocate(**(ulong**)( param_3 + 0x10 ));
            *(undefined4*)( p_Var6 + 0x20 ) = puVar11[8];
            uVar4 = glslang::GetThreadPoolAllocator();
            lVar9 = *(long*)( puVar11 + 0xe );
            lVar5 = *(long*)( puVar11 + 0xc );
            *(undefined8*)( p_Var6 + 0x30 ) = 0;
            *(ulong*)( p_Var6 + 0x28 ) = uVar4;
            *(undefined8*)( p_Var6 + 0x38 ) = 0;
            *(undefined8*)( p_Var6 + 0x40 ) = 0;
            if (lVar9 - lVar5 != 0) {
               p_Var7 = (_Rb_tree_node_base*)glslang::TPoolAllocator::allocate(uVar4);
            }

            *(_Rb_tree_node_base**)( p_Var6 + 0x40 ) = p_Var7 + ( lVar9 - lVar5 );
            *(_Rb_tree_node_base**)( p_Var6 + 0x30 ) = p_Var7;
            *(_Rb_tree_node_base**)( p_Var6 + 0x38 ) = p_Var7;
            lVar9 = *(long*)( puVar11 + 0xc );
            if (*(long*)( puVar11 + 0xe ) != lVar9) {
               lVar8 = *(long*)( puVar11 + 0xe ) - lVar9;
               lVar5 = 0;
               do {
                  *(undefined8*)( p_Var7 + lVar5 ) = *(undefined8*)( lVar9 + lVar5 );
                  lVar5 = lVar5 + 8;
               }
 while ( lVar8 != lVar5 );
               p_Var7 = p_Var7 + lVar8;
            }

            *(_Rb_tree_node_base**)( p_Var6 + 0x38 ) = p_Var7;
         }
;
      }
 while ( true );
   }

   /* glslang::TType::deepCopy(glslang::TType const&,
   glslang::TMap<glslang::TVector<glslang::TTypeLoc>*, glslang::TVector<glslang::TTypeLoc>*,
   std::less<glslang::TVector<glslang::TTypeLoc>*> >&) */
   void glslang::TType::deepCopy(TType *this, TType *param_1, TMap *param_2) {
      TMap *pTVar1;
      _Rb_tree_node_base *p_Var2;
      _Rb_tree *p_Var3;
      TType TVar4;
      undefined4 uVar5;
      _Rb_tree *p_Var6;
      _Rb_tree_node *p_Var7;
      basic_string *pbVar8;
      char *pcVar9;
      vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>> *pvVar10;
      long lVar11;
      undefined8 uVar12;
      TMap *pTVar13;
      TType TVar14;
      char cVar15;
      ulong uVar16;
      _Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>> *this_00;
      undefined8 uVar17;
      _Rb_tree_node *p_Var18;
      basic_string<char,std::char_traits<char>,glslang::std::allocator<char>> *pbVar19;
      undefined8 *puVar20;
      vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>> *pvVar21;
      undefined4 *puVar22;
      long lVar23;
      size_t sVar24;
      long *plVar25;
      ulong uVar26;
      _Rb_tree_node *p_Var27;
      long lVar28;
      long lVar29;
      TMap *pTVar30;
      TMap *pTVar31;
      long in_FS_OFFSET;
      _Rb_tree_node *local_68;
      long lStack_60;
      _Rb_tree *p_Stack_58;
      undefined8 uStack_50;
      long local_40;
      uVar17 = *(undefined8*)( param_1 + 0x18 );
      TVar14 = param_1[8];
      local_40 = *(long*)( in_FS_OFFSET + 0x28 );
      uVar5 = *(undefined4*)( param_1 + 0x80 );
      *(undefined8*)( this + 0x10 ) = *(undefined8*)( param_1 + 0x10 );
      *(undefined8*)( this + 0x18 ) = uVar17;
      uVar17 = *(undefined8*)( param_1 + 0x20 );
      uVar12 = *(undefined8*)( param_1 + 0x28 );
      this[8] = TVar14;
      *(undefined8*)( this + 0x20 ) = uVar17;
      *(undefined8*)( this + 0x28 ) = uVar12;
      uVar17 = *(undefined8*)( param_1 + 0x30 );
      uVar12 = *(undefined8*)( param_1 + 0x38 );
      *(undefined4*)( this + 0x80 ) = uVar5;
      *(undefined8*)( this + 0x30 ) = uVar17;
      *(undefined8*)( this + 0x38 ) = uVar12;
      uVar17 = *(undefined8*)( param_1 + 0x48 );
      *(undefined8*)( this + 0x40 ) = *(undefined8*)( param_1 + 0x40 );
      *(undefined8*)( this + 0x48 ) = uVar17;
      uVar17 = *(undefined8*)( param_1 + 0x58 );
      *(undefined8*)( this + 0x50 ) = *(undefined8*)( param_1 + 0x50 );
      *(undefined8*)( this + 0x58 ) = uVar17;
      TVar14 = param_1[9];
      this[9] = ( TType )((byte)this[9] & 0xf0 | (byte)TVar14 & 0xf);
      this[9] = ( TType )((byte)TVar14 & 0xf | (byte)param_1[9] & 0xf0);
      TVar14 = this[10];
      TVar4 = param_1[10];
      this[10] = ( TType )((byte)TVar14 & 0xf0 | (byte)TVar4 & 0xf);
      TVar14 = ( TType )((byte)TVar14 & 0xe0 | (byte)TVar4 & 0xf | (byte)param_1[10] & 0x10);
      this[10] = TVar14;
      uVar17 = *(undefined8*)( param_1 + 0x70 );
      uVar12 = *(undefined8*)( param_1 + 0x78 );
      *(undefined8*)( this + 0x60 ) = *(undefined8*)( param_1 + 0x60 );
      *(undefined8*)( this + 0x70 ) = uVar17;
      *(undefined8*)( this + 0x78 ) = uVar12;
      if (*(code**)( *(long*)this + 0x128 ) != isStruct) {
         ( **(code**)( *(long*)this + 0x128 ) )();
         TVar14 = this[10];
      }

      *(undefined8*)( this + 0x68 ) = *(undefined8*)( param_1 + 0x68 );
      uVar17 = *(undefined8*)( param_1 + 0x90 );
      *(undefined8*)( this + 0x88 ) = *(undefined8*)( param_1 + 0x88 );
      *(undefined8*)( this + 0x90 ) = uVar17;
      TVar4 = param_1[10];
      this[10] = ( TType )((byte)TVar14 & 0xdf | (byte)TVar4 & 0x20);
      this[10] = ( TType )((byte)TVar14 & 0x9f | (byte)TVar4 & 0x20 | (byte)param_1[10] & 0x40);
      *(ushort*)( this + 10 ) = *(ushort*)( this + 10 ) & 0xfc7f | *(ushort*)( param_1 + 10 ) & 0x380;
      this[0xb] = ( TType )((byte)this[0xb] & 0xfb | (byte)param_1[0xb] & 4);
      if (*(long*)( param_1 + 0x50 ) != 0) {
         uVar16 = glslang::GetThreadPoolAllocator();
         this_00 = (_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>*)glslang::TPoolAllocator::allocate(uVar16);
         uVar17 = glslang::GetThreadPoolAllocator();
         p_Var2 = (_Rb_tree_node_base*)( this_00 + 0x48 );
         *(undefined4*)( this_00 + 0x10 ) = 0;
         *(undefined8*)this_00 = uVar17;
         *(undefined8*)( this_00 + 0x18 ) = 0;
         *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( this_00 + 0x20 ) = this_00 + 0x10;
         *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( this_00 + 0x28 ) = this_00 + 0x10;
         *(undefined8*)( this_00 + 0x30 ) = 0;
         uVar17 = glslang::GetThreadPoolAllocator();
         *(_Rb_tree_node_base**)( this_00 + 0x58 ) = p_Var2;
         *(undefined8*)( this_00 + 0x38 ) = uVar17;
         *(undefined4*)( this_00 + 0x48 ) = 0;
         *(undefined8*)( this_00 + 0x50 ) = 0;
         *(_Rb_tree_node_base**)( this_00 + 0x60 ) = p_Var2;
         *(undefined8*)( this_00 + 0x68 ) = 0;
         uVar17 = glslang::GetThreadPoolAllocator();
         *(undefined4*)( this_00 + 0x80 ) = 0;
         *(undefined8*)( this_00 + 0x70 ) = uVar17;
         *(undefined8*)( this_00 + 0x88 ) = 0;
         *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( this_00 + 0x90 ) = this_00 + 0x80;
         *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( this_00 + 0x98 ) = this_00 + 0x80;
         *(undefined8*)( this_00 + 0xa0 ) = 0;
         *(_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>**)( this + 0x50 ) = this_00;
         p_Var6 = *(_Rb_tree**)( param_1 + 0x50 );
         if (p_Var6 != (_Rb_tree*)this_00) {
            std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>::operator =(this_00, p_Var6);
         }

         p_Var3 = (_Rb_tree*)( this_00 + 0x38 );
         if (p_Var3 != p_Var6 + 0x38) {
            local_68 = *(_Rb_tree_node**)( this_00 + 0x50 );
            lStack_60 = *(long*)( this_00 + 0x60 );
            if (local_68 == (_Rb_tree_node*)0x0) {
               lStack_60 = 0;
            }
 else {
               lVar29 = *(long*)( lStack_60 + 0x10 );
               *(undefined8*)( local_68 + 8 ) = 0;
               if (lVar29 != 0) {
                  lStack_60 = lVar29;
               }

            }

            *(undefined8*)( this_00 + 0x50 ) = 0;
            p_Var7 = *(_Rb_tree_node**)( p_Var6 + 0x50 );
            *(_Rb_tree_node_base**)( this_00 + 0x58 ) = p_Var2;
            *(_Rb_tree_node_base**)( this_00 + 0x60 ) = p_Var2;
            *(undefined8*)( this_00 + 0x68 ) = 0;
            p_Stack_58 = p_Var3;
            if (p_Var7 != (_Rb_tree_node*)0x0) {
               p_Var18 = std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>>::_M_copy<false,std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>>::_Reuse_or_alloc_node>(p_Var7, p_Var2, (_Reuse_or_alloc_node*)&local_68);
               p_Var7 = p_Var18;
               do {
                  p_Var27 = p_Var7;
                  p_Var7 = *(_Rb_tree_node**)( p_Var27 + 0x10 );
               }
 while ( p_Var7 != (_Rb_tree_node*)0x0 );
               *(_Rb_tree_node**)( this_00 + 0x58 ) = p_Var27;
               p_Var7 = p_Var18;
               do {
                  p_Var27 = p_Var7;
                  p_Var7 = *(_Rb_tree_node**)( p_Var27 + 0x18 );
               }
 while ( p_Var7 != (_Rb_tree_node*)0x0 );
               uVar17 = *(undefined8*)( p_Var6 + 0x68 );
               *(_Rb_tree_node**)( this_00 + 0x60 ) = p_Var27;
               *(_Rb_tree_node**)( this_00 + 0x50 ) = p_Var18;
               *(undefined8*)( this_00 + 0x68 ) = uVar17;
            }

            std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermTyped_const*>>>>::_M_erase(local_68);
         }

         if (p_Var6 + 0x70 != (_Rb_tree*)( this_00 + 0x70 )) {
            std::_Rb_tree<int,std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>,std::_Select1st<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>,std::less<int>,glslang::pool_allocator<std::pair<int_const,glslang::TVector<glslang::TIntermConstantUnion_const*>>>>::operator =(this_00 + 0x70, p_Var6 + 0x70);
         }

      }

      if (*(long*)( param_1 + 0x90 ) != 0) {
         uVar16 = glslang::GetThreadPoolAllocator();
         pbVar19 = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>*)glslang::TPoolAllocator::allocate(uVar16);
         uVar17 = glslang::GetThreadPoolAllocator();
         pbVar19[0x18] = (basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>)0x0;
         *(undefined8*)pbVar19 = uVar17;
         *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( pbVar19 + 8 ) = pbVar19 + 0x18;
         *(undefined8*)( pbVar19 + 0x10 ) = 0;
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::assign(pbVar19, "");
         *(undefined4*)( pbVar19 + 0x28 ) = 0xffffffff;
         uVar17 = glslang::GetThreadPoolAllocator();
         *(undefined8*)( pbVar19 + 0x38 ) = 0;
         *(undefined8*)( pbVar19 + 0x30 ) = uVar17;
         *(undefined8*)( pbVar19 + 0x40 ) = 0;
         *(undefined8*)( pbVar19 + 0x48 ) = 0;
         *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( this + 0x90 ) = pbVar19;
         pbVar8 = *(basic_string**)( param_1 + 0x90 );
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_assign(pbVar19, pbVar8);
         *(undefined4*)( pbVar19 + 0x28 ) = *(undefined4*)( pbVar8 + 0x28 );
         std::vector<glslang::TSpirvTypeParameter,glslang::pool_allocator<glslang::TSpirvTypeParameter>>::operator =((vector<glslang::TSpirvTypeParameter,glslang::pool_allocator<glslang::TSpirvTypeParameter>>*)( pbVar19 + 0x30 ), (vector*)( pbVar8 + 0x30 ));
      }

      if (*(long*)( param_1 + 0x60 ) != 0) {
         uVar16 = glslang::GetThreadPoolAllocator();
         puVar20 = (undefined8*)glslang::TPoolAllocator::allocate(uVar16);
         *(undefined4*)( puVar20 + 2 ) = 0;
         *(undefined2*)( (long)puVar20 + 0x14 ) = 1;
         *puVar20 = &PTR__TSmallArrayVector_00167ee0;
         puVar20[1] = 0;
         *(undefined8**)( this + 0x60 ) = puVar20;
         lVar29 = *(long*)( param_1 + 0x60 );
         lVar28 = *(long*)( lVar29 + 8 );
         *(undefined4*)( puVar20 + 2 ) = *(undefined4*)( lVar29 + 0x10 );
         *(undefined1*)( (long)puVar20 + 0x15 ) = *(undefined1*)( lVar29 + 0x15 );
         if (lVar28 == 0) {
            puVar20[1] = 0;
         }
 else {
            uVar16 = glslang::GetThreadPoolAllocator();
            pvVar21 = (vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>*)glslang::TPoolAllocator::allocate(uVar16);
            uVar17 = glslang::GetThreadPoolAllocator();
            *(undefined8*)( pvVar21 + 8 ) = 0;
            *(undefined8*)pvVar21 = uVar17;
            *(undefined8*)( pvVar21 + 0x10 ) = 0;
            *(undefined8*)( pvVar21 + 0x18 ) = 0;
            puVar20[1] = pvVar21;
            std::vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>::operator =(pvVar21, *(vector**)( lVar29 + 8 ));
         }

         *(undefined1*)( (long)puVar20 + 0x14 ) = *(undefined1*)( lVar29 + 0x14 );
      }

      if (*(long*)( param_1 + 0x88 ) != 0) {
         uVar16 = glslang::GetThreadPoolAllocator();
         puVar22 = (undefined4*)glslang::TPoolAllocator::allocate(uVar16);
         *(undefined1(*) [16])( puVar22 + 2 ) = (undefined1[16])0x0;
         *puVar22 = 0;
         *(undefined4**)( this + 0x88 ) = puVar22;
         uVar16 = glslang::GetThreadPoolAllocator();
         puVar20 = (undefined8*)glslang::TPoolAllocator::allocate(uVar16);
         *(undefined2*)( (long)puVar20 + 0x14 ) = 1;
         lVar28 = *(long*)( param_1 + 0x88 );
         *puVar20 = &PTR__TSmallArrayVector_00167ee0;
         lVar23 = *(long*)( this + 0x88 );
         *(undefined4*)( puVar20 + 2 ) = 0;
         puVar20[1] = 0;
         *(undefined8**)( lVar23 + 8 ) = puVar20;
         lVar29 = *(long*)( lVar28 + 8 );
         lVar11 = *(long*)( lVar29 + 8 );
         *(undefined4*)( puVar20 + 2 ) = *(undefined4*)( lVar29 + 0x10 );
         *(undefined1*)( (long)puVar20 + 0x15 ) = *(undefined1*)( lVar29 + 0x15 );
         if (lVar11 == 0) {
            puVar20[1] = 0;
         }
 else {
            uVar16 = glslang::GetThreadPoolAllocator();
            pvVar21 = (vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>*)glslang::TPoolAllocator::allocate(uVar16);
            uVar17 = glslang::GetThreadPoolAllocator();
            *(undefined8*)( pvVar21 + 8 ) = 0;
            *(undefined8*)pvVar21 = uVar17;
            *(undefined8*)( pvVar21 + 0x10 ) = 0;
            *(undefined8*)( pvVar21 + 0x18 ) = 0;
            puVar20[1] = pvVar21;
            std::vector<glslang::TArraySize,glslang::pool_allocator<glslang::TArraySize>>::operator =(pvVar21, *(vector**)( lVar29 + 8 ));
            lVar28 = *(long*)( param_1 + 0x88 );
            lVar23 = *(long*)( this + 0x88 );
         }

         pbVar8 = *(basic_string**)( lVar28 + 0x10 );
         *(undefined1*)( (long)puVar20 + 0x14 ) = *(undefined1*)( lVar29 + 0x14 );
         pbVar19 = *(basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>**)( lVar23 + 0x10 );
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_assign(pbVar19, pbVar8);
         *(undefined4*)( pbVar19 + 0x28 ) = *(undefined4*)( pbVar8 + 0x28 );
         std::vector<glslang::TSpirvTypeParameter,glslang::pool_allocator<glslang::TSpirvTypeParameter>>::operator =((vector<glslang::TSpirvTypeParameter,glslang::pool_allocator<glslang::TSpirvTypeParameter>>*)( pbVar19 + 0x30 ), (vector*)( pbVar8 + 0x30 ));
         **(uint**)( this + 0x88 ) = (uint)(byte)param_1[8];
      }

      if (*(code**)( *(long*)param_1 + 0x128 ) == isStruct) {
         if (( byte )((char)param_1[8] - 0xfU) < 2) {
            LAB_001678ad:uVar16 = *(ulong*)( param_1 + 0x68 );
            if (uVar16 != 0) {
               pTVar13 = *(TMap**)( param_2 + 0x18 );
               pTVar30 = param_2 + 0x10;
               if (*(TMap**)( param_2 + 0x18 ) != (TMap*)0x0) {
                  do {
                     while (true) {
                        pTVar31 = pTVar13;
                        pTVar1 = pTVar31 + 0x18;
                        if (uVar16 <= *(ulong*)( pTVar31 + 0x20 )) break;
                        pTVar13 = *(TMap**)pTVar1;
                        pTVar31 = pTVar30;
                        if (*(TMap**)pTVar1 == (TMap*)0x0) goto LAB_001678f9;
                     }
;
                     pTVar13 = *(TMap**)( pTVar31 + 0x10 );
                     pTVar30 = pTVar31;
                  }
 while ( *(TMap**)( pTVar31 + 0x10 ) != (TMap*)0x0 );
                  LAB_001678f9:if (( param_2 + 0x10 != pTVar31 ) && ( *(ulong*)( pTVar31 + 0x20 ) <= uVar16 )) {
                     *(undefined8*)( this + 0x68 ) = *(undefined8*)( pTVar31 + 0x28 );
                     goto LAB_001677c3;
                  }

               }

               uVar16 = glslang::GetThreadPoolAllocator();
               puVar20 = (undefined8*)glslang::TPoolAllocator::allocate(uVar16);
               uVar17 = glslang::GetThreadPoolAllocator();
               puVar20[1] = 0;
               *puVar20 = uVar17;
               puVar20[2] = 0;
               puVar20[3] = 0;
               *(undefined8**)( this + 0x68 ) = puVar20;
               plVar25 = (long*)std::map<glslang::TVector<glslang::TTypeLoc>*,glslang::TVector<glslang::TTypeLoc>*,std::less<glslang::TVector<glslang::TTypeLoc>*>,glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>>>::operator [](( map<glslang::TVector<glslang::TTypeLoc>*,glslang::TVector<glslang::TTypeLoc>*,std::less<glslang::TVector<glslang::TTypeLoc>*>,glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector < glslang::TTypeLoc>*>> > *)param_2,(TVector**)( param_1 + 0x68 ) ));
               *plVar25 = (long)puVar20;
               uVar17 = _LC291;
               lVar29 = *(long*)( *(long*)( param_1 + 0x68 ) + 8 );
               if (lVar29 != *(long*)( *(long*)( param_1 + 0x68 ) + 0x10 )) {
                  uVar16 = 0;
                  do {
                     lVar28 = uVar16 * 0x20;
                     plVar25 = (long*)( lVar29 + 8 + lVar28 );
                     lStack_60 = *plVar25;
                     p_Stack_58 = (_Rb_tree*)plVar25[1];
                     uStack_50 = *(undefined8*)( lVar29 + 0x18 + lVar28 );
                     uVar26 = glslang::GetThreadPoolAllocator();
                     local_68 = (_Rb_tree_node*)glslang::TPoolAllocator::allocate(uVar26);
                     *(undefined***)local_68 = &PTR__TType_00167f00;
                     ( (TType*)local_68 )[0x20] = ( TType )(( byte )((TType*)local_68)[0x20] & 0xf0);
                     *(undefined1(*) [16])( (TType*)local_68 + 0x88 ) = (undefined1[16])0x0;
                     *(undefined1(*) [16])( (TType*)local_68 + 0x60 ) = (undefined1[16])0x0;
                     *(uint*)( (TType*)local_68 + 8 ) = CONCAT22((short)( ( uint ) * (undefined4*)( (TType*)local_68 + 8 ) >> 0x10 ), 0x100) & 0xf800ffff;
                     *(undefined8*)( (TType*)local_68 + 0x44 ) = 0xfffff800;
                     *(undefined2*)( (TType*)local_68 + 0x58 ) = 0;
                     *(undefined1(*) [16])( (TType*)local_68 + 0x70 ) = (undefined1[16])0x0;
                     *(ulong*)( (TType*)local_68 + 0x2d ) = *(ulong*)( (TType*)local_68 + 0x2d ) & 0xffffff0000ffc07f | 0xffff001f80;
                     *(uint*)( (TType*)local_68 + 0x80 ) = *(uint*)( (TType*)local_68 + 0x80 ) & 0x9fc00000;
                     *(undefined8*)( (TType*)local_68 + 0x10 ) = 0;
                     *(undefined8*)( (TType*)local_68 + 0x24 ) = uVar17;
                     *(ulong*)( (TType*)local_68 + 0x38 ) = ( ulong )(( uint ) * (undefined8*)( (TType*)local_68 + 0x38 ) & 0xfe07ff00) | 0x1f800ff;
                     ( (TType*)local_68 )[0x40] = (TType)0x0;
                     *(ulong*)( (TType*)local_68 + 0x2c ) = *(ulong*)( (TType*)local_68 + 0x2c ) & 0xffffffff8000 | 0xffff000000004fff;
                     *(ulong*)( (TType*)local_68 + 0x34 ) = *(ulong*)( (TType*)local_68 + 0x34 ) | 0x7ff007fffffff;
                     *(undefined4*)( (TType*)local_68 + 0x4c ) = 0xffffffff;
                     *(ulong*)( (TType*)local_68 + 0x18 ) = *(ulong*)( (TType*)local_68 + 0x18 ) & 0x8000000400000000;
                     lVar29 = *(long*)( param_1 + 0x68 );
                     *(undefined8*)( (TType*)local_68 + 0x50 ) = 0;
                     deepCopy((TType*)local_68, *(TType**)( *(long*)( lVar29 + 8 ) + lVar28 ), param_2);
                     pvVar10 = *(vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>**)( this + 0x68 );
                     puVar20 = *(undefined8**)( pvVar10 + 0x10 );
                     if (puVar20 == *(undefined8**)( pvVar10 + 0x18 )) {
                        std::vector<glslang::TTypeLoc,glslang::pool_allocator<glslang::TTypeLoc>>::_M_realloc_insert<glslang::TTypeLoc_const&>(pvVar10, puVar20, &local_68);
                     }
 else {
                        *puVar20 = local_68;
                        puVar20[1] = lStack_60;
                        puVar20[2] = p_Stack_58;
                        puVar20[3] = uStack_50;
                        *(undefined8**)( pvVar10 + 0x10 ) = puVar20 + 4;
                     }

                     uVar16 = ( ulong )((int)uVar16 + 1);
                     lVar29 = *(long*)( *(long*)( param_1 + 0x68 ) + 8 );
                  }
 while ( uVar16 < ( ulong )(*(long*)( *(long*)( param_1 + 0x68 ) + 0x10 ) - lVar29 >> 5) );
               }

            }

         }

      }
 else {
         cVar15 = ( **(code**)( *(long*)param_1 + 0x128 ) )(param_1);
         if (cVar15 != '\0') goto LAB_001678ad;
      }

      LAB_001677c3:if (*(long*)( param_1 + 0x70 ) != 0) {
         pcVar9 = *(char**)( *(long*)( param_1 + 0x70 ) + 8 );
         uVar16 = glslang::GetThreadPoolAllocator();
         puVar20 = (undefined8*)glslang::TPoolAllocator::allocate(uVar16);
         uVar17 = glslang::GetThreadPoolAllocator();
         *puVar20 = uVar17;
         puVar20[1] = puVar20 + 3;
         if (pcVar9 == (char*)0x0) goto LAB_00167b64;
         sVar24 = strlen(pcVar9);
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(puVar20, pcVar9, pcVar9 + sVar24);
         *(undefined8**)( this + 0x70 ) = puVar20;
      }

      if (*(long*)( param_1 + 0x78 ) != 0) {
         pcVar9 = *(char**)( *(long*)( param_1 + 0x78 ) + 8 );
         uVar16 = glslang::GetThreadPoolAllocator();
         puVar20 = (undefined8*)glslang::TPoolAllocator::allocate(uVar16);
         uVar17 = glslang::GetThreadPoolAllocator();
         *puVar20 = uVar17;
         puVar20[1] = puVar20 + 3;
         if (pcVar9 == (char*)0x0) {
            LAB_00167b64:/* WARNING: Subroutine does not return */std::__throw_logic_error("basic_string: construction from null is not valid");
         }

         sVar24 = strlen(pcVar9);
         std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::_M_construct<char_const*>(puVar20, pcVar9, pcVar9 + sVar24);
         *(undefined8**)( this + 0x78 ) = puVar20;
      }

      if (local_40 != *(long*)( in_FS_OFFSET + 0x28 )) {
         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      return;
   }

   /* glslang::TType::clone() const */
   TType * __thiscallglslang::TType::clone(TType * this);
   {
      ulong uVar1;
      TType *this_00;
      long lVar2;
      long in_FS_OFFSET;
      undefined8 local_58[2];
      undefined4 local_48[2];
      long local_40;
      undefined4 *local_38;
      undefined4 *local_30;
      undefined8 local_28;
      long local_20;
      local_20 = *(long*)( in_FS_OFFSET + 0x28 );
      uVar1 = glslang::GetThreadPoolAllocator();
      this_00 = (TType*)glslang::TPoolAllocator::allocate(uVar1);
      *(undefined***)this_00 = &PTR__TType_00167f00;
      *(uint*)( this_00 + 0x80 ) = *(uint*)( this_00 + 0x80 ) & 0x9fc00000;
      this_00[0x20] = ( TType )((byte)this_00[0x20] & 0xf0);
      *(undefined8*)( this_00 + 0x10 ) = 0;
      *(uint*)( this_00 + 8 ) = CONCAT22((short)( ( uint ) * (undefined4*)( this_00 + 8 ) >> 0x10 ), 0x100) & 0xf800ffff;
      *(undefined8*)( this_00 + 0x44 ) = 0xfffff800;
      *(undefined2*)( this_00 + 0x58 ) = 0;
      *(undefined8*)( this_00 + 0x24 ) = 0xffffffffffffffff;
      *(ulong*)( this_00 + 0x2d ) = *(ulong*)( this_00 + 0x2d ) & 0xffffff0000ffc07f | 0xffff001f80;
      this_00[0x40] = (TType)0x0;
      *(undefined4*)( this_00 + 0x4c ) = 0xffffffff;
      *(undefined8*)( this_00 + 0x50 ) = 0;
      *(ulong*)( this_00 + 0x38 ) = ( ulong )(( uint ) * (undefined8*)( this_00 + 0x38 ) & 0xfe07ff00) | 0x1f800ff;
      *(undefined1(*) [16])( this_00 + 0x88 ) = (undefined1[16])0x0;
      *(ulong*)( this_00 + 0x2c ) = *(ulong*)( this_00 + 0x2c ) & 0xffffffff8000 | 0xffff000000004fff;
      *(ulong*)( this_00 + 0x34 ) = *(ulong*)( this_00 + 0x34 ) | 0x7ff007fffffff;
      *(ulong*)( this_00 + 0x18 ) = *(ulong*)( this_00 + 0x18 ) & 0x8000000400000000;
      *(undefined1(*) [16])( this_00 + 0x60 ) = (undefined1[16])0x0;
      *(undefined1(*) [16])( this_00 + 0x70 ) = (undefined1[16])0x0;
      local_58[0] = glslang::GetThreadPoolAllocator();
      local_38 = local_48;
      local_48[0] = 0;
      local_40 = 0;
      local_28 = 0;
      local_30 = local_38;
      deepCopy(this_00, this, (TMap*)local_58);
      for (lVar2 = local_40; lVar2 != 0; lVar2 = *(long*)( lVar2 + 0x10 )) {
         std::_Rb_tree<glslang::TVector<glslang::TTypeLoc>*,std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>,std::_Select1st<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector < glslang::TTypeLoc>*>>,std::less<glslang::TVector<glslang::TTypeLoc>*>,glslang::pool_allocator<std::pair<glslang::TVector<glslang::TTypeLoc>*const,glslang::TVector<glslang::TTypeLoc>*>> > ::_M_erase(*(_Rb_tree_node**)( lVar2 + 0x18 ));
      }

      if (local_20 != *(long*)( in_FS_OFFSET + 0x28 )) {
         /* WARNING: Subroutine does not return */
         __stack_chk_fail();
      }

      return this_00;
   }

   /* WARNING: Control flow encountered bad instruction data */
   /* glslang::TParseContextBase::~TParseContextBase() */
   void glslang::TParseContextBase::~TParseContextBase(TParseContextBase *this) {
      /* WARNING: Bad instruction - Truncating control flow here */
      halt_baddata();
   }

   /* WARNING: Control flow encountered bad instruction data */
   /* glslang::AccessChainTraverser::~AccessChainTraverser() */
   void glslang::AccessChainTraverser::~AccessChainTraverser(AccessChainTraverser *this) {
      /* WARNING: Bad instruction - Truncating control flow here */
      halt_baddata();
   }

   /* WARNING: Control flow encountered bad instruction data */
   /* glslang::TPrecisionManager::~TPrecisionManager() */
   void glslang::TPrecisionManager::~TPrecisionManager(TPrecisionManager *this) {
      /* WARNING: Bad instruction - Truncating control flow here */
      halt_baddata();
   }

   /* WARNING: Control flow encountered bad instruction data */
   /* glslang::TIntermTraverser::~TIntermTraverser() */
   void glslang::TIntermTraverser::~TIntermTraverser(TIntermTraverser *this) {
      /* WARNING: Bad instruction - Truncating control flow here */
      halt_baddata();
   }

   /* WARNING: Control flow encountered bad instruction data */
   /* glslang::TConstUnionArray::~TConstUnionArray() */
   void glslang::TConstUnionArray::~TConstUnionArray(TConstUnionArray *this) {
      /* WARNING: Bad instruction - Truncating control flow here */
      halt_baddata();
   }

   /* WARNING: Control flow encountered bad instruction data */
   /* glslang::TType::~TType() */
   void glslang::TType::~TType(TType *this) {
      /* WARNING: Bad instruction - Truncating control flow here */
      halt_baddata();
   }

   /* WARNING: Control flow encountered bad instruction data */
   /* glslang::TSmallArrayVector::~TSmallArrayVector() */
   void glslang::TSmallArrayVector::~TSmallArrayVector(TSmallArrayVector *this) {
      /* WARNING: Bad instruction - Truncating control flow here */
      halt_baddata();
   }

   /* WARNING: Control flow encountered bad instruction data */
   /* glslang::TFunction::TFunction(std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const*, glslang::TType const&, glslang::TOperator) */
   void glslang::TFunction::TFunction(void) {
      /* WARNING: Bad instruction - Truncating control flow here */
      halt_baddata();
   }

   /* WARNING: Control flow encountered bad instruction data */
   /* glslang::TType::TType(glslang::TPublicType const&) */
   void glslang::TType::TType(TType *this, TPublicType *param_1) {
      /* WARNING: Bad instruction - Truncating control flow here */
      halt_baddata();
   }

   /* WARNING: Control flow encountered bad instruction data */
   /* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const&) */
   void std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::basic_string(basic_string *param_1) {
      /* WARNING: Bad instruction - Truncating control flow here */
      halt_baddata();
   }

   /* WARNING: Control flow encountered bad instruction data */
   /* std::__cxx11::basic_string<char, std::char_traits<char>, glslang::std::allocator<char>
   >::basic_string<glslang::std::allocator<char> >(char const*, glslang::std::allocator<char>
   const&) */
   void std::__cxx11::basic_string<char,std::char_traits<char>,glslang::std::allocator<char>>::basic_string<glslang::std::allocator<char>>(char *param_1, allocator *param_2) {
      /* WARNING: Bad instruction - Truncating control flow here */
      halt_baddata();
   }

   /* WARNING: Control flow encountered bad instruction data */
   /* glslang::TVariable::TVariable(std::__cxx11::basic_string<char, std::char_traits<char>,
   glslang::std::allocator<char> > const*, glslang::TType const&, bool) */
   void glslang::TVariable::TVariable(TVariable *this, basic_string *param_1, TType *param_2, bool param_3) {
      /* WARNING: Bad instruction - Truncating control flow here */
      halt_baddata();
   }

   /* WARNING: Control flow encountered bad instruction data */
   /* glslang::TType::TType(glslang::TType const&, int, bool) */
   void glslang::TType::TType(TType *this, TType *param_1, int param_2, bool param_3) {
      /* WARNING: Bad instruction - Truncating control flow here */
      halt_baddata();
   }

   /* WARNING: Control flow encountered bad instruction data */
   /* glslang::TType::TType(glslang::TBasicType, glslang::TStorageQualifier, int, int, int, bool) */
   void glslang::TType::TType(void) {
      /* WARNING: Bad instruction - Truncating control flow here */
      halt_baddata();
   }

}

